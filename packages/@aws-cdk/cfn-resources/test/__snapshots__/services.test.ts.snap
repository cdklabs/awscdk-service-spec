// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`alexa-ask 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`Alexa::ASK::Skill\` resource creates an Alexa skill that enables customers to access new abilities.
 *
 * For more information about developing a skill, see the  .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html
 */
export class CfnSkill extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "Alexa::ASK::Skill";

  /**
   * Build a CfnSkill from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSkill {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSkillPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSkill(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-authenticationconfiguration
   */
  public authenticationConfiguration: CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable;

  /**
   * Configuration for the skill package that contains the components of the Alexa skill.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-skillpackage
   */
  public skillPackage: cdk.IResolvable | CfnSkill.SkillPackageProperty;

  /**
   * The vendor ID associated with the Amazon developer account that will host the skill.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-vendorid
   */
  public vendorId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSkillProps) {
    super(scope, id, {
      "type": CfnSkill.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "authenticationConfiguration", this);
    cdk.requireProperty(props, "skillPackage", this);
    cdk.requireProperty(props, "vendorId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.authenticationConfiguration = props.authenticationConfiguration;
    this.skillPackage = props.skillPackage;
    this.vendorId = props.vendorId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "authenticationConfiguration": this.authenticationConfiguration,
      "skillPackage": this.skillPackage,
      "vendorId": this.vendorId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSkill.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSkillPropsToCloudFormation(props);
  }
}

export namespace CfnSkill {
  /**
   * The \`AuthenticationConfiguration\` property type specifies the Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
   *
   * Only Login with Amazon security profiles created through the  are supported for authentication. A client ID, client secret, and refresh token are required. You can generate a client ID and client secret by creating a new  on the Amazon Developer Portal or you can retrieve them from an existing profile. You can then retrieve the refresh token using the Alexa Skills Kit CLI. For instructions, see  in the  .
   *
   * \`AuthenticationConfiguration\` is a property of the \`Alexa::ASK::Skill\` resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html
   */
  export interface AuthenticationConfigurationProperty {
    /**
     * Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
     *
     * Only Login with Amazon clients created through the  are supported. The client ID, client secret, and refresh token are required.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html#cfn-ask-skill-authenticationconfiguration-authenticationconfiguration
     */
    readonly authenticationConfiguration: CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable;

    /**
     * Configuration for the skill package that contains the components of the Alexa skill.
     *
     * Skill packages are retrieved from an Amazon S3 bucket and key and used to create and update the skill. For more information about the skill package format, see the  .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html#cfn-ask-skill-authenticationconfiguration-skillpackage
     */
    readonly skillPackage: cdk.IResolvable | CfnSkill.SkillPackageProperty;

    /**
     * The vendor ID associated with the Amazon developer account that will host the skill.
     *
     * Details for retrieving the vendor ID are in  . The provided LWA credentials must be linked to the developer account associated with this vendor ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html#cfn-ask-skill-authenticationconfiguration-vendorid
     */
    readonly vendorId: string;
  }

  /**
   * The \`SkillPackage\` property type contains configuration details for the skill package that contains the components of the Alexa skill.
   *
   * Skill packages are retrieved from an Amazon S3 bucket and key and used to create and update the skill. More details about the skill package format are located in the  .
   *
   * \`SkillPackage\` is a property of the \`Alexa::ASK::Skill\` resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html
   */
  export interface SkillPackageProperty {
    /**
     * Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
     *
     * Only Login with Amazon clients created through the  are supported. The client ID, client secret, and refresh token are required.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-authenticationconfiguration
     */
    readonly authenticationConfiguration: CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable;

    /**
     * Configuration for the skill package that contains the components of the Alexa skill.
     *
     * Skill packages are retrieved from an Amazon S3 bucket and key and used to create and update the skill. For more information about the skill package format, see the  .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-skillpackage
     */
    readonly skillPackage: cdk.IResolvable | CfnSkill.SkillPackageProperty;

    /**
     * The vendor ID associated with the Amazon developer account that will host the skill.
     *
     * Details for retrieving the vendor ID are in  . The provided LWA credentials must be linked to the developer account associated with this vendor ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-vendorid
     */
    readonly vendorId: string;
  }
}

/**
 * Properties for defining a \`CfnSkill\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html
 */
export interface CfnSkillProps {
  /**
   * Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
   *
   * Only Login with Amazon clients created through the  are supported. The client ID, client secret, and refresh token are required.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-authenticationconfiguration
   */
  readonly authenticationConfiguration: CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable;

  /**
   * Configuration for the skill package that contains the components of the Alexa skill.
   *
   * Skill packages are retrieved from an Amazon S3 bucket and key and used to create and update the skill. For more information about the skill package format, see the  .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-skillpackage
   */
  readonly skillPackage: cdk.IResolvable | CfnSkill.SkillPackageProperty;

  /**
   * The vendor ID associated with the Amazon developer account that will host the skill.
   *
   * Details for retrieving the vendor ID are in  . The provided LWA credentials must be linked to the developer account associated with this vendor ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-vendorid
   */
  readonly vendorId: string;
}

/**
 * Determine whether the given properties match those of a \`SkillPackageProperty\`
 *
 * @param properties - the TypeScript properties of a \`SkillPackageProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillSkillPackagePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationConfiguration", cdk.requiredValidator)(properties.authenticationConfiguration));
  errors.collect(cdk.propertyValidator("authenticationConfiguration", CfnSkillAuthenticationConfigurationPropertyValidator)(properties.authenticationConfiguration));
  errors.collect(cdk.propertyValidator("skillPackage", cdk.requiredValidator)(properties.skillPackage));
  errors.collect(cdk.propertyValidator("skillPackage", CfnSkillSkillPackagePropertyValidator)(properties.skillPackage));
  errors.collect(cdk.propertyValidator("vendorId", cdk.requiredValidator)(properties.vendorId));
  errors.collect(cdk.propertyValidator("vendorId", cdk.validateString)(properties.vendorId));
  return errors.wrap("supplied properties not correct for \\"SkillPackageProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSkillSkillPackagePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillSkillPackagePropertyValidator(properties).assertSuccess();
  return {
    "AuthenticationConfiguration": convertCfnSkillAuthenticationConfigurationPropertyToCloudFormation(properties.authenticationConfiguration),
    "SkillPackage": convertCfnSkillSkillPackagePropertyToCloudFormation(properties.skillPackage),
    "VendorId": cdk.stringToCloudFormation(properties.vendorId)
  };
}

// @ts-ignore TS6133
function CfnSkillSkillPackagePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSkill.SkillPackageProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkill.SkillPackageProperty>();
  ret.addPropertyResult("authenticationConfiguration", "AuthenticationConfiguration", (properties.AuthenticationConfiguration != null ? CfnSkillAuthenticationConfigurationPropertyFromCloudFormation(properties.AuthenticationConfiguration) : undefined));
  ret.addPropertyResult("skillPackage", "SkillPackage", (properties.SkillPackage != null ? CfnSkillSkillPackagePropertyFromCloudFormation(properties.SkillPackage) : undefined));
  ret.addPropertyResult("vendorId", "VendorId", (properties.VendorId != null ? cfn_parse.FromCloudFormation.getString(properties.VendorId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AuthenticationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`AuthenticationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillAuthenticationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationConfiguration", cdk.requiredValidator)(properties.authenticationConfiguration));
  errors.collect(cdk.propertyValidator("authenticationConfiguration", CfnSkillAuthenticationConfigurationPropertyValidator)(properties.authenticationConfiguration));
  errors.collect(cdk.propertyValidator("skillPackage", cdk.requiredValidator)(properties.skillPackage));
  errors.collect(cdk.propertyValidator("skillPackage", CfnSkillSkillPackagePropertyValidator)(properties.skillPackage));
  errors.collect(cdk.propertyValidator("vendorId", cdk.requiredValidator)(properties.vendorId));
  errors.collect(cdk.propertyValidator("vendorId", cdk.validateString)(properties.vendorId));
  return errors.wrap("supplied properties not correct for \\"AuthenticationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSkillAuthenticationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillAuthenticationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AuthenticationConfiguration": convertCfnSkillAuthenticationConfigurationPropertyToCloudFormation(properties.authenticationConfiguration),
    "SkillPackage": convertCfnSkillSkillPackagePropertyToCloudFormation(properties.skillPackage),
    "VendorId": cdk.stringToCloudFormation(properties.vendorId)
  };
}

// @ts-ignore TS6133
function CfnSkillAuthenticationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkill.AuthenticationConfigurationProperty>();
  ret.addPropertyResult("authenticationConfiguration", "AuthenticationConfiguration", (properties.AuthenticationConfiguration != null ? CfnSkillAuthenticationConfigurationPropertyFromCloudFormation(properties.AuthenticationConfiguration) : undefined));
  ret.addPropertyResult("skillPackage", "SkillPackage", (properties.SkillPackage != null ? CfnSkillSkillPackagePropertyFromCloudFormation(properties.SkillPackage) : undefined));
  ret.addPropertyResult("vendorId", "VendorId", (properties.VendorId != null ? cfn_parse.FromCloudFormation.getString(properties.VendorId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSkillProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSkillProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationConfiguration", cdk.requiredValidator)(properties.authenticationConfiguration));
  errors.collect(cdk.propertyValidator("authenticationConfiguration", CfnSkillAuthenticationConfigurationPropertyValidator)(properties.authenticationConfiguration));
  errors.collect(cdk.propertyValidator("skillPackage", cdk.requiredValidator)(properties.skillPackage));
  errors.collect(cdk.propertyValidator("skillPackage", CfnSkillSkillPackagePropertyValidator)(properties.skillPackage));
  errors.collect(cdk.propertyValidator("vendorId", cdk.requiredValidator)(properties.vendorId));
  errors.collect(cdk.propertyValidator("vendorId", cdk.validateString)(properties.vendorId));
  return errors.wrap("supplied properties not correct for \\"CfnSkillProps\\"");
}

// @ts-ignore TS6133
function convertCfnSkillPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillPropsValidator(properties).assertSuccess();
  return {
    "AuthenticationConfiguration": convertCfnSkillAuthenticationConfigurationPropertyToCloudFormation(properties.authenticationConfiguration),
    "SkillPackage": convertCfnSkillSkillPackagePropertyToCloudFormation(properties.skillPackage),
    "VendorId": cdk.stringToCloudFormation(properties.vendorId)
  };
}

// @ts-ignore TS6133
function CfnSkillPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSkillProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkillProps>();
  ret.addPropertyResult("authenticationConfiguration", "AuthenticationConfiguration", (properties.AuthenticationConfiguration != null ? CfnSkillAuthenticationConfigurationPropertyFromCloudFormation(properties.AuthenticationConfiguration) : undefined));
  ret.addPropertyResult("skillPackage", "SkillPackage", (properties.SkillPackage != null ? CfnSkillSkillPackagePropertyFromCloudFormation(properties.SkillPackage) : undefined));
  ret.addPropertyResult("vendorId", "VendorId", (properties.VendorId != null ? cfn_parse.FromCloudFormation.getString(properties.VendorId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-chatbot 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`AWS::Chatbot::MicrosoftTeamsChannelConfiguration\` resource configures a Microsoft Teams channel to allow users to use AWS Chatbot with AWS CloudFormation templates.
 *
 * This resource requires some setup to be done in the AWS Chatbot console. To provide the required Microsoft Teams team and tenant IDs, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console, then copy and paste the IDs from the console. For more details, see steps 1-4 in [Setting Up AWS Chatbot with Microsoft Teams](https://docs.aws.amazon.com/chatbot/latest/adminguide/teams-setup.html#teams-client-setup) in the *AWS Chatbot Administrator Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html
 */
export class CfnMicrosoftTeamsChannelConfiguration extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Chatbot::MicrosoftTeamsChannelConfiguration";

  /**
   * Build a CfnMicrosoftTeamsChannelConfiguration from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnMicrosoftTeamsChannelConfiguration {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnMicrosoftTeamsChannelConfigurationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnMicrosoftTeamsChannelConfiguration(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Amazon Resource Name (ARN) of the configuration
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The name of the configuration.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-configurationname
   */
  public configurationName: string;

  /**
   * The list of IAM policy ARNs that are applied as channel guardrails.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-guardrailpolicies
   */
  public guardrailPolicies?: Array<string>;

  /**
   * The ARN of the IAM role that defines the permissions for AWS Chatbot .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-iamrolearn
   */
  public iamRoleArn: string;

  /**
   * Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-logginglevel
   */
  public loggingLevel?: string;

  /**
   * The ARNs of the SNS topics that deliver notifications to AWS Chatbot .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-snstopicarns
   */
  public snsTopicArns?: Array<string>;

  /**
   * The ID of the Microsoft Team authorized with AWS Chatbot .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-teamid
   */
  public teamId: string;

  /**
   * The ID of the Microsoft Teams channel.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-teamschannelid
   */
  public teamsChannelId: string;

  /**
   * The ID of the Microsoft Teams tenant.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-teamstenantid
   */
  public teamsTenantId: string;

  /**
   * Enables use of a user role requirement in your chat configuration.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-userrolerequired
   */
  public userRoleRequired?: boolean | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnMicrosoftTeamsChannelConfigurationProps) {
    super(scope, id, {
      "type": CfnMicrosoftTeamsChannelConfiguration.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "configurationName", this);
    cdk.requireProperty(props, "iamRoleArn", this);
    cdk.requireProperty(props, "teamId", this);
    cdk.requireProperty(props, "teamsChannelId", this);
    cdk.requireProperty(props, "teamsTenantId", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.configurationName = props.configurationName;
    this.guardrailPolicies = props.guardrailPolicies;
    this.iamRoleArn = props.iamRoleArn;
    this.loggingLevel = props.loggingLevel;
    this.snsTopicArns = props.snsTopicArns;
    this.teamId = props.teamId;
    this.teamsChannelId = props.teamsChannelId;
    this.teamsTenantId = props.teamsTenantId;
    this.userRoleRequired = props.userRoleRequired;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "configurationName": this.configurationName,
      "guardrailPolicies": this.guardrailPolicies,
      "iamRoleArn": this.iamRoleArn,
      "loggingLevel": this.loggingLevel,
      "snsTopicArns": this.snsTopicArns,
      "teamId": this.teamId,
      "teamsChannelId": this.teamsChannelId,
      "teamsTenantId": this.teamsTenantId,
      "userRoleRequired": this.userRoleRequired
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnMicrosoftTeamsChannelConfiguration.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnMicrosoftTeamsChannelConfigurationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnMicrosoftTeamsChannelConfiguration\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html
 */
export interface CfnMicrosoftTeamsChannelConfigurationProps {
  /**
   * The name of the configuration.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-configurationname
   */
  readonly configurationName: string;

  /**
   * The list of IAM policy ARNs that are applied as channel guardrails.
   *
   * The AWS managed 'AdministratorAccess' policy is applied as a default if this is not set.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-guardrailpolicies
   */
  readonly guardrailPolicies?: Array<string>;

  /**
   * The ARN of the IAM role that defines the permissions for AWS Chatbot .
   *
   * This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see [IAM Policies for AWS Chatbot](https://docs.aws.amazon.com/chatbot/latest/adminguide/chatbot-iam-policies.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-iamrolearn
   */
  readonly iamRoleArn: string;

  /**
   * Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.
   *
   * Logging levels include \`ERROR\` , \`INFO\` , or \`NONE\` .
   *
   * @default - "NONE"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-logginglevel
   */
  readonly loggingLevel?: string;

  /**
   * The ARNs of the SNS topics that deliver notifications to AWS Chatbot .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-snstopicarns
   */
  readonly snsTopicArns?: Array<string>;

  /**
   * The ID of the Microsoft Team authorized with AWS Chatbot .
   *
   * To get the team ID, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console. Then you can copy and paste the team ID from the console. For more details, see steps 1-4 in [Get started with Microsoft Teams](https://docs.aws.amazon.com/chatbot/latest/adminguide/teams-setup.html#teams-client-setup) in the *AWS Chatbot Administrator Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-teamid
   */
  readonly teamId: string;

  /**
   * The ID of the Microsoft Teams channel.
   *
   * To get the channel ID, open Microsoft Teams, right click on the channel name in the left pane, then choose Copy. An example of the channel ID syntax is: \`19%3ab6ef35dc342d56ba5654e6fc6d25a071%40thread.tacv2\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-teamschannelid
   */
  readonly teamsChannelId: string;

  /**
   * The ID of the Microsoft Teams tenant.
   *
   * To get the tenant ID, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console. Then you can copy and paste the tenant ID from the console. For more details, see steps 1-4 in [Get started with Microsoft Teams](https://docs.aws.amazon.com/chatbot/latest/adminguide/teams-setup.html#teams-client-setup) in the *AWS Chatbot Administrator Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-teamstenantid
   */
  readonly teamsTenantId: string;

  /**
   * Enables use of a user role requirement in your chat configuration.
   *
   * @default - false
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-userrolerequired
   */
  readonly userRoleRequired?: boolean | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`CfnMicrosoftTeamsChannelConfigurationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnMicrosoftTeamsChannelConfigurationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnMicrosoftTeamsChannelConfigurationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("configurationName", cdk.requiredValidator)(properties.configurationName));
  errors.collect(cdk.propertyValidator("configurationName", cdk.validateString)(properties.configurationName));
  errors.collect(cdk.propertyValidator("guardrailPolicies", cdk.listValidator(cdk.validateString))(properties.guardrailPolicies));
  errors.collect(cdk.propertyValidator("iamRoleArn", cdk.requiredValidator)(properties.iamRoleArn));
  errors.collect(cdk.propertyValidator("iamRoleArn", cdk.validateString)(properties.iamRoleArn));
  errors.collect(cdk.propertyValidator("loggingLevel", cdk.validateString)(properties.loggingLevel));
  errors.collect(cdk.propertyValidator("snsTopicArns", cdk.listValidator(cdk.validateString))(properties.snsTopicArns));
  errors.collect(cdk.propertyValidator("teamId", cdk.requiredValidator)(properties.teamId));
  errors.collect(cdk.propertyValidator("teamId", cdk.validateString)(properties.teamId));
  errors.collect(cdk.propertyValidator("teamsChannelId", cdk.requiredValidator)(properties.teamsChannelId));
  errors.collect(cdk.propertyValidator("teamsChannelId", cdk.validateString)(properties.teamsChannelId));
  errors.collect(cdk.propertyValidator("teamsTenantId", cdk.requiredValidator)(properties.teamsTenantId));
  errors.collect(cdk.propertyValidator("teamsTenantId", cdk.validateString)(properties.teamsTenantId));
  errors.collect(cdk.propertyValidator("userRoleRequired", cdk.validateBoolean)(properties.userRoleRequired));
  return errors.wrap("supplied properties not correct for \\"CfnMicrosoftTeamsChannelConfigurationProps\\"");
}

// @ts-ignore TS6133
function convertCfnMicrosoftTeamsChannelConfigurationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnMicrosoftTeamsChannelConfigurationPropsValidator(properties).assertSuccess();
  return {
    "ConfigurationName": cdk.stringToCloudFormation(properties.configurationName),
    "GuardrailPolicies": cdk.listMapper(cdk.stringToCloudFormation)(properties.guardrailPolicies),
    "IamRoleArn": cdk.stringToCloudFormation(properties.iamRoleArn),
    "LoggingLevel": cdk.stringToCloudFormation(properties.loggingLevel),
    "SnsTopicArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.snsTopicArns),
    "TeamId": cdk.stringToCloudFormation(properties.teamId),
    "TeamsChannelId": cdk.stringToCloudFormation(properties.teamsChannelId),
    "TeamsTenantId": cdk.stringToCloudFormation(properties.teamsTenantId),
    "UserRoleRequired": cdk.booleanToCloudFormation(properties.userRoleRequired)
  };
}

// @ts-ignore TS6133
function CfnMicrosoftTeamsChannelConfigurationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnMicrosoftTeamsChannelConfigurationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnMicrosoftTeamsChannelConfigurationProps>();
  ret.addPropertyResult("configurationName", "ConfigurationName", (properties.ConfigurationName != null ? cfn_parse.FromCloudFormation.getString(properties.ConfigurationName) : undefined));
  ret.addPropertyResult("guardrailPolicies", "GuardrailPolicies", (properties.GuardrailPolicies != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GuardrailPolicies) : undefined));
  ret.addPropertyResult("iamRoleArn", "IamRoleArn", (properties.IamRoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.IamRoleArn) : undefined));
  ret.addPropertyResult("loggingLevel", "LoggingLevel", (properties.LoggingLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LoggingLevel) : undefined));
  ret.addPropertyResult("snsTopicArns", "SnsTopicArns", (properties.SnsTopicArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SnsTopicArns) : undefined));
  ret.addPropertyResult("teamId", "TeamId", (properties.TeamId != null ? cfn_parse.FromCloudFormation.getString(properties.TeamId) : undefined));
  ret.addPropertyResult("teamsChannelId", "TeamsChannelId", (properties.TeamsChannelId != null ? cfn_parse.FromCloudFormation.getString(properties.TeamsChannelId) : undefined));
  ret.addPropertyResult("teamsTenantId", "TeamsTenantId", (properties.TeamsTenantId != null ? cfn_parse.FromCloudFormation.getString(properties.TeamsTenantId) : undefined));
  ret.addPropertyResult("userRoleRequired", "UserRoleRequired", (properties.UserRoleRequired != null ? cfn_parse.FromCloudFormation.getBoolean(properties.UserRoleRequired) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * The \`AWS::Chatbot::SlackChannelConfiguration\` resource configures a Slack channel to allow users to use AWS Chatbot with AWS CloudFormation templates.
 *
 * This resource requires some setup to be done in the AWS Chatbot console. To provide the required Slack workspace ID, you must perform the initial authorization flow with Slack in the AWS Chatbot console, then copy and paste the workspace ID from the console. For more details, see steps 1-4 in [Setting Up AWS Chatbot with Slack](https://docs.aws.amazon.com/chatbot/latest/adminguide/setting-up.html#Setup_intro) in the *AWS Chatbot User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html
 */
export class CfnSlackChannelConfiguration extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Chatbot::SlackChannelConfiguration";

  /**
   * Build a CfnSlackChannelConfiguration from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSlackChannelConfiguration {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSlackChannelConfigurationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSlackChannelConfiguration(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Amazon Resource Name (ARN) of the configuration
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The name of the configuration.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-configurationname
   */
  public configurationName: string;

  /**
   * The list of IAM policy ARNs that are applied as channel guardrails.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-guardrailpolicies
   */
  public guardrailPolicies?: Array<string>;

  /**
   * The ARN of the IAM role that defines the permissions for AWS Chatbot .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-iamrolearn
   */
  public iamRoleArn: string;

  /**
   * Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-logginglevel
   */
  public loggingLevel?: string;

  /**
   * The ID of the Slack channel.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-slackchannelid
   */
  public slackChannelId: string;

  /**
   * The ID of the Slack workspace authorized with AWS Chatbot .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-slackworkspaceid
   */
  public slackWorkspaceId: string;

  /**
   * The ARNs of the SNS topics that deliver notifications to AWS Chatbot .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-snstopicarns
   */
  public snsTopicArns?: Array<string>;

  /**
   * Enables use of a user role requirement in your chat configuration.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-userrolerequired
   */
  public userRoleRequired?: boolean | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSlackChannelConfigurationProps) {
    super(scope, id, {
      "type": CfnSlackChannelConfiguration.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "configurationName", this);
    cdk.requireProperty(props, "iamRoleArn", this);
    cdk.requireProperty(props, "slackChannelId", this);
    cdk.requireProperty(props, "slackWorkspaceId", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.configurationName = props.configurationName;
    this.guardrailPolicies = props.guardrailPolicies;
    this.iamRoleArn = props.iamRoleArn;
    this.loggingLevel = props.loggingLevel;
    this.slackChannelId = props.slackChannelId;
    this.slackWorkspaceId = props.slackWorkspaceId;
    this.snsTopicArns = props.snsTopicArns;
    this.userRoleRequired = props.userRoleRequired;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "configurationName": this.configurationName,
      "guardrailPolicies": this.guardrailPolicies,
      "iamRoleArn": this.iamRoleArn,
      "loggingLevel": this.loggingLevel,
      "slackChannelId": this.slackChannelId,
      "slackWorkspaceId": this.slackWorkspaceId,
      "snsTopicArns": this.snsTopicArns,
      "userRoleRequired": this.userRoleRequired
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSlackChannelConfiguration.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSlackChannelConfigurationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSlackChannelConfiguration\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html
 */
export interface CfnSlackChannelConfigurationProps {
  /**
   * The name of the configuration.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-configurationname
   */
  readonly configurationName: string;

  /**
   * The list of IAM policy ARNs that are applied as channel guardrails.
   *
   * The AWS managed 'AdministratorAccess' policy is applied as a default if this is not set.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-guardrailpolicies
   */
  readonly guardrailPolicies?: Array<string>;

  /**
   * The ARN of the IAM role that defines the permissions for AWS Chatbot .
   *
   * This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see [IAM Policies for AWS Chatbot](https://docs.aws.amazon.com/chatbot/latest/adminguide/chatbot-iam-policies.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-iamrolearn
   */
  readonly iamRoleArn: string;

  /**
   * Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.
   *
   * Logging levels include \`ERROR\` , \`INFO\` , or \`NONE\` .
   *
   * @default - "NONE"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-logginglevel
   */
  readonly loggingLevel?: string;

  /**
   * The ID of the Slack channel.
   *
   * To get the ID, open Slack, right click on the channel name in the left pane, then choose Copy Link. The channel ID is the 9-character string at the end of the URL. For example, \`ABCBBLZZZ\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-slackchannelid
   */
  readonly slackChannelId: string;

  /**
   * The ID of the Slack workspace authorized with AWS Chatbot .
   *
   * To get the workspace ID, you must perform the initial authorization flow with Slack in the AWS Chatbot console. Then you can copy and paste the workspace ID from the console. For more details, see steps 1-4 in [Setting Up AWS Chatbot with Slack](https://docs.aws.amazon.com/chatbot/latest/adminguide/setting-up.html#Setup_intro) in the *AWS Chatbot User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-slackworkspaceid
   */
  readonly slackWorkspaceId: string;

  /**
   * The ARNs of the SNS topics that deliver notifications to AWS Chatbot .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-snstopicarns
   */
  readonly snsTopicArns?: Array<string>;

  /**
   * Enables use of a user role requirement in your chat configuration.
   *
   * @default - false
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-userrolerequired
   */
  readonly userRoleRequired?: boolean | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`CfnSlackChannelConfigurationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSlackChannelConfigurationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSlackChannelConfigurationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("configurationName", cdk.requiredValidator)(properties.configurationName));
  errors.collect(cdk.propertyValidator("configurationName", cdk.validateString)(properties.configurationName));
  errors.collect(cdk.propertyValidator("guardrailPolicies", cdk.listValidator(cdk.validateString))(properties.guardrailPolicies));
  errors.collect(cdk.propertyValidator("iamRoleArn", cdk.requiredValidator)(properties.iamRoleArn));
  errors.collect(cdk.propertyValidator("iamRoleArn", cdk.validateString)(properties.iamRoleArn));
  errors.collect(cdk.propertyValidator("loggingLevel", cdk.validateString)(properties.loggingLevel));
  errors.collect(cdk.propertyValidator("slackChannelId", cdk.requiredValidator)(properties.slackChannelId));
  errors.collect(cdk.propertyValidator("slackChannelId", cdk.validateString)(properties.slackChannelId));
  errors.collect(cdk.propertyValidator("slackWorkspaceId", cdk.requiredValidator)(properties.slackWorkspaceId));
  errors.collect(cdk.propertyValidator("slackWorkspaceId", cdk.validateString)(properties.slackWorkspaceId));
  errors.collect(cdk.propertyValidator("snsTopicArns", cdk.listValidator(cdk.validateString))(properties.snsTopicArns));
  errors.collect(cdk.propertyValidator("userRoleRequired", cdk.validateBoolean)(properties.userRoleRequired));
  return errors.wrap("supplied properties not correct for \\"CfnSlackChannelConfigurationProps\\"");
}

// @ts-ignore TS6133
function convertCfnSlackChannelConfigurationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSlackChannelConfigurationPropsValidator(properties).assertSuccess();
  return {
    "ConfigurationName": cdk.stringToCloudFormation(properties.configurationName),
    "GuardrailPolicies": cdk.listMapper(cdk.stringToCloudFormation)(properties.guardrailPolicies),
    "IamRoleArn": cdk.stringToCloudFormation(properties.iamRoleArn),
    "LoggingLevel": cdk.stringToCloudFormation(properties.loggingLevel),
    "SlackChannelId": cdk.stringToCloudFormation(properties.slackChannelId),
    "SlackWorkspaceId": cdk.stringToCloudFormation(properties.slackWorkspaceId),
    "SnsTopicArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.snsTopicArns),
    "UserRoleRequired": cdk.booleanToCloudFormation(properties.userRoleRequired)
  };
}

// @ts-ignore TS6133
function CfnSlackChannelConfigurationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSlackChannelConfigurationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSlackChannelConfigurationProps>();
  ret.addPropertyResult("configurationName", "ConfigurationName", (properties.ConfigurationName != null ? cfn_parse.FromCloudFormation.getString(properties.ConfigurationName) : undefined));
  ret.addPropertyResult("guardrailPolicies", "GuardrailPolicies", (properties.GuardrailPolicies != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GuardrailPolicies) : undefined));
  ret.addPropertyResult("iamRoleArn", "IamRoleArn", (properties.IamRoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.IamRoleArn) : undefined));
  ret.addPropertyResult("loggingLevel", "LoggingLevel", (properties.LoggingLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LoggingLevel) : undefined));
  ret.addPropertyResult("slackChannelId", "SlackChannelId", (properties.SlackChannelId != null ? cfn_parse.FromCloudFormation.getString(properties.SlackChannelId) : undefined));
  ret.addPropertyResult("slackWorkspaceId", "SlackWorkspaceId", (properties.SlackWorkspaceId != null ? cfn_parse.FromCloudFormation.getString(properties.SlackWorkspaceId) : undefined));
  ret.addPropertyResult("snsTopicArns", "SnsTopicArns", (properties.SnsTopicArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SnsTopicArns) : undefined));
  ret.addPropertyResult("userRoleRequired", "UserRoleRequired", (properties.UserRoleRequired != null ? cfn_parse.FromCloudFormation.getBoolean(properties.UserRoleRequired) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-ec2 1`] = `
{
  "augmentations": "// Copyright 2012-2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
/* eslint-disable prettier/prettier,max-len */
import * as cw from "aws-cdk-lib/aws-cloudwatch";
import { VpnConnectionBase } from "./vpn";

declare module "./vpn" {
  interface IVpnConnection {
    /**
     * Return the given named metric for this VPNConnection
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The state of the tunnel. 0 indicates DOWN and 1 indicates UP.
     *
     * Average over 5 minutes
     */
    metricTunnelState(props?: cw.MetricOptions): cw.Metric;

    /**
     * The bytes received through the VPN tunnel.
     *
     * Sum over 5 minutes
     */
    metricTunnelDataIn(props?: cw.MetricOptions): cw.Metric;

    /**
     * The bytes sent through the VPN tunnel.
     *
     * Sum over 5 minutes
     */
    metricTunnelDataOut(props?: cw.MetricOptions): cw.Metric;
  }
}



declare module "./vpn" {
  interface VpnConnectionBase {
    /**
     * Return the given named metric for this VPNConnection
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The state of the tunnel. 0 indicates DOWN and 1 indicates UP.
     *
     * Average over 5 minutes
     */
    metricTunnelState(props?: cw.MetricOptions): cw.Metric;

    /**
     * The bytes received through the VPN tunnel.
     *
     * Sum over 5 minutes
     */
    metricTunnelDataIn(props?: cw.MetricOptions): cw.Metric;

    /**
     * The bytes sent through the VPN tunnel.
     *
     * Sum over 5 minutes
     */
    metricTunnelDataOut(props?: cw.MetricOptions): cw.Metric;
  }
}

VpnConnectionBase.prototype.metric = function(metricName: string, props?: cw.MetricOptions) {
  return new cw.Metric({
    "namespace": "AWS/VPN",
    "metricName": metricName,
    "dimensionsMap": {
      "VpnId": this.vpnId
    },
    ...props
  }).attachTo(this);
};
VpnConnectionBase.prototype.metricTunnelState = function(props?: cw.MetricOptions) {
  return this.metric("TunnelState", {
    "statistic": "Average",
    ...props
  });
};
VpnConnectionBase.prototype.metricTunnelDataIn = function(props?: cw.MetricOptions) {
  return this.metric("TunnelDataIn", {
    "statistic": "Sum",
    ...props
  });
};
VpnConnectionBase.prototype.metricTunnelDataOut = function(props?: cw.MetricOptions) {
  return this.metric("TunnelDataOut", {
    "statistic": "Sum",
    ...props
  });
};",
  "metrics": "/* eslint-disable prettier/prettier,max-len */
export interface MetricWithDims<D> {
  readonly namespace: string;

  readonly metricName: string;

  readonly statistic: string;

  readonly dimensionsMap: D;
}

export class EC2CapacityReservationsMetrics {
  public static instanceUtilizationAverage(dimensions: { CapacityReservationId: string; }): MetricWithDims<{ CapacityReservationId: string; }> {
    return {
      "namespace": "AWS/EC2CapacityReservations",
      "metricName": "InstanceUtilization",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static usedInstanceCountAverage(dimensions: { CapacityReservationId: string; }): MetricWithDims<{ CapacityReservationId: string; }> {
    return {
      "namespace": "AWS/EC2CapacityReservations",
      "metricName": "UsedInstanceCount",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static availableInstanceCountAverage(dimensions: { CapacityReservationId: string; }): MetricWithDims<{ CapacityReservationId: string; }> {
    return {
      "namespace": "AWS/EC2CapacityReservations",
      "metricName": "AvailableInstanceCount",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static totalInstanceCountAverage(dimensions: { CapacityReservationId: string; }): MetricWithDims<{ CapacityReservationId: string; }> {
    return {
      "namespace": "AWS/EC2CapacityReservations",
      "metricName": "TotalInstanceCount",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}

export class EBSMetrics {
  public static volumeReadBytesSum(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeReadBytes",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static volumeWriteBytesSum(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeWriteBytes",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static volumeReadOpsSum(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeReadOps",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static volumeTotalReadTimeAverage(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeTotalReadTime",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static volumeWriteOpsSum(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeWriteOps",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static volumeTotalWriteTimeAverage(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeTotalWriteTime",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static volumeIdleTimeAverage(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeIdleTime",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static volumeQueueLengthAverage(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "VolumeQueueLength",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static burstBalanceAverage(dimensions: { VolumeId: string; }): MetricWithDims<{ VolumeId: string; }> {
    return {
      "namespace": "AWS/EBS",
      "metricName": "BurstBalance",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}

export class EC2Metrics {
  public static cpuCreditUsageAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "CPUCreditUsage",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuCreditBalanceAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "CPUCreditBalance",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuSurplusCreditBalanceAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "CPUSurplusCreditBalance",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuSurplusCreditsChargedAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "CPUSurplusCreditsCharged",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuUtilizationAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static cpuUtilizationAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static cpuUtilizationAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static cpuUtilizationAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static cpuUtilizationAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static cpuUtilizationAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "CPUUtilization",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskReadBytesAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static diskReadBytesAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static diskReadBytesAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static diskReadBytesAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static diskReadBytesAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static diskReadBytesAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "DiskReadBytes",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskReadOpsAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static diskReadOpsAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static diskReadOpsAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static diskReadOpsAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static diskReadOpsAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static diskReadOpsAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "DiskReadOps",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskWriteBytesAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static diskWriteBytesAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static diskWriteBytesAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static diskWriteBytesAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static diskWriteBytesAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static diskWriteBytesAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "DiskWriteBytes",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskWriteOpsAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static diskWriteOpsAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static diskWriteOpsAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static diskWriteOpsAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static diskWriteOpsAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static diskWriteOpsAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "DiskWriteOps",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static metadataNoTokenSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static metadataNoTokenSum(dimensions: {  }): MetricWithDims<{  }>;

  public static metadataNoTokenSum(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "MetadataNoToken",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static networkInAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static networkInAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static networkInAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static networkInAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static networkInAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static networkInAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "NetworkIn",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static networkOutAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static networkOutAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static networkOutAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static networkOutAverage(dimensions: { ImageId: string; }): MetricWithDims<{ ImageId: string; }>;

  public static networkOutAverage(dimensions: { InstanceType: string; }): MetricWithDims<{ InstanceType: string; }>;

  public static networkOutAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "NetworkOut",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static networkPacketsInAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static networkPacketsInAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static networkPacketsInAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static networkPacketsInAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "NetworkPacketsIn",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static networkPacketsOutAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }>;

  public static networkPacketsOutAverage(dimensions: {  }): MetricWithDims<{  }>;

  public static networkPacketsOutAverage(dimensions: { AutoScalingGroupName: string; }): MetricWithDims<{ AutoScalingGroupName: string; }>;

  public static networkPacketsOutAverage(dimensions: any): MetricWithDims<any> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "NetworkPacketsOut",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static statusCheckFailedSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "StatusCheckFailed",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static statusCheckFailedInstanceSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "StatusCheckFailed_Instance",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static statusCheckFailedSystemSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "AWS/EC2",
      "metricName": "StatusCheckFailed_System",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }
}

export class CWAgentMetrics {
  public static cpuUsageIdleAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "cpu_usage_idle",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuUsageIowaitAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "cpu_usage_iowait",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuUsageStealAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "cpu_usage_steal",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuUsageSystemAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "cpu_usage_system",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static cpuUsageUserAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "cpu_usage_user",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskInodesFreeSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "disk_inodes_free",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static diskInodesTotalSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "disk_inodes_total",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static diskInodesUsedSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "disk_inodes_used",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static diskUsedPercentAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "disk_used_percent",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskioIoTimeAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "diskio_io_time",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskioReadBytesAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "diskio_read_bytes",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskioReadsAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "diskio_reads",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskioWriteBytesAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "diskio_write_bytes",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static diskioWritesAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "diskio_writes",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static memCachedAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "mem_cached",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static memTotalAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "mem_total",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static memUsedAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "mem_used",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static memUsedPercentAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "mem_used_percent",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static netstatTcpEstablishedSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "netstat_tcp_established",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static netstatTcpTimeWaitSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "netstat_tcp_time_wait",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static swapUsedPercentAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "swap_used_percent",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static tcPv4ConnectionsEstablishedSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "TCPv4 Connections Established",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static tcPv6ConnectionsEstablishedSum(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "TCPv6 Connections Established",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static memoryCommittedBytesInUseAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "Memory % Committed Bytes In Use",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static processorIdleTimeAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "Processor % Idle Time",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static processorInterruptTimeAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "Processor % Interrupt Time",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static processorUserTimeAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "Processor % User Time",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static logicalDiskFreeSpaceAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "LogicalDisk % Free Space",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static pagingFileUsageAverage(dimensions: { InstanceId: string; }): MetricWithDims<{ InstanceId: string; }> {
    return {
      "namespace": "CWAgent",
      "metricName": "Paging File % Usage",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}

export class NATGatewayMetrics {
  public static activeConnectionCountMaximum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "ActiveConnectionCount",
      "dimensionsMap": dimensions,
      "statistic": "Maximum"
    };
  }

  public static packetsDropCountSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "PacketsDropCount",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static bytesInFromDestinationSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "BytesInFromDestination",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static bytesInFromSourceSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "BytesInFromSource",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static bytesOutToDestinationSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "BytesOutToDestination",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static bytesOutToSourceSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "BytesOutToSource",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static connectionAttemptCountSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "ConnectionAttemptCount",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static connectionEstablishedCountSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "ConnectionEstablishedCount",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static errorPortAllocationSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "ErrorPortAllocation",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static idleTimeoutCountSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "IdleTimeoutCount",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetsInFromDestinationSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "PacketsInFromDestination",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetsInFromSourceSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "PacketsInFromSource",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetsOutToDestinationSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "PacketsOutToDestination",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetsOutToSourceSum(dimensions: { NatGatewayId: string; }): MetricWithDims<{ NatGatewayId: string; }> {
    return {
      "namespace": "AWS/NATGateway",
      "metricName": "PacketsOutToSource",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }
}

export class TransitGatewayMetrics {
  public static bytesInSum(dimensions: { TransitGateway: string; }): MetricWithDims<{ TransitGateway: string; }> {
    return {
      "namespace": "AWS/TransitGateway",
      "metricName": "BytesIn",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static bytesOutSum(dimensions: { TransitGateway: string; }): MetricWithDims<{ TransitGateway: string; }> {
    return {
      "namespace": "AWS/TransitGateway",
      "metricName": "BytesOut",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetDropCountBlackholeSum(dimensions: { TransitGateway: string; }): MetricWithDims<{ TransitGateway: string; }> {
    return {
      "namespace": "AWS/TransitGateway",
      "metricName": "PacketDropCountBlackhole",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetDropCountNoRouteSum(dimensions: { TransitGateway: string; }): MetricWithDims<{ TransitGateway: string; }> {
    return {
      "namespace": "AWS/TransitGateway",
      "metricName": "PacketDropCountNoRoute",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetsInSum(dimensions: { TransitGateway: string; }): MetricWithDims<{ TransitGateway: string; }> {
    return {
      "namespace": "AWS/TransitGateway",
      "metricName": "PacketsIn",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static packetsOutSum(dimensions: { TransitGateway: string; }): MetricWithDims<{ TransitGateway: string; }> {
    return {
      "namespace": "AWS/TransitGateway",
      "metricName": "PacketsOut",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }
}

export class VPNMetrics {
  public static tunnelDataInSum(dimensions: { VpnId: string; }): MetricWithDims<{ VpnId: string; }> {
    return {
      "namespace": "AWS/VPN",
      "metricName": "TunnelDataIn",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }

  public static tunnelStateAverage(dimensions: { VpnId: string; }): MetricWithDims<{ VpnId: string; }> {
    return {
      "namespace": "AWS/VPN",
      "metricName": "TunnelState",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static tunnelDataOutSum(dimensions: { VpnId: string; }): MetricWithDims<{ VpnId: string; }> {
    return {
      "namespace": "AWS/VPN",
      "metricName": "TunnelDataOut",
      "dimensionsMap": dimensions,
      "statistic": "Sum"
    };
  }
}",
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * Creates a new Capacity Reservation with the specified attributes.
 *
 * For more information, see [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html) in the *Amazon EC2 User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html
 */
export class CfnCapacityReservation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::CapacityReservation";

  /**
   * Build a CfnCapacityReservation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnCapacityReservation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnCapacityReservationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnCapacityReservation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Returns the Availability Zone in which the capacity is reserved. For example: \`us-east-1a\` .
   *
   * @cloudformationAttribute AvailabilityZone
   */
  public readonly attrAvailabilityZone: string;

  /**
   * Returns the remaining capacity, which indicates the number of instances that can be launched in the Capacity Reservation. For example: \`9\` .
   *
   * @cloudformationAttribute AvailableInstanceCount
   */
  public readonly attrAvailableInstanceCount: cdk.IResolvable;

  /**
   * The ID of the Capacity Reservation.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Returns the type of instance for which the capacity is reserved. For example: \`m4.large\` .
   *
   * @cloudformationAttribute InstanceType
   */
  public readonly attrInstanceType: string;

  /**
   * Returns the tenancy of the Capacity Reservation. For example: \`dedicated\` .
   *
   * @cloudformationAttribute Tenancy
   */
  public readonly attrTenancy: string;

  /**
   * Returns the total number of instances for which the Capacity Reservation reserves capacity. For example: \`15\` .
   *
   * @cloudformationAttribute TotalInstanceCount
   */
  public readonly attrTotalInstanceCount: cdk.IResolvable;

  /**
   * The Availability Zone in which to create the Capacity Reservation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-availabilityzone
   */
  public availabilityZone: string;

  /**
   * Indicates whether the Capacity Reservation supports EBS-optimized instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ebsoptimized
   */
  public ebsOptimized?: boolean | cdk.IResolvable;

  /**
   * The date and time at which the Capacity Reservation expires.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddate
   */
  public endDate?: string;

  /**
   * Indicates the way in which the Capacity Reservation ends.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddatetype
   */
  public endDateType?: string;

  /**
   * *Deprecated.*.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ephemeralstorage
   */
  public ephemeralStorage?: boolean | cdk.IResolvable;

  /**
   * The number of instances for which to reserve capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancecount
   */
  public instanceCount: number;

  /**
   * Indicates the type of instance launches that the Capacity Reservation accepts. The options include:.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancematchcriteria
   */
  public instanceMatchCriteria?: string;

  /**
   * The type of operating system for which to reserve capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instanceplatform
   */
  public instancePlatform: string;

  /**
   * The instance type for which to reserve capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancetype
   */
  public instanceType: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-outpostarn
   */
  public outPostArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-placementgrouparn
   */
  public placementGroupArn?: string;

  /**
   * The tags to apply to the Capacity Reservation during launch.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tagspecifications
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservation.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tenancy
   */
  public tenancy?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnCapacityReservationProps) {
    super(scope, id, {
      "type": CfnCapacityReservation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "availabilityZone", this);
    cdk.requireProperty(props, "instanceCount", this);
    cdk.requireProperty(props, "instancePlatform", this);
    cdk.requireProperty(props, "instanceType", this);

    this.attrAvailabilityZone = cdk.Token.asString(this.getAtt("AvailabilityZone", cdk.ResolutionTypeHint.STRING));
    this.attrAvailableInstanceCount = this.getAtt("AvailableInstanceCount", cdk.ResolutionTypeHint.NUMBER);
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrInstanceType = cdk.Token.asString(this.getAtt("InstanceType", cdk.ResolutionTypeHint.STRING));
    this.attrTenancy = cdk.Token.asString(this.getAtt("Tenancy", cdk.ResolutionTypeHint.STRING));
    this.attrTotalInstanceCount = this.getAtt("TotalInstanceCount", cdk.ResolutionTypeHint.NUMBER);
    this.availabilityZone = props.availabilityZone;
    this.ebsOptimized = props.ebsOptimized;
    this.endDate = props.endDate;
    this.endDateType = props.endDateType;
    this.ephemeralStorage = props.ephemeralStorage;
    this.instanceCount = props.instanceCount;
    this.instanceMatchCriteria = props.instanceMatchCriteria;
    this.instancePlatform = props.instancePlatform;
    this.instanceType = props.instanceType;
    this.outPostArn = props.outPostArn;
    this.placementGroupArn = props.placementGroupArn;
    this.tagSpecifications = props.tagSpecifications;
    this.tenancy = props.tenancy;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "availabilityZone": this.availabilityZone,
      "ebsOptimized": this.ebsOptimized,
      "endDate": this.endDate,
      "endDateType": this.endDateType,
      "ephemeralStorage": this.ephemeralStorage,
      "instanceCount": this.instanceCount,
      "instanceMatchCriteria": this.instanceMatchCriteria,
      "instancePlatform": this.instancePlatform,
      "instanceType": this.instanceType,
      "outPostArn": this.outPostArn,
      "placementGroupArn": this.placementGroupArn,
      "tagSpecifications": this.tagSpecifications,
      "tenancy": this.tenancy
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnCapacityReservation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnCapacityReservationPropsToCloudFormation(props);
  }
}

export namespace CfnCapacityReservation {
  /**
   * An array of key-value pairs to apply to this resource.
   *
   * For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * The Availability Zone in which to create the Capacity Reservation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-availabilityzone
     */
    readonly availabilityZone: string;

    /**
     * Indicates whether the Capacity Reservation supports EBS-optimized instances.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * The date and time at which the Capacity Reservation expires.
     *
     * When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to \`expired\` when it reaches its end date and time.
     *
     * You must provide an \`EndDate\` value if \`EndDateType\` is \`limited\` . Omit \`EndDate\` if \`EndDateType\` is \`unlimited\` .
     *
     * If the \`EndDateType\` is \`limited\` , the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-enddate
     */
    readonly endDate?: string;

    /**
     * Indicates the way in which the Capacity Reservation ends.
     *
     * A Capacity Reservation can have one of the following end types:
     *
     * - \`unlimited\` - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an \`EndDate\` if the \`EndDateType\` is \`unlimited\` .
     * - \`limited\` - The Capacity Reservation expires automatically at a specified date and time. You must provide an \`EndDate\` value if the \`EndDateType\` value is \`limited\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-enddatetype
     */
    readonly endDateType?: string;

    /**
     * *Deprecated.*.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-ephemeralstorage
     */
    readonly ephemeralStorage?: boolean | cdk.IResolvable;

    /**
     * The number of instances for which to reserve capacity.
     *
     * Valid range: 1 - 1000
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-instancecount
     */
    readonly instanceCount: number;

    /**
     * Indicates the type of instance launches that the Capacity Reservation accepts. The options include:.
     *
     * - \`open\` - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters.
     * - \`targeted\` - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity.
     *
     * Default: \`open\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-instancematchcriteria
     */
    readonly instanceMatchCriteria?: string;

    /**
     * The type of operating system for which to reserve capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-instanceplatform
     */
    readonly instancePlatform: string;

    /**
     * The instance type for which to reserve capacity.
     *
     * For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-instancetype
     */
    readonly instanceType: string;

    /**
     * The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-outpostarn
     */
    readonly outPostArn?: string;

    /**
     * The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation.
     *
     * For more information, see [Capacity Reservations for cluster placement groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-cpg.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-placementgrouparn
     */
    readonly placementGroupArn?: string;

    /**
     * The tags to apply to the Capacity Reservation during launch.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservation.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:.
     *
     * - \`default\` - The Capacity Reservation is created on hardware that is shared with other AWS accounts .
     * - \`dedicated\` - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-tenancy
     */
    readonly tenancy?: string;
  }
}

/**
 * Properties for defining a \`CfnCapacityReservation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html
 */
export interface CfnCapacityReservationProps {
  /**
   * The Availability Zone in which to create the Capacity Reservation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-availabilityzone
   */
  readonly availabilityZone: string;

  /**
   * Indicates whether the Capacity Reservation supports EBS-optimized instances.
   *
   * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ebsoptimized
   */
  readonly ebsOptimized?: boolean | cdk.IResolvable;

  /**
   * The date and time at which the Capacity Reservation expires.
   *
   * When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to \`expired\` when it reaches its end date and time.
   *
   * You must provide an \`EndDate\` value if \`EndDateType\` is \`limited\` . Omit \`EndDate\` if \`EndDateType\` is \`unlimited\` .
   *
   * If the \`EndDateType\` is \`limited\` , the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddate
   */
  readonly endDate?: string;

  /**
   * Indicates the way in which the Capacity Reservation ends.
   *
   * A Capacity Reservation can have one of the following end types:
   *
   * - \`unlimited\` - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an \`EndDate\` if the \`EndDateType\` is \`unlimited\` .
   * - \`limited\` - The Capacity Reservation expires automatically at a specified date and time. You must provide an \`EndDate\` value if the \`EndDateType\` value is \`limited\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddatetype
   */
  readonly endDateType?: string;

  /**
   * *Deprecated.*.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ephemeralstorage
   */
  readonly ephemeralStorage?: boolean | cdk.IResolvable;

  /**
   * The number of instances for which to reserve capacity.
   *
   * Valid range: 1 - 1000
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancecount
   */
  readonly instanceCount: number;

  /**
   * Indicates the type of instance launches that the Capacity Reservation accepts. The options include:.
   *
   * - \`open\` - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters.
   * - \`targeted\` - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity.
   *
   * Default: \`open\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancematchcriteria
   */
  readonly instanceMatchCriteria?: string;

  /**
   * The type of operating system for which to reserve capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instanceplatform
   */
  readonly instancePlatform: string;

  /**
   * The instance type for which to reserve capacity.
   *
   * For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancetype
   */
  readonly instanceType: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-outpostarn
   */
  readonly outPostArn?: string;

  /**
   * The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation.
   *
   * For more information, see [Capacity Reservations for cluster placement groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-cpg.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-placementgrouparn
   */
  readonly placementGroupArn?: string;

  /**
   * The tags to apply to the Capacity Reservation during launch.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservation.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:.
   *
   * - \`default\` - The Capacity Reservation is created on hardware that is shared with other AWS accounts .
   * - \`dedicated\` - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tenancy
   */
  readonly tenancy?: string;
}

/**
 * Determine whether the given properties match those of a \`TagSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.requiredValidator)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("endDateType", cdk.validateString)(properties.endDateType));
  errors.collect(cdk.propertyValidator("ephemeralStorage", cdk.validateBoolean)(properties.ephemeralStorage));
  errors.collect(cdk.propertyValidator("instanceCount", cdk.requiredValidator)(properties.instanceCount));
  errors.collect(cdk.propertyValidator("instanceCount", cdk.validateNumber)(properties.instanceCount));
  errors.collect(cdk.propertyValidator("instanceMatchCriteria", cdk.validateString)(properties.instanceMatchCriteria));
  errors.collect(cdk.propertyValidator("instancePlatform", cdk.requiredValidator)(properties.instancePlatform));
  errors.collect(cdk.propertyValidator("instancePlatform", cdk.validateString)(properties.instancePlatform));
  errors.collect(cdk.propertyValidator("instanceType", cdk.requiredValidator)(properties.instanceType));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("outPostArn", cdk.validateString)(properties.outPostArn));
  errors.collect(cdk.propertyValidator("placementGroupArn", cdk.validateString)(properties.placementGroupArn));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnCapacityReservationTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  return errors.wrap("supplied properties not correct for \\"TagSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "EndDateType": cdk.stringToCloudFormation(properties.endDateType),
    "EphemeralStorage": cdk.booleanToCloudFormation(properties.ephemeralStorage),
    "InstanceCount": cdk.numberToCloudFormation(properties.instanceCount),
    "InstanceMatchCriteria": cdk.stringToCloudFormation(properties.instanceMatchCriteria),
    "InstancePlatform": cdk.stringToCloudFormation(properties.instancePlatform),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "OutPostArn": cdk.stringToCloudFormation(properties.outPostArn),
    "PlacementGroupArn": cdk.stringToCloudFormation(properties.placementGroupArn),
    "TagSpecifications": cdk.listMapper(convertCfnCapacityReservationTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnCapacityReservation.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservation.TagSpecificationProperty>();
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("endDateType", "EndDateType", (properties.EndDateType != null ? cfn_parse.FromCloudFormation.getString(properties.EndDateType) : undefined));
  ret.addPropertyResult("ephemeralStorage", "EphemeralStorage", (properties.EphemeralStorage != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EphemeralStorage) : undefined));
  ret.addPropertyResult("instanceCount", "InstanceCount", (properties.InstanceCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.InstanceCount) : undefined));
  ret.addPropertyResult("instanceMatchCriteria", "InstanceMatchCriteria", (properties.InstanceMatchCriteria != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceMatchCriteria) : undefined));
  ret.addPropertyResult("instancePlatform", "InstancePlatform", (properties.InstancePlatform != null ? cfn_parse.FromCloudFormation.getString(properties.InstancePlatform) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("outPostArn", "OutPostArn", (properties.OutPostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutPostArn) : undefined));
  ret.addPropertyResult("placementGroupArn", "PlacementGroupArn", (properties.PlacementGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupArn) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnCapacityReservationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnCapacityReservationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.requiredValidator)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("endDateType", cdk.validateString)(properties.endDateType));
  errors.collect(cdk.propertyValidator("ephemeralStorage", cdk.validateBoolean)(properties.ephemeralStorage));
  errors.collect(cdk.propertyValidator("instanceCount", cdk.requiredValidator)(properties.instanceCount));
  errors.collect(cdk.propertyValidator("instanceCount", cdk.validateNumber)(properties.instanceCount));
  errors.collect(cdk.propertyValidator("instanceMatchCriteria", cdk.validateString)(properties.instanceMatchCriteria));
  errors.collect(cdk.propertyValidator("instancePlatform", cdk.requiredValidator)(properties.instancePlatform));
  errors.collect(cdk.propertyValidator("instancePlatform", cdk.validateString)(properties.instancePlatform));
  errors.collect(cdk.propertyValidator("instanceType", cdk.requiredValidator)(properties.instanceType));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("outPostArn", cdk.validateString)(properties.outPostArn));
  errors.collect(cdk.propertyValidator("placementGroupArn", cdk.validateString)(properties.placementGroupArn));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnCapacityReservationTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  return errors.wrap("supplied properties not correct for \\"CfnCapacityReservationProps\\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationPropsValidator(properties).assertSuccess();
  return {
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "EndDateType": cdk.stringToCloudFormation(properties.endDateType),
    "EphemeralStorage": cdk.booleanToCloudFormation(properties.ephemeralStorage),
    "InstanceCount": cdk.numberToCloudFormation(properties.instanceCount),
    "InstanceMatchCriteria": cdk.stringToCloudFormation(properties.instanceMatchCriteria),
    "InstancePlatform": cdk.stringToCloudFormation(properties.instancePlatform),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "OutPostArn": cdk.stringToCloudFormation(properties.outPostArn),
    "PlacementGroupArn": cdk.stringToCloudFormation(properties.placementGroupArn),
    "TagSpecifications": cdk.listMapper(convertCfnCapacityReservationTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCapacityReservationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservationProps>();
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("endDateType", "EndDateType", (properties.EndDateType != null ? cfn_parse.FromCloudFormation.getString(properties.EndDateType) : undefined));
  ret.addPropertyResult("ephemeralStorage", "EphemeralStorage", (properties.EphemeralStorage != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EphemeralStorage) : undefined));
  ret.addPropertyResult("instanceCount", "InstanceCount", (properties.InstanceCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.InstanceCount) : undefined));
  ret.addPropertyResult("instanceMatchCriteria", "InstanceMatchCriteria", (properties.InstanceMatchCriteria != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceMatchCriteria) : undefined));
  ret.addPropertyResult("instancePlatform", "InstancePlatform", (properties.InstancePlatform != null ? cfn_parse.FromCloudFormation.getString(properties.InstancePlatform) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("outPostArn", "OutPostArn", (properties.OutPostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutPostArn) : undefined));
  ret.addPropertyResult("placementGroupArn", "PlacementGroupArn", (properties.PlacementGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupArn) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a new Capacity Reservation Fleet with the specified attributes.
 *
 * For more information, see [Capacity Reservation Fleets](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-fleets.html) in the *Amazon EC2 User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html
 */
export class CfnCapacityReservationFleet extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::CapacityReservationFleet";

  /**
   * Build a CfnCapacityReservationFleet from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnCapacityReservationFleet {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnCapacityReservationFleetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnCapacityReservationFleet(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the Capacity Reservation Fleet.
   *
   * @cloudformationAttribute CapacityReservationFleetId
   */
  public readonly attrCapacityReservationFleetId: string;

  /**
   * The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-allocationstrategy
   */
  public allocationStrategy?: string;

  /**
   * The date and time at which the Capacity Reservation Fleet expires.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-enddate
   */
  public endDate?: string;

  /**
   * Indicates the type of instance launches that the Capacity Reservation Fleet accepts.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancematchcriteria
   */
  public instanceMatchCriteria?: string;

  /**
   * Information about the instance types for which to reserve the capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancetypespecifications
   */
  public instanceTypeSpecifications?: Array<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-noremoveenddate
   */
  public noRemoveEndDate?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-removeenddate
   */
  public removeEndDate?: boolean | cdk.IResolvable;

  /**
   * The tags to assign to the Capacity Reservation Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tagspecifications
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservationFleet.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * Indicates the tenancy of the Capacity Reservation Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tenancy
   */
  public tenancy?: string;

  /**
   * The total number of capacity units to be reserved by the Capacity Reservation Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-totaltargetcapacity
   */
  public totalTargetCapacity?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnCapacityReservationFleetProps = {}) {
    super(scope, id, {
      "type": CfnCapacityReservationFleet.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrCapacityReservationFleetId = cdk.Token.asString(this.getAtt("CapacityReservationFleetId", cdk.ResolutionTypeHint.STRING));
    this.allocationStrategy = props.allocationStrategy;
    this.endDate = props.endDate;
    this.instanceMatchCriteria = props.instanceMatchCriteria;
    this.instanceTypeSpecifications = props.instanceTypeSpecifications;
    this.noRemoveEndDate = props.noRemoveEndDate;
    this.removeEndDate = props.removeEndDate;
    this.tagSpecifications = props.tagSpecifications;
    this.tenancy = props.tenancy;
    this.totalTargetCapacity = props.totalTargetCapacity;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allocationStrategy": this.allocationStrategy,
      "endDate": this.endDate,
      "instanceMatchCriteria": this.instanceMatchCriteria,
      "instanceTypeSpecifications": this.instanceTypeSpecifications,
      "noRemoveEndDate": this.noRemoveEndDate,
      "removeEndDate": this.removeEndDate,
      "tagSpecifications": this.tagSpecifications,
      "tenancy": this.tenancy,
      "totalTargetCapacity": this.totalTargetCapacity
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnCapacityReservationFleet.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnCapacityReservationFleetPropsToCloudFormation(props);
  }
}

export namespace CfnCapacityReservationFleet {
  /**
   * The tags to apply to a resource when the resource is being created.
   *
   * When you specify a tag, you must specify the resource type to tag, otherwise the request will fail.
   *
   * > The \`Valid Values\` lists all the resource types that can be tagged. However, the action you're using might not support tagging all of these resource types. If you try to tag a resource type that is unsupported for the action you're using, you'll get an error.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use.
     *
     * Currently, only the \`prioritized\` allocation strategy is supported. For more information, see [Allocation strategy](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy) in the Amazon EC2 User Guide.
     *
     * Valid values: \`prioritized\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-allocationstrategy
     */
    readonly allocationStrategy?: string;

    /**
     * The date and time at which the Capacity Reservation Fleet expires.
     *
     * When the Capacity Reservation Fleet expires, its state changes to \`expired\` and all of the Capacity Reservations in the Fleet expire.
     *
     * The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify \`5/31/2019\` , \`13:30:55\` , the Capacity Reservation Fleet is guaranteed to expire between \`13:30:55\` and \`14:30:55\` on \`5/31/2019\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-enddate
     */
    readonly endDate?: string;

    /**
     * Indicates the type of instance launches that the Capacity Reservation Fleet accepts.
     *
     * All Capacity Reservations in the Fleet inherit this instance matching criteria.
     *
     * Currently, Capacity Reservation Fleets support \`open\` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-instancematchcriteria
     */
    readonly instanceMatchCriteria?: string;

    /**
     * Information about the instance types for which to reserve the capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-instancetypespecifications
     */
    readonly instanceTypeSpecifications?: Array<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-noremoveenddate
     */
    readonly noRemoveEndDate?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-removeenddate
     */
    readonly removeEndDate?: boolean | cdk.IResolvable;

    /**
     * The tags to assign to the Capacity Reservation Fleet.
     *
     * The tags are automatically assigned to the Capacity Reservations in the Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservationFleet.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * Indicates the tenancy of the Capacity Reservation Fleet.
     *
     * All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings:
     *
     * - \`default\` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts .
     * - \`dedicated\` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-tenancy
     */
    readonly tenancy?: string;

    /**
     * The total number of capacity units to be reserved by the Capacity Reservation Fleet.
     *
     * This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-totaltargetcapacity
     */
    readonly totalTargetCapacity?: number;
  }

  /**
   * Specifies information about an instance type to use in a Capacity Reservation Fleet.
   *
   * \`InstanceTypeSpecification\` is a property of the [AWS::EC2::CapacityReservationFleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html
   */
  export interface InstanceTypeSpecificationProperty {
    /**
     * The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use.
     *
     * Currently, only the \`prioritized\` allocation strategy is supported. For more information, see [Allocation strategy](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy) in the Amazon EC2 User Guide.
     *
     * Valid values: \`prioritized\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-allocationstrategy
     */
    readonly allocationStrategy?: string;

    /**
     * The date and time at which the Capacity Reservation Fleet expires.
     *
     * When the Capacity Reservation Fleet expires, its state changes to \`expired\` and all of the Capacity Reservations in the Fleet expire.
     *
     * The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify \`5/31/2019\` , \`13:30:55\` , the Capacity Reservation Fleet is guaranteed to expire between \`13:30:55\` and \`14:30:55\` on \`5/31/2019\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-enddate
     */
    readonly endDate?: string;

    /**
     * Indicates the type of instance launches that the Capacity Reservation Fleet accepts.
     *
     * All Capacity Reservations in the Fleet inherit this instance matching criteria.
     *
     * Currently, Capacity Reservation Fleets support \`open\` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-instancematchcriteria
     */
    readonly instanceMatchCriteria?: string;

    /**
     * Information about the instance types for which to reserve the capacity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-instancetypespecifications
     */
    readonly instanceTypeSpecifications?: Array<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-noremoveenddate
     */
    readonly noRemoveEndDate?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-removeenddate
     */
    readonly removeEndDate?: boolean | cdk.IResolvable;

    /**
     * The tags to assign to the Capacity Reservation Fleet.
     *
     * The tags are automatically assigned to the Capacity Reservations in the Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservationFleet.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * Indicates the tenancy of the Capacity Reservation Fleet.
     *
     * All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings:
     *
     * - \`default\` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts .
     * - \`dedicated\` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-tenancy
     */
    readonly tenancy?: string;

    /**
     * The total number of capacity units to be reserved by the Capacity Reservation Fleet.
     *
     * This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-totaltargetcapacity
     */
    readonly totalTargetCapacity?: number;
  }
}

/**
 * Properties for defining a \`CfnCapacityReservationFleet\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html
 */
export interface CfnCapacityReservationFleetProps {
  /**
   * The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use.
   *
   * Currently, only the \`prioritized\` allocation strategy is supported. For more information, see [Allocation strategy](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy) in the Amazon EC2 User Guide.
   *
   * Valid values: \`prioritized\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-allocationstrategy
   */
  readonly allocationStrategy?: string;

  /**
   * The date and time at which the Capacity Reservation Fleet expires.
   *
   * When the Capacity Reservation Fleet expires, its state changes to \`expired\` and all of the Capacity Reservations in the Fleet expire.
   *
   * The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify \`5/31/2019\` , \`13:30:55\` , the Capacity Reservation Fleet is guaranteed to expire between \`13:30:55\` and \`14:30:55\` on \`5/31/2019\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-enddate
   */
  readonly endDate?: string;

  /**
   * Indicates the type of instance launches that the Capacity Reservation Fleet accepts.
   *
   * All Capacity Reservations in the Fleet inherit this instance matching criteria.
   *
   * Currently, Capacity Reservation Fleets support \`open\` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancematchcriteria
   */
  readonly instanceMatchCriteria?: string;

  /**
   * Information about the instance types for which to reserve the capacity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancetypespecifications
   */
  readonly instanceTypeSpecifications?: Array<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-noremoveenddate
   */
  readonly noRemoveEndDate?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-removeenddate
   */
  readonly removeEndDate?: boolean | cdk.IResolvable;

  /**
   * The tags to assign to the Capacity Reservation Fleet.
   *
   * The tags are automatically assigned to the Capacity Reservations in the Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnCapacityReservationFleet.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * Indicates the tenancy of the Capacity Reservation Fleet.
   *
   * All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings:
   *
   * - \`default\` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts .
   * - \`dedicated\` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tenancy
   */
  readonly tenancy?: string;

  /**
   * The total number of capacity units to be reserved by the Capacity Reservation Fleet.
   *
   * This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-totaltargetcapacity
   */
  readonly totalTargetCapacity?: number;
}

/**
 * Determine whether the given properties match those of a \`InstanceTypeSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`InstanceTypeSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationFleetInstanceTypeSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationStrategy", cdk.validateString)(properties.allocationStrategy));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("instanceMatchCriteria", cdk.validateString)(properties.instanceMatchCriteria));
  errors.collect(cdk.propertyValidator("instanceTypeSpecifications", cdk.listValidator(CfnCapacityReservationFleetInstanceTypeSpecificationPropertyValidator))(properties.instanceTypeSpecifications));
  errors.collect(cdk.propertyValidator("noRemoveEndDate", cdk.validateBoolean)(properties.noRemoveEndDate));
  errors.collect(cdk.propertyValidator("removeEndDate", cdk.validateBoolean)(properties.removeEndDate));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnCapacityReservationFleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("totalTargetCapacity", cdk.validateNumber)(properties.totalTargetCapacity));
  return errors.wrap("supplied properties not correct for \\"InstanceTypeSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationFleetInstanceTypeSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationFleetInstanceTypeSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "AllocationStrategy": cdk.stringToCloudFormation(properties.allocationStrategy),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "InstanceMatchCriteria": cdk.stringToCloudFormation(properties.instanceMatchCriteria),
    "InstanceTypeSpecifications": cdk.listMapper(convertCfnCapacityReservationFleetInstanceTypeSpecificationPropertyToCloudFormation)(properties.instanceTypeSpecifications),
    "NoRemoveEndDate": cdk.booleanToCloudFormation(properties.noRemoveEndDate),
    "RemoveEndDate": cdk.booleanToCloudFormation(properties.removeEndDate),
    "TagSpecifications": cdk.listMapper(convertCfnCapacityReservationFleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "TotalTargetCapacity": cdk.numberToCloudFormation(properties.totalTargetCapacity)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationFleetInstanceTypeSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservationFleet.InstanceTypeSpecificationProperty>();
  ret.addPropertyResult("allocationStrategy", "AllocationStrategy", (properties.AllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationStrategy) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("instanceMatchCriteria", "InstanceMatchCriteria", (properties.InstanceMatchCriteria != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceMatchCriteria) : undefined));
  ret.addPropertyResult("instanceTypeSpecifications", "InstanceTypeSpecifications", (properties.InstanceTypeSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationFleetInstanceTypeSpecificationPropertyFromCloudFormation)(properties.InstanceTypeSpecifications) : undefined));
  ret.addPropertyResult("noRemoveEndDate", "NoRemoveEndDate", (properties.NoRemoveEndDate != null ? cfn_parse.FromCloudFormation.getBoolean(properties.NoRemoveEndDate) : undefined));
  ret.addPropertyResult("removeEndDate", "RemoveEndDate", (properties.RemoveEndDate != null ? cfn_parse.FromCloudFormation.getBoolean(properties.RemoveEndDate) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationFleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("totalTargetCapacity", "TotalTargetCapacity", (properties.TotalTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.TotalTargetCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TagSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationFleetTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationStrategy", cdk.validateString)(properties.allocationStrategy));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("instanceMatchCriteria", cdk.validateString)(properties.instanceMatchCriteria));
  errors.collect(cdk.propertyValidator("instanceTypeSpecifications", cdk.listValidator(CfnCapacityReservationFleetInstanceTypeSpecificationPropertyValidator))(properties.instanceTypeSpecifications));
  errors.collect(cdk.propertyValidator("noRemoveEndDate", cdk.validateBoolean)(properties.noRemoveEndDate));
  errors.collect(cdk.propertyValidator("removeEndDate", cdk.validateBoolean)(properties.removeEndDate));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnCapacityReservationFleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("totalTargetCapacity", cdk.validateNumber)(properties.totalTargetCapacity));
  return errors.wrap("supplied properties not correct for \\"TagSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationFleetTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationFleetTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "AllocationStrategy": cdk.stringToCloudFormation(properties.allocationStrategy),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "InstanceMatchCriteria": cdk.stringToCloudFormation(properties.instanceMatchCriteria),
    "InstanceTypeSpecifications": cdk.listMapper(convertCfnCapacityReservationFleetInstanceTypeSpecificationPropertyToCloudFormation)(properties.instanceTypeSpecifications),
    "NoRemoveEndDate": cdk.booleanToCloudFormation(properties.noRemoveEndDate),
    "RemoveEndDate": cdk.booleanToCloudFormation(properties.removeEndDate),
    "TagSpecifications": cdk.listMapper(convertCfnCapacityReservationFleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "TotalTargetCapacity": cdk.numberToCloudFormation(properties.totalTargetCapacity)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationFleetTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnCapacityReservationFleet.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservationFleet.TagSpecificationProperty>();
  ret.addPropertyResult("allocationStrategy", "AllocationStrategy", (properties.AllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationStrategy) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("instanceMatchCriteria", "InstanceMatchCriteria", (properties.InstanceMatchCriteria != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceMatchCriteria) : undefined));
  ret.addPropertyResult("instanceTypeSpecifications", "InstanceTypeSpecifications", (properties.InstanceTypeSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationFleetInstanceTypeSpecificationPropertyFromCloudFormation)(properties.InstanceTypeSpecifications) : undefined));
  ret.addPropertyResult("noRemoveEndDate", "NoRemoveEndDate", (properties.NoRemoveEndDate != null ? cfn_parse.FromCloudFormation.getBoolean(properties.NoRemoveEndDate) : undefined));
  ret.addPropertyResult("removeEndDate", "RemoveEndDate", (properties.RemoveEndDate != null ? cfn_parse.FromCloudFormation.getBoolean(properties.RemoveEndDate) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationFleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("totalTargetCapacity", "TotalTargetCapacity", (properties.TotalTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.TotalTargetCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnCapacityReservationFleetProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnCapacityReservationFleetProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCapacityReservationFleetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationStrategy", cdk.validateString)(properties.allocationStrategy));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("instanceMatchCriteria", cdk.validateString)(properties.instanceMatchCriteria));
  errors.collect(cdk.propertyValidator("instanceTypeSpecifications", cdk.listValidator(CfnCapacityReservationFleetInstanceTypeSpecificationPropertyValidator))(properties.instanceTypeSpecifications));
  errors.collect(cdk.propertyValidator("noRemoveEndDate", cdk.validateBoolean)(properties.noRemoveEndDate));
  errors.collect(cdk.propertyValidator("removeEndDate", cdk.validateBoolean)(properties.removeEndDate));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnCapacityReservationFleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("totalTargetCapacity", cdk.validateNumber)(properties.totalTargetCapacity));
  return errors.wrap("supplied properties not correct for \\"CfnCapacityReservationFleetProps\\"");
}

// @ts-ignore TS6133
function convertCfnCapacityReservationFleetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCapacityReservationFleetPropsValidator(properties).assertSuccess();
  return {
    "AllocationStrategy": cdk.stringToCloudFormation(properties.allocationStrategy),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "InstanceMatchCriteria": cdk.stringToCloudFormation(properties.instanceMatchCriteria),
    "InstanceTypeSpecifications": cdk.listMapper(convertCfnCapacityReservationFleetInstanceTypeSpecificationPropertyToCloudFormation)(properties.instanceTypeSpecifications),
    "NoRemoveEndDate": cdk.booleanToCloudFormation(properties.noRemoveEndDate),
    "RemoveEndDate": cdk.booleanToCloudFormation(properties.removeEndDate),
    "TagSpecifications": cdk.listMapper(convertCfnCapacityReservationFleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "TotalTargetCapacity": cdk.numberToCloudFormation(properties.totalTargetCapacity)
  };
}

// @ts-ignore TS6133
function CfnCapacityReservationFleetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCapacityReservationFleetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCapacityReservationFleetProps>();
  ret.addPropertyResult("allocationStrategy", "AllocationStrategy", (properties.AllocationStrategy != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationStrategy) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("instanceMatchCriteria", "InstanceMatchCriteria", (properties.InstanceMatchCriteria != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceMatchCriteria) : undefined));
  ret.addPropertyResult("instanceTypeSpecifications", "InstanceTypeSpecifications", (properties.InstanceTypeSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationFleetInstanceTypeSpecificationPropertyFromCloudFormation)(properties.InstanceTypeSpecifications) : undefined));
  ret.addPropertyResult("noRemoveEndDate", "NoRemoveEndDate", (properties.NoRemoveEndDate != null ? cfn_parse.FromCloudFormation.getBoolean(properties.NoRemoveEndDate) : undefined));
  ret.addPropertyResult("removeEndDate", "RemoveEndDate", (properties.RemoveEndDate != null ? cfn_parse.FromCloudFormation.getBoolean(properties.RemoveEndDate) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnCapacityReservationFleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("totalTargetCapacity", "TotalTargetCapacity", (properties.TotalTargetCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.TotalTargetCapacity) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a carrier gateway.
 *
 * For more information about carrier gateways, see [Carrier gateways](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#wavelength-carrier-gateway) in the *AWS Wavelength Developer Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html
 */
export class CfnCarrierGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::CarrierGateway";

  /**
   * Build a CfnCarrierGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnCarrierGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnCarrierGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnCarrierGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the carrier gateway.
   *
   * @cloudformationAttribute CarrierGatewayId
   */
  public readonly attrCarrierGatewayId: string;

  /**
   * The AWS account ID of the owner of the carrier gateway.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The state of the carrier gateway.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags assigned to the carrier gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC associated with the carrier gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-vpcid
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnCarrierGatewayProps) {
    super(scope, id, {
      "type": CfnCarrierGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrCarrierGatewayId = cdk.Token.asString(this.getAtt("CarrierGatewayId", cdk.ResolutionTypeHint.STRING));
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::CarrierGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnCarrierGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnCarrierGatewayPropsToCloudFormation(props);
  }
}

export namespace CfnCarrierGateway {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-carriergateway-tag.html
   */
  export interface TagProperty {
    /**
     * The tags assigned to the carrier gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-carriergateway-tag.html#cfn-ec2-carriergateway-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnCarrierGateway.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the VPC associated with the carrier gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-carriergateway-tag.html#cfn-ec2-carriergateway-tag-vpcid
     */
    readonly vpcId: string;
  }
}

/**
 * Properties for defining a \`CfnCarrierGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html
 */
export interface CfnCarrierGatewayProps {
  /**
   * The tags assigned to the carrier gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC associated with the carrier gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCarrierGatewayTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnCarrierGatewayTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnCarrierGatewayTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCarrierGatewayTagPropertyValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(convertCfnCarrierGatewayTagPropertyToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnCarrierGatewayTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnCarrierGateway.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCarrierGateway.TagProperty>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnCarrierGatewayTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnCarrierGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnCarrierGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCarrierGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnCarrierGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnCarrierGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCarrierGatewayPropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnCarrierGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCarrierGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCarrierGatewayProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an ingress authorization rule to add to a Client VPN endpoint.
 *
 * Ingress authorization rules act as firewall rules that grant access to networks. You must configure ingress authorization rules to enable clients to access resources in AWS or on-premises networks.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html
 */
export class CfnClientVpnAuthorizationRule extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::ClientVpnAuthorizationRule";

  /**
   * Build a CfnClientVpnAuthorizationRule from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnClientVpnAuthorizationRule {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnClientVpnAuthorizationRulePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnClientVpnAuthorizationRule(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-accessgroupid
   */
  public accessGroupId?: string;

  /**
   * Indicates whether to grant access to all clients.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-authorizeallgroups
   */
  public authorizeAllGroups?: boolean | cdk.IResolvable;

  /**
   * The ID of the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-clientvpnendpointid
   */
  public clientVpnEndpointId: string;

  /**
   * A brief description of the authorization rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-description
   */
  public description?: string;

  /**
   * The IPv4 address range, in CIDR notation, of the network for which access is being authorized.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-targetnetworkcidr
   */
  public targetNetworkCidr: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnClientVpnAuthorizationRuleProps) {
    super(scope, id, {
      "type": CfnClientVpnAuthorizationRule.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "clientVpnEndpointId", this);
    cdk.requireProperty(props, "targetNetworkCidr", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.accessGroupId = props.accessGroupId;
    this.authorizeAllGroups = props.authorizeAllGroups;
    this.clientVpnEndpointId = props.clientVpnEndpointId;
    this.description = props.description;
    this.targetNetworkCidr = props.targetNetworkCidr;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "accessGroupId": this.accessGroupId,
      "authorizeAllGroups": this.authorizeAllGroups,
      "clientVpnEndpointId": this.clientVpnEndpointId,
      "description": this.description,
      "targetNetworkCidr": this.targetNetworkCidr
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnClientVpnAuthorizationRule.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnClientVpnAuthorizationRulePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnClientVpnAuthorizationRule\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html
 */
export interface CfnClientVpnAuthorizationRuleProps {
  /**
   * The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group.
   *
   * Required if \`AuthorizeAllGroups\` is \`false\` or not specified.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-accessgroupid
   */
  readonly accessGroupId?: string;

  /**
   * Indicates whether to grant access to all clients.
   *
   * Specify \`true\` to grant all clients who successfully establish a VPN connection access to the network. Must be set to \`true\` if \`AccessGroupId\` is not specified.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-authorizeallgroups
   */
  readonly authorizeAllGroups?: boolean | cdk.IResolvable;

  /**
   * The ID of the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-clientvpnendpointid
   */
  readonly clientVpnEndpointId: string;

  /**
   * A brief description of the authorization rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-description
   */
  readonly description?: string;

  /**
   * The IPv4 address range, in CIDR notation, of the network for which access is being authorized.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-targetnetworkcidr
   */
  readonly targetNetworkCidr: string;
}

/**
 * Determine whether the given properties match those of a \`CfnClientVpnAuthorizationRuleProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnClientVpnAuthorizationRuleProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnAuthorizationRulePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessGroupId", cdk.validateString)(properties.accessGroupId));
  errors.collect(cdk.propertyValidator("authorizeAllGroups", cdk.validateBoolean)(properties.authorizeAllGroups));
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.requiredValidator)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.validateString)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("targetNetworkCidr", cdk.requiredValidator)(properties.targetNetworkCidr));
  errors.collect(cdk.propertyValidator("targetNetworkCidr", cdk.validateString)(properties.targetNetworkCidr));
  return errors.wrap("supplied properties not correct for \\"CfnClientVpnAuthorizationRuleProps\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnAuthorizationRulePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnAuthorizationRulePropsValidator(properties).assertSuccess();
  return {
    "AccessGroupId": cdk.stringToCloudFormation(properties.accessGroupId),
    "AuthorizeAllGroups": cdk.booleanToCloudFormation(properties.authorizeAllGroups),
    "ClientVpnEndpointId": cdk.stringToCloudFormation(properties.clientVpnEndpointId),
    "Description": cdk.stringToCloudFormation(properties.description),
    "TargetNetworkCidr": cdk.stringToCloudFormation(properties.targetNetworkCidr)
  };
}

// @ts-ignore TS6133
function CfnClientVpnAuthorizationRulePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnAuthorizationRuleProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnAuthorizationRuleProps>();
  ret.addPropertyResult("accessGroupId", "AccessGroupId", (properties.AccessGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.AccessGroupId) : undefined));
  ret.addPropertyResult("authorizeAllGroups", "AuthorizeAllGroups", (properties.AuthorizeAllGroups != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AuthorizeAllGroups) : undefined));
  ret.addPropertyResult("clientVpnEndpointId", "ClientVpnEndpointId", (properties.ClientVpnEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientVpnEndpointId) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("targetNetworkCidr", "TargetNetworkCidr", (properties.TargetNetworkCidr != null ? cfn_parse.FromCloudFormation.getString(properties.TargetNetworkCidr) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a Client VPN endpoint.
 *
 * A Client VPN endpoint is the resource you create and configure to enable and manage client VPN sessions. It is the destination endpoint at which all client VPN sessions are terminated.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html
 */
export class CfnClientVpnEndpoint extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::ClientVpnEndpoint";

  /**
   * Build a CfnClientVpnEndpoint from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnClientVpnEndpoint {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnClientVpnEndpointPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnClientVpnEndpoint(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Information about the authentication method to be used to authenticate clients.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-authenticationoptions
   */
  public authenticationOptions: Array<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The IPv4 address range, in CIDR notation, from which to assign client IP addresses.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientcidrblock
   */
  public clientCidrBlock: string;

  /**
   * The options for managing connection authorization for new client connections.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientconnectoptions
   */
  public clientConnectOptions?: CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable;

  /**
   * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions
   */
  public clientLoginBannerOptions?: CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable;

  /**
   * Information about the client connection logging options.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-connectionlogoptions
   */
  public connectionLogOptions: CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable;

  /**
   * A brief description of the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-description
   */
  public description?: string;

  /**
   * Information about the DNS servers to be used for DNS resolution.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-dnsservers
   */
  public dnsServers?: Array<string>;

  /**
   * The IDs of one or more security groups to apply to the target network.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-securitygroupids
   */
  public securityGroupIds?: Array<string>;

  /**
   * Specify whether to enable the self-service portal for the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-selfserviceportal
   */
  public selfServicePortal?: string;

  /**
   * The ARN of the server certificate.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-servercertificatearn
   */
  public serverCertificateArn: string;

  /**
   * The maximum VPN session duration time in hours.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-sessiontimeouthours
   */
  public sessionTimeoutHours?: number;

  /**
   * Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-splittunnel
   */
  public splitTunnel?: boolean | cdk.IResolvable;

  /**
   * The tags to apply to the Client VPN endpoint during creation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-tagspecifications
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * The transport protocol to be used by the VPN session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-transportprotocol
   */
  public transportProtocol?: string;

  /**
   * The ID of the VPC to associate with the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpcid
   */
  public vpcId?: string;

  /**
   * The port number to assign to the Client VPN endpoint for TCP and UDP traffic.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpnport
   */
  public vpnPort?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnClientVpnEndpointProps) {
    super(scope, id, {
      "type": CfnClientVpnEndpoint.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "authenticationOptions", this);
    cdk.requireProperty(props, "clientCidrBlock", this);
    cdk.requireProperty(props, "connectionLogOptions", this);
    cdk.requireProperty(props, "serverCertificateArn", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.authenticationOptions = props.authenticationOptions;
    this.clientCidrBlock = props.clientCidrBlock;
    this.clientConnectOptions = props.clientConnectOptions;
    this.clientLoginBannerOptions = props.clientLoginBannerOptions;
    this.connectionLogOptions = props.connectionLogOptions;
    this.description = props.description;
    this.dnsServers = props.dnsServers;
    this.securityGroupIds = props.securityGroupIds;
    this.selfServicePortal = props.selfServicePortal;
    this.serverCertificateArn = props.serverCertificateArn;
    this.sessionTimeoutHours = props.sessionTimeoutHours;
    this.splitTunnel = props.splitTunnel;
    this.tagSpecifications = props.tagSpecifications;
    this.transportProtocol = props.transportProtocol;
    this.vpcId = props.vpcId;
    this.vpnPort = props.vpnPort;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "authenticationOptions": this.authenticationOptions,
      "clientCidrBlock": this.clientCidrBlock,
      "clientConnectOptions": this.clientConnectOptions,
      "clientLoginBannerOptions": this.clientLoginBannerOptions,
      "connectionLogOptions": this.connectionLogOptions,
      "description": this.description,
      "dnsServers": this.dnsServers,
      "securityGroupIds": this.securityGroupIds,
      "selfServicePortal": this.selfServicePortal,
      "serverCertificateArn": this.serverCertificateArn,
      "sessionTimeoutHours": this.sessionTimeoutHours,
      "splitTunnel": this.splitTunnel,
      "tagSpecifications": this.tagSpecifications,
      "transportProtocol": this.transportProtocol,
      "vpcId": this.vpcId,
      "vpnPort": this.vpnPort
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnClientVpnEndpoint.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnClientVpnEndpointPropsToCloudFormation(props);
  }
}

export namespace CfnClientVpnEndpoint {
  /**
   * Indicates whether client connect options are enabled.
   *
   * The default is \`false\` (not enabled).
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html
   */
  export interface ClientConnectOptionsProperty {
    /**
     * Information about the authentication method to be used to authenticate clients.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-authenticationoptions
     */
    readonly authenticationOptions: Array<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The IPv4 address range, in CIDR notation, from which to assign client IP addresses.
     *
     * The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. Client CIDR range must have a size of at least /22 and must not be greater than /12.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-clientcidrblock
     */
    readonly clientCidrBlock: string;

    /**
     * The options for managing connection authorization for new client connections.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-clientconnectoptions
     */
    readonly clientConnectOptions?: CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable;

    /**
     * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-clientloginbanneroptions
     */
    readonly clientLoginBannerOptions?: CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable;

    /**
     * Information about the client connection logging options.
     *
     * If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged:
     *
     * - Client connection requests
     * - Client connection results (successful and unsuccessful)
     * - Reasons for unsuccessful client connection requests
     * - Client connection termination time
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-connectionlogoptions
     */
    readonly connectionLogOptions: CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable;

    /**
     * A brief description of the Client VPN endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-description
     */
    readonly description?: string;

    /**
     * Information about the DNS servers to be used for DNS resolution.
     *
     * A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-dnsservers
     */
    readonly dnsServers?: Array<string>;

    /**
     * The IDs of one or more security groups to apply to the target network.
     *
     * You must also specify the ID of the VPC that contains the security groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * Specify whether to enable the self-service portal for the Client VPN endpoint.
     *
     * Default Value: \`enabled\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-selfserviceportal
     */
    readonly selfServicePortal?: string;

    /**
     * The ARN of the server certificate.
     *
     * For more information, see the [AWS Certificate Manager User Guide](https://docs.aws.amazon.com/acm/latest/userguide/) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-servercertificatearn
     */
    readonly serverCertificateArn: string;

    /**
     * The maximum VPN session duration time in hours.
     *
     * Valid values: \`8 | 10 | 12 | 24\`
     *
     * Default value: \`24\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-sessiontimeouthours
     */
    readonly sessionTimeoutHours?: number;

    /**
     * Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.
     *
     * By default, split-tunnel on a VPN endpoint is disabled.
     *
     * For information about split-tunnel VPN endpoints, see [Split-tunnel AWS Client VPN endpoint](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html) in the *AWS Client VPN Administrator Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-splittunnel
     */
    readonly splitTunnel?: boolean | cdk.IResolvable;

    /**
     * The tags to apply to the Client VPN endpoint during creation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * The transport protocol to be used by the VPN session.
     *
     * Default value: \`udp\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-transportprotocol
     */
    readonly transportProtocol?: string;

    /**
     * The ID of the VPC to associate with the Client VPN endpoint.
     *
     * If no security group IDs are specified in the request, the default security group for the VPC is applied.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-vpcid
     */
    readonly vpcId?: string;

    /**
     * The port number to assign to the Client VPN endpoint for TCP and UDP traffic.
     *
     * Valid Values: \`443\` | \`1194\`
     *
     * Default Value: \`443\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-vpnport
     */
    readonly vpnPort?: number;
  }

  /**
   * The tags to apply to a resource when the resource is being created.
   *
   * When you specify a tag, you must specify the resource type to tag, otherwise the request will fail.
   *
   * > The \`Valid Values\` lists all the resource types that can be tagged. However, the action you're using might not support tagging all of these resource types. If you try to tag a resource type that is unsupported for the action you're using, you'll get an error.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * Information about the authentication method to be used to authenticate clients.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-authenticationoptions
     */
    readonly authenticationOptions: Array<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The IPv4 address range, in CIDR notation, from which to assign client IP addresses.
     *
     * The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. Client CIDR range must have a size of at least /22 and must not be greater than /12.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-clientcidrblock
     */
    readonly clientCidrBlock: string;

    /**
     * The options for managing connection authorization for new client connections.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-clientconnectoptions
     */
    readonly clientConnectOptions?: CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable;

    /**
     * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-clientloginbanneroptions
     */
    readonly clientLoginBannerOptions?: CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable;

    /**
     * Information about the client connection logging options.
     *
     * If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged:
     *
     * - Client connection requests
     * - Client connection results (successful and unsuccessful)
     * - Reasons for unsuccessful client connection requests
     * - Client connection termination time
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-connectionlogoptions
     */
    readonly connectionLogOptions: CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable;

    /**
     * A brief description of the Client VPN endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-description
     */
    readonly description?: string;

    /**
     * Information about the DNS servers to be used for DNS resolution.
     *
     * A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-dnsservers
     */
    readonly dnsServers?: Array<string>;

    /**
     * The IDs of one or more security groups to apply to the target network.
     *
     * You must also specify the ID of the VPC that contains the security groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * Specify whether to enable the self-service portal for the Client VPN endpoint.
     *
     * Default Value: \`enabled\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-selfserviceportal
     */
    readonly selfServicePortal?: string;

    /**
     * The ARN of the server certificate.
     *
     * For more information, see the [AWS Certificate Manager User Guide](https://docs.aws.amazon.com/acm/latest/userguide/) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-servercertificatearn
     */
    readonly serverCertificateArn: string;

    /**
     * The maximum VPN session duration time in hours.
     *
     * Valid values: \`8 | 10 | 12 | 24\`
     *
     * Default value: \`24\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-sessiontimeouthours
     */
    readonly sessionTimeoutHours?: number;

    /**
     * Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.
     *
     * By default, split-tunnel on a VPN endpoint is disabled.
     *
     * For information about split-tunnel VPN endpoints, see [Split-tunnel AWS Client VPN endpoint](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html) in the *AWS Client VPN Administrator Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-splittunnel
     */
    readonly splitTunnel?: boolean | cdk.IResolvable;

    /**
     * The tags to apply to the Client VPN endpoint during creation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * The transport protocol to be used by the VPN session.
     *
     * Default value: \`udp\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-transportprotocol
     */
    readonly transportProtocol?: string;

    /**
     * The ID of the VPC to associate with the Client VPN endpoint.
     *
     * If no security group IDs are specified in the request, the default security group for the VPC is applied.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-vpcid
     */
    readonly vpcId?: string;

    /**
     * The port number to assign to the Client VPN endpoint for TCP and UDP traffic.
     *
     * Valid Values: \`443\` | \`1194\`
     *
     * Default Value: \`443\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-vpnport
     */
    readonly vpnPort?: number;
  }

  /**
   * Describes the authentication method to be used by a Client VPN endpoint.
   *
   * For more information, see [Authentication](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/authentication-authrization.html#client-authentication) in the *AWS Client VPN Administrator Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html
   */
  export interface ClientAuthenticationRequestProperty {
    /**
     * Information about the authentication method to be used to authenticate clients.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-authenticationoptions
     */
    readonly authenticationOptions: Array<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The IPv4 address range, in CIDR notation, from which to assign client IP addresses.
     *
     * The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. Client CIDR range must have a size of at least /22 and must not be greater than /12.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-clientcidrblock
     */
    readonly clientCidrBlock: string;

    /**
     * The options for managing connection authorization for new client connections.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-clientconnectoptions
     */
    readonly clientConnectOptions?: CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable;

    /**
     * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-clientloginbanneroptions
     */
    readonly clientLoginBannerOptions?: CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable;

    /**
     * Information about the client connection logging options.
     *
     * If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged:
     *
     * - Client connection requests
     * - Client connection results (successful and unsuccessful)
     * - Reasons for unsuccessful client connection requests
     * - Client connection termination time
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-connectionlogoptions
     */
    readonly connectionLogOptions: CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable;

    /**
     * A brief description of the Client VPN endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-description
     */
    readonly description?: string;

    /**
     * Information about the DNS servers to be used for DNS resolution.
     *
     * A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-dnsservers
     */
    readonly dnsServers?: Array<string>;

    /**
     * The IDs of one or more security groups to apply to the target network.
     *
     * You must also specify the ID of the VPC that contains the security groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * Specify whether to enable the self-service portal for the Client VPN endpoint.
     *
     * Default Value: \`enabled\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-selfserviceportal
     */
    readonly selfServicePortal?: string;

    /**
     * The ARN of the server certificate.
     *
     * For more information, see the [AWS Certificate Manager User Guide](https://docs.aws.amazon.com/acm/latest/userguide/) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-servercertificatearn
     */
    readonly serverCertificateArn: string;

    /**
     * The maximum VPN session duration time in hours.
     *
     * Valid values: \`8 | 10 | 12 | 24\`
     *
     * Default value: \`24\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-sessiontimeouthours
     */
    readonly sessionTimeoutHours?: number;

    /**
     * Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.
     *
     * By default, split-tunnel on a VPN endpoint is disabled.
     *
     * For information about split-tunnel VPN endpoints, see [Split-tunnel AWS Client VPN endpoint](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html) in the *AWS Client VPN Administrator Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-splittunnel
     */
    readonly splitTunnel?: boolean | cdk.IResolvable;

    /**
     * The tags to apply to the Client VPN endpoint during creation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * The transport protocol to be used by the VPN session.
     *
     * Default value: \`udp\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-transportprotocol
     */
    readonly transportProtocol?: string;

    /**
     * The ID of the VPC to associate with the Client VPN endpoint.
     *
     * If no security group IDs are specified in the request, the default security group for the VPC is applied.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-vpcid
     */
    readonly vpcId?: string;

    /**
     * The port number to assign to the Client VPN endpoint for TCP and UDP traffic.
     *
     * Valid Values: \`443\` | \`1194\`
     *
     * Default Value: \`443\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-vpnport
     */
    readonly vpnPort?: number;
  }

  /**
   * Describes the client connection logging options for the Client VPN endpoint.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html
   */
  export interface ConnectionLogOptionsProperty {
    /**
     * Information about the authentication method to be used to authenticate clients.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-authenticationoptions
     */
    readonly authenticationOptions: Array<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The IPv4 address range, in CIDR notation, from which to assign client IP addresses.
     *
     * The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. Client CIDR range must have a size of at least /22 and must not be greater than /12.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-clientcidrblock
     */
    readonly clientCidrBlock: string;

    /**
     * The options for managing connection authorization for new client connections.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-clientconnectoptions
     */
    readonly clientConnectOptions?: CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable;

    /**
     * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-clientloginbanneroptions
     */
    readonly clientLoginBannerOptions?: CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable;

    /**
     * Information about the client connection logging options.
     *
     * If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged:
     *
     * - Client connection requests
     * - Client connection results (successful and unsuccessful)
     * - Reasons for unsuccessful client connection requests
     * - Client connection termination time
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-connectionlogoptions
     */
    readonly connectionLogOptions: CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable;

    /**
     * A brief description of the Client VPN endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-description
     */
    readonly description?: string;

    /**
     * Information about the DNS servers to be used for DNS resolution.
     *
     * A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-dnsservers
     */
    readonly dnsServers?: Array<string>;

    /**
     * The IDs of one or more security groups to apply to the target network.
     *
     * You must also specify the ID of the VPC that contains the security groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * Specify whether to enable the self-service portal for the Client VPN endpoint.
     *
     * Default Value: \`enabled\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-selfserviceportal
     */
    readonly selfServicePortal?: string;

    /**
     * The ARN of the server certificate.
     *
     * For more information, see the [AWS Certificate Manager User Guide](https://docs.aws.amazon.com/acm/latest/userguide/) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-servercertificatearn
     */
    readonly serverCertificateArn: string;

    /**
     * The maximum VPN session duration time in hours.
     *
     * Valid values: \`8 | 10 | 12 | 24\`
     *
     * Default value: \`24\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-sessiontimeouthours
     */
    readonly sessionTimeoutHours?: number;

    /**
     * Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.
     *
     * By default, split-tunnel on a VPN endpoint is disabled.
     *
     * For information about split-tunnel VPN endpoints, see [Split-tunnel AWS Client VPN endpoint](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html) in the *AWS Client VPN Administrator Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-splittunnel
     */
    readonly splitTunnel?: boolean | cdk.IResolvable;

    /**
     * The tags to apply to the Client VPN endpoint during creation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * The transport protocol to be used by the VPN session.
     *
     * Default value: \`udp\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-transportprotocol
     */
    readonly transportProtocol?: string;

    /**
     * The ID of the VPC to associate with the Client VPN endpoint.
     *
     * If no security group IDs are specified in the request, the default security group for the VPC is applied.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-vpcid
     */
    readonly vpcId?: string;

    /**
     * The port number to assign to the Client VPN endpoint for TCP and UDP traffic.
     *
     * Valid Values: \`443\` | \`1194\`
     *
     * Default Value: \`443\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-vpnport
     */
    readonly vpnPort?: number;
  }

  /**
   * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html
   */
  export interface ClientLoginBannerOptionsProperty {
    /**
     * Information about the authentication method to be used to authenticate clients.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-authenticationoptions
     */
    readonly authenticationOptions: Array<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The IPv4 address range, in CIDR notation, from which to assign client IP addresses.
     *
     * The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. Client CIDR range must have a size of at least /22 and must not be greater than /12.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-clientcidrblock
     */
    readonly clientCidrBlock: string;

    /**
     * The options for managing connection authorization for new client connections.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-clientconnectoptions
     */
    readonly clientConnectOptions?: CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable;

    /**
     * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-clientloginbanneroptions
     */
    readonly clientLoginBannerOptions?: CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable;

    /**
     * Information about the client connection logging options.
     *
     * If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged:
     *
     * - Client connection requests
     * - Client connection results (successful and unsuccessful)
     * - Reasons for unsuccessful client connection requests
     * - Client connection termination time
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-connectionlogoptions
     */
    readonly connectionLogOptions: CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable;

    /**
     * A brief description of the Client VPN endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-description
     */
    readonly description?: string;

    /**
     * Information about the DNS servers to be used for DNS resolution.
     *
     * A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-dnsservers
     */
    readonly dnsServers?: Array<string>;

    /**
     * The IDs of one or more security groups to apply to the target network.
     *
     * You must also specify the ID of the VPC that contains the security groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * Specify whether to enable the self-service portal for the Client VPN endpoint.
     *
     * Default Value: \`enabled\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-selfserviceportal
     */
    readonly selfServicePortal?: string;

    /**
     * The ARN of the server certificate.
     *
     * For more information, see the [AWS Certificate Manager User Guide](https://docs.aws.amazon.com/acm/latest/userguide/) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-servercertificatearn
     */
    readonly serverCertificateArn: string;

    /**
     * The maximum VPN session duration time in hours.
     *
     * Valid values: \`8 | 10 | 12 | 24\`
     *
     * Default value: \`24\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-sessiontimeouthours
     */
    readonly sessionTimeoutHours?: number;

    /**
     * Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.
     *
     * By default, split-tunnel on a VPN endpoint is disabled.
     *
     * For information about split-tunnel VPN endpoints, see [Split-tunnel AWS Client VPN endpoint](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html) in the *AWS Client VPN Administrator Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-splittunnel
     */
    readonly splitTunnel?: boolean | cdk.IResolvable;

    /**
     * The tags to apply to the Client VPN endpoint during creation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * The transport protocol to be used by the VPN session.
     *
     * Default value: \`udp\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-transportprotocol
     */
    readonly transportProtocol?: string;

    /**
     * The ID of the VPC to associate with the Client VPN endpoint.
     *
     * If no security group IDs are specified in the request, the default security group for the VPC is applied.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-vpcid
     */
    readonly vpcId?: string;

    /**
     * The port number to assign to the Client VPN endpoint for TCP and UDP traffic.
     *
     * Valid Values: \`443\` | \`1194\`
     *
     * Default Value: \`443\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-vpnport
     */
    readonly vpnPort?: number;
  }
}

/**
 * Properties for defining a \`CfnClientVpnEndpoint\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html
 */
export interface CfnClientVpnEndpointProps {
  /**
   * Information about the authentication method to be used to authenticate clients.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-authenticationoptions
   */
  readonly authenticationOptions: Array<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The IPv4 address range, in CIDR notation, from which to assign client IP addresses.
   *
   * The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. Client CIDR range must have a size of at least /22 and must not be greater than /12.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientcidrblock
   */
  readonly clientCidrBlock: string;

  /**
   * The options for managing connection authorization for new client connections.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientconnectoptions
   */
  readonly clientConnectOptions?: CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable;

  /**
   * Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions
   */
  readonly clientLoginBannerOptions?: CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable;

  /**
   * Information about the client connection logging options.
   *
   * If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged:
   *
   * - Client connection requests
   * - Client connection results (successful and unsuccessful)
   * - Reasons for unsuccessful client connection requests
   * - Client connection termination time
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-connectionlogoptions
   */
  readonly connectionLogOptions: CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable;

  /**
   * A brief description of the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-description
   */
  readonly description?: string;

  /**
   * Information about the DNS servers to be used for DNS resolution.
   *
   * A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-dnsservers
   */
  readonly dnsServers?: Array<string>;

  /**
   * The IDs of one or more security groups to apply to the target network.
   *
   * You must also specify the ID of the VPC that contains the security groups.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * Specify whether to enable the self-service portal for the Client VPN endpoint.
   *
   * Default Value: \`enabled\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-selfserviceportal
   */
  readonly selfServicePortal?: string;

  /**
   * The ARN of the server certificate.
   *
   * For more information, see the [AWS Certificate Manager User Guide](https://docs.aws.amazon.com/acm/latest/userguide/) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-servercertificatearn
   */
  readonly serverCertificateArn: string;

  /**
   * The maximum VPN session duration time in hours.
   *
   * Valid values: \`8 | 10 | 12 | 24\`
   *
   * Default value: \`24\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-sessiontimeouthours
   */
  readonly sessionTimeoutHours?: number;

  /**
   * Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.
   *
   * By default, split-tunnel on a VPN endpoint is disabled.
   *
   * For information about split-tunnel VPN endpoints, see [Split-tunnel AWS Client VPN endpoint](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html) in the *AWS Client VPN Administrator Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-splittunnel
   */
  readonly splitTunnel?: boolean | cdk.IResolvable;

  /**
   * The tags to apply to the Client VPN endpoint during creation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * The transport protocol to be used by the VPN session.
   *
   * Default value: \`udp\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-transportprotocol
   */
  readonly transportProtocol?: string;

  /**
   * The ID of the VPC to associate with the Client VPN endpoint.
   *
   * If no security group IDs are specified in the request, the default security group for the VPC is applied.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpcid
   */
  readonly vpcId?: string;

  /**
   * The port number to assign to the Client VPN endpoint for TCP and UDP traffic.
   *
   * Valid Values: \`443\` | \`1194\`
   *
   * Default Value: \`443\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpnport
   */
  readonly vpnPort?: number;
}

/**
 * Determine whether the given properties match those of a \`ClientLoginBannerOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`ClientLoginBannerOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.requiredValidator)(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.listValidator(CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator))(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.requiredValidator)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.validateString)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientConnectOptions", CfnClientVpnEndpointClientConnectOptionsPropertyValidator)(properties.clientConnectOptions));
  errors.collect(cdk.propertyValidator("clientLoginBannerOptions", CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator)(properties.clientLoginBannerOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", cdk.requiredValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", CfnClientVpnEndpointConnectionLogOptionsPropertyValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("dnsServers", cdk.listValidator(cdk.validateString))(properties.dnsServers));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("selfServicePortal", cdk.validateString)(properties.selfServicePortal));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.requiredValidator)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.validateString)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("sessionTimeoutHours", cdk.validateNumber)(properties.sessionTimeoutHours));
  errors.collect(cdk.propertyValidator("splitTunnel", cdk.validateBoolean)(properties.splitTunnel));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnClientVpnEndpointTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("transportProtocol", cdk.validateString)(properties.transportProtocol));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpnPort", cdk.validateNumber)(properties.vpnPort));
  return errors.wrap("supplied properties not correct for \\"ClientLoginBannerOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointClientLoginBannerOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AuthenticationOptions": cdk.listMapper(convertCfnClientVpnEndpointClientAuthenticationRequestPropertyToCloudFormation)(properties.authenticationOptions),
    "ClientCidrBlock": cdk.stringToCloudFormation(properties.clientCidrBlock),
    "ClientConnectOptions": convertCfnClientVpnEndpointClientConnectOptionsPropertyToCloudFormation(properties.clientConnectOptions),
    "ClientLoginBannerOptions": convertCfnClientVpnEndpointClientLoginBannerOptionsPropertyToCloudFormation(properties.clientLoginBannerOptions),
    "ConnectionLogOptions": convertCfnClientVpnEndpointConnectionLogOptionsPropertyToCloudFormation(properties.connectionLogOptions),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DnsServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.dnsServers),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SelfServicePortal": cdk.stringToCloudFormation(properties.selfServicePortal),
    "ServerCertificateArn": cdk.stringToCloudFormation(properties.serverCertificateArn),
    "SessionTimeoutHours": cdk.numberToCloudFormation(properties.sessionTimeoutHours),
    "SplitTunnel": cdk.booleanToCloudFormation(properties.splitTunnel),
    "TagSpecifications": cdk.listMapper(convertCfnClientVpnEndpointTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TransportProtocol": cdk.stringToCloudFormation(properties.transportProtocol),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId),
    "VpnPort": cdk.numberToCloudFormation(properties.vpnPort)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointClientLoginBannerOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty>();
  ret.addPropertyResult("authenticationOptions", "AuthenticationOptions", (properties.AuthenticationOptions != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointClientAuthenticationRequestPropertyFromCloudFormation)(properties.AuthenticationOptions) : undefined));
  ret.addPropertyResult("clientCidrBlock", "ClientCidrBlock", (properties.ClientCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.ClientCidrBlock) : undefined));
  ret.addPropertyResult("clientConnectOptions", "ClientConnectOptions", (properties.ClientConnectOptions != null ? CfnClientVpnEndpointClientConnectOptionsPropertyFromCloudFormation(properties.ClientConnectOptions) : undefined));
  ret.addPropertyResult("clientLoginBannerOptions", "ClientLoginBannerOptions", (properties.ClientLoginBannerOptions != null ? CfnClientVpnEndpointClientLoginBannerOptionsPropertyFromCloudFormation(properties.ClientLoginBannerOptions) : undefined));
  ret.addPropertyResult("connectionLogOptions", "ConnectionLogOptions", (properties.ConnectionLogOptions != null ? CfnClientVpnEndpointConnectionLogOptionsPropertyFromCloudFormation(properties.ConnectionLogOptions) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("dnsServers", "DnsServers", (properties.DnsServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DnsServers) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("selfServicePortal", "SelfServicePortal", (properties.SelfServicePortal != null ? cfn_parse.FromCloudFormation.getString(properties.SelfServicePortal) : undefined));
  ret.addPropertyResult("serverCertificateArn", "ServerCertificateArn", (properties.ServerCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.ServerCertificateArn) : undefined));
  ret.addPropertyResult("sessionTimeoutHours", "SessionTimeoutHours", (properties.SessionTimeoutHours != null ? cfn_parse.FromCloudFormation.getNumber(properties.SessionTimeoutHours) : undefined));
  ret.addPropertyResult("splitTunnel", "SplitTunnel", (properties.SplitTunnel != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SplitTunnel) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("transportProtocol", "TransportProtocol", (properties.TransportProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.TransportProtocol) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addPropertyResult("vpnPort", "VpnPort", (properties.VpnPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.VpnPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ConnectionLogOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`ConnectionLogOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointConnectionLogOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.requiredValidator)(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.listValidator(CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator))(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.requiredValidator)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.validateString)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientConnectOptions", CfnClientVpnEndpointClientConnectOptionsPropertyValidator)(properties.clientConnectOptions));
  errors.collect(cdk.propertyValidator("clientLoginBannerOptions", CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator)(properties.clientLoginBannerOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", cdk.requiredValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", CfnClientVpnEndpointConnectionLogOptionsPropertyValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("dnsServers", cdk.listValidator(cdk.validateString))(properties.dnsServers));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("selfServicePortal", cdk.validateString)(properties.selfServicePortal));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.requiredValidator)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.validateString)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("sessionTimeoutHours", cdk.validateNumber)(properties.sessionTimeoutHours));
  errors.collect(cdk.propertyValidator("splitTunnel", cdk.validateBoolean)(properties.splitTunnel));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnClientVpnEndpointTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("transportProtocol", cdk.validateString)(properties.transportProtocol));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpnPort", cdk.validateNumber)(properties.vpnPort));
  return errors.wrap("supplied properties not correct for \\"ConnectionLogOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointConnectionLogOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointConnectionLogOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AuthenticationOptions": cdk.listMapper(convertCfnClientVpnEndpointClientAuthenticationRequestPropertyToCloudFormation)(properties.authenticationOptions),
    "ClientCidrBlock": cdk.stringToCloudFormation(properties.clientCidrBlock),
    "ClientConnectOptions": convertCfnClientVpnEndpointClientConnectOptionsPropertyToCloudFormation(properties.clientConnectOptions),
    "ClientLoginBannerOptions": convertCfnClientVpnEndpointClientLoginBannerOptionsPropertyToCloudFormation(properties.clientLoginBannerOptions),
    "ConnectionLogOptions": convertCfnClientVpnEndpointConnectionLogOptionsPropertyToCloudFormation(properties.connectionLogOptions),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DnsServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.dnsServers),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SelfServicePortal": cdk.stringToCloudFormation(properties.selfServicePortal),
    "ServerCertificateArn": cdk.stringToCloudFormation(properties.serverCertificateArn),
    "SessionTimeoutHours": cdk.numberToCloudFormation(properties.sessionTimeoutHours),
    "SplitTunnel": cdk.booleanToCloudFormation(properties.splitTunnel),
    "TagSpecifications": cdk.listMapper(convertCfnClientVpnEndpointTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TransportProtocol": cdk.stringToCloudFormation(properties.transportProtocol),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId),
    "VpnPort": cdk.numberToCloudFormation(properties.vpnPort)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointConnectionLogOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.ConnectionLogOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.ConnectionLogOptionsProperty>();
  ret.addPropertyResult("authenticationOptions", "AuthenticationOptions", (properties.AuthenticationOptions != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointClientAuthenticationRequestPropertyFromCloudFormation)(properties.AuthenticationOptions) : undefined));
  ret.addPropertyResult("clientCidrBlock", "ClientCidrBlock", (properties.ClientCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.ClientCidrBlock) : undefined));
  ret.addPropertyResult("clientConnectOptions", "ClientConnectOptions", (properties.ClientConnectOptions != null ? CfnClientVpnEndpointClientConnectOptionsPropertyFromCloudFormation(properties.ClientConnectOptions) : undefined));
  ret.addPropertyResult("clientLoginBannerOptions", "ClientLoginBannerOptions", (properties.ClientLoginBannerOptions != null ? CfnClientVpnEndpointClientLoginBannerOptionsPropertyFromCloudFormation(properties.ClientLoginBannerOptions) : undefined));
  ret.addPropertyResult("connectionLogOptions", "ConnectionLogOptions", (properties.ConnectionLogOptions != null ? CfnClientVpnEndpointConnectionLogOptionsPropertyFromCloudFormation(properties.ConnectionLogOptions) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("dnsServers", "DnsServers", (properties.DnsServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DnsServers) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("selfServicePortal", "SelfServicePortal", (properties.SelfServicePortal != null ? cfn_parse.FromCloudFormation.getString(properties.SelfServicePortal) : undefined));
  ret.addPropertyResult("serverCertificateArn", "ServerCertificateArn", (properties.ServerCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.ServerCertificateArn) : undefined));
  ret.addPropertyResult("sessionTimeoutHours", "SessionTimeoutHours", (properties.SessionTimeoutHours != null ? cfn_parse.FromCloudFormation.getNumber(properties.SessionTimeoutHours) : undefined));
  ret.addPropertyResult("splitTunnel", "SplitTunnel", (properties.SplitTunnel != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SplitTunnel) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("transportProtocol", "TransportProtocol", (properties.TransportProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.TransportProtocol) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addPropertyResult("vpnPort", "VpnPort", (properties.VpnPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.VpnPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ClientAuthenticationRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`ClientAuthenticationRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.requiredValidator)(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.listValidator(CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator))(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.requiredValidator)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.validateString)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientConnectOptions", CfnClientVpnEndpointClientConnectOptionsPropertyValidator)(properties.clientConnectOptions));
  errors.collect(cdk.propertyValidator("clientLoginBannerOptions", CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator)(properties.clientLoginBannerOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", cdk.requiredValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", CfnClientVpnEndpointConnectionLogOptionsPropertyValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("dnsServers", cdk.listValidator(cdk.validateString))(properties.dnsServers));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("selfServicePortal", cdk.validateString)(properties.selfServicePortal));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.requiredValidator)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.validateString)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("sessionTimeoutHours", cdk.validateNumber)(properties.sessionTimeoutHours));
  errors.collect(cdk.propertyValidator("splitTunnel", cdk.validateBoolean)(properties.splitTunnel));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnClientVpnEndpointTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("transportProtocol", cdk.validateString)(properties.transportProtocol));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpnPort", cdk.validateNumber)(properties.vpnPort));
  return errors.wrap("supplied properties not correct for \\"ClientAuthenticationRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointClientAuthenticationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator(properties).assertSuccess();
  return {
    "AuthenticationOptions": cdk.listMapper(convertCfnClientVpnEndpointClientAuthenticationRequestPropertyToCloudFormation)(properties.authenticationOptions),
    "ClientCidrBlock": cdk.stringToCloudFormation(properties.clientCidrBlock),
    "ClientConnectOptions": convertCfnClientVpnEndpointClientConnectOptionsPropertyToCloudFormation(properties.clientConnectOptions),
    "ClientLoginBannerOptions": convertCfnClientVpnEndpointClientLoginBannerOptionsPropertyToCloudFormation(properties.clientLoginBannerOptions),
    "ConnectionLogOptions": convertCfnClientVpnEndpointConnectionLogOptionsPropertyToCloudFormation(properties.connectionLogOptions),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DnsServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.dnsServers),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SelfServicePortal": cdk.stringToCloudFormation(properties.selfServicePortal),
    "ServerCertificateArn": cdk.stringToCloudFormation(properties.serverCertificateArn),
    "SessionTimeoutHours": cdk.numberToCloudFormation(properties.sessionTimeoutHours),
    "SplitTunnel": cdk.booleanToCloudFormation(properties.splitTunnel),
    "TagSpecifications": cdk.listMapper(convertCfnClientVpnEndpointTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TransportProtocol": cdk.stringToCloudFormation(properties.transportProtocol),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId),
    "VpnPort": cdk.numberToCloudFormation(properties.vpnPort)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointClientAuthenticationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.ClientAuthenticationRequestProperty>();
  ret.addPropertyResult("authenticationOptions", "AuthenticationOptions", (properties.AuthenticationOptions != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointClientAuthenticationRequestPropertyFromCloudFormation)(properties.AuthenticationOptions) : undefined));
  ret.addPropertyResult("clientCidrBlock", "ClientCidrBlock", (properties.ClientCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.ClientCidrBlock) : undefined));
  ret.addPropertyResult("clientConnectOptions", "ClientConnectOptions", (properties.ClientConnectOptions != null ? CfnClientVpnEndpointClientConnectOptionsPropertyFromCloudFormation(properties.ClientConnectOptions) : undefined));
  ret.addPropertyResult("clientLoginBannerOptions", "ClientLoginBannerOptions", (properties.ClientLoginBannerOptions != null ? CfnClientVpnEndpointClientLoginBannerOptionsPropertyFromCloudFormation(properties.ClientLoginBannerOptions) : undefined));
  ret.addPropertyResult("connectionLogOptions", "ConnectionLogOptions", (properties.ConnectionLogOptions != null ? CfnClientVpnEndpointConnectionLogOptionsPropertyFromCloudFormation(properties.ConnectionLogOptions) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("dnsServers", "DnsServers", (properties.DnsServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DnsServers) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("selfServicePortal", "SelfServicePortal", (properties.SelfServicePortal != null ? cfn_parse.FromCloudFormation.getString(properties.SelfServicePortal) : undefined));
  ret.addPropertyResult("serverCertificateArn", "ServerCertificateArn", (properties.ServerCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.ServerCertificateArn) : undefined));
  ret.addPropertyResult("sessionTimeoutHours", "SessionTimeoutHours", (properties.SessionTimeoutHours != null ? cfn_parse.FromCloudFormation.getNumber(properties.SessionTimeoutHours) : undefined));
  ret.addPropertyResult("splitTunnel", "SplitTunnel", (properties.SplitTunnel != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SplitTunnel) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("transportProtocol", "TransportProtocol", (properties.TransportProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.TransportProtocol) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addPropertyResult("vpnPort", "VpnPort", (properties.VpnPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.VpnPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TagSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.requiredValidator)(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.listValidator(CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator))(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.requiredValidator)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.validateString)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientConnectOptions", CfnClientVpnEndpointClientConnectOptionsPropertyValidator)(properties.clientConnectOptions));
  errors.collect(cdk.propertyValidator("clientLoginBannerOptions", CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator)(properties.clientLoginBannerOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", cdk.requiredValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", CfnClientVpnEndpointConnectionLogOptionsPropertyValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("dnsServers", cdk.listValidator(cdk.validateString))(properties.dnsServers));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("selfServicePortal", cdk.validateString)(properties.selfServicePortal));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.requiredValidator)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.validateString)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("sessionTimeoutHours", cdk.validateNumber)(properties.sessionTimeoutHours));
  errors.collect(cdk.propertyValidator("splitTunnel", cdk.validateBoolean)(properties.splitTunnel));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnClientVpnEndpointTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("transportProtocol", cdk.validateString)(properties.transportProtocol));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpnPort", cdk.validateNumber)(properties.vpnPort));
  return errors.wrap("supplied properties not correct for \\"TagSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "AuthenticationOptions": cdk.listMapper(convertCfnClientVpnEndpointClientAuthenticationRequestPropertyToCloudFormation)(properties.authenticationOptions),
    "ClientCidrBlock": cdk.stringToCloudFormation(properties.clientCidrBlock),
    "ClientConnectOptions": convertCfnClientVpnEndpointClientConnectOptionsPropertyToCloudFormation(properties.clientConnectOptions),
    "ClientLoginBannerOptions": convertCfnClientVpnEndpointClientLoginBannerOptionsPropertyToCloudFormation(properties.clientLoginBannerOptions),
    "ConnectionLogOptions": convertCfnClientVpnEndpointConnectionLogOptionsPropertyToCloudFormation(properties.connectionLogOptions),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DnsServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.dnsServers),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SelfServicePortal": cdk.stringToCloudFormation(properties.selfServicePortal),
    "ServerCertificateArn": cdk.stringToCloudFormation(properties.serverCertificateArn),
    "SessionTimeoutHours": cdk.numberToCloudFormation(properties.sessionTimeoutHours),
    "SplitTunnel": cdk.booleanToCloudFormation(properties.splitTunnel),
    "TagSpecifications": cdk.listMapper(convertCfnClientVpnEndpointTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TransportProtocol": cdk.stringToCloudFormation(properties.transportProtocol),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId),
    "VpnPort": cdk.numberToCloudFormation(properties.vpnPort)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnClientVpnEndpoint.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.TagSpecificationProperty>();
  ret.addPropertyResult("authenticationOptions", "AuthenticationOptions", (properties.AuthenticationOptions != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointClientAuthenticationRequestPropertyFromCloudFormation)(properties.AuthenticationOptions) : undefined));
  ret.addPropertyResult("clientCidrBlock", "ClientCidrBlock", (properties.ClientCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.ClientCidrBlock) : undefined));
  ret.addPropertyResult("clientConnectOptions", "ClientConnectOptions", (properties.ClientConnectOptions != null ? CfnClientVpnEndpointClientConnectOptionsPropertyFromCloudFormation(properties.ClientConnectOptions) : undefined));
  ret.addPropertyResult("clientLoginBannerOptions", "ClientLoginBannerOptions", (properties.ClientLoginBannerOptions != null ? CfnClientVpnEndpointClientLoginBannerOptionsPropertyFromCloudFormation(properties.ClientLoginBannerOptions) : undefined));
  ret.addPropertyResult("connectionLogOptions", "ConnectionLogOptions", (properties.ConnectionLogOptions != null ? CfnClientVpnEndpointConnectionLogOptionsPropertyFromCloudFormation(properties.ConnectionLogOptions) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("dnsServers", "DnsServers", (properties.DnsServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DnsServers) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("selfServicePortal", "SelfServicePortal", (properties.SelfServicePortal != null ? cfn_parse.FromCloudFormation.getString(properties.SelfServicePortal) : undefined));
  ret.addPropertyResult("serverCertificateArn", "ServerCertificateArn", (properties.ServerCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.ServerCertificateArn) : undefined));
  ret.addPropertyResult("sessionTimeoutHours", "SessionTimeoutHours", (properties.SessionTimeoutHours != null ? cfn_parse.FromCloudFormation.getNumber(properties.SessionTimeoutHours) : undefined));
  ret.addPropertyResult("splitTunnel", "SplitTunnel", (properties.SplitTunnel != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SplitTunnel) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("transportProtocol", "TransportProtocol", (properties.TransportProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.TransportProtocol) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addPropertyResult("vpnPort", "VpnPort", (properties.VpnPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.VpnPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ClientConnectOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`ClientConnectOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointClientConnectOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.requiredValidator)(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.listValidator(CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator))(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.requiredValidator)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.validateString)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientConnectOptions", CfnClientVpnEndpointClientConnectOptionsPropertyValidator)(properties.clientConnectOptions));
  errors.collect(cdk.propertyValidator("clientLoginBannerOptions", CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator)(properties.clientLoginBannerOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", cdk.requiredValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", CfnClientVpnEndpointConnectionLogOptionsPropertyValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("dnsServers", cdk.listValidator(cdk.validateString))(properties.dnsServers));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("selfServicePortal", cdk.validateString)(properties.selfServicePortal));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.requiredValidator)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.validateString)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("sessionTimeoutHours", cdk.validateNumber)(properties.sessionTimeoutHours));
  errors.collect(cdk.propertyValidator("splitTunnel", cdk.validateBoolean)(properties.splitTunnel));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnClientVpnEndpointTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("transportProtocol", cdk.validateString)(properties.transportProtocol));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpnPort", cdk.validateNumber)(properties.vpnPort));
  return errors.wrap("supplied properties not correct for \\"ClientConnectOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointClientConnectOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointClientConnectOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AuthenticationOptions": cdk.listMapper(convertCfnClientVpnEndpointClientAuthenticationRequestPropertyToCloudFormation)(properties.authenticationOptions),
    "ClientCidrBlock": cdk.stringToCloudFormation(properties.clientCidrBlock),
    "ClientConnectOptions": convertCfnClientVpnEndpointClientConnectOptionsPropertyToCloudFormation(properties.clientConnectOptions),
    "ClientLoginBannerOptions": convertCfnClientVpnEndpointClientLoginBannerOptionsPropertyToCloudFormation(properties.clientLoginBannerOptions),
    "ConnectionLogOptions": convertCfnClientVpnEndpointConnectionLogOptionsPropertyToCloudFormation(properties.connectionLogOptions),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DnsServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.dnsServers),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SelfServicePortal": cdk.stringToCloudFormation(properties.selfServicePortal),
    "ServerCertificateArn": cdk.stringToCloudFormation(properties.serverCertificateArn),
    "SessionTimeoutHours": cdk.numberToCloudFormation(properties.sessionTimeoutHours),
    "SplitTunnel": cdk.booleanToCloudFormation(properties.splitTunnel),
    "TagSpecifications": cdk.listMapper(convertCfnClientVpnEndpointTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TransportProtocol": cdk.stringToCloudFormation(properties.transportProtocol),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId),
    "VpnPort": cdk.numberToCloudFormation(properties.vpnPort)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointClientConnectOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpoint.ClientConnectOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpoint.ClientConnectOptionsProperty>();
  ret.addPropertyResult("authenticationOptions", "AuthenticationOptions", (properties.AuthenticationOptions != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointClientAuthenticationRequestPropertyFromCloudFormation)(properties.AuthenticationOptions) : undefined));
  ret.addPropertyResult("clientCidrBlock", "ClientCidrBlock", (properties.ClientCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.ClientCidrBlock) : undefined));
  ret.addPropertyResult("clientConnectOptions", "ClientConnectOptions", (properties.ClientConnectOptions != null ? CfnClientVpnEndpointClientConnectOptionsPropertyFromCloudFormation(properties.ClientConnectOptions) : undefined));
  ret.addPropertyResult("clientLoginBannerOptions", "ClientLoginBannerOptions", (properties.ClientLoginBannerOptions != null ? CfnClientVpnEndpointClientLoginBannerOptionsPropertyFromCloudFormation(properties.ClientLoginBannerOptions) : undefined));
  ret.addPropertyResult("connectionLogOptions", "ConnectionLogOptions", (properties.ConnectionLogOptions != null ? CfnClientVpnEndpointConnectionLogOptionsPropertyFromCloudFormation(properties.ConnectionLogOptions) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("dnsServers", "DnsServers", (properties.DnsServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DnsServers) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("selfServicePortal", "SelfServicePortal", (properties.SelfServicePortal != null ? cfn_parse.FromCloudFormation.getString(properties.SelfServicePortal) : undefined));
  ret.addPropertyResult("serverCertificateArn", "ServerCertificateArn", (properties.ServerCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.ServerCertificateArn) : undefined));
  ret.addPropertyResult("sessionTimeoutHours", "SessionTimeoutHours", (properties.SessionTimeoutHours != null ? cfn_parse.FromCloudFormation.getNumber(properties.SessionTimeoutHours) : undefined));
  ret.addPropertyResult("splitTunnel", "SplitTunnel", (properties.SplitTunnel != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SplitTunnel) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("transportProtocol", "TransportProtocol", (properties.TransportProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.TransportProtocol) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addPropertyResult("vpnPort", "VpnPort", (properties.VpnPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.VpnPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnClientVpnEndpointProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnClientVpnEndpointProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnEndpointPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.requiredValidator)(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("authenticationOptions", cdk.listValidator(CfnClientVpnEndpointClientAuthenticationRequestPropertyValidator))(properties.authenticationOptions));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.requiredValidator)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientCidrBlock", cdk.validateString)(properties.clientCidrBlock));
  errors.collect(cdk.propertyValidator("clientConnectOptions", CfnClientVpnEndpointClientConnectOptionsPropertyValidator)(properties.clientConnectOptions));
  errors.collect(cdk.propertyValidator("clientLoginBannerOptions", CfnClientVpnEndpointClientLoginBannerOptionsPropertyValidator)(properties.clientLoginBannerOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", cdk.requiredValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("connectionLogOptions", CfnClientVpnEndpointConnectionLogOptionsPropertyValidator)(properties.connectionLogOptions));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("dnsServers", cdk.listValidator(cdk.validateString))(properties.dnsServers));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("selfServicePortal", cdk.validateString)(properties.selfServicePortal));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.requiredValidator)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("serverCertificateArn", cdk.validateString)(properties.serverCertificateArn));
  errors.collect(cdk.propertyValidator("sessionTimeoutHours", cdk.validateNumber)(properties.sessionTimeoutHours));
  errors.collect(cdk.propertyValidator("splitTunnel", cdk.validateBoolean)(properties.splitTunnel));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnClientVpnEndpointTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("transportProtocol", cdk.validateString)(properties.transportProtocol));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpnPort", cdk.validateNumber)(properties.vpnPort));
  return errors.wrap("supplied properties not correct for \\"CfnClientVpnEndpointProps\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnEndpointPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnEndpointPropsValidator(properties).assertSuccess();
  return {
    "AuthenticationOptions": cdk.listMapper(convertCfnClientVpnEndpointClientAuthenticationRequestPropertyToCloudFormation)(properties.authenticationOptions),
    "ClientCidrBlock": cdk.stringToCloudFormation(properties.clientCidrBlock),
    "ClientConnectOptions": convertCfnClientVpnEndpointClientConnectOptionsPropertyToCloudFormation(properties.clientConnectOptions),
    "ClientLoginBannerOptions": convertCfnClientVpnEndpointClientLoginBannerOptionsPropertyToCloudFormation(properties.clientLoginBannerOptions),
    "ConnectionLogOptions": convertCfnClientVpnEndpointConnectionLogOptionsPropertyToCloudFormation(properties.connectionLogOptions),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DnsServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.dnsServers),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SelfServicePortal": cdk.stringToCloudFormation(properties.selfServicePortal),
    "ServerCertificateArn": cdk.stringToCloudFormation(properties.serverCertificateArn),
    "SessionTimeoutHours": cdk.numberToCloudFormation(properties.sessionTimeoutHours),
    "SplitTunnel": cdk.booleanToCloudFormation(properties.splitTunnel),
    "TagSpecifications": cdk.listMapper(convertCfnClientVpnEndpointTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TransportProtocol": cdk.stringToCloudFormation(properties.transportProtocol),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId),
    "VpnPort": cdk.numberToCloudFormation(properties.vpnPort)
  };
}

// @ts-ignore TS6133
function CfnClientVpnEndpointPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnEndpointProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnEndpointProps>();
  ret.addPropertyResult("authenticationOptions", "AuthenticationOptions", (properties.AuthenticationOptions != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointClientAuthenticationRequestPropertyFromCloudFormation)(properties.AuthenticationOptions) : undefined));
  ret.addPropertyResult("clientCidrBlock", "ClientCidrBlock", (properties.ClientCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.ClientCidrBlock) : undefined));
  ret.addPropertyResult("clientConnectOptions", "ClientConnectOptions", (properties.ClientConnectOptions != null ? CfnClientVpnEndpointClientConnectOptionsPropertyFromCloudFormation(properties.ClientConnectOptions) : undefined));
  ret.addPropertyResult("clientLoginBannerOptions", "ClientLoginBannerOptions", (properties.ClientLoginBannerOptions != null ? CfnClientVpnEndpointClientLoginBannerOptionsPropertyFromCloudFormation(properties.ClientLoginBannerOptions) : undefined));
  ret.addPropertyResult("connectionLogOptions", "ConnectionLogOptions", (properties.ConnectionLogOptions != null ? CfnClientVpnEndpointConnectionLogOptionsPropertyFromCloudFormation(properties.ConnectionLogOptions) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("dnsServers", "DnsServers", (properties.DnsServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DnsServers) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("selfServicePortal", "SelfServicePortal", (properties.SelfServicePortal != null ? cfn_parse.FromCloudFormation.getString(properties.SelfServicePortal) : undefined));
  ret.addPropertyResult("serverCertificateArn", "ServerCertificateArn", (properties.ServerCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.ServerCertificateArn) : undefined));
  ret.addPropertyResult("sessionTimeoutHours", "SessionTimeoutHours", (properties.SessionTimeoutHours != null ? cfn_parse.FromCloudFormation.getNumber(properties.SessionTimeoutHours) : undefined));
  ret.addPropertyResult("splitTunnel", "SplitTunnel", (properties.SplitTunnel != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SplitTunnel) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnClientVpnEndpointTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("transportProtocol", "TransportProtocol", (properties.TransportProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.TransportProtocol) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addPropertyResult("vpnPort", "VpnPort", (properties.VpnPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.VpnPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a network route to add to a Client VPN endpoint.
 *
 * Each Client VPN endpoint has a route table that describes the available destination network routes. Each route in the route table specifies the path for traffic to specific resources or networks.
 *
 * A target network association must be created before you can specify a route. If you're setting up all the components of a Client VPN endpoint at the same time, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the \`AWS::EC2::ClientVpnTargetNetworkAssociation\` resource.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html
 */
export class CfnClientVpnRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::ClientVpnRoute";

  /**
   * Build a CfnClientVpnRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnClientVpnRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnClientVpnRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnClientVpnRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the Client VPN endpoint to which to add the route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-clientvpnendpointid
   */
  public clientVpnEndpointId: string;

  /**
   * A brief description of the route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-description
   */
  public description?: string;

  /**
   * The IPv4 address range, in CIDR notation, of the route destination. For example:.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-destinationcidrblock
   */
  public destinationCidrBlock: string;

  /**
   * The ID of the subnet through which you want to route traffic.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-targetvpcsubnetid
   */
  public targetVpcSubnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnClientVpnRouteProps) {
    super(scope, id, {
      "type": CfnClientVpnRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "clientVpnEndpointId", this);
    cdk.requireProperty(props, "destinationCidrBlock", this);
    cdk.requireProperty(props, "targetVpcSubnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.clientVpnEndpointId = props.clientVpnEndpointId;
    this.description = props.description;
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.targetVpcSubnetId = props.targetVpcSubnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "clientVpnEndpointId": this.clientVpnEndpointId,
      "description": this.description,
      "destinationCidrBlock": this.destinationCidrBlock,
      "targetVpcSubnetId": this.targetVpcSubnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnClientVpnRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnClientVpnRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnClientVpnRoute\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html
 */
export interface CfnClientVpnRouteProps {
  /**
   * The ID of the Client VPN endpoint to which to add the route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-clientvpnendpointid
   */
  readonly clientVpnEndpointId: string;

  /**
   * A brief description of the route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-description
   */
  readonly description?: string;

  /**
   * The IPv4 address range, in CIDR notation, of the route destination. For example:.
   *
   * - To add a route for Internet access, enter \`0.0.0.0/0\`
   * - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range
   * - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range
   * - To add a route for the local network, enter the client CIDR range
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-destinationcidrblock
   */
  readonly destinationCidrBlock: string;

  /**
   * The ID of the subnet through which you want to route traffic.
   *
   * The specified subnet must be an existing target network of the Client VPN endpoint.
   *
   * Alternatively, if you're adding a route for the local network, specify \`local\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-targetvpcsubnetid
   */
  readonly targetVpcSubnetId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnClientVpnRouteProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnClientVpnRouteProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.requiredValidator)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.validateString)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.requiredValidator)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("targetVpcSubnetId", cdk.requiredValidator)(properties.targetVpcSubnetId));
  errors.collect(cdk.propertyValidator("targetVpcSubnetId", cdk.validateString)(properties.targetVpcSubnetId));
  return errors.wrap("supplied properties not correct for \\"CfnClientVpnRouteProps\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnRoutePropsValidator(properties).assertSuccess();
  return {
    "ClientVpnEndpointId": cdk.stringToCloudFormation(properties.clientVpnEndpointId),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "TargetVpcSubnetId": cdk.stringToCloudFormation(properties.targetVpcSubnetId)
  };
}

// @ts-ignore TS6133
function CfnClientVpnRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnRouteProps>();
  ret.addPropertyResult("clientVpnEndpointId", "ClientVpnEndpointId", (properties.ClientVpnEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientVpnEndpointId) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("targetVpcSubnetId", "TargetVpcSubnetId", (properties.TargetVpcSubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.TargetVpcSubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a target network to associate with a Client VPN endpoint.
 *
 * A target network is a subnet in a VPC. You can associate multiple subnets from the same VPC with a Client VPN endpoint. You can associate only one subnet in each Availability Zone. We recommend that you associate at least two subnets to provide Availability Zone redundancy.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html
 */
export class CfnClientVpnTargetNetworkAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::ClientVpnTargetNetworkAssociation";

  /**
   * Build a CfnClientVpnTargetNetworkAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnClientVpnTargetNetworkAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnClientVpnTargetNetworkAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnClientVpnTargetNetworkAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-clientvpnendpointid
   */
  public clientVpnEndpointId: string;

  /**
   * The ID of the subnet to associate with the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-subnetid
   */
  public subnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnClientVpnTargetNetworkAssociationProps) {
    super(scope, id, {
      "type": CfnClientVpnTargetNetworkAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "clientVpnEndpointId", this);
    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.clientVpnEndpointId = props.clientVpnEndpointId;
    this.subnetId = props.subnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "clientVpnEndpointId": this.clientVpnEndpointId,
      "subnetId": this.subnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnClientVpnTargetNetworkAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnClientVpnTargetNetworkAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnClientVpnTargetNetworkAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html
 */
export interface CfnClientVpnTargetNetworkAssociationProps {
  /**
   * The ID of the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-clientvpnendpointid
   */
  readonly clientVpnEndpointId: string;

  /**
   * The ID of the subnet to associate with the Client VPN endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-subnetid
   */
  readonly subnetId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnClientVpnTargetNetworkAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnClientVpnTargetNetworkAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnClientVpnTargetNetworkAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.requiredValidator)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("clientVpnEndpointId", cdk.validateString)(properties.clientVpnEndpointId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \\"CfnClientVpnTargetNetworkAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnClientVpnTargetNetworkAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnClientVpnTargetNetworkAssociationPropsValidator(properties).assertSuccess();
  return {
    "ClientVpnEndpointId": cdk.stringToCloudFormation(properties.clientVpnEndpointId),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnClientVpnTargetNetworkAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnClientVpnTargetNetworkAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnClientVpnTargetNetworkAssociationProps>();
  ret.addPropertyResult("clientVpnEndpointId", "ClientVpnEndpointId", (properties.ClientVpnEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientVpnEndpointId) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a customer gateway.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html
 */
export class CfnCustomerGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::CustomerGateway";

  /**
   * Build a CfnCustomerGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnCustomerGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnCustomerGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnCustomerGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the customer gateway.
   *
   * @cloudformationAttribute CustomerGatewayId
   */
  public readonly attrCustomerGatewayId: string;

  /**
   * For devices that support BGP, the customer gateway's BGP ASN.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-bgpasn
   */
  public bgpAsn: number;

  /**
   * The name of customer gateway device.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-devicename
   */
  public deviceName?: string;

  /**
   * IPv4 address for the customer gateway device's outside interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-ipaddress
   */
  public ipAddress: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * One or more tags for the customer gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The type of VPN connection that this customer gateway supports ( \`ipsec.1\` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-type
   */
  public type: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnCustomerGatewayProps) {
    super(scope, id, {
      "type": CfnCustomerGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "bgpAsn", this);
    cdk.requireProperty(props, "ipAddress", this);
    cdk.requireProperty(props, "type", this);

    this.attrCustomerGatewayId = cdk.Token.asString(this.getAtt("CustomerGatewayId", cdk.ResolutionTypeHint.STRING));
    this.bgpAsn = props.bgpAsn;
    this.deviceName = props.deviceName;
    this.ipAddress = props.ipAddress;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::CustomerGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.type = props.type;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "bgpAsn": this.bgpAsn,
      "deviceName": this.deviceName,
      "ipAddress": this.ipAddress,
      "tags": this.tags.renderTags(),
      "type": this.type
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnCustomerGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnCustomerGatewayPropsToCloudFormation(props);
  }
}

export namespace CfnCustomerGateway {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-customergateway-tag.html
   */
  export interface TagProperty {
    /**
     * For devices that support BGP, the customer gateway's BGP ASN.
     *
     * Default: 65000
     *
     * @default - 65000
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-customergateway-tag.html#cfn-ec2-customergateway-tag-bgpasn
     */
    readonly bgpAsn: number;

    /**
     * The name of customer gateway device.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-customergateway-tag.html#cfn-ec2-customergateway-tag-devicename
     */
    readonly deviceName?: string;

    /**
     * IPv4 address for the customer gateway device's outside interface.
     *
     * The address must be static.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-customergateway-tag.html#cfn-ec2-customergateway-tag-ipaddress
     */
    readonly ipAddress: string;

    /**
     * One or more tags for the customer gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-customergateway-tag.html#cfn-ec2-customergateway-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnCustomerGateway.TagProperty> | cdk.IResolvable;

    /**
     * The type of VPN connection that this customer gateway supports ( \`ipsec.1\` ).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-customergateway-tag.html#cfn-ec2-customergateway-tag-type
     */
    readonly type: string;
  }
}

/**
 * Properties for defining a \`CfnCustomerGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html
 */
export interface CfnCustomerGatewayProps {
  /**
   * For devices that support BGP, the customer gateway's BGP ASN.
   *
   * Default: 65000
   *
   * @default - 65000
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-bgpasn
   */
  readonly bgpAsn: number;

  /**
   * The name of customer gateway device.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-devicename
   */
  readonly deviceName?: string;

  /**
   * IPv4 address for the customer gateway device's outside interface.
   *
   * The address must be static.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-ipaddress
   */
  readonly ipAddress: string;

  /**
   * One or more tags for the customer gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The type of VPN connection that this customer gateway supports ( \`ipsec.1\` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-type
   */
  readonly type: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCustomerGatewayTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bgpAsn", cdk.requiredValidator)(properties.bgpAsn));
  errors.collect(cdk.propertyValidator("bgpAsn", cdk.validateNumber)(properties.bgpAsn));
  errors.collect(cdk.propertyValidator("deviceName", cdk.validateString)(properties.deviceName));
  errors.collect(cdk.propertyValidator("ipAddress", cdk.requiredValidator)(properties.ipAddress));
  errors.collect(cdk.propertyValidator("ipAddress", cdk.validateString)(properties.ipAddress));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnCustomerGatewayTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnCustomerGatewayTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCustomerGatewayTagPropertyValidator(properties).assertSuccess();
  return {
    "BgpAsn": cdk.numberToCloudFormation(properties.bgpAsn),
    "DeviceName": cdk.stringToCloudFormation(properties.deviceName),
    "IpAddress": cdk.stringToCloudFormation(properties.ipAddress),
    "Tags": cdk.listMapper(convertCfnCustomerGatewayTagPropertyToCloudFormation)(properties.tags),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnCustomerGatewayTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnCustomerGateway.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCustomerGateway.TagProperty>();
  ret.addPropertyResult("bgpAsn", "BgpAsn", (properties.BgpAsn != null ? cfn_parse.FromCloudFormation.getNumber(properties.BgpAsn) : undefined));
  ret.addPropertyResult("deviceName", "DeviceName", (properties.DeviceName != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceName) : undefined));
  ret.addPropertyResult("ipAddress", "IpAddress", (properties.IpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.IpAddress) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnCustomerGatewayTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnCustomerGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnCustomerGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnCustomerGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bgpAsn", cdk.requiredValidator)(properties.bgpAsn));
  errors.collect(cdk.propertyValidator("bgpAsn", cdk.validateNumber)(properties.bgpAsn));
  errors.collect(cdk.propertyValidator("deviceName", cdk.validateString)(properties.deviceName));
  errors.collect(cdk.propertyValidator("ipAddress", cdk.requiredValidator)(properties.ipAddress));
  errors.collect(cdk.propertyValidator("ipAddress", cdk.validateString)(properties.ipAddress));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"CfnCustomerGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnCustomerGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnCustomerGatewayPropsValidator(properties).assertSuccess();
  return {
    "BgpAsn": cdk.numberToCloudFormation(properties.bgpAsn),
    "DeviceName": cdk.stringToCloudFormation(properties.deviceName),
    "IpAddress": cdk.stringToCloudFormation(properties.ipAddress),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnCustomerGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnCustomerGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnCustomerGatewayProps>();
  ret.addPropertyResult("bgpAsn", "BgpAsn", (properties.BgpAsn != null ? cfn_parse.FromCloudFormation.getNumber(properties.BgpAsn) : undefined));
  ret.addPropertyResult("deviceName", "DeviceName", (properties.DeviceName != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceName) : undefined));
  ret.addPropertyResult("ipAddress", "IpAddress", (properties.IpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.IpAddress) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a set of DHCP options for your VPC.
 *
 * You must specify at least one of the following properties: \`DomainNameServers\` , \`NetbiosNameServers\` , \`NtpServers\` . If you specify \`NetbiosNameServers\` , you must specify \`NetbiosNodeType\` .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html
 */
export class CfnDHCPOptions extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::DHCPOptions";

  /**
   * Build a CfnDHCPOptions from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnDHCPOptions {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnDHCPOptionsPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnDHCPOptions(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the DHCP options set.
   *
   * @cloudformationAttribute DhcpOptionsId
   */
  public readonly attrDhcpOptionsId: string;

  /**
   * This value is used to complete unqualified DNS hostnames.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainname
   */
  public domainName?: string;

  /**
   * The IPv4 addresses of up to four domain name servers, or \`AmazonProvidedDNS\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainnameservers
   */
  public domainNameServers?: Array<string>;

  /**
   * The IPv4 addresses of up to four NetBIOS name servers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnameservers
   */
  public netbiosNameServers?: Array<string>;

  /**
   * The NetBIOS node type (1, 2, 4, or 8).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnodetype
   */
  public netbiosNodeType?: number;

  /**
   * The IPv4 addresses of up to four Network Time Protocol (NTP) servers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-ntpservers
   */
  public ntpServers?: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the DHCP options set.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnDHCPOptionsProps = {}) {
    super(scope, id, {
      "type": CfnDHCPOptions.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrDhcpOptionsId = cdk.Token.asString(this.getAtt("DhcpOptionsId", cdk.ResolutionTypeHint.STRING));
    this.domainName = props.domainName;
    this.domainNameServers = props.domainNameServers;
    this.netbiosNameServers = props.netbiosNameServers;
    this.netbiosNodeType = props.netbiosNodeType;
    this.ntpServers = props.ntpServers;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::DHCPOptions", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "domainName": this.domainName,
      "domainNameServers": this.domainNameServers,
      "netbiosNameServers": this.netbiosNameServers,
      "netbiosNodeType": this.netbiosNodeType,
      "ntpServers": this.ntpServers,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnDHCPOptions.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnDHCPOptionsPropsToCloudFormation(props);
  }
}

export namespace CfnDHCPOptions {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-dhcpoptions-tag.html
   */
  export interface TagProperty {
    /**
     * This value is used to complete unqualified DNS hostnames.
     *
     * If you're using AmazonProvidedDNS in \`us-east-1\` , specify \`ec2.internal\` . If you're using AmazonProvidedDNS in another Region, specify *region* . \`compute.internal\` (for example, \`ap-northeast-1.compute.internal\` ). Otherwise, specify a domain name (for example, *MyCompany.com* ).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-dhcpoptions-tag.html#cfn-ec2-dhcpoptions-tag-domainname
     */
    readonly domainName?: string;

    /**
     * The IPv4 addresses of up to four domain name servers, or \`AmazonProvidedDNS\` .
     *
     * The default is \`AmazonProvidedDNS\` . To have your instance receive a custom DNS hostname as specified in \`DomainName\` , you must set this property to a custom DNS server.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-dhcpoptions-tag.html#cfn-ec2-dhcpoptions-tag-domainnameservers
     */
    readonly domainNameServers?: Array<string>;

    /**
     * The IPv4 addresses of up to four NetBIOS name servers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-dhcpoptions-tag.html#cfn-ec2-dhcpoptions-tag-netbiosnameservers
     */
    readonly netbiosNameServers?: Array<string>;

    /**
     * The NetBIOS node type (1, 2, 4, or 8).
     *
     * We recommend that you specify 2 (broadcast and multicast are not currently supported).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-dhcpoptions-tag.html#cfn-ec2-dhcpoptions-tag-netbiosnodetype
     */
    readonly netbiosNodeType?: number;

    /**
     * The IPv4 addresses of up to four Network Time Protocol (NTP) servers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-dhcpoptions-tag.html#cfn-ec2-dhcpoptions-tag-ntpservers
     */
    readonly ntpServers?: Array<string>;

    /**
     * Any tags assigned to the DHCP options set.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-dhcpoptions-tag.html#cfn-ec2-dhcpoptions-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnDHCPOptions.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnDHCPOptions\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html
 */
export interface CfnDHCPOptionsProps {
  /**
   * This value is used to complete unqualified DNS hostnames.
   *
   * If you're using AmazonProvidedDNS in \`us-east-1\` , specify \`ec2.internal\` . If you're using AmazonProvidedDNS in another Region, specify *region* . \`compute.internal\` (for example, \`ap-northeast-1.compute.internal\` ). Otherwise, specify a domain name (for example, *MyCompany.com* ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainname
   */
  readonly domainName?: string;

  /**
   * The IPv4 addresses of up to four domain name servers, or \`AmazonProvidedDNS\` .
   *
   * The default is \`AmazonProvidedDNS\` . To have your instance receive a custom DNS hostname as specified in \`DomainName\` , you must set this property to a custom DNS server.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainnameservers
   */
  readonly domainNameServers?: Array<string>;

  /**
   * The IPv4 addresses of up to four NetBIOS name servers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnameservers
   */
  readonly netbiosNameServers?: Array<string>;

  /**
   * The NetBIOS node type (1, 2, 4, or 8).
   *
   * We recommend that you specify 2 (broadcast and multicast are not currently supported).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnodetype
   */
  readonly netbiosNodeType?: number;

  /**
   * The IPv4 addresses of up to four Network Time Protocol (NTP) servers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-ntpservers
   */
  readonly ntpServers?: Array<string>;

  /**
   * Any tags assigned to the DHCP options set.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnDHCPOptionsTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("domainName", cdk.validateString)(properties.domainName));
  errors.collect(cdk.propertyValidator("domainNameServers", cdk.listValidator(cdk.validateString))(properties.domainNameServers));
  errors.collect(cdk.propertyValidator("netbiosNameServers", cdk.listValidator(cdk.validateString))(properties.netbiosNameServers));
  errors.collect(cdk.propertyValidator("netbiosNodeType", cdk.validateNumber)(properties.netbiosNodeType));
  errors.collect(cdk.propertyValidator("ntpServers", cdk.listValidator(cdk.validateString))(properties.ntpServers));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnDHCPOptionsTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnDHCPOptionsTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnDHCPOptionsTagPropertyValidator(properties).assertSuccess();
  return {
    "DomainName": cdk.stringToCloudFormation(properties.domainName),
    "DomainNameServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.domainNameServers),
    "NetbiosNameServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.netbiosNameServers),
    "NetbiosNodeType": cdk.numberToCloudFormation(properties.netbiosNodeType),
    "NtpServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.ntpServers),
    "Tags": cdk.listMapper(convertCfnDHCPOptionsTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnDHCPOptionsTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnDHCPOptions.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnDHCPOptions.TagProperty>();
  ret.addPropertyResult("domainName", "DomainName", (properties.DomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DomainName) : undefined));
  ret.addPropertyResult("domainNameServers", "DomainNameServers", (properties.DomainNameServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DomainNameServers) : undefined));
  ret.addPropertyResult("netbiosNameServers", "NetbiosNameServers", (properties.NetbiosNameServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NetbiosNameServers) : undefined));
  ret.addPropertyResult("netbiosNodeType", "NetbiosNodeType", (properties.NetbiosNodeType != null ? cfn_parse.FromCloudFormation.getNumber(properties.NetbiosNodeType) : undefined));
  ret.addPropertyResult("ntpServers", "NtpServers", (properties.NtpServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NtpServers) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnDHCPOptionsTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnDHCPOptionsProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnDHCPOptionsProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnDHCPOptionsPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("domainName", cdk.validateString)(properties.domainName));
  errors.collect(cdk.propertyValidator("domainNameServers", cdk.listValidator(cdk.validateString))(properties.domainNameServers));
  errors.collect(cdk.propertyValidator("netbiosNameServers", cdk.listValidator(cdk.validateString))(properties.netbiosNameServers));
  errors.collect(cdk.propertyValidator("netbiosNodeType", cdk.validateNumber)(properties.netbiosNodeType));
  errors.collect(cdk.propertyValidator("ntpServers", cdk.listValidator(cdk.validateString))(properties.ntpServers));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnDHCPOptionsProps\\"");
}

// @ts-ignore TS6133
function convertCfnDHCPOptionsPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnDHCPOptionsPropsValidator(properties).assertSuccess();
  return {
    "DomainName": cdk.stringToCloudFormation(properties.domainName),
    "DomainNameServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.domainNameServers),
    "NetbiosNameServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.netbiosNameServers),
    "NetbiosNodeType": cdk.numberToCloudFormation(properties.netbiosNodeType),
    "NtpServers": cdk.listMapper(cdk.stringToCloudFormation)(properties.ntpServers),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnDHCPOptionsPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnDHCPOptionsProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnDHCPOptionsProps>();
  ret.addPropertyResult("domainName", "DomainName", (properties.DomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DomainName) : undefined));
  ret.addPropertyResult("domainNameServers", "DomainNameServers", (properties.DomainNameServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.DomainNameServers) : undefined));
  ret.addPropertyResult("netbiosNameServers", "NetbiosNameServers", (properties.NetbiosNameServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NetbiosNameServers) : undefined));
  ret.addPropertyResult("netbiosNodeType", "NetbiosNodeType", (properties.NetbiosNodeType != null ? cfn_parse.FromCloudFormation.getNumber(properties.NetbiosNodeType) : undefined));
  ret.addPropertyResult("ntpServers", "NtpServers", (properties.NtpServers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NtpServers) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies the configuration information to launch a fleet--or group--of instances.
 *
 * An EC2 Fleet can launch multiple instance types across multiple Availability Zones, using the On-Demand Instance, Reserved Instance, and Spot Instance purchasing models together. Using EC2 Fleet, you can define separate On-Demand and Spot capacity targets, specify the instance types that work best for your applications, and specify how Amazon EC2 should distribute your fleet capacity within each purchasing model. For more information, see [Launching an EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet.html) in the *Amazon EC2 User Guide for Linux Instances* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html
 */
export class CfnEC2Fleet extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EC2Fleet";

  /**
   * Build a CfnEC2Fleet from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEC2Fleet {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEC2FleetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEC2Fleet(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the EC2 Fleet.
   *
   * @cloudformationAttribute FleetId
   */
  public readonly attrFleetId: string;

  /**
   * Reserved.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-context
   */
  public context?: string;

  /**
   * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-excesscapacityterminationpolicy
   */
  public excessCapacityTerminationPolicy?: string;

  /**
   * The configuration for the EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-launchtemplateconfigs
   */
  public launchTemplateConfigs: Array<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Describes the configuration of On-Demand Instances in an EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-ondemandoptions
   */
  public onDemandOptions?: cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty;

  /**
   * Indicates whether EC2 Fleet should replace unhealthy Spot Instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-replaceunhealthyinstances
   */
  public replaceUnhealthyInstances?: boolean | cdk.IResolvable;

  /**
   * Describes the configuration of Spot Instances in an EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-spotoptions
   */
  public spotOptions?: cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty;

  /**
   * The key-value pair for tagging the EC2 Fleet request on creation. For more information, see [Tagging your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-tagspecifications
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * The number of units to request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-targetcapacityspecification
   */
  public targetCapacitySpecification: cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty;

  /**
   * Indicates whether running instances should be terminated when the EC2 Fleet expires.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-terminateinstanceswithexpiration
   */
  public terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

  /**
   * The fleet type. The default value is \`maintain\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-type
   */
  public type?: string;

  /**
   * The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validfrom
   */
  public validFrom?: string;

  /**
   * The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validuntil
   */
  public validUntil?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEC2FleetProps) {
    super(scope, id, {
      "type": CfnEC2Fleet.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "launchTemplateConfigs", this);
    cdk.requireProperty(props, "targetCapacitySpecification", this);

    this.attrFleetId = cdk.Token.asString(this.getAtt("FleetId", cdk.ResolutionTypeHint.STRING));
    this.context = props.context;
    this.excessCapacityTerminationPolicy = props.excessCapacityTerminationPolicy;
    this.launchTemplateConfigs = props.launchTemplateConfigs;
    this.onDemandOptions = props.onDemandOptions;
    this.replaceUnhealthyInstances = props.replaceUnhealthyInstances;
    this.spotOptions = props.spotOptions;
    this.tagSpecifications = props.tagSpecifications;
    this.targetCapacitySpecification = props.targetCapacitySpecification;
    this.terminateInstancesWithExpiration = props.terminateInstancesWithExpiration;
    this.type = props.type;
    this.validFrom = props.validFrom;
    this.validUntil = props.validUntil;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "context": this.context,
      "excessCapacityTerminationPolicy": this.excessCapacityTerminationPolicy,
      "launchTemplateConfigs": this.launchTemplateConfigs,
      "onDemandOptions": this.onDemandOptions,
      "replaceUnhealthyInstances": this.replaceUnhealthyInstances,
      "spotOptions": this.spotOptions,
      "tagSpecifications": this.tagSpecifications,
      "targetCapacitySpecification": this.targetCapacitySpecification,
      "terminateInstancesWithExpiration": this.terminateInstancesWithExpiration,
      "type": this.type,
      "validFrom": this.validFrom,
      "validUntil": this.validUntil
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEC2Fleet.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEC2FleetPropsToCloudFormation(props);
  }
}

export namespace CfnEC2Fleet {
  /**
   * Specifies the number of units to request for an EC2 Fleet.
   *
   * You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is \`maintain\` , you can specify a target capacity of \`0\` and add capacity later.
   *
   * \`TargetCapacitySpecificationRequest\` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html
   */
  export interface TargetCapacitySpecificationRequestProperty {
    /**
     * Reserved.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-context
     */
    readonly context?: string;

    /**
     * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
     *
     * Supported only for fleets of type \`maintain\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-excesscapacityterminationpolicy
     */
    readonly excessCapacityTerminationPolicy?: string;

    /**
     * The configuration for the EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-launchtemplateconfigs
     */
    readonly launchTemplateConfigs: Array<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Describes the configuration of On-Demand Instances in an EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-ondemandoptions
     */
    readonly onDemandOptions?: cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty;

    /**
     * Indicates whether EC2 Fleet should replace unhealthy Spot Instances.
     *
     * Supported only for fleets of type \`maintain\` . For more information, see [EC2 Fleet health checks](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-replaceunhealthyinstances
     */
    readonly replaceUnhealthyInstances?: boolean | cdk.IResolvable;

    /**
     * Describes the configuration of Spot Instances in an EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-spotoptions
     */
    readonly spotOptions?: cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty;

    /**
     * The key-value pair for tagging the EC2 Fleet request on creation. For more information, see [Tagging your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
     *
     * If the fleet type is \`instant\` , specify a resource type of \`fleet\` to tag the fleet or \`instance\` to tag the instances at launch.
     *
     * If the fleet type is \`maintain\` or \`request\` , specify a resource type of \`fleet\` to tag the fleet. You cannot specify a resource type of \`instance\` . To tag instances at launch, specify the tags in a [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of units to request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-targetcapacityspecification
     */
    readonly targetCapacitySpecification: cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty;

    /**
     * Indicates whether running instances should be terminated when the EC2 Fleet expires.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-terminateinstanceswithexpiration
     */
    readonly terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

    /**
     * The fleet type. The default value is \`maintain\` .
     *
     * - \`maintain\` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
     * - \`request\` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
     * - \`instant\` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.
     *
     * For more information, see [EC2 Fleet request types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-type
     */
    readonly type?: string;

    /**
     * The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * The default is to start fulfilling the request immediately.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-validfrom
     */
    readonly validFrom?: string;

    /**
     * The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-validuntil
     */
    readonly validUntil?: string;
  }

  /**
   * Specifies the allocation strategy of On-Demand Instances in an EC2 Fleet.
   *
   * \`OnDemandOptionsRequest\` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html
   */
  export interface OnDemandOptionsRequestProperty {
    /**
     * Reserved.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-context
     */
    readonly context?: string;

    /**
     * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
     *
     * Supported only for fleets of type \`maintain\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-excesscapacityterminationpolicy
     */
    readonly excessCapacityTerminationPolicy?: string;

    /**
     * The configuration for the EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-launchtemplateconfigs
     */
    readonly launchTemplateConfigs: Array<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Describes the configuration of On-Demand Instances in an EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-ondemandoptions
     */
    readonly onDemandOptions?: cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty;

    /**
     * Indicates whether EC2 Fleet should replace unhealthy Spot Instances.
     *
     * Supported only for fleets of type \`maintain\` . For more information, see [EC2 Fleet health checks](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-replaceunhealthyinstances
     */
    readonly replaceUnhealthyInstances?: boolean | cdk.IResolvable;

    /**
     * Describes the configuration of Spot Instances in an EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-spotoptions
     */
    readonly spotOptions?: cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty;

    /**
     * The key-value pair for tagging the EC2 Fleet request on creation. For more information, see [Tagging your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
     *
     * If the fleet type is \`instant\` , specify a resource type of \`fleet\` to tag the fleet or \`instance\` to tag the instances at launch.
     *
     * If the fleet type is \`maintain\` or \`request\` , specify a resource type of \`fleet\` to tag the fleet. You cannot specify a resource type of \`instance\` . To tag instances at launch, specify the tags in a [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of units to request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-targetcapacityspecification
     */
    readonly targetCapacitySpecification: cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty;

    /**
     * Indicates whether running instances should be terminated when the EC2 Fleet expires.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-terminateinstanceswithexpiration
     */
    readonly terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

    /**
     * The fleet type. The default value is \`maintain\` .
     *
     * - \`maintain\` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
     * - \`request\` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
     * - \`instant\` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.
     *
     * For more information, see [EC2 Fleet request types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-type
     */
    readonly type?: string;

    /**
     * The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * The default is to start fulfilling the request immediately.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-validfrom
     */
    readonly validFrom?: string;

    /**
     * The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-validuntil
     */
    readonly validUntil?: string;
  }

  /**
   * Specifies the tags to apply to a resource when the resource is being created for an EC2 Fleet.
   *
   * \`TagSpecification\` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html
   */
  export interface TagSpecificationProperty {
    /**
     * Reserved.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-context
     */
    readonly context?: string;

    /**
     * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
     *
     * Supported only for fleets of type \`maintain\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-excesscapacityterminationpolicy
     */
    readonly excessCapacityTerminationPolicy?: string;

    /**
     * The configuration for the EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-launchtemplateconfigs
     */
    readonly launchTemplateConfigs: Array<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Describes the configuration of On-Demand Instances in an EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-ondemandoptions
     */
    readonly onDemandOptions?: cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty;

    /**
     * Indicates whether EC2 Fleet should replace unhealthy Spot Instances.
     *
     * Supported only for fleets of type \`maintain\` . For more information, see [EC2 Fleet health checks](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-replaceunhealthyinstances
     */
    readonly replaceUnhealthyInstances?: boolean | cdk.IResolvable;

    /**
     * Describes the configuration of Spot Instances in an EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-spotoptions
     */
    readonly spotOptions?: cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty;

    /**
     * The key-value pair for tagging the EC2 Fleet request on creation. For more information, see [Tagging your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
     *
     * If the fleet type is \`instant\` , specify a resource type of \`fleet\` to tag the fleet or \`instance\` to tag the instances at launch.
     *
     * If the fleet type is \`maintain\` or \`request\` , specify a resource type of \`fleet\` to tag the fleet. You cannot specify a resource type of \`instance\` . To tag instances at launch, specify the tags in a [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of units to request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-targetcapacityspecification
     */
    readonly targetCapacitySpecification: cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty;

    /**
     * Indicates whether running instances should be terminated when the EC2 Fleet expires.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-terminateinstanceswithexpiration
     */
    readonly terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

    /**
     * The fleet type. The default value is \`maintain\` .
     *
     * - \`maintain\` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
     * - \`request\` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
     * - \`instant\` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.
     *
     * For more information, see [EC2 Fleet request types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-type
     */
    readonly type?: string;

    /**
     * The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * The default is to start fulfilling the request immediately.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-validfrom
     */
    readonly validFrom?: string;

    /**
     * The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-validuntil
     */
    readonly validUntil?: string;
  }

  /**
   * Specifies the configuration of Spot Instances for an EC2 Fleet.
   *
   * \`SpotOptionsRequest\` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html
   */
  export interface SpotOptionsRequestProperty {
    /**
     * Reserved.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-context
     */
    readonly context?: string;

    /**
     * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
     *
     * Supported only for fleets of type \`maintain\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-excesscapacityterminationpolicy
     */
    readonly excessCapacityTerminationPolicy?: string;

    /**
     * The configuration for the EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-launchtemplateconfigs
     */
    readonly launchTemplateConfigs: Array<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Describes the configuration of On-Demand Instances in an EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-ondemandoptions
     */
    readonly onDemandOptions?: cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty;

    /**
     * Indicates whether EC2 Fleet should replace unhealthy Spot Instances.
     *
     * Supported only for fleets of type \`maintain\` . For more information, see [EC2 Fleet health checks](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-replaceunhealthyinstances
     */
    readonly replaceUnhealthyInstances?: boolean | cdk.IResolvable;

    /**
     * Describes the configuration of Spot Instances in an EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-spotoptions
     */
    readonly spotOptions?: cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty;

    /**
     * The key-value pair for tagging the EC2 Fleet request on creation. For more information, see [Tagging your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
     *
     * If the fleet type is \`instant\` , specify a resource type of \`fleet\` to tag the fleet or \`instance\` to tag the instances at launch.
     *
     * If the fleet type is \`maintain\` or \`request\` , specify a resource type of \`fleet\` to tag the fleet. You cannot specify a resource type of \`instance\` . To tag instances at launch, specify the tags in a [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of units to request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-targetcapacityspecification
     */
    readonly targetCapacitySpecification: cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty;

    /**
     * Indicates whether running instances should be terminated when the EC2 Fleet expires.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-terminateinstanceswithexpiration
     */
    readonly terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

    /**
     * The fleet type. The default value is \`maintain\` .
     *
     * - \`maintain\` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
     * - \`request\` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
     * - \`instant\` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.
     *
     * For more information, see [EC2 Fleet request types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-type
     */
    readonly type?: string;

    /**
     * The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * The default is to start fulfilling the request immediately.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-validfrom
     */
    readonly validFrom?: string;

    /**
     * The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-validuntil
     */
    readonly validUntil?: string;
  }

  /**
   * Specifies a launch template and overrides for an EC2 Fleet.
   *
   * \`FleetLaunchTemplateConfigRequest\` is a property of the [AWS::EC2::EC2Fleet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html
   */
  export interface FleetLaunchTemplateConfigRequestProperty {
    /**
     * Reserved.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-context
     */
    readonly context?: string;

    /**
     * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
     *
     * Supported only for fleets of type \`maintain\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-excesscapacityterminationpolicy
     */
    readonly excessCapacityTerminationPolicy?: string;

    /**
     * The configuration for the EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-launchtemplateconfigs
     */
    readonly launchTemplateConfigs: Array<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Describes the configuration of On-Demand Instances in an EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-ondemandoptions
     */
    readonly onDemandOptions?: cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty;

    /**
     * Indicates whether EC2 Fleet should replace unhealthy Spot Instances.
     *
     * Supported only for fleets of type \`maintain\` . For more information, see [EC2 Fleet health checks](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-replaceunhealthyinstances
     */
    readonly replaceUnhealthyInstances?: boolean | cdk.IResolvable;

    /**
     * Describes the configuration of Spot Instances in an EC2 Fleet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-spotoptions
     */
    readonly spotOptions?: cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty;

    /**
     * The key-value pair for tagging the EC2 Fleet request on creation. For more information, see [Tagging your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
     *
     * If the fleet type is \`instant\` , specify a resource type of \`fleet\` to tag the fleet or \`instance\` to tag the instances at launch.
     *
     * If the fleet type is \`maintain\` or \`request\` , specify a resource type of \`fleet\` to tag the fleet. You cannot specify a resource type of \`instance\` . To tag instances at launch, specify the tags in a [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of units to request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-targetcapacityspecification
     */
    readonly targetCapacitySpecification: cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty;

    /**
     * Indicates whether running instances should be terminated when the EC2 Fleet expires.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-terminateinstanceswithexpiration
     */
    readonly terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

    /**
     * The fleet type. The default value is \`maintain\` .
     *
     * - \`maintain\` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
     * - \`request\` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
     * - \`instant\` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.
     *
     * For more information, see [EC2 Fleet request types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-type
     */
    readonly type?: string;

    /**
     * The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * The default is to start fulfilling the request immediately.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-validfrom
     */
    readonly validFrom?: string;

    /**
     * The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
     *
     * At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-validuntil
     */
    readonly validUntil?: string;
  }
}

/**
 * Properties for defining a \`CfnEC2Fleet\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html
 */
export interface CfnEC2FleetProps {
  /**
   * Reserved.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-context
   */
  readonly context?: string;

  /**
   * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
   *
   * Supported only for fleets of type \`maintain\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-excesscapacityterminationpolicy
   */
  readonly excessCapacityTerminationPolicy?: string;

  /**
   * The configuration for the EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-launchtemplateconfigs
   */
  readonly launchTemplateConfigs: Array<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Describes the configuration of On-Demand Instances in an EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-ondemandoptions
   */
  readonly onDemandOptions?: cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty;

  /**
   * Indicates whether EC2 Fleet should replace unhealthy Spot Instances.
   *
   * Supported only for fleets of type \`maintain\` . For more information, see [EC2 Fleet health checks](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-replaceunhealthyinstances
   */
  readonly replaceUnhealthyInstances?: boolean | cdk.IResolvable;

  /**
   * Describes the configuration of Spot Instances in an EC2 Fleet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-spotoptions
   */
  readonly spotOptions?: cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty;

  /**
   * The key-value pair for tagging the EC2 Fleet request on creation. For more information, see [Tagging your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
   *
   * If the fleet type is \`instant\` , specify a resource type of \`fleet\` to tag the fleet or \`instance\` to tag the instances at launch.
   *
   * If the fleet type is \`maintain\` or \`request\` , specify a resource type of \`fleet\` to tag the fleet. You cannot specify a resource type of \`instance\` . To tag instances at launch, specify the tags in a [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> | cdk.IResolvable;

  /**
   * The number of units to request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-targetcapacityspecification
   */
  readonly targetCapacitySpecification: cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty;

  /**
   * Indicates whether running instances should be terminated when the EC2 Fleet expires.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-terminateinstanceswithexpiration
   */
  readonly terminateInstancesWithExpiration?: boolean | cdk.IResolvable;

  /**
   * The fleet type. The default value is \`maintain\` .
   *
   * - \`maintain\` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
   * - \`request\` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
   * - \`instant\` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.
   *
   * For more information, see [EC2 Fleet request types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-type
   */
  readonly type?: string;

  /**
   * The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
   *
   * The default is to start fulfilling the request immediately.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validfrom
   */
  readonly validFrom?: string;

  /**
   * The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).
   *
   * At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validuntil
   */
  readonly validUntil?: string;
}

/**
 * Determine whether the given properties match those of a \`FleetLaunchTemplateConfigRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`FleetLaunchTemplateConfigRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("context", cdk.validateString)(properties.context));
  errors.collect(cdk.propertyValidator("excessCapacityTerminationPolicy", cdk.validateString)(properties.excessCapacityTerminationPolicy));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.requiredValidator)(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.listValidator(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator))(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("onDemandOptions", CfnEC2FleetOnDemandOptionsRequestPropertyValidator)(properties.onDemandOptions));
  errors.collect(cdk.propertyValidator("replaceUnhealthyInstances", cdk.validateBoolean)(properties.replaceUnhealthyInstances));
  errors.collect(cdk.propertyValidator("spotOptions", CfnEC2FleetSpotOptionsRequestPropertyValidator)(properties.spotOptions));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnEC2FleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", cdk.requiredValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("terminateInstancesWithExpiration", cdk.validateBoolean)(properties.terminateInstancesWithExpiration));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("validFrom", cdk.validateString)(properties.validFrom));
  errors.collect(cdk.propertyValidator("validUntil", cdk.validateString)(properties.validUntil));
  return errors.wrap("supplied properties not correct for \\"FleetLaunchTemplateConfigRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetFleetLaunchTemplateConfigRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator(properties).assertSuccess();
  return {
    "Context": cdk.stringToCloudFormation(properties.context),
    "ExcessCapacityTerminationPolicy": cdk.stringToCloudFormation(properties.excessCapacityTerminationPolicy),
    "LaunchTemplateConfigs": cdk.listMapper(convertCfnEC2FleetFleetLaunchTemplateConfigRequestPropertyToCloudFormation)(properties.launchTemplateConfigs),
    "OnDemandOptions": convertCfnEC2FleetOnDemandOptionsRequestPropertyToCloudFormation(properties.onDemandOptions),
    "ReplaceUnhealthyInstances": cdk.booleanToCloudFormation(properties.replaceUnhealthyInstances),
    "SpotOptions": convertCfnEC2FleetSpotOptionsRequestPropertyToCloudFormation(properties.spotOptions),
    "TagSpecifications": cdk.listMapper(convertCfnEC2FleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TargetCapacitySpecification": convertCfnEC2FleetTargetCapacitySpecificationRequestPropertyToCloudFormation(properties.targetCapacitySpecification),
    "TerminateInstancesWithExpiration": cdk.booleanToCloudFormation(properties.terminateInstancesWithExpiration),
    "Type": cdk.stringToCloudFormation(properties.type),
    "ValidFrom": cdk.stringToCloudFormation(properties.validFrom),
    "ValidUntil": cdk.stringToCloudFormation(properties.validUntil)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty>();
  ret.addPropertyResult("context", "Context", (properties.Context != null ? cfn_parse.FromCloudFormation.getString(properties.Context) : undefined));
  ret.addPropertyResult("excessCapacityTerminationPolicy", "ExcessCapacityTerminationPolicy", (properties.ExcessCapacityTerminationPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.ExcessCapacityTerminationPolicy) : undefined));
  ret.addPropertyResult("launchTemplateConfigs", "LaunchTemplateConfigs", (properties.LaunchTemplateConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyFromCloudFormation)(properties.LaunchTemplateConfigs) : undefined));
  ret.addPropertyResult("onDemandOptions", "OnDemandOptions", (properties.OnDemandOptions != null ? CfnEC2FleetOnDemandOptionsRequestPropertyFromCloudFormation(properties.OnDemandOptions) : undefined));
  ret.addPropertyResult("replaceUnhealthyInstances", "ReplaceUnhealthyInstances", (properties.ReplaceUnhealthyInstances != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ReplaceUnhealthyInstances) : undefined));
  ret.addPropertyResult("spotOptions", "SpotOptions", (properties.SpotOptions != null ? CfnEC2FleetSpotOptionsRequestPropertyFromCloudFormation(properties.SpotOptions) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("targetCapacitySpecification", "TargetCapacitySpecification", (properties.TargetCapacitySpecification != null ? CfnEC2FleetTargetCapacitySpecificationRequestPropertyFromCloudFormation(properties.TargetCapacitySpecification) : undefined));
  ret.addPropertyResult("terminateInstancesWithExpiration", "TerminateInstancesWithExpiration", (properties.TerminateInstancesWithExpiration != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TerminateInstancesWithExpiration) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("validFrom", "ValidFrom", (properties.ValidFrom != null ? cfn_parse.FromCloudFormation.getString(properties.ValidFrom) : undefined));
  ret.addPropertyResult("validUntil", "ValidUntil", (properties.ValidUntil != null ? cfn_parse.FromCloudFormation.getString(properties.ValidUntil) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SpotOptionsRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`SpotOptionsRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetSpotOptionsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("context", cdk.validateString)(properties.context));
  errors.collect(cdk.propertyValidator("excessCapacityTerminationPolicy", cdk.validateString)(properties.excessCapacityTerminationPolicy));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.requiredValidator)(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.listValidator(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator))(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("onDemandOptions", CfnEC2FleetOnDemandOptionsRequestPropertyValidator)(properties.onDemandOptions));
  errors.collect(cdk.propertyValidator("replaceUnhealthyInstances", cdk.validateBoolean)(properties.replaceUnhealthyInstances));
  errors.collect(cdk.propertyValidator("spotOptions", CfnEC2FleetSpotOptionsRequestPropertyValidator)(properties.spotOptions));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnEC2FleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", cdk.requiredValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("terminateInstancesWithExpiration", cdk.validateBoolean)(properties.terminateInstancesWithExpiration));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("validFrom", cdk.validateString)(properties.validFrom));
  errors.collect(cdk.propertyValidator("validUntil", cdk.validateString)(properties.validUntil));
  return errors.wrap("supplied properties not correct for \\"SpotOptionsRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetSpotOptionsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetSpotOptionsRequestPropertyValidator(properties).assertSuccess();
  return {
    "Context": cdk.stringToCloudFormation(properties.context),
    "ExcessCapacityTerminationPolicy": cdk.stringToCloudFormation(properties.excessCapacityTerminationPolicy),
    "LaunchTemplateConfigs": cdk.listMapper(convertCfnEC2FleetFleetLaunchTemplateConfigRequestPropertyToCloudFormation)(properties.launchTemplateConfigs),
    "OnDemandOptions": convertCfnEC2FleetOnDemandOptionsRequestPropertyToCloudFormation(properties.onDemandOptions),
    "ReplaceUnhealthyInstances": cdk.booleanToCloudFormation(properties.replaceUnhealthyInstances),
    "SpotOptions": convertCfnEC2FleetSpotOptionsRequestPropertyToCloudFormation(properties.spotOptions),
    "TagSpecifications": cdk.listMapper(convertCfnEC2FleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TargetCapacitySpecification": convertCfnEC2FleetTargetCapacitySpecificationRequestPropertyToCloudFormation(properties.targetCapacitySpecification),
    "TerminateInstancesWithExpiration": cdk.booleanToCloudFormation(properties.terminateInstancesWithExpiration),
    "Type": cdk.stringToCloudFormation(properties.type),
    "ValidFrom": cdk.stringToCloudFormation(properties.validFrom),
    "ValidUntil": cdk.stringToCloudFormation(properties.validUntil)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetSpotOptionsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.SpotOptionsRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.SpotOptionsRequestProperty>();
  ret.addPropertyResult("context", "Context", (properties.Context != null ? cfn_parse.FromCloudFormation.getString(properties.Context) : undefined));
  ret.addPropertyResult("excessCapacityTerminationPolicy", "ExcessCapacityTerminationPolicy", (properties.ExcessCapacityTerminationPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.ExcessCapacityTerminationPolicy) : undefined));
  ret.addPropertyResult("launchTemplateConfigs", "LaunchTemplateConfigs", (properties.LaunchTemplateConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyFromCloudFormation)(properties.LaunchTemplateConfigs) : undefined));
  ret.addPropertyResult("onDemandOptions", "OnDemandOptions", (properties.OnDemandOptions != null ? CfnEC2FleetOnDemandOptionsRequestPropertyFromCloudFormation(properties.OnDemandOptions) : undefined));
  ret.addPropertyResult("replaceUnhealthyInstances", "ReplaceUnhealthyInstances", (properties.ReplaceUnhealthyInstances != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ReplaceUnhealthyInstances) : undefined));
  ret.addPropertyResult("spotOptions", "SpotOptions", (properties.SpotOptions != null ? CfnEC2FleetSpotOptionsRequestPropertyFromCloudFormation(properties.SpotOptions) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("targetCapacitySpecification", "TargetCapacitySpecification", (properties.TargetCapacitySpecification != null ? CfnEC2FleetTargetCapacitySpecificationRequestPropertyFromCloudFormation(properties.TargetCapacitySpecification) : undefined));
  ret.addPropertyResult("terminateInstancesWithExpiration", "TerminateInstancesWithExpiration", (properties.TerminateInstancesWithExpiration != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TerminateInstancesWithExpiration) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("validFrom", "ValidFrom", (properties.ValidFrom != null ? cfn_parse.FromCloudFormation.getString(properties.ValidFrom) : undefined));
  ret.addPropertyResult("validUntil", "ValidUntil", (properties.ValidUntil != null ? cfn_parse.FromCloudFormation.getString(properties.ValidUntil) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TagSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("context", cdk.validateString)(properties.context));
  errors.collect(cdk.propertyValidator("excessCapacityTerminationPolicy", cdk.validateString)(properties.excessCapacityTerminationPolicy));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.requiredValidator)(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.listValidator(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator))(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("onDemandOptions", CfnEC2FleetOnDemandOptionsRequestPropertyValidator)(properties.onDemandOptions));
  errors.collect(cdk.propertyValidator("replaceUnhealthyInstances", cdk.validateBoolean)(properties.replaceUnhealthyInstances));
  errors.collect(cdk.propertyValidator("spotOptions", CfnEC2FleetSpotOptionsRequestPropertyValidator)(properties.spotOptions));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnEC2FleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", cdk.requiredValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("terminateInstancesWithExpiration", cdk.validateBoolean)(properties.terminateInstancesWithExpiration));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("validFrom", cdk.validateString)(properties.validFrom));
  errors.collect(cdk.propertyValidator("validUntil", cdk.validateString)(properties.validUntil));
  return errors.wrap("supplied properties not correct for \\"TagSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Context": cdk.stringToCloudFormation(properties.context),
    "ExcessCapacityTerminationPolicy": cdk.stringToCloudFormation(properties.excessCapacityTerminationPolicy),
    "LaunchTemplateConfigs": cdk.listMapper(convertCfnEC2FleetFleetLaunchTemplateConfigRequestPropertyToCloudFormation)(properties.launchTemplateConfigs),
    "OnDemandOptions": convertCfnEC2FleetOnDemandOptionsRequestPropertyToCloudFormation(properties.onDemandOptions),
    "ReplaceUnhealthyInstances": cdk.booleanToCloudFormation(properties.replaceUnhealthyInstances),
    "SpotOptions": convertCfnEC2FleetSpotOptionsRequestPropertyToCloudFormation(properties.spotOptions),
    "TagSpecifications": cdk.listMapper(convertCfnEC2FleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TargetCapacitySpecification": convertCfnEC2FleetTargetCapacitySpecificationRequestPropertyToCloudFormation(properties.targetCapacitySpecification),
    "TerminateInstancesWithExpiration": cdk.booleanToCloudFormation(properties.terminateInstancesWithExpiration),
    "Type": cdk.stringToCloudFormation(properties.type),
    "ValidFrom": cdk.stringToCloudFormation(properties.validFrom),
    "ValidUntil": cdk.stringToCloudFormation(properties.validUntil)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.TagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.TagSpecificationProperty>();
  ret.addPropertyResult("context", "Context", (properties.Context != null ? cfn_parse.FromCloudFormation.getString(properties.Context) : undefined));
  ret.addPropertyResult("excessCapacityTerminationPolicy", "ExcessCapacityTerminationPolicy", (properties.ExcessCapacityTerminationPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.ExcessCapacityTerminationPolicy) : undefined));
  ret.addPropertyResult("launchTemplateConfigs", "LaunchTemplateConfigs", (properties.LaunchTemplateConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyFromCloudFormation)(properties.LaunchTemplateConfigs) : undefined));
  ret.addPropertyResult("onDemandOptions", "OnDemandOptions", (properties.OnDemandOptions != null ? CfnEC2FleetOnDemandOptionsRequestPropertyFromCloudFormation(properties.OnDemandOptions) : undefined));
  ret.addPropertyResult("replaceUnhealthyInstances", "ReplaceUnhealthyInstances", (properties.ReplaceUnhealthyInstances != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ReplaceUnhealthyInstances) : undefined));
  ret.addPropertyResult("spotOptions", "SpotOptions", (properties.SpotOptions != null ? CfnEC2FleetSpotOptionsRequestPropertyFromCloudFormation(properties.SpotOptions) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("targetCapacitySpecification", "TargetCapacitySpecification", (properties.TargetCapacitySpecification != null ? CfnEC2FleetTargetCapacitySpecificationRequestPropertyFromCloudFormation(properties.TargetCapacitySpecification) : undefined));
  ret.addPropertyResult("terminateInstancesWithExpiration", "TerminateInstancesWithExpiration", (properties.TerminateInstancesWithExpiration != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TerminateInstancesWithExpiration) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("validFrom", "ValidFrom", (properties.ValidFrom != null ? cfn_parse.FromCloudFormation.getString(properties.ValidFrom) : undefined));
  ret.addPropertyResult("validUntil", "ValidUntil", (properties.ValidUntil != null ? cfn_parse.FromCloudFormation.getString(properties.ValidUntil) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`OnDemandOptionsRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`OnDemandOptionsRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetOnDemandOptionsRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("context", cdk.validateString)(properties.context));
  errors.collect(cdk.propertyValidator("excessCapacityTerminationPolicy", cdk.validateString)(properties.excessCapacityTerminationPolicy));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.requiredValidator)(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.listValidator(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator))(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("onDemandOptions", CfnEC2FleetOnDemandOptionsRequestPropertyValidator)(properties.onDemandOptions));
  errors.collect(cdk.propertyValidator("replaceUnhealthyInstances", cdk.validateBoolean)(properties.replaceUnhealthyInstances));
  errors.collect(cdk.propertyValidator("spotOptions", CfnEC2FleetSpotOptionsRequestPropertyValidator)(properties.spotOptions));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnEC2FleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", cdk.requiredValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("terminateInstancesWithExpiration", cdk.validateBoolean)(properties.terminateInstancesWithExpiration));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("validFrom", cdk.validateString)(properties.validFrom));
  errors.collect(cdk.propertyValidator("validUntil", cdk.validateString)(properties.validUntil));
  return errors.wrap("supplied properties not correct for \\"OnDemandOptionsRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetOnDemandOptionsRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetOnDemandOptionsRequestPropertyValidator(properties).assertSuccess();
  return {
    "Context": cdk.stringToCloudFormation(properties.context),
    "ExcessCapacityTerminationPolicy": cdk.stringToCloudFormation(properties.excessCapacityTerminationPolicy),
    "LaunchTemplateConfigs": cdk.listMapper(convertCfnEC2FleetFleetLaunchTemplateConfigRequestPropertyToCloudFormation)(properties.launchTemplateConfigs),
    "OnDemandOptions": convertCfnEC2FleetOnDemandOptionsRequestPropertyToCloudFormation(properties.onDemandOptions),
    "ReplaceUnhealthyInstances": cdk.booleanToCloudFormation(properties.replaceUnhealthyInstances),
    "SpotOptions": convertCfnEC2FleetSpotOptionsRequestPropertyToCloudFormation(properties.spotOptions),
    "TagSpecifications": cdk.listMapper(convertCfnEC2FleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TargetCapacitySpecification": convertCfnEC2FleetTargetCapacitySpecificationRequestPropertyToCloudFormation(properties.targetCapacitySpecification),
    "TerminateInstancesWithExpiration": cdk.booleanToCloudFormation(properties.terminateInstancesWithExpiration),
    "Type": cdk.stringToCloudFormation(properties.type),
    "ValidFrom": cdk.stringToCloudFormation(properties.validFrom),
    "ValidUntil": cdk.stringToCloudFormation(properties.validUntil)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetOnDemandOptionsRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.OnDemandOptionsRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.OnDemandOptionsRequestProperty>();
  ret.addPropertyResult("context", "Context", (properties.Context != null ? cfn_parse.FromCloudFormation.getString(properties.Context) : undefined));
  ret.addPropertyResult("excessCapacityTerminationPolicy", "ExcessCapacityTerminationPolicy", (properties.ExcessCapacityTerminationPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.ExcessCapacityTerminationPolicy) : undefined));
  ret.addPropertyResult("launchTemplateConfigs", "LaunchTemplateConfigs", (properties.LaunchTemplateConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyFromCloudFormation)(properties.LaunchTemplateConfigs) : undefined));
  ret.addPropertyResult("onDemandOptions", "OnDemandOptions", (properties.OnDemandOptions != null ? CfnEC2FleetOnDemandOptionsRequestPropertyFromCloudFormation(properties.OnDemandOptions) : undefined));
  ret.addPropertyResult("replaceUnhealthyInstances", "ReplaceUnhealthyInstances", (properties.ReplaceUnhealthyInstances != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ReplaceUnhealthyInstances) : undefined));
  ret.addPropertyResult("spotOptions", "SpotOptions", (properties.SpotOptions != null ? CfnEC2FleetSpotOptionsRequestPropertyFromCloudFormation(properties.SpotOptions) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("targetCapacitySpecification", "TargetCapacitySpecification", (properties.TargetCapacitySpecification != null ? CfnEC2FleetTargetCapacitySpecificationRequestPropertyFromCloudFormation(properties.TargetCapacitySpecification) : undefined));
  ret.addPropertyResult("terminateInstancesWithExpiration", "TerminateInstancesWithExpiration", (properties.TerminateInstancesWithExpiration != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TerminateInstancesWithExpiration) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("validFrom", "ValidFrom", (properties.ValidFrom != null ? cfn_parse.FromCloudFormation.getString(properties.ValidFrom) : undefined));
  ret.addPropertyResult("validUntil", "ValidUntil", (properties.ValidUntil != null ? cfn_parse.FromCloudFormation.getString(properties.ValidUntil) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TargetCapacitySpecificationRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`TargetCapacitySpecificationRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("context", cdk.validateString)(properties.context));
  errors.collect(cdk.propertyValidator("excessCapacityTerminationPolicy", cdk.validateString)(properties.excessCapacityTerminationPolicy));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.requiredValidator)(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.listValidator(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator))(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("onDemandOptions", CfnEC2FleetOnDemandOptionsRequestPropertyValidator)(properties.onDemandOptions));
  errors.collect(cdk.propertyValidator("replaceUnhealthyInstances", cdk.validateBoolean)(properties.replaceUnhealthyInstances));
  errors.collect(cdk.propertyValidator("spotOptions", CfnEC2FleetSpotOptionsRequestPropertyValidator)(properties.spotOptions));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnEC2FleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", cdk.requiredValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("terminateInstancesWithExpiration", cdk.validateBoolean)(properties.terminateInstancesWithExpiration));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("validFrom", cdk.validateString)(properties.validFrom));
  errors.collect(cdk.propertyValidator("validUntil", cdk.validateString)(properties.validUntil));
  return errors.wrap("supplied properties not correct for \\"TargetCapacitySpecificationRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetTargetCapacitySpecificationRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator(properties).assertSuccess();
  return {
    "Context": cdk.stringToCloudFormation(properties.context),
    "ExcessCapacityTerminationPolicy": cdk.stringToCloudFormation(properties.excessCapacityTerminationPolicy),
    "LaunchTemplateConfigs": cdk.listMapper(convertCfnEC2FleetFleetLaunchTemplateConfigRequestPropertyToCloudFormation)(properties.launchTemplateConfigs),
    "OnDemandOptions": convertCfnEC2FleetOnDemandOptionsRequestPropertyToCloudFormation(properties.onDemandOptions),
    "ReplaceUnhealthyInstances": cdk.booleanToCloudFormation(properties.replaceUnhealthyInstances),
    "SpotOptions": convertCfnEC2FleetSpotOptionsRequestPropertyToCloudFormation(properties.spotOptions),
    "TagSpecifications": cdk.listMapper(convertCfnEC2FleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TargetCapacitySpecification": convertCfnEC2FleetTargetCapacitySpecificationRequestPropertyToCloudFormation(properties.targetCapacitySpecification),
    "TerminateInstancesWithExpiration": cdk.booleanToCloudFormation(properties.terminateInstancesWithExpiration),
    "Type": cdk.stringToCloudFormation(properties.type),
    "ValidFrom": cdk.stringToCloudFormation(properties.validFrom),
    "ValidUntil": cdk.stringToCloudFormation(properties.validUntil)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetTargetCapacitySpecificationRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEC2Fleet.TargetCapacitySpecificationRequestProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2Fleet.TargetCapacitySpecificationRequestProperty>();
  ret.addPropertyResult("context", "Context", (properties.Context != null ? cfn_parse.FromCloudFormation.getString(properties.Context) : undefined));
  ret.addPropertyResult("excessCapacityTerminationPolicy", "ExcessCapacityTerminationPolicy", (properties.ExcessCapacityTerminationPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.ExcessCapacityTerminationPolicy) : undefined));
  ret.addPropertyResult("launchTemplateConfigs", "LaunchTemplateConfigs", (properties.LaunchTemplateConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyFromCloudFormation)(properties.LaunchTemplateConfigs) : undefined));
  ret.addPropertyResult("onDemandOptions", "OnDemandOptions", (properties.OnDemandOptions != null ? CfnEC2FleetOnDemandOptionsRequestPropertyFromCloudFormation(properties.OnDemandOptions) : undefined));
  ret.addPropertyResult("replaceUnhealthyInstances", "ReplaceUnhealthyInstances", (properties.ReplaceUnhealthyInstances != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ReplaceUnhealthyInstances) : undefined));
  ret.addPropertyResult("spotOptions", "SpotOptions", (properties.SpotOptions != null ? CfnEC2FleetSpotOptionsRequestPropertyFromCloudFormation(properties.SpotOptions) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("targetCapacitySpecification", "TargetCapacitySpecification", (properties.TargetCapacitySpecification != null ? CfnEC2FleetTargetCapacitySpecificationRequestPropertyFromCloudFormation(properties.TargetCapacitySpecification) : undefined));
  ret.addPropertyResult("terminateInstancesWithExpiration", "TerminateInstancesWithExpiration", (properties.TerminateInstancesWithExpiration != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TerminateInstancesWithExpiration) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("validFrom", "ValidFrom", (properties.ValidFrom != null ? cfn_parse.FromCloudFormation.getString(properties.ValidFrom) : undefined));
  ret.addPropertyResult("validUntil", "ValidUntil", (properties.ValidUntil != null ? cfn_parse.FromCloudFormation.getString(properties.ValidUntil) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnEC2FleetProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnEC2FleetProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEC2FleetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("context", cdk.validateString)(properties.context));
  errors.collect(cdk.propertyValidator("excessCapacityTerminationPolicy", cdk.validateString)(properties.excessCapacityTerminationPolicy));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.requiredValidator)(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("launchTemplateConfigs", cdk.listValidator(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyValidator))(properties.launchTemplateConfigs));
  errors.collect(cdk.propertyValidator("onDemandOptions", CfnEC2FleetOnDemandOptionsRequestPropertyValidator)(properties.onDemandOptions));
  errors.collect(cdk.propertyValidator("replaceUnhealthyInstances", cdk.validateBoolean)(properties.replaceUnhealthyInstances));
  errors.collect(cdk.propertyValidator("spotOptions", CfnEC2FleetSpotOptionsRequestPropertyValidator)(properties.spotOptions));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnEC2FleetTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", cdk.requiredValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("targetCapacitySpecification", CfnEC2FleetTargetCapacitySpecificationRequestPropertyValidator)(properties.targetCapacitySpecification));
  errors.collect(cdk.propertyValidator("terminateInstancesWithExpiration", cdk.validateBoolean)(properties.terminateInstancesWithExpiration));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("validFrom", cdk.validateString)(properties.validFrom));
  errors.collect(cdk.propertyValidator("validUntil", cdk.validateString)(properties.validUntil));
  return errors.wrap("supplied properties not correct for \\"CfnEC2FleetProps\\"");
}

// @ts-ignore TS6133
function convertCfnEC2FleetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEC2FleetPropsValidator(properties).assertSuccess();
  return {
    "Context": cdk.stringToCloudFormation(properties.context),
    "ExcessCapacityTerminationPolicy": cdk.stringToCloudFormation(properties.excessCapacityTerminationPolicy),
    "LaunchTemplateConfigs": cdk.listMapper(convertCfnEC2FleetFleetLaunchTemplateConfigRequestPropertyToCloudFormation)(properties.launchTemplateConfigs),
    "OnDemandOptions": convertCfnEC2FleetOnDemandOptionsRequestPropertyToCloudFormation(properties.onDemandOptions),
    "ReplaceUnhealthyInstances": cdk.booleanToCloudFormation(properties.replaceUnhealthyInstances),
    "SpotOptions": convertCfnEC2FleetSpotOptionsRequestPropertyToCloudFormation(properties.spotOptions),
    "TagSpecifications": cdk.listMapper(convertCfnEC2FleetTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "TargetCapacitySpecification": convertCfnEC2FleetTargetCapacitySpecificationRequestPropertyToCloudFormation(properties.targetCapacitySpecification),
    "TerminateInstancesWithExpiration": cdk.booleanToCloudFormation(properties.terminateInstancesWithExpiration),
    "Type": cdk.stringToCloudFormation(properties.type),
    "ValidFrom": cdk.stringToCloudFormation(properties.validFrom),
    "ValidUntil": cdk.stringToCloudFormation(properties.validUntil)
  };
}

// @ts-ignore TS6133
function CfnEC2FleetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEC2FleetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEC2FleetProps>();
  ret.addPropertyResult("context", "Context", (properties.Context != null ? cfn_parse.FromCloudFormation.getString(properties.Context) : undefined));
  ret.addPropertyResult("excessCapacityTerminationPolicy", "ExcessCapacityTerminationPolicy", (properties.ExcessCapacityTerminationPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.ExcessCapacityTerminationPolicy) : undefined));
  ret.addPropertyResult("launchTemplateConfigs", "LaunchTemplateConfigs", (properties.LaunchTemplateConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetFleetLaunchTemplateConfigRequestPropertyFromCloudFormation)(properties.LaunchTemplateConfigs) : undefined));
  ret.addPropertyResult("onDemandOptions", "OnDemandOptions", (properties.OnDemandOptions != null ? CfnEC2FleetOnDemandOptionsRequestPropertyFromCloudFormation(properties.OnDemandOptions) : undefined));
  ret.addPropertyResult("replaceUnhealthyInstances", "ReplaceUnhealthyInstances", (properties.ReplaceUnhealthyInstances != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ReplaceUnhealthyInstances) : undefined));
  ret.addPropertyResult("spotOptions", "SpotOptions", (properties.SpotOptions != null ? CfnEC2FleetSpotOptionsRequestPropertyFromCloudFormation(properties.SpotOptions) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnEC2FleetTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("targetCapacitySpecification", "TargetCapacitySpecification", (properties.TargetCapacitySpecification != null ? CfnEC2FleetTargetCapacitySpecificationRequestPropertyFromCloudFormation(properties.TargetCapacitySpecification) : undefined));
  ret.addPropertyResult("terminateInstancesWithExpiration", "TerminateInstancesWithExpiration", (properties.TerminateInstancesWithExpiration != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TerminateInstancesWithExpiration) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("validFrom", "ValidFrom", (properties.ValidFrom != null ? cfn_parse.FromCloudFormation.getString(properties.ValidFrom) : undefined));
  ret.addPropertyResult("validUntil", "ValidUntil", (properties.ValidUntil != null ? cfn_parse.FromCloudFormation.getString(properties.ValidUntil) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * [IPv6 only] Specifies an egress-only internet gateway for your VPC.
 *
 * An egress-only internet gateway is used to enable outbound communication over IPv6 from instances in your VPC to the internet, and prevents hosts outside of your VPC from initiating an IPv6 connection with your instance.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html
 */
export class CfnEgressOnlyInternetGateway extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EgressOnlyInternetGateway";

  /**
   * Build a CfnEgressOnlyInternetGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEgressOnlyInternetGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEgressOnlyInternetGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEgressOnlyInternetGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the egress-only internet gateway.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the VPC for which to create the egress-only internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html#cfn-ec2-egressonlyinternetgateway-vpcid
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEgressOnlyInternetGatewayProps) {
    super(scope, id, {
      "type": CfnEgressOnlyInternetGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEgressOnlyInternetGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEgressOnlyInternetGatewayPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnEgressOnlyInternetGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html
 */
export interface CfnEgressOnlyInternetGatewayProps {
  /**
   * The ID of the VPC for which to create the egress-only internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html#cfn-ec2-egressonlyinternetgateway-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnEgressOnlyInternetGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnEgressOnlyInternetGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEgressOnlyInternetGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnEgressOnlyInternetGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnEgressOnlyInternetGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEgressOnlyInternetGatewayPropsValidator(properties).assertSuccess();
  return {
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnEgressOnlyInternetGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEgressOnlyInternetGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEgressOnlyInternetGatewayProps>();
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an Elastic IP (EIP) address and can, optionally, associate it with an Amazon EC2 instance.
 *
 * You can allocate an Elastic IP address from an address pool owned by AWS or from an address pool created from a public IPv4 address range that you have brought to AWS for use with your AWS resources using bring your own IP addresses (BYOIP). For more information, see [Bring Your Own IP Addresses (BYOIP)](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html) in the *Amazon EC2 User Guide* .
 *
 * For more information, see [Elastic IP Addresses](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html) in the *Amazon EC2 User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html
 */
export class CfnEIP extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EIP";

  /**
   * Build a CfnEIP from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEIP {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEIPPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEIP(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID that AWS assigns to represent the allocation of the address for use with Amazon VPC. This is returned only for VPC elastic IP addresses. For example, \`eipalloc-5723d13e\` .
   *
   * @cloudformationAttribute AllocationId
   */
  public readonly attrAllocationId: string;

  /**
   * The Elastic IP address.
   *
   * @cloudformationAttribute PublicIp
   */
  public readonly attrPublicIp: string;

  /**
   * The network ( \`vpc\` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-domain
   */
  public domain?: string;

  /**
   * The ID of the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-instanceid
   */
  public instanceId?: string;

  /**
   * A unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises IP addresses.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-networkbordergroup
   */
  public networkBorderGroup?: string;

  /**
   * The ID of an address pool that you own.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-publicipv4pool
   */
  public publicIpv4Pool?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the Elastic IP address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The Elastic IP address you are accepting for transfer.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-transferaddress
   */
  public transferAddress?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEIPProps = {}) {
    super(scope, id, {
      "type": CfnEIP.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrAllocationId = cdk.Token.asString(this.getAtt("AllocationId", cdk.ResolutionTypeHint.STRING));
    this.attrPublicIp = cdk.Token.asString(this.getAtt("PublicIp", cdk.ResolutionTypeHint.STRING));
    this.domain = props.domain;
    this.instanceId = props.instanceId;
    this.networkBorderGroup = props.networkBorderGroup;
    this.publicIpv4Pool = props.publicIpv4Pool;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::EIP", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transferAddress = props.transferAddress;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "domain": this.domain,
      "instanceId": this.instanceId,
      "networkBorderGroup": this.networkBorderGroup,
      "publicIpv4Pool": this.publicIpv4Pool,
      "tags": this.tags.renderTags(),
      "transferAddress": this.transferAddress
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEIP.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEIPPropsToCloudFormation(props);
  }
}

export namespace CfnEIP {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-tag.html
   */
  export interface TagProperty {
    /**
     * The network ( \`vpc\` ).
     *
     * If you define an Elastic IP address and associate it with a VPC that is defined in the same template, you must declare a dependency on the VPC-gateway attachment by using the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) on this resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-tag.html#cfn-ec2-eip-tag-domain
     */
    readonly domain?: string;

    /**
     * The ID of the instance.
     *
     * > Updates to the \`InstanceId\` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-tag.html#cfn-ec2-eip-tag-instanceid
     */
    readonly instanceId?: string;

    /**
     * A unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises IP addresses.
     *
     * Use this parameter to limit the IP address to this location. IP addresses cannot move between network border groups.
     *
     * Use [DescribeAvailabilityZones](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html) to view the network border groups.
     *
     * You cannot use a network border group with EC2 Classic. If you attempt this operation on EC2 Classic, you receive an \`InvalidParameterCombination\` error.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-tag.html#cfn-ec2-eip-tag-networkbordergroup
     */
    readonly networkBorderGroup?: string;

    /**
     * The ID of an address pool that you own.
     *
     * Use this parameter to let Amazon EC2 select an address from the address pool.
     *
     * > Updates to the \`PublicIpv4Pool\` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-tag.html#cfn-ec2-eip-tag-publicipv4pool
     */
    readonly publicIpv4Pool?: string;

    /**
     * Any tags assigned to the Elastic IP address.
     *
     * > Updates to the \`Tags\` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-tag.html#cfn-ec2-eip-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnEIP.TagProperty> | cdk.IResolvable;

    /**
     * The Elastic IP address you are accepting for transfer.
     *
     * You can only accept one transferred address. For more information on Elastic IP address transfers, see [Transfer Elastic IP addresses](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#transfer-EIPs-intro) in the *Amazon Virtual Private Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-tag.html#cfn-ec2-eip-tag-transferaddress
     */
    readonly transferAddress?: string;
  }
}

/**
 * Properties for defining a \`CfnEIP\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html
 */
export interface CfnEIPProps {
  /**
   * The network ( \`vpc\` ).
   *
   * If you define an Elastic IP address and associate it with a VPC that is defined in the same template, you must declare a dependency on the VPC-gateway attachment by using the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) on this resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-domain
   */
  readonly domain?: string;

  /**
   * The ID of the instance.
   *
   * > Updates to the \`InstanceId\` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-instanceid
   */
  readonly instanceId?: string;

  /**
   * A unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises IP addresses.
   *
   * Use this parameter to limit the IP address to this location. IP addresses cannot move between network border groups.
   *
   * Use [DescribeAvailabilityZones](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html) to view the network border groups.
   *
   * You cannot use a network border group with EC2 Classic. If you attempt this operation on EC2 Classic, you receive an \`InvalidParameterCombination\` error.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-networkbordergroup
   */
  readonly networkBorderGroup?: string;

  /**
   * The ID of an address pool that you own.
   *
   * Use this parameter to let Amazon EC2 select an address from the address pool.
   *
   * > Updates to the \`PublicIpv4Pool\` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-publicipv4pool
   */
  readonly publicIpv4Pool?: string;

  /**
   * Any tags assigned to the Elastic IP address.
   *
   * > Updates to the \`Tags\` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The Elastic IP address you are accepting for transfer.
   *
   * You can only accept one transferred address. For more information on Elastic IP address transfers, see [Transfer Elastic IP addresses](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#transfer-EIPs-intro) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-transferaddress
   */
  readonly transferAddress?: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEIPTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("domain", cdk.validateString)(properties.domain));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("networkBorderGroup", cdk.validateString)(properties.networkBorderGroup));
  errors.collect(cdk.propertyValidator("publicIpv4Pool", cdk.validateString)(properties.publicIpv4Pool));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnEIPTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("transferAddress", cdk.validateString)(properties.transferAddress));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnEIPTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEIPTagPropertyValidator(properties).assertSuccess();
  return {
    "Domain": cdk.stringToCloudFormation(properties.domain),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "NetworkBorderGroup": cdk.stringToCloudFormation(properties.networkBorderGroup),
    "PublicIpv4Pool": cdk.stringToCloudFormation(properties.publicIpv4Pool),
    "Tags": cdk.listMapper(convertCfnEIPTagPropertyToCloudFormation)(properties.tags),
    "TransferAddress": cdk.stringToCloudFormation(properties.transferAddress)
  };
}

// @ts-ignore TS6133
function CfnEIPTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnEIP.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEIP.TagProperty>();
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? cfn_parse.FromCloudFormation.getString(properties.Domain) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("networkBorderGroup", "NetworkBorderGroup", (properties.NetworkBorderGroup != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkBorderGroup) : undefined));
  ret.addPropertyResult("publicIpv4Pool", "PublicIpv4Pool", (properties.PublicIpv4Pool != null ? cfn_parse.FromCloudFormation.getString(properties.PublicIpv4Pool) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnEIPTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("transferAddress", "TransferAddress", (properties.TransferAddress != null ? cfn_parse.FromCloudFormation.getString(properties.TransferAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnEIPProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnEIPProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEIPPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("domain", cdk.validateString)(properties.domain));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("networkBorderGroup", cdk.validateString)(properties.networkBorderGroup));
  errors.collect(cdk.propertyValidator("publicIpv4Pool", cdk.validateString)(properties.publicIpv4Pool));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transferAddress", cdk.validateString)(properties.transferAddress));
  return errors.wrap("supplied properties not correct for \\"CfnEIPProps\\"");
}

// @ts-ignore TS6133
function convertCfnEIPPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEIPPropsValidator(properties).assertSuccess();
  return {
    "Domain": cdk.stringToCloudFormation(properties.domain),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "NetworkBorderGroup": cdk.stringToCloudFormation(properties.networkBorderGroup),
    "PublicIpv4Pool": cdk.stringToCloudFormation(properties.publicIpv4Pool),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransferAddress": cdk.stringToCloudFormation(properties.transferAddress)
  };
}

// @ts-ignore TS6133
function CfnEIPPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEIPProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEIPProps>();
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? cfn_parse.FromCloudFormation.getString(properties.Domain) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("networkBorderGroup", "NetworkBorderGroup", (properties.NetworkBorderGroup != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkBorderGroup) : undefined));
  ret.addPropertyResult("publicIpv4Pool", "PublicIpv4Pool", (properties.PublicIpv4Pool != null ? cfn_parse.FromCloudFormation.getString(properties.PublicIpv4Pool) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transferAddress", "TransferAddress", (properties.TransferAddress != null ? cfn_parse.FromCloudFormation.getString(properties.TransferAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates an Elastic IP address with an instance or a network interface.
 *
 * Before you can use an Elastic IP address, you must allocate it to your account. For more information about working with Elastic IP addresses, see [Elastic IP address concepts and rules](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#vpc-eip-overview) .
 *
 * You must specify \`AllocationId\` and either \`InstanceId\` , \`NetworkInterfaceId\` , or \`PrivateIpAddress\` .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html
 */
export class CfnEIPAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EIPAssociation";

  /**
   * Build a CfnEIPAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEIPAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEIPAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEIPAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The allocation ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-allocationid
   */
  public allocationId?: string;

  /**
   * Deprecated.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-eip
   */
  public eip?: string;

  /**
   * The ID of the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-instanceid
   */
  public instanceId?: string;

  /**
   * The ID of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-networkinterfaceid
   */
  public networkInterfaceId?: string;

  /**
   * The primary or secondary private IP address to associate with the Elastic IP address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-privateipaddress
   */
  public privateIpAddress?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEIPAssociationProps = {}) {
    super(scope, id, {
      "type": CfnEIPAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.allocationId = props.allocationId;
    this.eip = props.eip;
    this.instanceId = props.instanceId;
    this.networkInterfaceId = props.networkInterfaceId;
    this.privateIpAddress = props.privateIpAddress;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allocationId": this.allocationId,
      "eip": this.eip,
      "instanceId": this.instanceId,
      "networkInterfaceId": this.networkInterfaceId,
      "privateIpAddress": this.privateIpAddress
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEIPAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEIPAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnEIPAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html
 */
export interface CfnEIPAssociationProps {
  /**
   * The allocation ID.
   *
   * This is required.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-allocationid
   */
  readonly allocationId?: string;

  /**
   * Deprecated.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-eip
   */
  readonly eip?: string;

  /**
   * The ID of the instance.
   *
   * The instance must have exactly one attached network interface. You can specify either the instance ID or the network interface ID, but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-instanceid
   */
  readonly instanceId?: string;

  /**
   * The ID of the network interface.
   *
   * If the instance has more than one network interface, you must specify a network interface ID.
   *
   * You can specify either the instance ID or the network interface ID, but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-networkinterfaceid
   */
  readonly networkInterfaceId?: string;

  /**
   * The primary or secondary private IP address to associate with the Elastic IP address.
   *
   * If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-privateipaddress
   */
  readonly privateIpAddress?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnEIPAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnEIPAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEIPAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationId", cdk.validateString)(properties.allocationId));
  errors.collect(cdk.propertyValidator("eip", cdk.validateString)(properties.eip));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  return errors.wrap("supplied properties not correct for \\"CfnEIPAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnEIPAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEIPAssociationPropsValidator(properties).assertSuccess();
  return {
    "AllocationId": cdk.stringToCloudFormation(properties.allocationId),
    "EIP": cdk.stringToCloudFormation(properties.eip),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress)
  };
}

// @ts-ignore TS6133
function CfnEIPAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEIPAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEIPAssociationProps>();
  ret.addPropertyResult("allocationId", "AllocationId", (properties.AllocationId != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationId) : undefined));
  ret.addPropertyResult("eip", "EIP", (properties.EIP != null ? cfn_parse.FromCloudFormation.getString(properties.EIP) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates an AWS Identity and Access Management (IAM) role with an AWS Certificate Manager (ACM) certificate.
 *
 * This enables the certificate to be used by the ACM for Nitro Enclaves application inside an enclave. For more information, see [AWS Certificate Manager for Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave-refapp.html) in the *AWS Nitro Enclaves User Guide* .
 *
 * When the IAM role is associated with the ACM certificate, the certificate, certificate chain, and encrypted private key are placed in an Amazon S3 location that only the associated IAM role can access. The private key of the certificate is encrypted with an AWS managed key that has an attached attestation-based key policy.
 *
 * To enable the IAM role to access the Amazon S3 object, you must grant it permission to call \`s3:GetObject\` on the Amazon S3 bucket returned by the command. To enable the IAM role to access the KMS key, you must grant it permission to call \`kms:Decrypt\` on the KMS key returned by the command. For more information, see [Grant the role permission to access the certificate and encryption key](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave-refapp.html#add-policy) in the *AWS Nitro Enclaves User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html
 */
export class CfnEnclaveCertificateIamRoleAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::EnclaveCertificateIamRoleAssociation";

  /**
   * Build a CfnEnclaveCertificateIamRoleAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEnclaveCertificateIamRoleAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnEnclaveCertificateIamRoleAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnEnclaveCertificateIamRoleAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The name of the Amazon S3 bucket to which the certificate was uploaded.
   *
   * @cloudformationAttribute CertificateS3BucketName
   */
  public readonly attrCertificateS3BucketName: string;

  /**
   * The Amazon S3 object key where the certificate, certificate chain, and encrypted private key bundle are stored. The object key is formatted as follows: \`role_arn\` / \`certificate_arn\` .
   *
   * @cloudformationAttribute CertificateS3ObjectKey
   */
  public readonly attrCertificateS3ObjectKey: string;

  /**
   * The ID of the AWS KMS key used to encrypt the private key of the certificate.
   *
   * @cloudformationAttribute EncryptionKmsKeyId
   */
  public readonly attrEncryptionKmsKeyId: string;

  /**
   * The ARN of the ACM certificate with which to associate the IAM role.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-certificatearn
   */
  public certificateArn: string;

  /**
   * The ARN of the IAM role to associate with the ACM certificate.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-rolearn
   */
  public roleArn: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnEnclaveCertificateIamRoleAssociationProps) {
    super(scope, id, {
      "type": CfnEnclaveCertificateIamRoleAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "certificateArn", this);
    cdk.requireProperty(props, "roleArn", this);

    this.attrCertificateS3BucketName = cdk.Token.asString(this.getAtt("CertificateS3BucketName", cdk.ResolutionTypeHint.STRING));
    this.attrCertificateS3ObjectKey = cdk.Token.asString(this.getAtt("CertificateS3ObjectKey", cdk.ResolutionTypeHint.STRING));
    this.attrEncryptionKmsKeyId = cdk.Token.asString(this.getAtt("EncryptionKmsKeyId", cdk.ResolutionTypeHint.STRING));
    this.certificateArn = props.certificateArn;
    this.roleArn = props.roleArn;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "certificateArn": this.certificateArn,
      "roleArn": this.roleArn
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnEnclaveCertificateIamRoleAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnEnclaveCertificateIamRoleAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnEnclaveCertificateIamRoleAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html
 */
export interface CfnEnclaveCertificateIamRoleAssociationProps {
  /**
   * The ARN of the ACM certificate with which to associate the IAM role.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-certificatearn
   */
  readonly certificateArn: string;

  /**
   * The ARN of the IAM role to associate with the ACM certificate.
   *
   * You can associate up to 16 IAM roles with an ACM certificate.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-rolearn
   */
  readonly roleArn: string;
}

/**
 * Determine whether the given properties match those of a \`CfnEnclaveCertificateIamRoleAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnEnclaveCertificateIamRoleAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnEnclaveCertificateIamRoleAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("certificateArn", cdk.requiredValidator)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("certificateArn", cdk.validateString)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("roleArn", cdk.requiredValidator)(properties.roleArn));
  errors.collect(cdk.propertyValidator("roleArn", cdk.validateString)(properties.roleArn));
  return errors.wrap("supplied properties not correct for \\"CfnEnclaveCertificateIamRoleAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnEnclaveCertificateIamRoleAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnEnclaveCertificateIamRoleAssociationPropsValidator(properties).assertSuccess();
  return {
    "CertificateArn": cdk.stringToCloudFormation(properties.certificateArn),
    "RoleArn": cdk.stringToCloudFormation(properties.roleArn)
  };
}

// @ts-ignore TS6133
function CfnEnclaveCertificateIamRoleAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnEnclaveCertificateIamRoleAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnEnclaveCertificateIamRoleAssociationProps>();
  ret.addPropertyResult("certificateArn", "CertificateArn", (properties.CertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.CertificateArn) : undefined));
  ret.addPropertyResult("roleArn", "RoleArn", (properties.RoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.RoleArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a VPC flow log that captures IP traffic for a specified network interface, subnet, or VPC.
 *
 * To view the log data, use Amazon CloudWatch Logs (CloudWatch Logs) to help troubleshoot connection issues. For example, you can use a flow log to investigate why certain traffic isn't reaching an instance, which can help you diagnose overly restrictive security group rules. For more information, see [VPC Flow Logs](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html) in the *Amazon VPC User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html
 */
export class CfnFlowLog extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::FlowLog";

  /**
   * Build a CfnFlowLog from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnFlowLog {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnFlowLogPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnFlowLog(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the flow log. For example, \`fl-123456abc123abc1\` .
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ARN of the IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-deliverlogspermissionarn
   */
  public deliverLogsPermissionArn?: string;

  /**
   * The destination options. The following options are supported:.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-destinationoptions
   */
  public destinationOptions?: any | cdk.IResolvable;

  /**
   * The destination for the flow log data. The meaning of this parameter depends on the destination type.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination
   */
  public logDestination?: string;

  /**
   * The type of destination for the flow log data.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype
   */
  public logDestinationType?: string;

  /**
   * The fields to include in the flow log record, in the order in which they should appear.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logformat
   */
  public logFormat?: string;

  /**
   * The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-loggroupname
   */
  public logGroupName?: string;

  /**
   * The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-maxaggregationinterval
   */
  public maxAggregationInterval?: number;

  /**
   * The ID of the resource to monitor.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourceid
   */
  public resourceId: string;

  /**
   * The type of resource to monitor.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourcetype
   */
  public resourceType: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply to the flow logs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-traffictype
   */
  public trafficType?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnFlowLogProps) {
    super(scope, id, {
      "type": CfnFlowLog.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "resourceId", this);
    cdk.requireProperty(props, "resourceType", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.deliverLogsPermissionArn = props.deliverLogsPermissionArn;
    this.destinationOptions = props.destinationOptions;
    this.logDestination = props.logDestination;
    this.logDestinationType = props.logDestinationType;
    this.logFormat = props.logFormat;
    this.logGroupName = props.logGroupName;
    this.maxAggregationInterval = props.maxAggregationInterval;
    this.resourceId = props.resourceId;
    this.resourceType = props.resourceType;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::FlowLog", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.trafficType = props.trafficType;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "deliverLogsPermissionArn": this.deliverLogsPermissionArn,
      "destinationOptions": this.destinationOptions,
      "logDestination": this.logDestination,
      "logDestinationType": this.logDestinationType,
      "logFormat": this.logFormat,
      "logGroupName": this.logGroupName,
      "maxAggregationInterval": this.maxAggregationInterval,
      "resourceId": this.resourceId,
      "resourceType": this.resourceType,
      "tags": this.tags.renderTags(),
      "trafficType": this.trafficType
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnFlowLog.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnFlowLogPropsToCloudFormation(props);
  }
}

export namespace CfnFlowLog {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-tag.html
   */
  export interface TagProperty {
    /**
     * The ARN of the IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account.
     *
     * This parameter is required if the destination type is \`cloud-watch-logs\` and unsupported otherwise.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-tag.html#cfn-ec2-flowlog-tag-deliverlogspermissionarn
     */
    readonly deliverLogsPermissionArn?: string;

    /**
     * The destination options. The following options are supported:.
     *
     * - \`FileFormat\` - The format for the flow log ( \`plain-text\` | \`parquet\` ). The default is \`plain-text\` .
     * - \`HiveCompatiblePartitions\` - Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3 ( \`true\` | \`false\` ). The default is \`false\` .
     * - \`PerHourPartition\` - Indicates whether to partition the flow log per hour ( \`true\` | \`false\` ). The default is \`false\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-tag.html#cfn-ec2-flowlog-tag-destinationoptions
     */
    readonly destinationOptions?: any | cdk.IResolvable;

    /**
     * The destination for the flow log data. The meaning of this parameter depends on the destination type.
     *
     * - If the destination type is \`cloud-watch-logs\` , specify the ARN of a CloudWatch Logs log group. For example:
     *
     * arn:aws:logs: *region* : *account_id* :log-group: *my_group*
     *
     * Alternatively, use the \`LogGroupName\` parameter.
     * - If the destination type is \`s3\` , specify the ARN of an S3 bucket. For example:
     *
     * arn:aws:s3::: *my_bucket* / *my_subfolder* /
     *
     * The subfolder is optional. Note that you can't use \`AWSLogs\` as a subfolder name.
     * - If the destination type is \`kinesis-data-firehose\` , specify the ARN of a Kinesis Data Firehose delivery stream. For example:
     *
     * arn:aws:firehose: *region* : *account_id* :deliverystream: *my_stream*
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-tag.html#cfn-ec2-flowlog-tag-logdestination
     */
    readonly logDestination?: string;

    /**
     * The type of destination for the flow log data.
     *
     * Default: \`cloud-watch-logs\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-tag.html#cfn-ec2-flowlog-tag-logdestinationtype
     */
    readonly logDestinationType?: string;

    /**
     * The fields to include in the flow log record, in the order in which they should appear.
     *
     * If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must include at least one field. For more information about the available fields, see [Flow log records](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records) in the *Amazon VPC User Guide* or [Transit Gateway Flow Log records](https://docs.aws.amazon.com/vpc/latest/tgw/tgw-flow-logs.html#flow-log-records) in the *AWS Transit Gateway Guide* .
     *
     * Specify the fields using the \`\${field-id}\` format, separated by spaces.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-tag.html#cfn-ec2-flowlog-tag-logformat
     */
    readonly logFormat?: string;

    /**
     * The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs.
     *
     * This parameter is valid only if the destination type is \`cloud-watch-logs\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-tag.html#cfn-ec2-flowlog-tag-loggroupname
     */
    readonly logGroupName?: string;

    /**
     * The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
     *
     * The possible values are 60 seconds (1 minute) or 600 seconds (10 minutes). This parameter must be 60 seconds for transit gateway resource types.
     *
     * When a network interface is attached to a [Nitro-based instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) , the aggregation interval is always 60 seconds or less, regardless of the value that you specify.
     *
     * Default: 600
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-tag.html#cfn-ec2-flowlog-tag-maxaggregationinterval
     */
    readonly maxAggregationInterval?: number;

    /**
     * The ID of the resource to monitor.
     *
     * For example, if the resource type is \`VPC\` , specify the ID of the VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-tag.html#cfn-ec2-flowlog-tag-resourceid
     */
    readonly resourceId: string;

    /**
     * The type of resource to monitor.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-tag.html#cfn-ec2-flowlog-tag-resourcetype
     */
    readonly resourceType: string;

    /**
     * The tags to apply to the flow logs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-tag.html#cfn-ec2-flowlog-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnFlowLog.TagProperty> | cdk.IResolvable;

    /**
     * The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
     *
     * This parameter is not supported for transit gateway resource types. It is required for the other resource types.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-tag.html#cfn-ec2-flowlog-tag-traffictype
     */
    readonly trafficType?: string;
  }
}

/**
 * Properties for defining a \`CfnFlowLog\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html
 */
export interface CfnFlowLogProps {
  /**
   * The ARN of the IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account.
   *
   * This parameter is required if the destination type is \`cloud-watch-logs\` and unsupported otherwise.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-deliverlogspermissionarn
   */
  readonly deliverLogsPermissionArn?: string;

  /**
   * The destination options. The following options are supported:.
   *
   * - \`FileFormat\` - The format for the flow log ( \`plain-text\` | \`parquet\` ). The default is \`plain-text\` .
   * - \`HiveCompatiblePartitions\` - Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3 ( \`true\` | \`false\` ). The default is \`false\` .
   * - \`PerHourPartition\` - Indicates whether to partition the flow log per hour ( \`true\` | \`false\` ). The default is \`false\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-destinationoptions
   */
  readonly destinationOptions?: any | cdk.IResolvable;

  /**
   * The destination for the flow log data. The meaning of this parameter depends on the destination type.
   *
   * - If the destination type is \`cloud-watch-logs\` , specify the ARN of a CloudWatch Logs log group. For example:
   *
   * arn:aws:logs: *region* : *account_id* :log-group: *my_group*
   *
   * Alternatively, use the \`LogGroupName\` parameter.
   * - If the destination type is \`s3\` , specify the ARN of an S3 bucket. For example:
   *
   * arn:aws:s3::: *my_bucket* / *my_subfolder* /
   *
   * The subfolder is optional. Note that you can't use \`AWSLogs\` as a subfolder name.
   * - If the destination type is \`kinesis-data-firehose\` , specify the ARN of a Kinesis Data Firehose delivery stream. For example:
   *
   * arn:aws:firehose: *region* : *account_id* :deliverystream: *my_stream*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination
   */
  readonly logDestination?: string;

  /**
   * The type of destination for the flow log data.
   *
   * Default: \`cloud-watch-logs\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype
   */
  readonly logDestinationType?: string;

  /**
   * The fields to include in the flow log record, in the order in which they should appear.
   *
   * If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must include at least one field. For more information about the available fields, see [Flow log records](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records) in the *Amazon VPC User Guide* or [Transit Gateway Flow Log records](https://docs.aws.amazon.com/vpc/latest/tgw/tgw-flow-logs.html#flow-log-records) in the *AWS Transit Gateway Guide* .
   *
   * Specify the fields using the \`\${field-id}\` format, separated by spaces.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logformat
   */
  readonly logFormat?: string;

  /**
   * The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs.
   *
   * This parameter is valid only if the destination type is \`cloud-watch-logs\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-loggroupname
   */
  readonly logGroupName?: string;

  /**
   * The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
   *
   * The possible values are 60 seconds (1 minute) or 600 seconds (10 minutes). This parameter must be 60 seconds for transit gateway resource types.
   *
   * When a network interface is attached to a [Nitro-based instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) , the aggregation interval is always 60 seconds or less, regardless of the value that you specify.
   *
   * Default: 600
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-maxaggregationinterval
   */
  readonly maxAggregationInterval?: number;

  /**
   * The ID of the resource to monitor.
   *
   * For example, if the resource type is \`VPC\` , specify the ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourceid
   */
  readonly resourceId: string;

  /**
   * The type of resource to monitor.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourcetype
   */
  readonly resourceType: string;

  /**
   * The tags to apply to the flow logs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
   *
   * This parameter is not supported for transit gateway resource types. It is required for the other resource types.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-traffictype
   */
  readonly trafficType?: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFlowLogTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deliverLogsPermissionArn", cdk.validateString)(properties.deliverLogsPermissionArn));
  errors.collect(cdk.propertyValidator("destinationOptions", cdk.validateObject)(properties.destinationOptions));
  errors.collect(cdk.propertyValidator("logDestination", cdk.validateString)(properties.logDestination));
  errors.collect(cdk.propertyValidator("logDestinationType", cdk.validateString)(properties.logDestinationType));
  errors.collect(cdk.propertyValidator("logFormat", cdk.validateString)(properties.logFormat));
  errors.collect(cdk.propertyValidator("logGroupName", cdk.validateString)(properties.logGroupName));
  errors.collect(cdk.propertyValidator("maxAggregationInterval", cdk.validateNumber)(properties.maxAggregationInterval));
  errors.collect(cdk.propertyValidator("resourceId", cdk.requiredValidator)(properties.resourceId));
  errors.collect(cdk.propertyValidator("resourceId", cdk.validateString)(properties.resourceId));
  errors.collect(cdk.propertyValidator("resourceType", cdk.requiredValidator)(properties.resourceType));
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnFlowLogTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("trafficType", cdk.validateString)(properties.trafficType));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFlowLogTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFlowLogTagPropertyValidator(properties).assertSuccess();
  return {
    "DeliverLogsPermissionArn": cdk.stringToCloudFormation(properties.deliverLogsPermissionArn),
    "DestinationOptions": cdk.objectToCloudFormation(properties.destinationOptions),
    "LogDestination": cdk.stringToCloudFormation(properties.logDestination),
    "LogDestinationType": cdk.stringToCloudFormation(properties.logDestinationType),
    "LogFormat": cdk.stringToCloudFormation(properties.logFormat),
    "LogGroupName": cdk.stringToCloudFormation(properties.logGroupName),
    "MaxAggregationInterval": cdk.numberToCloudFormation(properties.maxAggregationInterval),
    "ResourceId": cdk.stringToCloudFormation(properties.resourceId),
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(convertCfnFlowLogTagPropertyToCloudFormation)(properties.tags),
    "TrafficType": cdk.stringToCloudFormation(properties.trafficType)
  };
}

// @ts-ignore TS6133
function CfnFlowLogTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFlowLog.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFlowLog.TagProperty>();
  ret.addPropertyResult("deliverLogsPermissionArn", "DeliverLogsPermissionArn", (properties.DeliverLogsPermissionArn != null ? cfn_parse.FromCloudFormation.getString(properties.DeliverLogsPermissionArn) : undefined));
  ret.addPropertyResult("destinationOptions", "DestinationOptions", (properties.DestinationOptions != null ? cfn_parse.FromCloudFormation.getAny(properties.DestinationOptions) : undefined));
  ret.addPropertyResult("logDestination", "LogDestination", (properties.LogDestination != null ? cfn_parse.FromCloudFormation.getString(properties.LogDestination) : undefined));
  ret.addPropertyResult("logDestinationType", "LogDestinationType", (properties.LogDestinationType != null ? cfn_parse.FromCloudFormation.getString(properties.LogDestinationType) : undefined));
  ret.addPropertyResult("logFormat", "LogFormat", (properties.LogFormat != null ? cfn_parse.FromCloudFormation.getString(properties.LogFormat) : undefined));
  ret.addPropertyResult("logGroupName", "LogGroupName", (properties.LogGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.LogGroupName) : undefined));
  ret.addPropertyResult("maxAggregationInterval", "MaxAggregationInterval", (properties.MaxAggregationInterval != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxAggregationInterval) : undefined));
  ret.addPropertyResult("resourceId", "ResourceId", (properties.ResourceId != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceId) : undefined));
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnFlowLogTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("trafficType", "TrafficType", (properties.TrafficType != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnFlowLogProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnFlowLogProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFlowLogPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deliverLogsPermissionArn", cdk.validateString)(properties.deliverLogsPermissionArn));
  errors.collect(cdk.propertyValidator("destinationOptions", cdk.validateObject)(properties.destinationOptions));
  errors.collect(cdk.propertyValidator("logDestination", cdk.validateString)(properties.logDestination));
  errors.collect(cdk.propertyValidator("logDestinationType", cdk.validateString)(properties.logDestinationType));
  errors.collect(cdk.propertyValidator("logFormat", cdk.validateString)(properties.logFormat));
  errors.collect(cdk.propertyValidator("logGroupName", cdk.validateString)(properties.logGroupName));
  errors.collect(cdk.propertyValidator("maxAggregationInterval", cdk.validateNumber)(properties.maxAggregationInterval));
  errors.collect(cdk.propertyValidator("resourceId", cdk.requiredValidator)(properties.resourceId));
  errors.collect(cdk.propertyValidator("resourceId", cdk.validateString)(properties.resourceId));
  errors.collect(cdk.propertyValidator("resourceType", cdk.requiredValidator)(properties.resourceType));
  errors.collect(cdk.propertyValidator("resourceType", cdk.validateString)(properties.resourceType));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("trafficType", cdk.validateString)(properties.trafficType));
  return errors.wrap("supplied properties not correct for \\"CfnFlowLogProps\\"");
}

// @ts-ignore TS6133
function convertCfnFlowLogPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFlowLogPropsValidator(properties).assertSuccess();
  return {
    "DeliverLogsPermissionArn": cdk.stringToCloudFormation(properties.deliverLogsPermissionArn),
    "DestinationOptions": cdk.objectToCloudFormation(properties.destinationOptions),
    "LogDestination": cdk.stringToCloudFormation(properties.logDestination),
    "LogDestinationType": cdk.stringToCloudFormation(properties.logDestinationType),
    "LogFormat": cdk.stringToCloudFormation(properties.logFormat),
    "LogGroupName": cdk.stringToCloudFormation(properties.logGroupName),
    "MaxAggregationInterval": cdk.numberToCloudFormation(properties.maxAggregationInterval),
    "ResourceId": cdk.stringToCloudFormation(properties.resourceId),
    "ResourceType": cdk.stringToCloudFormation(properties.resourceType),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TrafficType": cdk.stringToCloudFormation(properties.trafficType)
  };
}

// @ts-ignore TS6133
function CfnFlowLogPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFlowLogProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFlowLogProps>();
  ret.addPropertyResult("deliverLogsPermissionArn", "DeliverLogsPermissionArn", (properties.DeliverLogsPermissionArn != null ? cfn_parse.FromCloudFormation.getString(properties.DeliverLogsPermissionArn) : undefined));
  ret.addPropertyResult("destinationOptions", "DestinationOptions", (properties.DestinationOptions != null ? cfn_parse.FromCloudFormation.getAny(properties.DestinationOptions) : undefined));
  ret.addPropertyResult("logDestination", "LogDestination", (properties.LogDestination != null ? cfn_parse.FromCloudFormation.getString(properties.LogDestination) : undefined));
  ret.addPropertyResult("logDestinationType", "LogDestinationType", (properties.LogDestinationType != null ? cfn_parse.FromCloudFormation.getString(properties.LogDestinationType) : undefined));
  ret.addPropertyResult("logFormat", "LogFormat", (properties.LogFormat != null ? cfn_parse.FromCloudFormation.getString(properties.LogFormat) : undefined));
  ret.addPropertyResult("logGroupName", "LogGroupName", (properties.LogGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.LogGroupName) : undefined));
  ret.addPropertyResult("maxAggregationInterval", "MaxAggregationInterval", (properties.MaxAggregationInterval != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxAggregationInterval) : undefined));
  ret.addPropertyResult("resourceId", "ResourceId", (properties.ResourceId != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceId) : undefined));
  ret.addPropertyResult("resourceType", "ResourceType", (properties.ResourceType != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceType) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("trafficType", "TrafficType", (properties.TrafficType != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a virtual private gateway or internet gateway with a route table.
 *
 * The gateway and route table must be in the same VPC. This association causes the incoming traffic to the gateway to be routed according to the routes in the route table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html
 */
export class CfnGatewayRouteTableAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::GatewayRouteTableAssociation";

  /**
   * Build a CfnGatewayRouteTableAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnGatewayRouteTableAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnGatewayRouteTableAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnGatewayRouteTableAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the route table association.
   *
   * @cloudformationAttribute AssociationId
   */
  public readonly attrAssociationId: string;

  /**
   * The ID of the gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-gatewayid
   */
  public gatewayId: string;

  /**
   * The ID of the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-routetableid
   */
  public routeTableId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnGatewayRouteTableAssociationProps) {
    super(scope, id, {
      "type": CfnGatewayRouteTableAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "gatewayId", this);
    cdk.requireProperty(props, "routeTableId", this);

    this.attrAssociationId = cdk.Token.asString(this.getAtt("AssociationId", cdk.ResolutionTypeHint.STRING));
    this.gatewayId = props.gatewayId;
    this.routeTableId = props.routeTableId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "gatewayId": this.gatewayId,
      "routeTableId": this.routeTableId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnGatewayRouteTableAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnGatewayRouteTableAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnGatewayRouteTableAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html
 */
export interface CfnGatewayRouteTableAssociationProps {
  /**
   * The ID of the gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-gatewayid
   */
  readonly gatewayId: string;

  /**
   * The ID of the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-routetableid
   */
  readonly routeTableId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnGatewayRouteTableAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnGatewayRouteTableAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnGatewayRouteTableAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("gatewayId", cdk.requiredValidator)(properties.gatewayId));
  errors.collect(cdk.propertyValidator("gatewayId", cdk.validateString)(properties.gatewayId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.requiredValidator)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.validateString)(properties.routeTableId));
  return errors.wrap("supplied properties not correct for \\"CfnGatewayRouteTableAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnGatewayRouteTableAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnGatewayRouteTableAssociationPropsValidator(properties).assertSuccess();
  return {
    "GatewayId": cdk.stringToCloudFormation(properties.gatewayId),
    "RouteTableId": cdk.stringToCloudFormation(properties.routeTableId)
  };
}

// @ts-ignore TS6133
function CfnGatewayRouteTableAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnGatewayRouteTableAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnGatewayRouteTableAssociationProps>();
  ret.addPropertyResult("gatewayId", "GatewayId", (properties.GatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.GatewayId) : undefined));
  ret.addPropertyResult("routeTableId", "RouteTableId", (properties.RouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.RouteTableId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Allocates a fully dedicated physical server for launching EC2 instances.
 *
 * Because the host is fully dedicated for your use, it can help you address compliance requirements and reduce costs by allowing you to use your existing server-bound software licenses. For more information, see [Dedicated Hosts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-overview.html) in the *Amazon EC2 User Guide for Linux Instances* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html
 */
export class CfnHost extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Host";

  /**
   * Build a CfnHost from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnHost {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnHostPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnHost(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the host.
   *
   * @cloudformationAttribute HostId
   */
  public readonly attrHostId: string;

  /**
   * Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-autoplacement
   */
  public autoPlacement?: string;

  /**
   * The Availability Zone in which to allocate the Dedicated Host.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-availabilityzone
   */
  public availabilityZone: string;

  /**
   * Indicates whether host maintenance is enabled or disabled for the Dedicated Host.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostmaintenance
   */
  public hostMaintenance?: string;

  /**
   * Indicates whether to enable or disable host recovery for the Dedicated Host.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostrecovery
   */
  public hostRecovery?: string;

  /**
   * The instance family supported by the Dedicated Host.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancefamily
   */
  public instanceFamily?: string;

  /**
   * Specifies the instance type to be supported by the Dedicated Hosts.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancetype
   */
  public instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the AWS Outpost on which the Dedicated Host is allocated.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-outpostarn
   */
  public outpostArn?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnHostProps) {
    super(scope, id, {
      "type": CfnHost.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "availabilityZone", this);

    this.attrHostId = cdk.Token.asString(this.getAtt("HostId", cdk.ResolutionTypeHint.STRING));
    this.autoPlacement = props.autoPlacement;
    this.availabilityZone = props.availabilityZone;
    this.hostMaintenance = props.hostMaintenance;
    this.hostRecovery = props.hostRecovery;
    this.instanceFamily = props.instanceFamily;
    this.instanceType = props.instanceType;
    this.outpostArn = props.outpostArn;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "autoPlacement": this.autoPlacement,
      "availabilityZone": this.availabilityZone,
      "hostMaintenance": this.hostMaintenance,
      "hostRecovery": this.hostRecovery,
      "instanceFamily": this.instanceFamily,
      "instanceType": this.instanceType,
      "outpostArn": this.outpostArn
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnHost.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnHostPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnHost\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html
 */
export interface CfnHostProps {
  /**
   * Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID.
   *
   * For more information, see [Understanding auto-placement and affinity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding) in the *Amazon EC2 User Guide* .
   *
   * Default: \`on\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-autoplacement
   */
  readonly autoPlacement?: string;

  /**
   * The Availability Zone in which to allocate the Dedicated Host.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-availabilityzone
   */
  readonly availabilityZone: string;

  /**
   * Indicates whether host maintenance is enabled or disabled for the Dedicated Host.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostmaintenance
   */
  readonly hostMaintenance?: string;

  /**
   * Indicates whether to enable or disable host recovery for the Dedicated Host.
   *
   * Host recovery is disabled by default. For more information, see [Host recovery](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html) in the *Amazon EC2 User Guide* .
   *
   * Default: \`off\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostrecovery
   */
  readonly hostRecovery?: string;

  /**
   * The instance family supported by the Dedicated Host.
   *
   * For example, \`m5\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancefamily
   */
  readonly instanceFamily?: string;

  /**
   * Specifies the instance type to be supported by the Dedicated Hosts.
   *
   * If you specify an instance type, the Dedicated Hosts support instances of the specified instance type only.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancetype
   */
  readonly instanceType?: string;

  /**
   * The Amazon Resource Name (ARN) of the AWS Outpost on which the Dedicated Host is allocated.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-outpostarn
   */
  readonly outpostArn?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnHostProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnHostProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHostPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoPlacement", cdk.validateString)(properties.autoPlacement));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.requiredValidator)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("hostMaintenance", cdk.validateString)(properties.hostMaintenance));
  errors.collect(cdk.propertyValidator("hostRecovery", cdk.validateString)(properties.hostRecovery));
  errors.collect(cdk.propertyValidator("instanceFamily", cdk.validateString)(properties.instanceFamily));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("outpostArn", cdk.validateString)(properties.outpostArn));
  return errors.wrap("supplied properties not correct for \\"CfnHostProps\\"");
}

// @ts-ignore TS6133
function convertCfnHostPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHostPropsValidator(properties).assertSuccess();
  return {
    "AutoPlacement": cdk.stringToCloudFormation(properties.autoPlacement),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "HostMaintenance": cdk.stringToCloudFormation(properties.hostMaintenance),
    "HostRecovery": cdk.stringToCloudFormation(properties.hostRecovery),
    "InstanceFamily": cdk.stringToCloudFormation(properties.instanceFamily),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "OutpostArn": cdk.stringToCloudFormation(properties.outpostArn)
  };
}

// @ts-ignore TS6133
function CfnHostPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHostProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHostProps>();
  ret.addPropertyResult("autoPlacement", "AutoPlacement", (properties.AutoPlacement != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPlacement) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("hostMaintenance", "HostMaintenance", (properties.HostMaintenance != null ? cfn_parse.FromCloudFormation.getString(properties.HostMaintenance) : undefined));
  ret.addPropertyResult("hostRecovery", "HostRecovery", (properties.HostRecovery != null ? cfn_parse.FromCloudFormation.getString(properties.HostRecovery) : undefined));
  ret.addPropertyResult("instanceFamily", "InstanceFamily", (properties.InstanceFamily != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceFamily) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("outpostArn", "OutpostArn", (properties.OutpostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutpostArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an EC2 instance.
 *
 * If an Elastic IP address is attached to your instance, AWS CloudFormation reattaches the Elastic IP address after it updates the instance. For more information about updating stacks, see [AWS CloudFormation Stacks Updates](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html
 */
export class CfnInstance extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Instance";

  /**
   * Build a CfnInstance from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnInstance {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnInstancePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnInstance(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Availability Zone where the specified instance is launched. For example: \`us-east-1b\` .
   *
   * You can retrieve a list of all Availability Zones for a Region by using the [Fn::GetAZs](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-getavailabilityzones.html) intrinsic function.
   *
   * @cloudformationAttribute AvailabilityZone
   */
  public readonly attrAvailabilityZone: string;

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The private DNS name of the specified instance. For example: \`ip-10-24-34-0.ec2.internal\` .
   *
   * @cloudformationAttribute PrivateDnsName
   */
  public readonly attrPrivateDnsName: string;

  /**
   * The private IP address of the specified instance. For example: \`10.24.34.0\` .
   *
   * @cloudformationAttribute PrivateIp
   */
  public readonly attrPrivateIp: string;

  /**
   * The public DNS name of the specified instance. For example: \`ec2-107-20-50-45.compute-1.amazonaws.com\` .
   *
   * @cloudformationAttribute PublicDnsName
   */
  public readonly attrPublicDnsName: string;

  /**
   * The public IP address of the specified instance. For example: \`192.0.2.0\` .
   *
   * @cloudformationAttribute PublicIp
   */
  public readonly attrPublicIp: string;

  /**
   * This property is reserved for internal use.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-additionalinfo
   */
  public additionalInfo?: string;

  /**
   * Indicates whether the instance is associated with a dedicated host.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-affinity
   */
  public affinity?: string;

  /**
   * The Availability Zone of the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-availabilityzone
   */
  public availabilityZone?: string;

  /**
   * The block device mapping entries that defines the block devices to attach to the instance at launch.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-blockdevicemappings
   */
  public blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The CPU options for the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-cpuoptions
   */
  public cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

  /**
   * The credit option for CPU usage of the burstable performance instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-creditspecification
   */
  public creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

  /**
   * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-disableapitermination
   */
  public disableApiTermination?: boolean | cdk.IResolvable;

  /**
   * Indicates whether the instance is optimized for Amazon EBS I/O.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ebsoptimized
   */
  public ebsOptimized?: boolean | cdk.IResolvable;

  /**
   * An elastic GPU to associate with the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-elasticgpuspecifications
   */
  public elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * An elastic inference accelerator to associate with the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-elasticinferenceaccelerators
   */
  public elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Indicates whether the instance is enabled for AWS Nitro Enclaves.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-enclaveoptions
   */
  public enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

  /**
   * Indicates whether an instance is enabled for hibernation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hibernationoptions
   */
  public hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

  /**
   * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hostid
   */
  public hostId?: string;

  /**
   * The ARN of the host resource group in which to launch the instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hostresourcegrouparn
   */
  public hostResourceGroupArn?: string;

  /**
   * The name of an IAM instance profile.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-iaminstanceprofile
   */
  public iamInstanceProfile?: string;

  /**
   * The ID of the AMI.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-imageid
   */
  public imageId?: string;

  /**
   * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-instanceinitiatedshutdownbehavior
   */
  public instanceInitiatedShutdownBehavior?: string;

  /**
   * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-instancetype
   */
  public instanceType?: string;

  /**
   * The number of IPv6 addresses to associate with the primary network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ipv6addresscount
   */
  public ipv6AddressCount?: number;

  /**
   * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ipv6addresses
   */
  public ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The ID of the kernel.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-kernelid
   */
  public kernelId?: string;

  /**
   * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-keyname
   */
  public keyName?: string;

  /**
   * The launch template to use to launch the instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-launchtemplate
   */
  public launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

  /**
   * The license configurations.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-licensespecifications
   */
  public licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

  /**
   * Specifies whether detailed monitoring is enabled for the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-monitoring
   */
  public monitoring?: boolean | cdk.IResolvable;

  /**
   * The network interfaces to associate with the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-networkinterfaces
   */
  public networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

  /**
   * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-placementgroupname
   */
  public placementGroupName?: string;

  /**
   * The options for the instance hostname.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-privatednsnameoptions
   */
  public privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

  /**
   * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-privateipaddress
   */
  public privateIpAddress?: string;

  /**
   * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation
   */
  public propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

  /**
   * The ID of the RAM disk to select.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ramdiskid
   */
  public ramdiskId?: string;

  /**
   * The IDs of the security groups.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-securitygroupids
   */
  public securityGroupIds?: Array<string>;

  /**
   * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-securitygroups
   */
  public securityGroups?: Array<string>;

  /**
   * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-sourcedestcheck
   */
  public sourceDestCheck?: boolean | cdk.IResolvable;

  /**
   * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ssmassociations
   */
  public ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

  /**
   * The ID of the subnet to launch the instance into.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-subnetid
   */
  public subnetId?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to add to the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The tenancy of the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-tenancy
   */
  public tenancy?: string;

  /**
   * The user data script to make available to the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-userdata
   */
  public userData?: string;

  /**
   * The volumes to attach to the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-volumes
   */
  public volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnInstanceProps = {}) {
    super(scope, id, {
      "type": CfnInstance.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrAvailabilityZone = cdk.Token.asString(this.getAtt("AvailabilityZone", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrPrivateDnsName = cdk.Token.asString(this.getAtt("PrivateDnsName", cdk.ResolutionTypeHint.STRING));
    this.attrPrivateIp = cdk.Token.asString(this.getAtt("PrivateIp", cdk.ResolutionTypeHint.STRING));
    this.attrPublicDnsName = cdk.Token.asString(this.getAtt("PublicDnsName", cdk.ResolutionTypeHint.STRING));
    this.attrPublicIp = cdk.Token.asString(this.getAtt("PublicIp", cdk.ResolutionTypeHint.STRING));
    this.additionalInfo = props.additionalInfo;
    this.affinity = props.affinity;
    this.availabilityZone = props.availabilityZone;
    this.blockDeviceMappings = props.blockDeviceMappings;
    this.cpuOptions = props.cpuOptions;
    this.creditSpecification = props.creditSpecification;
    this.disableApiTermination = props.disableApiTermination;
    this.ebsOptimized = props.ebsOptimized;
    this.elasticGpuSpecifications = props.elasticGpuSpecifications;
    this.elasticInferenceAccelerators = props.elasticInferenceAccelerators;
    this.enclaveOptions = props.enclaveOptions;
    this.hibernationOptions = props.hibernationOptions;
    this.hostId = props.hostId;
    this.hostResourceGroupArn = props.hostResourceGroupArn;
    this.iamInstanceProfile = props.iamInstanceProfile;
    this.imageId = props.imageId;
    this.instanceInitiatedShutdownBehavior = props.instanceInitiatedShutdownBehavior;
    this.instanceType = props.instanceType;
    this.ipv6AddressCount = props.ipv6AddressCount;
    this.ipv6Addresses = props.ipv6Addresses;
    this.kernelId = props.kernelId;
    this.keyName = props.keyName;
    this.launchTemplate = props.launchTemplate;
    this.licenseSpecifications = props.licenseSpecifications;
    this.monitoring = props.monitoring;
    this.networkInterfaces = props.networkInterfaces;
    this.placementGroupName = props.placementGroupName;
    this.privateDnsNameOptions = props.privateDnsNameOptions;
    this.privateIpAddress = props.privateIpAddress;
    this.propagateTagsToVolumeOnCreation = props.propagateTagsToVolumeOnCreation;
    this.ramdiskId = props.ramdiskId;
    this.securityGroupIds = props.securityGroupIds;
    this.securityGroups = props.securityGroups;
    this.sourceDestCheck = props.sourceDestCheck;
    this.ssmAssociations = props.ssmAssociations;
    this.subnetId = props.subnetId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::Instance", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.tenancy = props.tenancy;
    this.userData = props.userData;
    this.volumes = props.volumes;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "additionalInfo": this.additionalInfo,
      "affinity": this.affinity,
      "availabilityZone": this.availabilityZone,
      "blockDeviceMappings": this.blockDeviceMappings,
      "cpuOptions": this.cpuOptions,
      "creditSpecification": this.creditSpecification,
      "disableApiTermination": this.disableApiTermination,
      "ebsOptimized": this.ebsOptimized,
      "elasticGpuSpecifications": this.elasticGpuSpecifications,
      "elasticInferenceAccelerators": this.elasticInferenceAccelerators,
      "enclaveOptions": this.enclaveOptions,
      "hibernationOptions": this.hibernationOptions,
      "hostId": this.hostId,
      "hostResourceGroupArn": this.hostResourceGroupArn,
      "iamInstanceProfile": this.iamInstanceProfile,
      "imageId": this.imageId,
      "instanceInitiatedShutdownBehavior": this.instanceInitiatedShutdownBehavior,
      "instanceType": this.instanceType,
      "ipv6AddressCount": this.ipv6AddressCount,
      "ipv6Addresses": this.ipv6Addresses,
      "kernelId": this.kernelId,
      "keyName": this.keyName,
      "launchTemplate": this.launchTemplate,
      "licenseSpecifications": this.licenseSpecifications,
      "monitoring": this.monitoring,
      "networkInterfaces": this.networkInterfaces,
      "placementGroupName": this.placementGroupName,
      "privateDnsNameOptions": this.privateDnsNameOptions,
      "privateIpAddress": this.privateIpAddress,
      "propagateTagsToVolumeOnCreation": this.propagateTagsToVolumeOnCreation,
      "ramdiskId": this.ramdiskId,
      "securityGroupIds": this.securityGroupIds,
      "securityGroups": this.securityGroups,
      "sourceDestCheck": this.sourceDestCheck,
      "ssmAssociations": this.ssmAssociations,
      "subnetId": this.subnetId,
      "tags": this.tags.renderTags(),
      "tenancy": this.tenancy,
      "userData": this.userData,
      "volumes": this.volumes
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnInstance.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnInstancePropsToCloudFormation(props);
  }
}

export namespace CfnInstance {
  /**
   * Specifies a block device mapping for an instance.
   *
   * You must specify exactly one of the following properties: \`VirtualName\` , \`Ebs\` , or \`NoDevice\` .
   *
   * \`BlockDeviceMapping\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html
   */
  export interface BlockDeviceMappingProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the IPv6 address for the instance.
   *
   * \`InstanceIpv6Address\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html
   */
  export interface InstanceIpv6AddressProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the type of Elastic GPU.
   *
   * An Elastic GPU is a GPU resource that you can attach to your Amazon EC2 instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide for Windows Instances* .
   *
   * \`ElasticGpuSpecification\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html
   */
  export interface ElasticGpuSpecificationProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the Elastic Inference Accelerator for the instance.
   *
   * \`ElasticInferenceAccelerator\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html
   */
  export interface ElasticInferenceAcceleratorProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * Specifies a volume to attach to an instance.
   *
   * \`Volume\` is an embedded property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html
   */
  export interface VolumeProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * Specifies a launch template to use when launching an Amazon EC2 instance.
   *
   * You must specify the following:
   *
   * - The ID or the name of the launch template, but not both.
   * - The version of the launch template.
   *
   * \`LaunchTemplateSpecification\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) in the *Amazon EC2 User Guide* .
   *
   * For examples of launch templates, see [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html
   */
  export interface LaunchTemplateSpecificationProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * Indicates whether the instance is enabled for AWS Nitro Enclaves.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html
   */
  export interface EnclaveOptionsProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * Specifies a network interface that is to be attached to an instance.
   *
   * You can create a network interface when launching an instance. For an example, see the [AWS::EC2::Instance examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#aws-properties-ec2-instance--examples--Automatically_assign_a_public_IP_address) .
   *
   * Alternatively, you can attach an existing network interface when launching an instance. For an example, see the [AWS::EC2:NetworkInterface examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#aws-resource-ec2-networkinterface--examples) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html
   */
  export interface NetworkInterfaceProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html
   */
  export interface TagProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-tag.html#cfn-ec2-instance-tag-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the hibernation options for the instance.
   *
   * \`HibernationOptions\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html
   */
  export interface HibernationOptionsProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the license configuration to use.
   *
   * \`LicenseSpecification\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html
   */
  export interface LicenseSpecificationProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the CPU options for the instance.
   *
   * When you specify CPU options, you must specify both the number of CPU cores and threads per core.
   *
   * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html
   */
  export interface CpuOptionsProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * The type of hostnames to assign to instances in the subnet at launch.
   *
   * For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html
   */
  export interface PrivateDnsNameOptionsProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the SSM document and parameter values in AWS Systems Manager to associate with an instance.
   *
   * \`SsmAssociations\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html
   */
  export interface SsmAssociationProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the credit option for CPU usage of a T instance.
   *
   * \`CreditSpecification\` is a property of the [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource.
   *
   * For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html
   */
  export interface CreditSpecificationProperty {
    /**
     * This property is reserved for internal use.
     *
     * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-additionalinfo
     */
    readonly additionalInfo?: string;

    /**
     * Indicates whether the instance is associated with a dedicated host.
     *
     * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-affinity
     */
    readonly affinity?: string;

    /**
     * The Availability Zone of the instance.
     *
     * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
     *
     * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The block device mapping entries that defines the block devices to attach to the instance at launch.
     *
     * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
     *
     * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-blockdevicemappings
     */
    readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The CPU options for the instance.
     *
     * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-cpuoptions
     */
    readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

    /**
     * The credit option for CPU usage of the burstable performance instance.
     *
     * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
     *
     * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-creditspecification
     */
    readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

    /**
     * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
     *
     * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-disableapitermination
     */
    readonly disableApiTermination?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the instance is optimized for Amazon EBS I/O.
     *
     * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
     *
     * Default: \`false\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-ebsoptimized
     */
    readonly ebsOptimized?: boolean | cdk.IResolvable;

    /**
     * An elastic GPU to associate with the instance.
     *
     * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-elasticgpuspecifications
     */
    readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * An elastic inference accelerator to associate with the instance.
     *
     * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
     *
     * You cannot specify accelerators from different generations in the same request.
     *
     * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-elasticinferenceaccelerators
     */
    readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-enclaveoptions
     */
    readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

    /**
     * Indicates whether an instance is enabled for hibernation.
     *
     * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
     *
     * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-hibernationoptions
     */
    readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

    /**
     * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
     *
     * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-hostid
     */
    readonly hostId?: string;

    /**
     * The ARN of the host resource group in which to launch the instances.
     *
     * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-hostresourcegrouparn
     */
    readonly hostResourceGroupArn?: string;

    /**
     * The name of an IAM instance profile.
     *
     * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-iaminstanceprofile
     */
    readonly iamInstanceProfile?: string;

    /**
     * The ID of the AMI.
     *
     * An AMI ID is required to launch an instance and must be specified here or in a launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-imageid
     */
    readonly imageId?: string;

    /**
     * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
     *
     * Default: \`stop\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-instanceinitiatedshutdownbehavior
     */
    readonly instanceInitiatedShutdownBehavior?: string;

    /**
     * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
     *
     * Default: \`m1.small\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-instancetype
     */
    readonly instanceType?: string;

    /**
     * The number of IPv6 addresses to associate with the primary network interface.
     *
     * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
     *
     * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The ID of the kernel.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-kernelid
     */
    readonly kernelId?: string;

    /**
     * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
     *
     * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-keyname
     */
    readonly keyName?: string;

    /**
     * The launch template to use to launch the instances.
     *
     * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-launchtemplate
     */
    readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

    /**
     * The license configurations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-licensespecifications
     */
    readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

    /**
     * Specifies whether detailed monitoring is enabled for the instance.
     *
     * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-monitoring
     */
    readonly monitoring?: boolean | cdk.IResolvable;

    /**
     * The network interfaces to associate with the instance.
     *
     * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
     * >
     * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-networkinterfaces
     */
    readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

    /**
     * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-placementgroupname
     */
    readonly placementGroupName?: string;

    /**
     * The options for the instance hostname.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-privatednsnameoptions
     */
    readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

    /**
     * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
     *
     * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
     *
     * You cannot specify this option and the network interfaces option in the same request.
     *
     * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
     *
     * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-propagatetagstovolumeoncreation
     */
    readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

    /**
     * The ID of the RAM disk to select.
     *
     * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
     *
     * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-ramdiskid
     */
    readonly ramdiskId?: string;

    /**
     * The IDs of the security groups.
     *
     * You can specify the IDs of existing security groups and references to resources created by the stack template.
     *
     * If you specify a network interface, you must specify any security groups as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
     *
     * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
     *
     * Default: Amazon EC2 uses the default security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
     *
     * > You can currently associate only one document with an instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-ssmassociations
     */
    readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

    /**
     * The ID of the subnet to launch the instance into.
     *
     * If you specify a network interface, you must specify any subnets as part of the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-subnetid
     */
    readonly subnetId?: string;

    /**
     * The tags to add to the instance.
     *
     * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInstance.TagProperty> | cdk.IResolvable;

    /**
     * The tenancy of the instance.
     *
     * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-tenancy
     */
    readonly tenancy?: string;

    /**
     * The user data script to make available to the instance.
     *
     * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
     *
     * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-userdata
     */
    readonly userData?: string;

    /**
     * The volumes to attach to the instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-volumes
     */
    readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnInstance\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html
 */
export interface CfnInstanceProps {
  /**
   * This property is reserved for internal use.
   *
   * If you use it, the stack fails with this error: \`Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-additionalinfo
   */
  readonly additionalInfo?: string;

  /**
   * Indicates whether the instance is associated with a dedicated host.
   *
   * If you want the instance to always restart on the same host on which it was launched, specify \`host\` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify \`default\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-affinity
   */
  readonly affinity?: string;

  /**
   * The Availability Zone of the instance.
   *
   * If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
   *
   * This parameter is not supported by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-availabilityzone
   */
  readonly availabilityZone?: string;

  /**
   * The block device mapping entries that defines the block devices to attach to the instance at launch.
   *
   * By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the \`DeleteOnTermination\` setting.
   *
   * > After the instance is running, you can modify only the \`DeleteOnTermination\` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-blockdevicemappings
   */
  readonly blockDeviceMappings?: Array<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The CPU options for the instance.
   *
   * For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-cpuoptions
   */
  readonly cpuOptions?: CfnInstance.CpuOptionsProperty | cdk.IResolvable;

  /**
   * The credit option for CPU usage of the burstable performance instance.
   *
   * Valid values are \`standard\` and \`unlimited\` . To change this attribute after launch, use [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html) . For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide* .
   *
   * Default: \`standard\` (T2 instances) or \`unlimited\` (T3/T3a/T4g instances)
   *
   * For T3 instances with \`host\` tenancy, only \`standard\` is supported.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-creditspecification
   */
  readonly creditSpecification?: CfnInstance.CreditSpecificationProperty | cdk.IResolvable;

  /**
   * If you set this parameter to \`true\` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;
   *
   * otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html) . Alternatively, if you set \`InstanceInitiatedShutdownBehavior\` to \`terminate\` , you can terminate the instance by running the shutdown command from the instance.
   *
   * Default: \`false\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-disableapitermination
   */
  readonly disableApiTermination?: boolean | cdk.IResolvable;

  /**
   * Indicates whether the instance is optimized for Amazon EBS I/O.
   *
   * This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
   *
   * Default: \`false\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ebsoptimized
   */
  readonly ebsOptimized?: boolean | cdk.IResolvable;

  /**
   * An elastic GPU to associate with the instance.
   *
   * An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-elasticgpuspecifications
   */
  readonly elasticGpuSpecifications?: Array<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * An elastic inference accelerator to associate with the instance.
   *
   * Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
   *
   * You cannot specify accelerators from different generations in the same request.
   *
   * > Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-elasticinferenceaccelerators
   */
  readonly elasticInferenceAccelerators?: Array<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Indicates whether the instance is enabled for AWS Nitro Enclaves.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-enclaveoptions
   */
  readonly enclaveOptions?: CfnInstance.EnclaveOptionsProperty | cdk.IResolvable;

  /**
   * Indicates whether an instance is enabled for hibernation.
   *
   * For more information, see [Hibernate your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide* .
   *
   * You can't enable hibernation and AWS Nitro Enclaves on the same instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hibernationoptions
   */
  readonly hibernationOptions?: CfnInstance.HibernationOptionsProperty | cdk.IResolvable;

  /**
   * If you specify host for the \`Affinity\` property, the ID of a dedicated host that the instance is associated with.
   *
   * If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hostid
   */
  readonly hostId?: string;

  /**
   * The ARN of the host resource group in which to launch the instances.
   *
   * If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to \`host\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hostresourcegrouparn
   */
  readonly hostResourceGroupArn?: string;

  /**
   * The name of an IAM instance profile.
   *
   * To create a new IAM instance profile, use the [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html) resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-iaminstanceprofile
   */
  readonly iamInstanceProfile?: string;

  /**
   * The ID of the AMI.
   *
   * An AMI ID is required to launch an instance and must be specified here or in a launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-imageid
   */
  readonly imageId?: string;

  /**
   * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
   *
   * Default: \`stop\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-instanceinitiatedshutdownbehavior
   */
  readonly instanceInitiatedShutdownBehavior?: string;

  /**
   * The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
   *
   * Default: \`m1.small\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-instancetype
   */
  readonly instanceType?: string;

  /**
   * The number of IPv6 addresses to associate with the primary network interface.
   *
   * Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
   *
   * You cannot specify this option and the network interfaces option in the same request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ipv6addresscount
   */
  readonly ipv6AddressCount?: number;

  /**
   * The IPv6 addresses from the range of the subnet to associate with the primary network interface.
   *
   * You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
   *
   * You cannot specify this option and the network interfaces option in the same request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ipv6addresses
   */
  readonly ipv6Addresses?: Array<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The ID of the kernel.
   *
   * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-kernelid
   */
  readonly kernelId?: string;

  /**
   * The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html) .
   *
   * > If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-keyname
   */
  readonly keyName?: string;

  /**
   * The launch template to use to launch the instances.
   *
   * Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-launchtemplate
   */
  readonly launchTemplate?: cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty;

  /**
   * The license configurations.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-licensespecifications
   */
  readonly licenseSpecifications?: Array<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> | cdk.IResolvable;

  /**
   * Specifies whether detailed monitoring is enabled for the instance.
   *
   * Specify \`true\` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-monitoring
   */
  readonly monitoring?: boolean | cdk.IResolvable;

  /**
   * The network interfaces to associate with the instance.
   *
   * > If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.
   * >
   * > If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the VPC-gateway attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-networkinterfaces
   */
  readonly networkInterfaces?: Array<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> | cdk.IResolvable;

  /**
   * The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-placementgroupname
   */
  readonly placementGroupName?: string;

  /**
   * The options for the instance hostname.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-privatednsnameoptions
   */
  readonly privateDnsNameOptions?: cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty;

  /**
   * The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.
   *
   * Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
   *
   * You cannot specify this option and the network interfaces option in the same request.
   *
   * If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-privateipaddress
   */
  readonly privateIpAddress?: string;

  /**
   * Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.
   *
   * If you specify \`true\` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify \`false\` , those tags are not assigned to the attached volumes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation
   */
  readonly propagateTagsToVolumeOnCreation?: boolean | cdk.IResolvable;

  /**
   * The ID of the RAM disk to select.
   *
   * Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
   *
   * > We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ramdiskid
   */
  readonly ramdiskId?: string;

  /**
   * The IDs of the security groups.
   *
   * You can specify the IDs of existing security groups and references to resources created by the stack template.
   *
   * If you specify a network interface, you must specify any security groups as part of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
   *
   * You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.
   *
   * Default: Amazon EC2 uses the default security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-securitygroups
   */
  readonly securityGroups?: Array<string>;

  /**
   * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
   *
   * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-sourcedestcheck
   */
  readonly sourceDestCheck?: boolean | cdk.IResolvable;

  /**
   * The SSM [document](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html) and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see [Create an IAM instance profile for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html) in the *AWS Systems Manager User Guide* .
   *
   * > You can currently associate only one document with an instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ssmassociations
   */
  readonly ssmAssociations?: Array<cdk.IResolvable | CfnInstance.SsmAssociationProperty> | cdk.IResolvable;

  /**
   * The ID of the subnet to launch the instance into.
   *
   * If you specify a network interface, you must specify any subnets as part of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-subnetid
   */
  readonly subnetId?: string;

  /**
   * The tags to add to the instance.
   *
   * These tags are not applied to the EBS volumes, such as the root volume, unless [PropagateTagsToVolumeOnCreation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation) is \`true\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The tenancy of the instance.
   *
   * An instance with a tenancy of \`dedicated\` runs on single-tenant hardware.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-tenancy
   */
  readonly tenancy?: string;

  /**
   * The user data script to make available to the instance.
   *
   * User data is limited to 16 KB. You must provide base64-encoded text. For more information, see [Fn::Base64](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html) .
   *
   * User data runs only at instance launch. For more information, see [Run commands on your Linux instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) and [Run commands on your Windows instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-userdata
   */
  readonly userData?: string;

  /**
   * The volumes to attach to the instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-volumes
   */
  readonly volumes?: Array<cdk.IResolvable | CfnInstance.VolumeProperty> | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`CreditSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CreditSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceCreditSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"CreditSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceCreditSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.CreditSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.CreditSpecificationProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SsmAssociationProperty\`
 *
 * @param properties - the TypeScript properties of a \`SsmAssociationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceSsmAssociationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"SsmAssociationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceSsmAssociationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceSsmAssociationPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceSsmAssociationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.SsmAssociationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.SsmAssociationProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PrivateDnsNameOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`PrivateDnsNameOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstancePrivateDnsNameOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"PrivateDnsNameOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstancePrivateDnsNameOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.PrivateDnsNameOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.PrivateDnsNameOptionsProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CpuOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`CpuOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceCpuOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"CpuOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceCpuOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceCpuOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.CpuOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.CpuOptionsProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LicenseSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LicenseSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceLicenseSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"LicenseSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceLicenseSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceLicenseSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceLicenseSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.LicenseSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.LicenseSpecificationProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`HibernationOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`HibernationOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceHibernationOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"HibernationOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceHibernationOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.HibernationOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.HibernationOptionsProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceTagPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.TagProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NetworkInterfaceProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkInterfaceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceNetworkInterfacePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"NetworkInterfaceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceNetworkInterfacePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceNetworkInterfacePropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceNetworkInterfacePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.NetworkInterfaceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.NetworkInterfaceProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EnclaveOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`EnclaveOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceEnclaveOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"EnclaveOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceEnclaveOptionsPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.EnclaveOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.EnclaveOptionsProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LaunchTemplateSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LaunchTemplateSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceLaunchTemplateSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"LaunchTemplateSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceLaunchTemplateSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.LaunchTemplateSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.LaunchTemplateSpecificationProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VolumeProperty\`
 *
 * @param properties - the TypeScript properties of a \`VolumeProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceVolumePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"VolumeProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceVolumePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceVolumePropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceVolumePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInstance.VolumeProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.VolumeProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ElasticInferenceAcceleratorProperty\`
 *
 * @param properties - the TypeScript properties of a \`ElasticInferenceAcceleratorProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceElasticInferenceAcceleratorPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"ElasticInferenceAcceleratorProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceElasticInferenceAcceleratorPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.ElasticInferenceAcceleratorProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.ElasticInferenceAcceleratorProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ElasticGpuSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ElasticGpuSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceElasticGpuSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"ElasticGpuSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceElasticGpuSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.ElasticGpuSpecificationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.ElasticGpuSpecificationProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InstanceIpv6AddressProperty\`
 *
 * @param properties - the TypeScript properties of a \`InstanceIpv6AddressProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceInstanceIpv6AddressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"InstanceIpv6AddressProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceInstanceIpv6AddressPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.InstanceIpv6AddressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.InstanceIpv6AddressProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`BlockDeviceMappingProperty\`
 *
 * @param properties - the TypeScript properties of a \`BlockDeviceMappingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstanceBlockDeviceMappingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"BlockDeviceMappingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstanceBlockDeviceMappingPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnInstanceTagPropertyToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstanceBlockDeviceMappingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstance.BlockDeviceMappingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstance.BlockDeviceMappingProperty>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnInstanceProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnInstanceProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInstancePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalInfo", cdk.validateString)(properties.additionalInfo));
  errors.collect(cdk.propertyValidator("affinity", cdk.validateString)(properties.affinity));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("blockDeviceMappings", cdk.listValidator(CfnInstanceBlockDeviceMappingPropertyValidator))(properties.blockDeviceMappings));
  errors.collect(cdk.propertyValidator("cpuOptions", CfnInstanceCpuOptionsPropertyValidator)(properties.cpuOptions));
  errors.collect(cdk.propertyValidator("creditSpecification", CfnInstanceCreditSpecificationPropertyValidator)(properties.creditSpecification));
  errors.collect(cdk.propertyValidator("disableApiTermination", cdk.validateBoolean)(properties.disableApiTermination));
  errors.collect(cdk.propertyValidator("ebsOptimized", cdk.validateBoolean)(properties.ebsOptimized));
  errors.collect(cdk.propertyValidator("elasticGpuSpecifications", cdk.listValidator(CfnInstanceElasticGpuSpecificationPropertyValidator))(properties.elasticGpuSpecifications));
  errors.collect(cdk.propertyValidator("elasticInferenceAccelerators", cdk.listValidator(CfnInstanceElasticInferenceAcceleratorPropertyValidator))(properties.elasticInferenceAccelerators));
  errors.collect(cdk.propertyValidator("enclaveOptions", CfnInstanceEnclaveOptionsPropertyValidator)(properties.enclaveOptions));
  errors.collect(cdk.propertyValidator("hibernationOptions", CfnInstanceHibernationOptionsPropertyValidator)(properties.hibernationOptions));
  errors.collect(cdk.propertyValidator("hostId", cdk.validateString)(properties.hostId));
  errors.collect(cdk.propertyValidator("hostResourceGroupArn", cdk.validateString)(properties.hostResourceGroupArn));
  errors.collect(cdk.propertyValidator("iamInstanceProfile", cdk.validateString)(properties.iamInstanceProfile));
  errors.collect(cdk.propertyValidator("imageId", cdk.validateString)(properties.imageId));
  errors.collect(cdk.propertyValidator("instanceInitiatedShutdownBehavior", cdk.validateString)(properties.instanceInitiatedShutdownBehavior));
  errors.collect(cdk.propertyValidator("instanceType", cdk.validateString)(properties.instanceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnInstanceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("kernelId", cdk.validateString)(properties.kernelId));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("launchTemplate", CfnInstanceLaunchTemplateSpecificationPropertyValidator)(properties.launchTemplate));
  errors.collect(cdk.propertyValidator("licenseSpecifications", cdk.listValidator(CfnInstanceLicenseSpecificationPropertyValidator))(properties.licenseSpecifications));
  errors.collect(cdk.propertyValidator("monitoring", cdk.validateBoolean)(properties.monitoring));
  errors.collect(cdk.propertyValidator("networkInterfaces", cdk.listValidator(CfnInstanceNetworkInterfacePropertyValidator))(properties.networkInterfaces));
  errors.collect(cdk.propertyValidator("placementGroupName", cdk.validateString)(properties.placementGroupName));
  errors.collect(cdk.propertyValidator("privateDnsNameOptions", CfnInstancePrivateDnsNameOptionsPropertyValidator)(properties.privateDnsNameOptions));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("propagateTagsToVolumeOnCreation", cdk.validateBoolean)(properties.propagateTagsToVolumeOnCreation));
  errors.collect(cdk.propertyValidator("ramdiskId", cdk.validateString)(properties.ramdiskId));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("ssmAssociations", cdk.listValidator(CfnInstanceSsmAssociationPropertyValidator))(properties.ssmAssociations));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("tenancy", cdk.validateString)(properties.tenancy));
  errors.collect(cdk.propertyValidator("userData", cdk.validateString)(properties.userData));
  errors.collect(cdk.propertyValidator("volumes", cdk.listValidator(CfnInstanceVolumePropertyValidator))(properties.volumes));
  return errors.wrap("supplied properties not correct for \\"CfnInstanceProps\\"");
}

// @ts-ignore TS6133
function convertCfnInstancePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInstancePropsValidator(properties).assertSuccess();
  return {
    "AdditionalInfo": cdk.stringToCloudFormation(properties.additionalInfo),
    "Affinity": cdk.stringToCloudFormation(properties.affinity),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "BlockDeviceMappings": cdk.listMapper(convertCfnInstanceBlockDeviceMappingPropertyToCloudFormation)(properties.blockDeviceMappings),
    "CpuOptions": convertCfnInstanceCpuOptionsPropertyToCloudFormation(properties.cpuOptions),
    "CreditSpecification": convertCfnInstanceCreditSpecificationPropertyToCloudFormation(properties.creditSpecification),
    "DisableApiTermination": cdk.booleanToCloudFormation(properties.disableApiTermination),
    "EbsOptimized": cdk.booleanToCloudFormation(properties.ebsOptimized),
    "ElasticGpuSpecifications": cdk.listMapper(convertCfnInstanceElasticGpuSpecificationPropertyToCloudFormation)(properties.elasticGpuSpecifications),
    "ElasticInferenceAccelerators": cdk.listMapper(convertCfnInstanceElasticInferenceAcceleratorPropertyToCloudFormation)(properties.elasticInferenceAccelerators),
    "EnclaveOptions": convertCfnInstanceEnclaveOptionsPropertyToCloudFormation(properties.enclaveOptions),
    "HibernationOptions": convertCfnInstanceHibernationOptionsPropertyToCloudFormation(properties.hibernationOptions),
    "HostId": cdk.stringToCloudFormation(properties.hostId),
    "HostResourceGroupArn": cdk.stringToCloudFormation(properties.hostResourceGroupArn),
    "IamInstanceProfile": cdk.stringToCloudFormation(properties.iamInstanceProfile),
    "ImageId": cdk.stringToCloudFormation(properties.imageId),
    "InstanceInitiatedShutdownBehavior": cdk.stringToCloudFormation(properties.instanceInitiatedShutdownBehavior),
    "InstanceType": cdk.stringToCloudFormation(properties.instanceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnInstanceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "KernelId": cdk.stringToCloudFormation(properties.kernelId),
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "LaunchTemplate": convertCfnInstanceLaunchTemplateSpecificationPropertyToCloudFormation(properties.launchTemplate),
    "LicenseSpecifications": cdk.listMapper(convertCfnInstanceLicenseSpecificationPropertyToCloudFormation)(properties.licenseSpecifications),
    "Monitoring": cdk.booleanToCloudFormation(properties.monitoring),
    "NetworkInterfaces": cdk.listMapper(convertCfnInstanceNetworkInterfacePropertyToCloudFormation)(properties.networkInterfaces),
    "PlacementGroupName": cdk.stringToCloudFormation(properties.placementGroupName),
    "PrivateDnsNameOptions": convertCfnInstancePrivateDnsNameOptionsPropertyToCloudFormation(properties.privateDnsNameOptions),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PropagateTagsToVolumeOnCreation": cdk.booleanToCloudFormation(properties.propagateTagsToVolumeOnCreation),
    "RamdiskId": cdk.stringToCloudFormation(properties.ramdiskId),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SsmAssociations": cdk.listMapper(convertCfnInstanceSsmAssociationPropertyToCloudFormation)(properties.ssmAssociations),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Tenancy": cdk.stringToCloudFormation(properties.tenancy),
    "UserData": cdk.stringToCloudFormation(properties.userData),
    "Volumes": cdk.listMapper(convertCfnInstanceVolumePropertyToCloudFormation)(properties.volumes)
  };
}

// @ts-ignore TS6133
function CfnInstancePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInstanceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInstanceProps>();
  ret.addPropertyResult("additionalInfo", "AdditionalInfo", (properties.AdditionalInfo != null ? cfn_parse.FromCloudFormation.getString(properties.AdditionalInfo) : undefined));
  ret.addPropertyResult("affinity", "Affinity", (properties.Affinity != null ? cfn_parse.FromCloudFormation.getString(properties.Affinity) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("blockDeviceMappings", "BlockDeviceMappings", (properties.BlockDeviceMappings != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceBlockDeviceMappingPropertyFromCloudFormation)(properties.BlockDeviceMappings) : undefined));
  ret.addPropertyResult("cpuOptions", "CpuOptions", (properties.CpuOptions != null ? CfnInstanceCpuOptionsPropertyFromCloudFormation(properties.CpuOptions) : undefined));
  ret.addPropertyResult("creditSpecification", "CreditSpecification", (properties.CreditSpecification != null ? CfnInstanceCreditSpecificationPropertyFromCloudFormation(properties.CreditSpecification) : undefined));
  ret.addPropertyResult("disableApiTermination", "DisableApiTermination", (properties.DisableApiTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableApiTermination) : undefined));
  ret.addPropertyResult("ebsOptimized", "EbsOptimized", (properties.EbsOptimized != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EbsOptimized) : undefined));
  ret.addPropertyResult("elasticGpuSpecifications", "ElasticGpuSpecifications", (properties.ElasticGpuSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticGpuSpecificationPropertyFromCloudFormation)(properties.ElasticGpuSpecifications) : undefined));
  ret.addPropertyResult("elasticInferenceAccelerators", "ElasticInferenceAccelerators", (properties.ElasticInferenceAccelerators != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceElasticInferenceAcceleratorPropertyFromCloudFormation)(properties.ElasticInferenceAccelerators) : undefined));
  ret.addPropertyResult("enclaveOptions", "EnclaveOptions", (properties.EnclaveOptions != null ? CfnInstanceEnclaveOptionsPropertyFromCloudFormation(properties.EnclaveOptions) : undefined));
  ret.addPropertyResult("hibernationOptions", "HibernationOptions", (properties.HibernationOptions != null ? CfnInstanceHibernationOptionsPropertyFromCloudFormation(properties.HibernationOptions) : undefined));
  ret.addPropertyResult("hostId", "HostId", (properties.HostId != null ? cfn_parse.FromCloudFormation.getString(properties.HostId) : undefined));
  ret.addPropertyResult("hostResourceGroupArn", "HostResourceGroupArn", (properties.HostResourceGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.HostResourceGroupArn) : undefined));
  ret.addPropertyResult("iamInstanceProfile", "IamInstanceProfile", (properties.IamInstanceProfile != null ? cfn_parse.FromCloudFormation.getString(properties.IamInstanceProfile) : undefined));
  ret.addPropertyResult("imageId", "ImageId", (properties.ImageId != null ? cfn_parse.FromCloudFormation.getString(properties.ImageId) : undefined));
  ret.addPropertyResult("instanceInitiatedShutdownBehavior", "InstanceInitiatedShutdownBehavior", (properties.InstanceInitiatedShutdownBehavior != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceInitiatedShutdownBehavior) : undefined));
  ret.addPropertyResult("instanceType", "InstanceType", (properties.InstanceType != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("kernelId", "KernelId", (properties.KernelId != null ? cfn_parse.FromCloudFormation.getString(properties.KernelId) : undefined));
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("launchTemplate", "LaunchTemplate", (properties.LaunchTemplate != null ? CfnInstanceLaunchTemplateSpecificationPropertyFromCloudFormation(properties.LaunchTemplate) : undefined));
  ret.addPropertyResult("licenseSpecifications", "LicenseSpecifications", (properties.LicenseSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceLicenseSpecificationPropertyFromCloudFormation)(properties.LicenseSpecifications) : undefined));
  ret.addPropertyResult("monitoring", "Monitoring", (properties.Monitoring != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Monitoring) : undefined));
  ret.addPropertyResult("networkInterfaces", "NetworkInterfaces", (properties.NetworkInterfaces != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceNetworkInterfacePropertyFromCloudFormation)(properties.NetworkInterfaces) : undefined));
  ret.addPropertyResult("placementGroupName", "PlacementGroupName", (properties.PlacementGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.PlacementGroupName) : undefined));
  ret.addPropertyResult("privateDnsNameOptions", "PrivateDnsNameOptions", (properties.PrivateDnsNameOptions != null ? CfnInstancePrivateDnsNameOptionsPropertyFromCloudFormation(properties.PrivateDnsNameOptions) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("propagateTagsToVolumeOnCreation", "PropagateTagsToVolumeOnCreation", (properties.PropagateTagsToVolumeOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PropagateTagsToVolumeOnCreation) : undefined));
  ret.addPropertyResult("ramdiskId", "RamdiskId", (properties.RamdiskId != null ? cfn_parse.FromCloudFormation.getString(properties.RamdiskId) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("ssmAssociations", "SsmAssociations", (properties.SsmAssociations != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceSsmAssociationPropertyFromCloudFormation)(properties.SsmAssociations) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("tenancy", "Tenancy", (properties.Tenancy != null ? cfn_parse.FromCloudFormation.getString(properties.Tenancy) : undefined));
  ret.addPropertyResult("userData", "UserData", (properties.UserData != null ? cfn_parse.FromCloudFormation.getString(properties.UserData) : undefined));
  ret.addPropertyResult("volumes", "Volumes", (properties.Volumes != null ? cfn_parse.FromCloudFormation.getArray(CfnInstanceVolumePropertyFromCloudFormation)(properties.Volumes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Allocates an internet gateway for use with a VPC.
 *
 * After creating the Internet gateway, you then attach it to a VPC.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html
 */
export class CfnInternetGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::InternetGateway";

  /**
   * Build a CfnInternetGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnInternetGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnInternetGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnInternetGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the internet gateway.
   *
   * @cloudformationAttribute InternetGatewayId
   */
  public readonly attrInternetGatewayId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags to assign to the internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html#cfn-ec2-internetgateway-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnInternetGatewayProps = {}) {
    super(scope, id, {
      "type": CfnInternetGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrInternetGatewayId = cdk.Token.asString(this.getAtt("InternetGatewayId", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::InternetGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnInternetGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnInternetGatewayPropsToCloudFormation(props);
  }
}

export namespace CfnInternetGateway {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-internetgateway-tag.html
   */
  export interface TagProperty {
    /**
     * Any tags to assign to the internet gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-internetgateway-tag.html#cfn-ec2-internetgateway-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnInternetGateway.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnInternetGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html
 */
export interface CfnInternetGatewayProps {
  /**
   * Any tags to assign to the internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html#cfn-ec2-internetgateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInternetGatewayTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnInternetGatewayTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnInternetGatewayTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInternetGatewayTagPropertyValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(convertCfnInternetGatewayTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnInternetGatewayTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnInternetGateway.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInternetGateway.TagProperty>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnInternetGatewayTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnInternetGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnInternetGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnInternetGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnInternetGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnInternetGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnInternetGatewayPropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnInternetGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnInternetGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnInternetGatewayProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * IPAM is a VPC feature that you can use to automate your IP address management workflows including assigning, tracking, troubleshooting, and auditing IP addresses across AWS Regions and accounts throughout your AWS Organization.
 *
 * For more information, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html
 */
export class CfnIPAM extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAM";

  /**
   * Build a CfnIPAM from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAM {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAM(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the IPAM.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ID of the IPAM.
   *
   * @cloudformationAttribute IpamId
   */
  public readonly attrIpamId: string;

  /**
   * The ID of the IPAM's default private scope.
   *
   * @cloudformationAttribute PrivateDefaultScopeId
   */
  public readonly attrPrivateDefaultScopeId: string;

  /**
   * The ID of the IPAM's default public scope.
   *
   * @cloudformationAttribute PublicDefaultScopeId
   */
  public readonly attrPublicDefaultScopeId: string;

  /**
   * The number of scopes in the IPAM. The scope quota is 5.
   *
   * @cloudformationAttribute ScopeCount
   */
  public readonly attrScopeCount: cdk.IResolvable;

  /**
   * The IPAM's default resource discovery association ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-defaultresourcediscoveryassociationid
   */
  public defaultResourceDiscoveryAssociationId?: string;

  /**
   * The IPAM's default resource discovery ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-defaultresourcediscoveryid
   */
  public defaultResourceDiscoveryId?: string;

  /**
   * The description for the IPAM.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-description
   */
  public description?: string;

  /**
   * The operating Regions for an IPAM.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-operatingregions
   */
  public operatingRegions?: Array<CfnIPAM.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The IPAM's resource discovery association count.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-resourcediscoveryassociationcount
   */
  public resourceDiscoveryAssociationCount?: number;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The key/value combination of a tag assigned to the resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMProps = {}) {
    super(scope, id, {
      "type": CfnIPAM.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamId = cdk.Token.asString(this.getAtt("IpamId", cdk.ResolutionTypeHint.STRING));
    this.attrPrivateDefaultScopeId = cdk.Token.asString(this.getAtt("PrivateDefaultScopeId", cdk.ResolutionTypeHint.STRING));
    this.attrPublicDefaultScopeId = cdk.Token.asString(this.getAtt("PublicDefaultScopeId", cdk.ResolutionTypeHint.STRING));
    this.attrScopeCount = this.getAtt("ScopeCount", cdk.ResolutionTypeHint.NUMBER);
    this.defaultResourceDiscoveryAssociationId = props.defaultResourceDiscoveryAssociationId;
    this.defaultResourceDiscoveryId = props.defaultResourceDiscoveryId;
    this.description = props.description;
    this.operatingRegions = props.operatingRegions;
    this.resourceDiscoveryAssociationCount = props.resourceDiscoveryAssociationCount;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAM", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "defaultResourceDiscoveryAssociationId": this.defaultResourceDiscoveryAssociationId,
      "defaultResourceDiscoveryId": this.defaultResourceDiscoveryId,
      "description": this.description,
      "operatingRegions": this.operatingRegions,
      "resourceDiscoveryAssociationCount": this.resourceDiscoveryAssociationCount,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAM.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMPropsToCloudFormation(props);
  }
}

export namespace CfnIPAM {
  /**
   * The operating Regions for an IPAM.
   *
   * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
   *
   * For more information about operating Regions, see [Create an IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html
   */
  export interface IpamOperatingRegionProperty {
    /**
     * The IPAM's default resource discovery association ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html#cfn-ec2-ipam-ipamoperatingregion-defaultresourcediscoveryassociationid
     */
    readonly defaultResourceDiscoveryAssociationId?: string;

    /**
     * The IPAM's default resource discovery ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html#cfn-ec2-ipam-ipamoperatingregion-defaultresourcediscoveryid
     */
    readonly defaultResourceDiscoveryId?: string;

    /**
     * The description for the IPAM.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html#cfn-ec2-ipam-ipamoperatingregion-description
     */
    readonly description?: string;

    /**
     * The operating Regions for an IPAM.
     *
     * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
     *
     * For more information about operating Regions, see [Create an IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html) in the *Amazon VPC IPAM User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html#cfn-ec2-ipam-ipamoperatingregion-operatingregions
     */
    readonly operatingRegions?: Array<CfnIPAM.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The IPAM's resource discovery association count.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html#cfn-ec2-ipam-ipamoperatingregion-resourcediscoveryassociationcount
     */
    readonly resourceDiscoveryAssociationCount?: number;

    /**
     * The key/value combination of a tag assigned to the resource.
     *
     * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key \`Owner\` and the value \`TeamA\` , specify \`tag:Owner\` for the filter name and \`TeamA\` for the filter value.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html#cfn-ec2-ipam-ipamoperatingregion-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnIPAM.TagProperty> | cdk.IResolvable;
  }

  /**
   * A key-value pair to associate with a resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-tag.html
   */
  export interface TagProperty {
    /**
     * The IPAM's default resource discovery association ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-tag.html#cfn-ec2-ipam-tag-defaultresourcediscoveryassociationid
     */
    readonly defaultResourceDiscoveryAssociationId?: string;

    /**
     * The IPAM's default resource discovery ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-tag.html#cfn-ec2-ipam-tag-defaultresourcediscoveryid
     */
    readonly defaultResourceDiscoveryId?: string;

    /**
     * The description for the IPAM.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-tag.html#cfn-ec2-ipam-tag-description
     */
    readonly description?: string;

    /**
     * The operating Regions for an IPAM.
     *
     * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
     *
     * For more information about operating Regions, see [Create an IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html) in the *Amazon VPC IPAM User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-tag.html#cfn-ec2-ipam-tag-operatingregions
     */
    readonly operatingRegions?: Array<CfnIPAM.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The IPAM's resource discovery association count.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-tag.html#cfn-ec2-ipam-tag-resourcediscoveryassociationcount
     */
    readonly resourceDiscoveryAssociationCount?: number;

    /**
     * The key/value combination of a tag assigned to the resource.
     *
     * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key \`Owner\` and the value \`TeamA\` , specify \`tag:Owner\` for the filter name and \`TeamA\` for the filter value.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-tag.html#cfn-ec2-ipam-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnIPAM.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnIPAM\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html
 */
export interface CfnIPAMProps {
  /**
   * The IPAM's default resource discovery association ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-defaultresourcediscoveryassociationid
   */
  readonly defaultResourceDiscoveryAssociationId?: string;

  /**
   * The IPAM's default resource discovery ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-defaultresourcediscoveryid
   */
  readonly defaultResourceDiscoveryId?: string;

  /**
   * The description for the IPAM.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-description
   */
  readonly description?: string;

  /**
   * The operating Regions for an IPAM.
   *
   * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
   *
   * For more information about operating Regions, see [Create an IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-operatingregions
   */
  readonly operatingRegions?: Array<CfnIPAM.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The IPAM's resource discovery association count.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-resourcediscoveryassociationcount
   */
  readonly resourceDiscoveryAssociationCount?: number;

  /**
   * The key/value combination of a tag assigned to the resource.
   *
   * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key \`Owner\` and the value \`TeamA\` , specify \`tag:Owner\` for the filter name and \`TeamA\` for the filter value.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("defaultResourceDiscoveryAssociationId", cdk.validateString)(properties.defaultResourceDiscoveryAssociationId));
  errors.collect(cdk.propertyValidator("defaultResourceDiscoveryId", cdk.validateString)(properties.defaultResourceDiscoveryId));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("operatingRegions", cdk.listValidator(CfnIPAMIpamOperatingRegionPropertyValidator))(properties.operatingRegions));
  errors.collect(cdk.propertyValidator("resourceDiscoveryAssociationCount", cdk.validateNumber)(properties.resourceDiscoveryAssociationCount));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnIPAMTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMTagPropertyValidator(properties).assertSuccess();
  return {
    "DefaultResourceDiscoveryAssociationId": cdk.stringToCloudFormation(properties.defaultResourceDiscoveryAssociationId),
    "DefaultResourceDiscoveryId": cdk.stringToCloudFormation(properties.defaultResourceDiscoveryId),
    "Description": cdk.stringToCloudFormation(properties.description),
    "OperatingRegions": cdk.listMapper(convertCfnIPAMIpamOperatingRegionPropertyToCloudFormation)(properties.operatingRegions),
    "ResourceDiscoveryAssociationCount": cdk.numberToCloudFormation(properties.resourceDiscoveryAssociationCount),
    "Tags": cdk.listMapper(convertCfnIPAMTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnIPAM.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAM.TagProperty>();
  ret.addPropertyResult("defaultResourceDiscoveryAssociationId", "DefaultResourceDiscoveryAssociationId", (properties.DefaultResourceDiscoveryAssociationId != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultResourceDiscoveryAssociationId) : undefined));
  ret.addPropertyResult("defaultResourceDiscoveryId", "DefaultResourceDiscoveryId", (properties.DefaultResourceDiscoveryId != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultResourceDiscoveryId) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("operatingRegions", "OperatingRegions", (properties.OperatingRegions != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMIpamOperatingRegionPropertyFromCloudFormation)(properties.OperatingRegions) : undefined));
  ret.addPropertyResult("resourceDiscoveryAssociationCount", "ResourceDiscoveryAssociationCount", (properties.ResourceDiscoveryAssociationCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.ResourceDiscoveryAssociationCount) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`IpamOperatingRegionProperty\`
 *
 * @param properties - the TypeScript properties of a \`IpamOperatingRegionProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMIpamOperatingRegionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("defaultResourceDiscoveryAssociationId", cdk.validateString)(properties.defaultResourceDiscoveryAssociationId));
  errors.collect(cdk.propertyValidator("defaultResourceDiscoveryId", cdk.validateString)(properties.defaultResourceDiscoveryId));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("operatingRegions", cdk.listValidator(CfnIPAMIpamOperatingRegionPropertyValidator))(properties.operatingRegions));
  errors.collect(cdk.propertyValidator("resourceDiscoveryAssociationCount", cdk.validateNumber)(properties.resourceDiscoveryAssociationCount));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnIPAMTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"IpamOperatingRegionProperty\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMIpamOperatingRegionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMIpamOperatingRegionPropertyValidator(properties).assertSuccess();
  return {
    "DefaultResourceDiscoveryAssociationId": cdk.stringToCloudFormation(properties.defaultResourceDiscoveryAssociationId),
    "DefaultResourceDiscoveryId": cdk.stringToCloudFormation(properties.defaultResourceDiscoveryId),
    "Description": cdk.stringToCloudFormation(properties.description),
    "OperatingRegions": cdk.listMapper(convertCfnIPAMIpamOperatingRegionPropertyToCloudFormation)(properties.operatingRegions),
    "ResourceDiscoveryAssociationCount": cdk.numberToCloudFormation(properties.resourceDiscoveryAssociationCount),
    "Tags": cdk.listMapper(convertCfnIPAMTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMIpamOperatingRegionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAM.IpamOperatingRegionProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAM.IpamOperatingRegionProperty>();
  ret.addPropertyResult("defaultResourceDiscoveryAssociationId", "DefaultResourceDiscoveryAssociationId", (properties.DefaultResourceDiscoveryAssociationId != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultResourceDiscoveryAssociationId) : undefined));
  ret.addPropertyResult("defaultResourceDiscoveryId", "DefaultResourceDiscoveryId", (properties.DefaultResourceDiscoveryId != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultResourceDiscoveryId) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("operatingRegions", "OperatingRegions", (properties.OperatingRegions != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMIpamOperatingRegionPropertyFromCloudFormation)(properties.OperatingRegions) : undefined));
  ret.addPropertyResult("resourceDiscoveryAssociationCount", "ResourceDiscoveryAssociationCount", (properties.ResourceDiscoveryAssociationCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.ResourceDiscoveryAssociationCount) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("defaultResourceDiscoveryAssociationId", cdk.validateString)(properties.defaultResourceDiscoveryAssociationId));
  errors.collect(cdk.propertyValidator("defaultResourceDiscoveryId", cdk.validateString)(properties.defaultResourceDiscoveryId));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("operatingRegions", cdk.listValidator(CfnIPAMIpamOperatingRegionPropertyValidator))(properties.operatingRegions));
  errors.collect(cdk.propertyValidator("resourceDiscoveryAssociationCount", cdk.validateNumber)(properties.resourceDiscoveryAssociationCount));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPropsValidator(properties).assertSuccess();
  return {
    "DefaultResourceDiscoveryAssociationId": cdk.stringToCloudFormation(properties.defaultResourceDiscoveryAssociationId),
    "DefaultResourceDiscoveryId": cdk.stringToCloudFormation(properties.defaultResourceDiscoveryId),
    "Description": cdk.stringToCloudFormation(properties.description),
    "OperatingRegions": cdk.listMapper(convertCfnIPAMIpamOperatingRegionPropertyToCloudFormation)(properties.operatingRegions),
    "ResourceDiscoveryAssociationCount": cdk.numberToCloudFormation(properties.resourceDiscoveryAssociationCount),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMProps>();
  ret.addPropertyResult("defaultResourceDiscoveryAssociationId", "DefaultResourceDiscoveryAssociationId", (properties.DefaultResourceDiscoveryAssociationId != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultResourceDiscoveryAssociationId) : undefined));
  ret.addPropertyResult("defaultResourceDiscoveryId", "DefaultResourceDiscoveryId", (properties.DefaultResourceDiscoveryId != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultResourceDiscoveryId) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("operatingRegions", "OperatingRegions", (properties.OperatingRegions != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMIpamOperatingRegionPropertyFromCloudFormation)(properties.OperatingRegions) : undefined));
  ret.addPropertyResult("resourceDiscoveryAssociationCount", "ResourceDiscoveryAssociationCount", (properties.ResourceDiscoveryAssociationCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.ResourceDiscoveryAssociationCount) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * In IPAM, an allocation is a CIDR assignment from an IPAM pool to another IPAM pool or to a resource.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html
 */
export class CfnIPAMAllocation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMAllocation";

  /**
   * Build a CfnIPAMAllocation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMAllocation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMAllocationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMAllocation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of an allocation.
   *
   * @cloudformationAttribute IpamPoolAllocationId
   */
  public readonly attrIpamPoolAllocationId: string;

  /**
   * The CIDR you would like to allocate from the IPAM pool. Note the following:.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-cidr
   */
  public cidr?: string;

  /**
   * A description for the allocation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-description
   */
  public description?: string;

  /**
   * The ID of the IPAM pool from which you would like to allocate a CIDR.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-ipampoolid
   */
  public ipamPoolId: string;

  /**
   * The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-netmasklength
   */
  public netmaskLength?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMAllocationProps) {
    super(scope, id, {
      "type": CfnIPAMAllocation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipamPoolId", this);

    this.attrIpamPoolAllocationId = cdk.Token.asString(this.getAtt("IpamPoolAllocationId", cdk.ResolutionTypeHint.STRING));
    this.cidr = props.cidr;
    this.description = props.description;
    this.ipamPoolId = props.ipamPoolId;
    this.netmaskLength = props.netmaskLength;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidr": this.cidr,
      "description": this.description,
      "ipamPoolId": this.ipamPoolId,
      "netmaskLength": this.netmaskLength
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMAllocation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMAllocationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnIPAMAllocation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html
 */
export interface CfnIPAMAllocationProps {
  /**
   * The CIDR you would like to allocate from the IPAM pool. Note the following:.
   *
   * - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.
   * - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.
   *
   * Possible values: Any available IPv4 or IPv6 CIDR.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-cidr
   */
  readonly cidr?: string;

  /**
   * A description for the allocation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-description
   */
  readonly description?: string;

  /**
   * The ID of the IPAM pool from which you would like to allocate a CIDR.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-ipampoolid
   */
  readonly ipamPoolId: string;

  /**
   * The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:.
   *
   * - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.
   * - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.
   *
   * Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-netmasklength
   */
  readonly netmaskLength?: number;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMAllocationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMAllocationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMAllocationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("ipamPoolId", cdk.requiredValidator)(properties.ipamPoolId));
  errors.collect(cdk.propertyValidator("ipamPoolId", cdk.validateString)(properties.ipamPoolId));
  errors.collect(cdk.propertyValidator("netmaskLength", cdk.validateNumber)(properties.netmaskLength));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMAllocationProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMAllocationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMAllocationPropsValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr),
    "Description": cdk.stringToCloudFormation(properties.description),
    "IpamPoolId": cdk.stringToCloudFormation(properties.ipamPoolId),
    "NetmaskLength": cdk.numberToCloudFormation(properties.netmaskLength)
  };
}

// @ts-ignore TS6133
function CfnIPAMAllocationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMAllocationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMAllocationProps>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("ipamPoolId", "IpamPoolId", (properties.IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamPoolId) : undefined));
  ret.addPropertyResult("netmaskLength", "NetmaskLength", (properties.NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.NetmaskLength) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * In IPAM, a pool is a collection of contiguous IP addresses CIDRs.
 *
 * Pools enable you to organize your IP addresses according to your routing and security needs. For example, if you have separate routing and security needs for development and production applications, you can create a pool for each.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html
 */
export class CfnIPAMPool extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMPool";

  /**
   * Build a CfnIPAMPool from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMPool {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMPoolPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMPool(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the IPAM pool.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ARN of the IPAM.
   *
   * @cloudformationAttribute IpamArn
   */
  public readonly attrIpamArn: string;

  /**
   * The ID of the IPAM pool.
   *
   * @cloudformationAttribute IpamPoolId
   */
  public readonly attrIpamPoolId: string;

  /**
   * The ARN of the scope of the IPAM pool.
   *
   * @cloudformationAttribute IpamScopeArn
   */
  public readonly attrIpamScopeArn: string;

  /**
   * The scope of the IPAM.
   *
   * @cloudformationAttribute IpamScopeType
   */
  public readonly attrIpamScopeType: string;

  /**
   * The depth of pools in your IPAM pool. The pool depth quota is 10.
   *
   * @cloudformationAttribute PoolDepth
   */
  public readonly attrPoolDepth: cdk.IResolvable;

  /**
   * The state of the IPAM pool.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * A message related to the failed creation of an IPAM pool.
   *
   * @cloudformationAttribute StateMessage
   */
  public readonly attrStateMessage: string;

  /**
   * The address family of the pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-addressfamily
   */
  public addressFamily: string;

  /**
   * The default netmask length for allocations added to this pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationdefaultnetmasklength
   */
  public allocationDefaultNetmaskLength?: number;

  /**
   * The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationmaxnetmasklength
   */
  public allocationMaxNetmaskLength?: number;

  /**
   * The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationminnetmasklength
   */
  public allocationMinNetmaskLength?: number;

  /**
   * Tags that are required for resources that use CIDRs from this IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationresourcetags
   */
  public allocationResourceTags?: Array<cdk.IResolvable | CfnIPAMPool.TagProperty> | cdk.IResolvable;

  /**
   * If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-autoimport
   */
  public autoImport?: boolean | cdk.IResolvable;

  /**
   * Limits which service in AWS that the pool can be used in.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-awsservice
   */
  public awsService?: string;

  /**
   * The description of the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-description
   */
  public description?: string;

  /**
   * The ID of the scope in which you would like to create the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-ipamscopeid
   */
  public ipamScopeId: string;

  /**
   * The locale of the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-locale
   */
  public locale?: string;

  /**
   * Information about the CIDRs provisioned to an IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-provisionedcidrs
   */
  public provisionedCidrs?: Array<cdk.IResolvable | CfnIPAMPool.ProvisionedCidrProperty> | cdk.IResolvable;

  /**
   * The IP address source for pools in the public scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publicipsource
   */
  public publicIpSource?: string;

  /**
   * Determines if a pool is publicly advertisable.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publiclyadvertisable
   */
  public publiclyAdvertisable?: boolean | cdk.IResolvable;

  /**
   * The ID of the source IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-sourceipampoolid
   */
  public sourceIpamPoolId?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The key/value combination of a tag assigned to the resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMPoolProps) {
    super(scope, id, {
      "type": CfnIPAMPool.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "addressFamily", this);
    cdk.requireProperty(props, "ipamScopeId", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamArn = cdk.Token.asString(this.getAtt("IpamArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamPoolId = cdk.Token.asString(this.getAtt("IpamPoolId", cdk.ResolutionTypeHint.STRING));
    this.attrIpamScopeArn = cdk.Token.asString(this.getAtt("IpamScopeArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamScopeType = cdk.Token.asString(this.getAtt("IpamScopeType", cdk.ResolutionTypeHint.STRING));
    this.attrPoolDepth = this.getAtt("PoolDepth", cdk.ResolutionTypeHint.NUMBER);
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrStateMessage = cdk.Token.asString(this.getAtt("StateMessage", cdk.ResolutionTypeHint.STRING));
    this.addressFamily = props.addressFamily;
    this.allocationDefaultNetmaskLength = props.allocationDefaultNetmaskLength;
    this.allocationMaxNetmaskLength = props.allocationMaxNetmaskLength;
    this.allocationMinNetmaskLength = props.allocationMinNetmaskLength;
    this.allocationResourceTags = props.allocationResourceTags;
    this.autoImport = props.autoImport;
    this.awsService = props.awsService;
    this.description = props.description;
    this.ipamScopeId = props.ipamScopeId;
    this.locale = props.locale;
    this.provisionedCidrs = props.provisionedCidrs;
    this.publicIpSource = props.publicIpSource;
    this.publiclyAdvertisable = props.publiclyAdvertisable;
    this.sourceIpamPoolId = props.sourceIpamPoolId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAMPool", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "addressFamily": this.addressFamily,
      "allocationDefaultNetmaskLength": this.allocationDefaultNetmaskLength,
      "allocationMaxNetmaskLength": this.allocationMaxNetmaskLength,
      "allocationMinNetmaskLength": this.allocationMinNetmaskLength,
      "allocationResourceTags": this.allocationResourceTags,
      "autoImport": this.autoImport,
      "awsService": this.awsService,
      "description": this.description,
      "ipamScopeId": this.ipamScopeId,
      "locale": this.locale,
      "provisionedCidrs": this.provisionedCidrs,
      "publicIpSource": this.publicIpSource,
      "publiclyAdvertisable": this.publiclyAdvertisable,
      "sourceIpamPoolId": this.sourceIpamPoolId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMPool.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMPoolPropsToCloudFormation(props);
  }
}

export namespace CfnIPAMPool {
  /**
   * A key-value pair to associate with a resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html
   */
  export interface TagProperty {
    /**
     * The address family of the pool.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-addressfamily
     */
    readonly addressFamily: string;

    /**
     * The default netmask length for allocations added to this pool.
     *
     * If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-allocationdefaultnetmasklength
     */
    readonly allocationDefaultNetmaskLength?: number;

    /**
     * The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant.
     *
     * The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-allocationmaxnetmasklength
     */
    readonly allocationMaxNetmaskLength?: number;

    /**
     * The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant.
     *
     * The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-allocationminnetmasklength
     */
    readonly allocationMinNetmaskLength?: number;

    /**
     * Tags that are required for resources that use CIDRs from this IPAM pool.
     *
     * Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-allocationresourcetags
     */
    readonly allocationResourceTags?: Array<cdk.IResolvable | CfnIPAMPool.TagProperty> | cdk.IResolvable;

    /**
     * If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
     *
     * The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only.
     *
     * A locale must be set on the pool for this feature to work.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-autoimport
     */
    readonly autoImport?: boolean | cdk.IResolvable;

    /**
     * Limits which service in AWS that the pool can be used in.
     *
     * "ec2", for example, allows users to use space for Elastic IP addresses and VPCs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-awsservice
     */
    readonly awsService?: string;

    /**
     * The description of the IPAM pool.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-description
     */
    readonly description?: string;

    /**
     * The ID of the scope in which you would like to create the IPAM pool.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-ipamscopeid
     */
    readonly ipamScopeId: string;

    /**
     * The locale of the IPAM pool.
     *
     * In IPAM, the locale is the AWS Region where you want to make an IPAM pool available for allocations. Only resources in the same Region as the locale of the pool can get IP address allocations from the pool. You can only allocate a CIDR for a VPC, for example, from an IPAM pool that shares a locale with the VPC’s Region. Note that once you choose a Locale for a pool, you cannot modify it. If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-locale
     */
    readonly locale?: string;

    /**
     * Information about the CIDRs provisioned to an IPAM pool.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-provisionedcidrs
     */
    readonly provisionedCidrs?: Array<cdk.IResolvable | CfnIPAMPool.ProvisionedCidrProperty> | cdk.IResolvable;

    /**
     * The IP address source for pools in the public scope.
     *
     * Only used for provisioning IP address CIDRs to pools in the public scope. Default is \`BYOIP\` . For more information, see [Create IPv6 pools](https://docs.aws.amazon.com//vpc/latest/ipam/intro-create-ipv6-pools.html) in the *Amazon VPC IPAM User Guide* . By default, you can add only one Amazon-provided IPv6 CIDR block to a top-level IPv6 pool. For information on increasing the default limit, see [Quotas for your IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/quotas-ipam.html) in the *Amazon VPC IPAM User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-publicipsource
     */
    readonly publicIpSource?: string;

    /**
     * Determines if a pool is publicly advertisable.
     *
     * This option is not available for pools with AddressFamily set to \`ipv4\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-publiclyadvertisable
     */
    readonly publiclyAdvertisable?: boolean | cdk.IResolvable;

    /**
     * The ID of the source IPAM pool.
     *
     * You can use this option to create an IPAM pool within an existing source pool.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-sourceipampoolid
     */
    readonly sourceIpamPoolId?: string;

    /**
     * The key/value combination of a tag assigned to the resource.
     *
     * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key \`Owner\` and the value \`TeamA\` , specify \`tag:Owner\` for the filter name and \`TeamA\` for the filter value.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-tag.html#cfn-ec2-ipampool-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnIPAMPool.TagProperty> | cdk.IResolvable;
  }

  /**
   * The CIDR provisioned to the IPAM pool.
   *
   * A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is \`10.24.34.0/23\` . An IPv6 CIDR example is \`2001:DB8::/32\` .
   *
   * > This resource type does not allow you to provision a CIDR using the netmask length. To provision a CIDR using netmask length, use [AWS::EC2::IPAMPoolCidr](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html
   */
  export interface ProvisionedCidrProperty {
    /**
     * The address family of the pool.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-addressfamily
     */
    readonly addressFamily: string;

    /**
     * The default netmask length for allocations added to this pool.
     *
     * If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-allocationdefaultnetmasklength
     */
    readonly allocationDefaultNetmaskLength?: number;

    /**
     * The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant.
     *
     * The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-allocationmaxnetmasklength
     */
    readonly allocationMaxNetmaskLength?: number;

    /**
     * The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant.
     *
     * The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-allocationminnetmasklength
     */
    readonly allocationMinNetmaskLength?: number;

    /**
     * Tags that are required for resources that use CIDRs from this IPAM pool.
     *
     * Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-allocationresourcetags
     */
    readonly allocationResourceTags?: Array<cdk.IResolvable | CfnIPAMPool.TagProperty> | cdk.IResolvable;

    /**
     * If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
     *
     * The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only.
     *
     * A locale must be set on the pool for this feature to work.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-autoimport
     */
    readonly autoImport?: boolean | cdk.IResolvable;

    /**
     * Limits which service in AWS that the pool can be used in.
     *
     * "ec2", for example, allows users to use space for Elastic IP addresses and VPCs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-awsservice
     */
    readonly awsService?: string;

    /**
     * The description of the IPAM pool.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-description
     */
    readonly description?: string;

    /**
     * The ID of the scope in which you would like to create the IPAM pool.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-ipamscopeid
     */
    readonly ipamScopeId: string;

    /**
     * The locale of the IPAM pool.
     *
     * In IPAM, the locale is the AWS Region where you want to make an IPAM pool available for allocations. Only resources in the same Region as the locale of the pool can get IP address allocations from the pool. You can only allocate a CIDR for a VPC, for example, from an IPAM pool that shares a locale with the VPC’s Region. Note that once you choose a Locale for a pool, you cannot modify it. If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-locale
     */
    readonly locale?: string;

    /**
     * Information about the CIDRs provisioned to an IPAM pool.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-provisionedcidrs
     */
    readonly provisionedCidrs?: Array<cdk.IResolvable | CfnIPAMPool.ProvisionedCidrProperty> | cdk.IResolvable;

    /**
     * The IP address source for pools in the public scope.
     *
     * Only used for provisioning IP address CIDRs to pools in the public scope. Default is \`BYOIP\` . For more information, see [Create IPv6 pools](https://docs.aws.amazon.com//vpc/latest/ipam/intro-create-ipv6-pools.html) in the *Amazon VPC IPAM User Guide* . By default, you can add only one Amazon-provided IPv6 CIDR block to a top-level IPv6 pool. For information on increasing the default limit, see [Quotas for your IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/quotas-ipam.html) in the *Amazon VPC IPAM User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-publicipsource
     */
    readonly publicIpSource?: string;

    /**
     * Determines if a pool is publicly advertisable.
     *
     * This option is not available for pools with AddressFamily set to \`ipv4\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-publiclyadvertisable
     */
    readonly publiclyAdvertisable?: boolean | cdk.IResolvable;

    /**
     * The ID of the source IPAM pool.
     *
     * You can use this option to create an IPAM pool within an existing source pool.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-sourceipampoolid
     */
    readonly sourceIpamPoolId?: string;

    /**
     * The key/value combination of a tag assigned to the resource.
     *
     * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key \`Owner\` and the value \`TeamA\` , specify \`tag:Owner\` for the filter name and \`TeamA\` for the filter value.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnIPAMPool.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnIPAMPool\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html
 */
export interface CfnIPAMPoolProps {
  /**
   * The address family of the pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-addressfamily
   */
  readonly addressFamily: string;

  /**
   * The default netmask length for allocations added to this pool.
   *
   * If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationdefaultnetmasklength
   */
  readonly allocationDefaultNetmaskLength?: number;

  /**
   * The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant.
   *
   * The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationmaxnetmasklength
   */
  readonly allocationMaxNetmaskLength?: number;

  /**
   * The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant.
   *
   * The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationminnetmasklength
   */
  readonly allocationMinNetmaskLength?: number;

  /**
   * Tags that are required for resources that use CIDRs from this IPAM pool.
   *
   * Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationresourcetags
   */
  readonly allocationResourceTags?: Array<cdk.IResolvable | CfnIPAMPool.TagProperty> | cdk.IResolvable;

  /**
   * If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
   *
   * The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only.
   *
   * A locale must be set on the pool for this feature to work.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-autoimport
   */
  readonly autoImport?: boolean | cdk.IResolvable;

  /**
   * Limits which service in AWS that the pool can be used in.
   *
   * "ec2", for example, allows users to use space for Elastic IP addresses and VPCs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-awsservice
   */
  readonly awsService?: string;

  /**
   * The description of the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-description
   */
  readonly description?: string;

  /**
   * The ID of the scope in which you would like to create the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-ipamscopeid
   */
  readonly ipamScopeId: string;

  /**
   * The locale of the IPAM pool.
   *
   * In IPAM, the locale is the AWS Region where you want to make an IPAM pool available for allocations. Only resources in the same Region as the locale of the pool can get IP address allocations from the pool. You can only allocate a CIDR for a VPC, for example, from an IPAM pool that shares a locale with the VPC’s Region. Note that once you choose a Locale for a pool, you cannot modify it. If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-locale
   */
  readonly locale?: string;

  /**
   * Information about the CIDRs provisioned to an IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-provisionedcidrs
   */
  readonly provisionedCidrs?: Array<cdk.IResolvable | CfnIPAMPool.ProvisionedCidrProperty> | cdk.IResolvable;

  /**
   * The IP address source for pools in the public scope.
   *
   * Only used for provisioning IP address CIDRs to pools in the public scope. Default is \`BYOIP\` . For more information, see [Create IPv6 pools](https://docs.aws.amazon.com//vpc/latest/ipam/intro-create-ipv6-pools.html) in the *Amazon VPC IPAM User Guide* . By default, you can add only one Amazon-provided IPv6 CIDR block to a top-level IPv6 pool. For information on increasing the default limit, see [Quotas for your IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/quotas-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publicipsource
   */
  readonly publicIpSource?: string;

  /**
   * Determines if a pool is publicly advertisable.
   *
   * This option is not available for pools with AddressFamily set to \`ipv4\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publiclyadvertisable
   */
  readonly publiclyAdvertisable?: boolean | cdk.IResolvable;

  /**
   * The ID of the source IPAM pool.
   *
   * You can use this option to create an IPAM pool within an existing source pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-sourceipampoolid
   */
  readonly sourceIpamPoolId?: string;

  /**
   * The key/value combination of a tag assigned to the resource.
   *
   * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key \`Owner\` and the value \`TeamA\` , specify \`tag:Owner\` for the filter name and \`TeamA\` for the filter value.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`ProvisionedCidrProperty\`
 *
 * @param properties - the TypeScript properties of a \`ProvisionedCidrProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPoolProvisionedCidrPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addressFamily", cdk.requiredValidator)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("addressFamily", cdk.validateString)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("allocationDefaultNetmaskLength", cdk.validateNumber)(properties.allocationDefaultNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationMaxNetmaskLength", cdk.validateNumber)(properties.allocationMaxNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationMinNetmaskLength", cdk.validateNumber)(properties.allocationMinNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationResourceTags", cdk.listValidator(CfnIPAMPoolTagPropertyValidator))(properties.allocationResourceTags));
  errors.collect(cdk.propertyValidator("autoImport", cdk.validateBoolean)(properties.autoImport));
  errors.collect(cdk.propertyValidator("awsService", cdk.validateString)(properties.awsService));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("ipamScopeId", cdk.requiredValidator)(properties.ipamScopeId));
  errors.collect(cdk.propertyValidator("ipamScopeId", cdk.validateString)(properties.ipamScopeId));
  errors.collect(cdk.propertyValidator("locale", cdk.validateString)(properties.locale));
  errors.collect(cdk.propertyValidator("provisionedCidrs", cdk.listValidator(CfnIPAMPoolProvisionedCidrPropertyValidator))(properties.provisionedCidrs));
  errors.collect(cdk.propertyValidator("publicIpSource", cdk.validateString)(properties.publicIpSource));
  errors.collect(cdk.propertyValidator("publiclyAdvertisable", cdk.validateBoolean)(properties.publiclyAdvertisable));
  errors.collect(cdk.propertyValidator("sourceIpamPoolId", cdk.validateString)(properties.sourceIpamPoolId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnIPAMPoolTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"ProvisionedCidrProperty\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPoolProvisionedCidrPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPoolProvisionedCidrPropertyValidator(properties).assertSuccess();
  return {
    "AddressFamily": cdk.stringToCloudFormation(properties.addressFamily),
    "AllocationDefaultNetmaskLength": cdk.numberToCloudFormation(properties.allocationDefaultNetmaskLength),
    "AllocationMaxNetmaskLength": cdk.numberToCloudFormation(properties.allocationMaxNetmaskLength),
    "AllocationMinNetmaskLength": cdk.numberToCloudFormation(properties.allocationMinNetmaskLength),
    "AllocationResourceTags": cdk.listMapper(convertCfnIPAMPoolTagPropertyToCloudFormation)(properties.allocationResourceTags),
    "AutoImport": cdk.booleanToCloudFormation(properties.autoImport),
    "AwsService": cdk.stringToCloudFormation(properties.awsService),
    "Description": cdk.stringToCloudFormation(properties.description),
    "IpamScopeId": cdk.stringToCloudFormation(properties.ipamScopeId),
    "Locale": cdk.stringToCloudFormation(properties.locale),
    "ProvisionedCidrs": cdk.listMapper(convertCfnIPAMPoolProvisionedCidrPropertyToCloudFormation)(properties.provisionedCidrs),
    "PublicIpSource": cdk.stringToCloudFormation(properties.publicIpSource),
    "PubliclyAdvertisable": cdk.booleanToCloudFormation(properties.publiclyAdvertisable),
    "SourceIpamPoolId": cdk.stringToCloudFormation(properties.sourceIpamPoolId),
    "Tags": cdk.listMapper(convertCfnIPAMPoolTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMPoolProvisionedCidrPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnIPAMPool.ProvisionedCidrProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMPool.ProvisionedCidrProperty>();
  ret.addPropertyResult("addressFamily", "AddressFamily", (properties.AddressFamily != null ? cfn_parse.FromCloudFormation.getString(properties.AddressFamily) : undefined));
  ret.addPropertyResult("allocationDefaultNetmaskLength", "AllocationDefaultNetmaskLength", (properties.AllocationDefaultNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationDefaultNetmaskLength) : undefined));
  ret.addPropertyResult("allocationMaxNetmaskLength", "AllocationMaxNetmaskLength", (properties.AllocationMaxNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationMaxNetmaskLength) : undefined));
  ret.addPropertyResult("allocationMinNetmaskLength", "AllocationMinNetmaskLength", (properties.AllocationMinNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationMinNetmaskLength) : undefined));
  ret.addPropertyResult("allocationResourceTags", "AllocationResourceTags", (properties.AllocationResourceTags != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMPoolTagPropertyFromCloudFormation)(properties.AllocationResourceTags) : undefined));
  ret.addPropertyResult("autoImport", "AutoImport", (properties.AutoImport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoImport) : undefined));
  ret.addPropertyResult("awsService", "AwsService", (properties.AwsService != null ? cfn_parse.FromCloudFormation.getString(properties.AwsService) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("ipamScopeId", "IpamScopeId", (properties.IpamScopeId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamScopeId) : undefined));
  ret.addPropertyResult("locale", "Locale", (properties.Locale != null ? cfn_parse.FromCloudFormation.getString(properties.Locale) : undefined));
  ret.addPropertyResult("provisionedCidrs", "ProvisionedCidrs", (properties.ProvisionedCidrs != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMPoolProvisionedCidrPropertyFromCloudFormation)(properties.ProvisionedCidrs) : undefined));
  ret.addPropertyResult("publicIpSource", "PublicIpSource", (properties.PublicIpSource != null ? cfn_parse.FromCloudFormation.getString(properties.PublicIpSource) : undefined));
  ret.addPropertyResult("publiclyAdvertisable", "PubliclyAdvertisable", (properties.PubliclyAdvertisable != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PubliclyAdvertisable) : undefined));
  ret.addPropertyResult("sourceIpamPoolId", "SourceIpamPoolId", (properties.SourceIpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceIpamPoolId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMPoolTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPoolTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addressFamily", cdk.requiredValidator)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("addressFamily", cdk.validateString)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("allocationDefaultNetmaskLength", cdk.validateNumber)(properties.allocationDefaultNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationMaxNetmaskLength", cdk.validateNumber)(properties.allocationMaxNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationMinNetmaskLength", cdk.validateNumber)(properties.allocationMinNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationResourceTags", cdk.listValidator(CfnIPAMPoolTagPropertyValidator))(properties.allocationResourceTags));
  errors.collect(cdk.propertyValidator("autoImport", cdk.validateBoolean)(properties.autoImport));
  errors.collect(cdk.propertyValidator("awsService", cdk.validateString)(properties.awsService));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("ipamScopeId", cdk.requiredValidator)(properties.ipamScopeId));
  errors.collect(cdk.propertyValidator("ipamScopeId", cdk.validateString)(properties.ipamScopeId));
  errors.collect(cdk.propertyValidator("locale", cdk.validateString)(properties.locale));
  errors.collect(cdk.propertyValidator("provisionedCidrs", cdk.listValidator(CfnIPAMPoolProvisionedCidrPropertyValidator))(properties.provisionedCidrs));
  errors.collect(cdk.propertyValidator("publicIpSource", cdk.validateString)(properties.publicIpSource));
  errors.collect(cdk.propertyValidator("publiclyAdvertisable", cdk.validateBoolean)(properties.publiclyAdvertisable));
  errors.collect(cdk.propertyValidator("sourceIpamPoolId", cdk.validateString)(properties.sourceIpamPoolId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnIPAMPoolTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPoolTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPoolTagPropertyValidator(properties).assertSuccess();
  return {
    "AddressFamily": cdk.stringToCloudFormation(properties.addressFamily),
    "AllocationDefaultNetmaskLength": cdk.numberToCloudFormation(properties.allocationDefaultNetmaskLength),
    "AllocationMaxNetmaskLength": cdk.numberToCloudFormation(properties.allocationMaxNetmaskLength),
    "AllocationMinNetmaskLength": cdk.numberToCloudFormation(properties.allocationMinNetmaskLength),
    "AllocationResourceTags": cdk.listMapper(convertCfnIPAMPoolTagPropertyToCloudFormation)(properties.allocationResourceTags),
    "AutoImport": cdk.booleanToCloudFormation(properties.autoImport),
    "AwsService": cdk.stringToCloudFormation(properties.awsService),
    "Description": cdk.stringToCloudFormation(properties.description),
    "IpamScopeId": cdk.stringToCloudFormation(properties.ipamScopeId),
    "Locale": cdk.stringToCloudFormation(properties.locale),
    "ProvisionedCidrs": cdk.listMapper(convertCfnIPAMPoolProvisionedCidrPropertyToCloudFormation)(properties.provisionedCidrs),
    "PublicIpSource": cdk.stringToCloudFormation(properties.publicIpSource),
    "PubliclyAdvertisable": cdk.booleanToCloudFormation(properties.publiclyAdvertisable),
    "SourceIpamPoolId": cdk.stringToCloudFormation(properties.sourceIpamPoolId),
    "Tags": cdk.listMapper(convertCfnIPAMPoolTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMPoolTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnIPAMPool.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMPool.TagProperty>();
  ret.addPropertyResult("addressFamily", "AddressFamily", (properties.AddressFamily != null ? cfn_parse.FromCloudFormation.getString(properties.AddressFamily) : undefined));
  ret.addPropertyResult("allocationDefaultNetmaskLength", "AllocationDefaultNetmaskLength", (properties.AllocationDefaultNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationDefaultNetmaskLength) : undefined));
  ret.addPropertyResult("allocationMaxNetmaskLength", "AllocationMaxNetmaskLength", (properties.AllocationMaxNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationMaxNetmaskLength) : undefined));
  ret.addPropertyResult("allocationMinNetmaskLength", "AllocationMinNetmaskLength", (properties.AllocationMinNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationMinNetmaskLength) : undefined));
  ret.addPropertyResult("allocationResourceTags", "AllocationResourceTags", (properties.AllocationResourceTags != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMPoolTagPropertyFromCloudFormation)(properties.AllocationResourceTags) : undefined));
  ret.addPropertyResult("autoImport", "AutoImport", (properties.AutoImport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoImport) : undefined));
  ret.addPropertyResult("awsService", "AwsService", (properties.AwsService != null ? cfn_parse.FromCloudFormation.getString(properties.AwsService) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("ipamScopeId", "IpamScopeId", (properties.IpamScopeId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamScopeId) : undefined));
  ret.addPropertyResult("locale", "Locale", (properties.Locale != null ? cfn_parse.FromCloudFormation.getString(properties.Locale) : undefined));
  ret.addPropertyResult("provisionedCidrs", "ProvisionedCidrs", (properties.ProvisionedCidrs != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMPoolProvisionedCidrPropertyFromCloudFormation)(properties.ProvisionedCidrs) : undefined));
  ret.addPropertyResult("publicIpSource", "PublicIpSource", (properties.PublicIpSource != null ? cfn_parse.FromCloudFormation.getString(properties.PublicIpSource) : undefined));
  ret.addPropertyResult("publiclyAdvertisable", "PubliclyAdvertisable", (properties.PubliclyAdvertisable != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PubliclyAdvertisable) : undefined));
  ret.addPropertyResult("sourceIpamPoolId", "SourceIpamPoolId", (properties.SourceIpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceIpamPoolId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMPoolTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMPoolProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMPoolProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPoolPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addressFamily", cdk.requiredValidator)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("addressFamily", cdk.validateString)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("allocationDefaultNetmaskLength", cdk.validateNumber)(properties.allocationDefaultNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationMaxNetmaskLength", cdk.validateNumber)(properties.allocationMaxNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationMinNetmaskLength", cdk.validateNumber)(properties.allocationMinNetmaskLength));
  errors.collect(cdk.propertyValidator("allocationResourceTags", cdk.listValidator(CfnIPAMPoolTagPropertyValidator))(properties.allocationResourceTags));
  errors.collect(cdk.propertyValidator("autoImport", cdk.validateBoolean)(properties.autoImport));
  errors.collect(cdk.propertyValidator("awsService", cdk.validateString)(properties.awsService));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("ipamScopeId", cdk.requiredValidator)(properties.ipamScopeId));
  errors.collect(cdk.propertyValidator("ipamScopeId", cdk.validateString)(properties.ipamScopeId));
  errors.collect(cdk.propertyValidator("locale", cdk.validateString)(properties.locale));
  errors.collect(cdk.propertyValidator("provisionedCidrs", cdk.listValidator(CfnIPAMPoolProvisionedCidrPropertyValidator))(properties.provisionedCidrs));
  errors.collect(cdk.propertyValidator("publicIpSource", cdk.validateString)(properties.publicIpSource));
  errors.collect(cdk.propertyValidator("publiclyAdvertisable", cdk.validateBoolean)(properties.publiclyAdvertisable));
  errors.collect(cdk.propertyValidator("sourceIpamPoolId", cdk.validateString)(properties.sourceIpamPoolId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMPoolProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPoolPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPoolPropsValidator(properties).assertSuccess();
  return {
    "AddressFamily": cdk.stringToCloudFormation(properties.addressFamily),
    "AllocationDefaultNetmaskLength": cdk.numberToCloudFormation(properties.allocationDefaultNetmaskLength),
    "AllocationMaxNetmaskLength": cdk.numberToCloudFormation(properties.allocationMaxNetmaskLength),
    "AllocationMinNetmaskLength": cdk.numberToCloudFormation(properties.allocationMinNetmaskLength),
    "AllocationResourceTags": cdk.listMapper(convertCfnIPAMPoolTagPropertyToCloudFormation)(properties.allocationResourceTags),
    "AutoImport": cdk.booleanToCloudFormation(properties.autoImport),
    "AwsService": cdk.stringToCloudFormation(properties.awsService),
    "Description": cdk.stringToCloudFormation(properties.description),
    "IpamScopeId": cdk.stringToCloudFormation(properties.ipamScopeId),
    "Locale": cdk.stringToCloudFormation(properties.locale),
    "ProvisionedCidrs": cdk.listMapper(convertCfnIPAMPoolProvisionedCidrPropertyToCloudFormation)(properties.provisionedCidrs),
    "PublicIpSource": cdk.stringToCloudFormation(properties.publicIpSource),
    "PubliclyAdvertisable": cdk.booleanToCloudFormation(properties.publiclyAdvertisable),
    "SourceIpamPoolId": cdk.stringToCloudFormation(properties.sourceIpamPoolId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMPoolPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMPoolProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMPoolProps>();
  ret.addPropertyResult("addressFamily", "AddressFamily", (properties.AddressFamily != null ? cfn_parse.FromCloudFormation.getString(properties.AddressFamily) : undefined));
  ret.addPropertyResult("allocationDefaultNetmaskLength", "AllocationDefaultNetmaskLength", (properties.AllocationDefaultNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationDefaultNetmaskLength) : undefined));
  ret.addPropertyResult("allocationMaxNetmaskLength", "AllocationMaxNetmaskLength", (properties.AllocationMaxNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationMaxNetmaskLength) : undefined));
  ret.addPropertyResult("allocationMinNetmaskLength", "AllocationMinNetmaskLength", (properties.AllocationMinNetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.AllocationMinNetmaskLength) : undefined));
  ret.addPropertyResult("allocationResourceTags", "AllocationResourceTags", (properties.AllocationResourceTags != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMPoolTagPropertyFromCloudFormation)(properties.AllocationResourceTags) : undefined));
  ret.addPropertyResult("autoImport", "AutoImport", (properties.AutoImport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoImport) : undefined));
  ret.addPropertyResult("awsService", "AwsService", (properties.AwsService != null ? cfn_parse.FromCloudFormation.getString(properties.AwsService) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("ipamScopeId", "IpamScopeId", (properties.IpamScopeId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamScopeId) : undefined));
  ret.addPropertyResult("locale", "Locale", (properties.Locale != null ? cfn_parse.FromCloudFormation.getString(properties.Locale) : undefined));
  ret.addPropertyResult("provisionedCidrs", "ProvisionedCidrs", (properties.ProvisionedCidrs != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMPoolProvisionedCidrPropertyFromCloudFormation)(properties.ProvisionedCidrs) : undefined));
  ret.addPropertyResult("publicIpSource", "PublicIpSource", (properties.PublicIpSource != null ? cfn_parse.FromCloudFormation.getString(properties.PublicIpSource) : undefined));
  ret.addPropertyResult("publiclyAdvertisable", "PubliclyAdvertisable", (properties.PubliclyAdvertisable != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PubliclyAdvertisable) : undefined));
  ret.addPropertyResult("sourceIpamPoolId", "SourceIpamPoolId", (properties.SourceIpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceIpamPoolId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * A CIDR provisioned to an IPAM pool.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html
 */
export class CfnIPAMPoolCidr extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMPoolCidr";

  /**
   * Build a CfnIPAMPoolCidr from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMPoolCidr {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMPoolCidrPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMPoolCidr(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The IPAM pool CIDR ID.
   *
   * @cloudformationAttribute IpamPoolCidrId
   */
  public readonly attrIpamPoolCidrId: string;

  /**
   * The state of the CIDR.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The CIDR provisioned to the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-cidr
   */
  public cidr?: string;

  /**
   * The ID of the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-ipampoolid
   */
  public ipamPoolId: string;

  /**
   * The netmask length of the CIDR you'd like to provision to a pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-netmasklength
   */
  public netmaskLength?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMPoolCidrProps) {
    super(scope, id, {
      "type": CfnIPAMPoolCidr.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipamPoolId", this);

    this.attrIpamPoolCidrId = cdk.Token.asString(this.getAtt("IpamPoolCidrId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.cidr = props.cidr;
    this.ipamPoolId = props.ipamPoolId;
    this.netmaskLength = props.netmaskLength;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidr": this.cidr,
      "ipamPoolId": this.ipamPoolId,
      "netmaskLength": this.netmaskLength
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMPoolCidr.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMPoolCidrPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnIPAMPoolCidr\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html
 */
export interface CfnIPAMPoolCidrProps {
  /**
   * The CIDR provisioned to the IPAM pool.
   *
   * A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is \`10.24.34.0/23\` . An IPv6 CIDR example is \`2001:DB8::/32\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-cidr
   */
  readonly cidr?: string;

  /**
   * The ID of the IPAM pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-ipampoolid
   */
  readonly ipamPoolId: string;

  /**
   * The netmask length of the CIDR you'd like to provision to a pool.
   *
   * Can be used for provisioning Amazon-provided IPv6 CIDRs to top-level pools and for provisioning CIDRs to pools with source pools. Cannot be used to provision BYOIP CIDRs to top-level pools. "NetmaskLength" or "Cidr" is required.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-netmasklength
   */
  readonly netmaskLength?: number;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMPoolCidrProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMPoolCidrProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMPoolCidrPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidr", cdk.validateString)(properties.cidr));
  errors.collect(cdk.propertyValidator("ipamPoolId", cdk.requiredValidator)(properties.ipamPoolId));
  errors.collect(cdk.propertyValidator("ipamPoolId", cdk.validateString)(properties.ipamPoolId));
  errors.collect(cdk.propertyValidator("netmaskLength", cdk.validateNumber)(properties.netmaskLength));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMPoolCidrProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMPoolCidrPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMPoolCidrPropsValidator(properties).assertSuccess();
  return {
    "Cidr": cdk.stringToCloudFormation(properties.cidr),
    "IpamPoolId": cdk.stringToCloudFormation(properties.ipamPoolId),
    "NetmaskLength": cdk.numberToCloudFormation(properties.netmaskLength)
  };
}

// @ts-ignore TS6133
function CfnIPAMPoolCidrPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMPoolCidrProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMPoolCidrProps>();
  ret.addPropertyResult("cidr", "Cidr", (properties.Cidr != null ? cfn_parse.FromCloudFormation.getString(properties.Cidr) : undefined));
  ret.addPropertyResult("ipamPoolId", "IpamPoolId", (properties.IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamPoolId) : undefined));
  ret.addPropertyResult("netmaskLength", "NetmaskLength", (properties.NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.NetmaskLength) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * A resource discovery is an IPAM component that enables IPAM to manage and monitor resources that belong to the owning account.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html
 */
export class CfnIPAMResourceDiscovery extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMResourceDiscovery";

  /**
   * Build a CfnIPAMResourceDiscovery from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMResourceDiscovery {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMResourceDiscoveryPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMResourceDiscovery(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The resource discovery ARN.
   *
   * @cloudformationAttribute IpamResourceDiscoveryArn
   */
  public readonly attrIpamResourceDiscoveryArn: string;

  /**
   * The resource discovery ID.
   *
   * @cloudformationAttribute IpamResourceDiscoveryId
   */
  public readonly attrIpamResourceDiscoveryId: string;

  /**
   * The resource discovery Region.
   *
   * @cloudformationAttribute IpamResourceDiscoveryRegion
   */
  public readonly attrIpamResourceDiscoveryRegion: string;

  /**
   * Defines if the resource discovery is the default. The default resource discovery is the resource discovery automatically created when you create an IPAM.
   *
   * @cloudformationAttribute IsDefault
   */
  public readonly attrIsDefault: cdk.IResolvable;

  /**
   * The owner ID.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The resource discovery's state.
   *
   * - \`create-in-progress\` - Resource discovery is being created.
   * - \`create-complete\` - Resource discovery creation is complete.
   * - \`create-failed\` - Resource discovery creation has failed.
   * - \`modify-in-progress\` - Resource discovery is being modified.
   * - \`modify-complete\` - Resource discovery modification is complete.
   * - \`modify-failed\` - Resource discovery modification has failed.
   * - \`delete-in-progress\` - Resource discovery is being deleted.
   * - \`delete-complete\` - Resource discovery deletion is complete.
   * - \`delete-failed\` - Resource discovery deletion has failed.
   * - \`isolate-in-progress\` - AWS account that created the resource discovery has been removed and the resource discovery is being isolated.
   * - \`isolate-complete\` - Resource discovery isolation is complete.
   * - \`restore-in-progress\` - AWS account that created the resource discovery and was isolated has been restored.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The resource discovery description.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-description
   */
  public description?: string;

  /**
   * The operating Regions for the resource discovery.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-operatingregions
   */
  public operatingRegions?: Array<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * A tag is a label that you assign to an AWS resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMResourceDiscoveryProps = {}) {
    super(scope, id, {
      "type": CfnIPAMResourceDiscovery.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrIpamResourceDiscoveryArn = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamResourceDiscoveryId = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryId", cdk.ResolutionTypeHint.STRING));
    this.attrIpamResourceDiscoveryRegion = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryRegion", cdk.ResolutionTypeHint.STRING));
    this.attrIsDefault = this.getAtt("IsDefault");
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.operatingRegions = props.operatingRegions;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAMResourceDiscovery", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "operatingRegions": this.operatingRegions,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMResourceDiscovery.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMResourceDiscoveryPropsToCloudFormation(props);
  }
}

export namespace CfnIPAMResourceDiscovery {
  /**
   * The operating Regions for an IPAM.
   *
   * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
   *
   * For more information about operating Regions, see [Create an IPAM](https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html
   */
  export interface IpamOperatingRegionProperty {
    /**
     * The resource discovery description.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html#cfn-ec2-ipamresourcediscovery-ipamoperatingregion-description
     */
    readonly description?: string;

    /**
     * The operating Regions for the resource discovery.
     *
     * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html#cfn-ec2-ipamresourcediscovery-ipamoperatingregion-operatingregions
     */
    readonly operatingRegions?: Array<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * A tag is a label that you assign to an AWS resource.
     *
     * Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html#cfn-ec2-ipamresourcediscovery-ipamoperatingregion-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnIPAMResourceDiscovery.TagProperty> | cdk.IResolvable;
  }

  /**
   * A key-value pair to associate with a resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-tag.html
   */
  export interface TagProperty {
    /**
     * The resource discovery description.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-tag.html#cfn-ec2-ipamresourcediscovery-tag-description
     */
    readonly description?: string;

    /**
     * The operating Regions for the resource discovery.
     *
     * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-tag.html#cfn-ec2-ipamresourcediscovery-tag-operatingregions
     */
    readonly operatingRegions?: Array<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * A tag is a label that you assign to an AWS resource.
     *
     * Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-tag.html#cfn-ec2-ipamresourcediscovery-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnIPAMResourceDiscovery.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnIPAMResourceDiscovery\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html
 */
export interface CfnIPAMResourceDiscoveryProps {
  /**
   * The resource discovery description.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-description
   */
  readonly description?: string;

  /**
   * The operating Regions for the resource discovery.
   *
   * Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-operatingregions
   */
  readonly operatingRegions?: Array<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * A tag is a label that you assign to an AWS resource.
   *
   * Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("operatingRegions", cdk.listValidator(CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyValidator))(properties.operatingRegions));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnIPAMResourceDiscoveryTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMResourceDiscoveryTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMResourceDiscoveryTagPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "OperatingRegions": cdk.listMapper(convertCfnIPAMResourceDiscoveryIpamOperatingRegionPropertyToCloudFormation)(properties.operatingRegions),
    "Tags": cdk.listMapper(convertCfnIPAMResourceDiscoveryTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnIPAMResourceDiscovery.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMResourceDiscovery.TagProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("operatingRegions", "OperatingRegions", (properties.OperatingRegions != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyFromCloudFormation)(properties.OperatingRegions) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMResourceDiscoveryTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`IpamOperatingRegionProperty\`
 *
 * @param properties - the TypeScript properties of a \`IpamOperatingRegionProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("operatingRegions", cdk.listValidator(CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyValidator))(properties.operatingRegions));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnIPAMResourceDiscoveryTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"IpamOperatingRegionProperty\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMResourceDiscoveryIpamOperatingRegionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "OperatingRegions": cdk.listMapper(convertCfnIPAMResourceDiscoveryIpamOperatingRegionPropertyToCloudFormation)(properties.operatingRegions),
    "Tags": cdk.listMapper(convertCfnIPAMResourceDiscoveryTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMResourceDiscovery.IpamOperatingRegionProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("operatingRegions", "OperatingRegions", (properties.OperatingRegions != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyFromCloudFormation)(properties.OperatingRegions) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMResourceDiscoveryTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMResourceDiscoveryProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMResourceDiscoveryProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("operatingRegions", cdk.listValidator(CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyValidator))(properties.operatingRegions));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMResourceDiscoveryProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMResourceDiscoveryPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMResourceDiscoveryPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "OperatingRegions": cdk.listMapper(convertCfnIPAMResourceDiscoveryIpamOperatingRegionPropertyToCloudFormation)(properties.operatingRegions),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMResourceDiscoveryProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMResourceDiscoveryProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("operatingRegions", "OperatingRegions", (properties.OperatingRegions != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMResourceDiscoveryIpamOperatingRegionPropertyFromCloudFormation)(properties.OperatingRegions) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * An IPAM resource discovery association.
 *
 * An associated resource discovery is a resource discovery that has been associated with an IPAM. IPAM aggregates the resource CIDRs discovered by the associated resource discovery.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html
 */
export class CfnIPAMResourceDiscoveryAssociation extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMResourceDiscoveryAssociation";

  /**
   * Build a CfnIPAMResourceDiscoveryAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMResourceDiscoveryAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMResourceDiscoveryAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMResourceDiscoveryAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The IPAM ARN.
   *
   * @cloudformationAttribute IpamArn
   */
  public readonly attrIpamArn: string;

  /**
   * The IPAM home Region.
   *
   * @cloudformationAttribute IpamRegion
   */
  public readonly attrIpamRegion: string;

  /**
   * The resource discovery association ARN.
   *
   * @cloudformationAttribute IpamResourceDiscoveryAssociationArn
   */
  public readonly attrIpamResourceDiscoveryAssociationArn: string;

  /**
   * The resource discovery association ID.
   *
   * @cloudformationAttribute IpamResourceDiscoveryAssociationId
   */
  public readonly attrIpamResourceDiscoveryAssociationId: string;

  /**
   * Defines if the resource discovery is the default. When you create an IPAM, a default resource discovery is created for your IPAM and it's associated with your IPAM.
   *
   * @cloudformationAttribute IsDefault
   */
  public readonly attrIsDefault: cdk.IResolvable;

  /**
   * The owner ID.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The resource discovery status.
   *
   * - \`active\` - Connection or permissions required to read the results of the resource discovery are intact.
   * - \`not-found\` - Connection or permissions required to read the results of the resource discovery are broken. This may happen if the owner of the resource discovery stopped sharing it or deleted the resource discovery. Verify the resource discovery still exists and the AWS RAM resource share is still intact.
   *
   * @cloudformationAttribute ResourceDiscoveryStatus
   */
  public readonly attrResourceDiscoveryStatus: string;

  /**
   * The lifecycle state of the association when you associate or disassociate a resource discovery.
   *
   * - \`associate-in-progress\` - Resource discovery is being associated.
   * - \`associate-complete\` - Resource discovery association is complete.
   * - \`associate-failed\` - Resource discovery association has failed.
   * - \`disassociate-in-progress\` - Resource discovery is being disassociated.
   * - \`disassociate-complete\` - Resource discovery disassociation is complete.
   * - \`disassociate-failed\` - Resource discovery disassociation has failed.
   * - \`isolate-in-progress\` - AWS account that created the resource discovery association has been removed and the resource discovery associatation is being isolated.
   * - \`isolate-complete\` - Resource discovery isolation is complete..
   * - \`restore-in-progress\` - Resource discovery is being restored.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The IPAM ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-ipamid
   */
  public ipamId: string;

  /**
   * The resource discovery ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-ipamresourcediscoveryid
   */
  public ipamResourceDiscoveryId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * A tag is a label that you assign to an AWS resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMResourceDiscoveryAssociationProps) {
    super(scope, id, {
      "type": CfnIPAMResourceDiscoveryAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipamId", this);
    cdk.requireProperty(props, "ipamResourceDiscoveryId", this);

    this.attrIpamArn = cdk.Token.asString(this.getAtt("IpamArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamRegion = cdk.Token.asString(this.getAtt("IpamRegion", cdk.ResolutionTypeHint.STRING));
    this.attrIpamResourceDiscoveryAssociationArn = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryAssociationArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamResourceDiscoveryAssociationId = cdk.Token.asString(this.getAtt("IpamResourceDiscoveryAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrIsDefault = this.getAtt("IsDefault");
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceDiscoveryStatus = cdk.Token.asString(this.getAtt("ResourceDiscoveryStatus", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.ipamId = props.ipamId;
    this.ipamResourceDiscoveryId = props.ipamResourceDiscoveryId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAMResourceDiscoveryAssociation", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "ipamId": this.ipamId,
      "ipamResourceDiscoveryId": this.ipamResourceDiscoveryId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMResourceDiscoveryAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMResourceDiscoveryAssociationPropsToCloudFormation(props);
  }
}

export namespace CfnIPAMResourceDiscoveryAssociation {
  /**
   * A key-value pair to associate with a resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscoveryassociation-tag.html
   */
  export interface TagProperty {
    /**
     * The IPAM ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscoveryassociation-tag.html#cfn-ec2-ipamresourcediscoveryassociation-tag-ipamid
     */
    readonly ipamId: string;

    /**
     * The resource discovery ID.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscoveryassociation-tag.html#cfn-ec2-ipamresourcediscoveryassociation-tag-ipamresourcediscoveryid
     */
    readonly ipamResourceDiscoveryId: string;

    /**
     * A tag is a label that you assign to an AWS resource.
     *
     * Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscoveryassociation-tag.html#cfn-ec2-ipamresourcediscoveryassociation-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnIPAMResourceDiscoveryAssociation.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnIPAMResourceDiscoveryAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html
 */
export interface CfnIPAMResourceDiscoveryAssociationProps {
  /**
   * The IPAM ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-ipamid
   */
  readonly ipamId: string;

  /**
   * The resource discovery ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-ipamresourcediscoveryid
   */
  readonly ipamResourceDiscoveryId: string;

  /**
   * A tag is a label that you assign to an AWS resource.
   *
   * Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryAssociationTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipamId", cdk.requiredValidator)(properties.ipamId));
  errors.collect(cdk.propertyValidator("ipamId", cdk.validateString)(properties.ipamId));
  errors.collect(cdk.propertyValidator("ipamResourceDiscoveryId", cdk.requiredValidator)(properties.ipamResourceDiscoveryId));
  errors.collect(cdk.propertyValidator("ipamResourceDiscoveryId", cdk.validateString)(properties.ipamResourceDiscoveryId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnIPAMResourceDiscoveryAssociationTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMResourceDiscoveryAssociationTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMResourceDiscoveryAssociationTagPropertyValidator(properties).assertSuccess();
  return {
    "IpamId": cdk.stringToCloudFormation(properties.ipamId),
    "IpamResourceDiscoveryId": cdk.stringToCloudFormation(properties.ipamResourceDiscoveryId),
    "Tags": cdk.listMapper(convertCfnIPAMResourceDiscoveryAssociationTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryAssociationTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnIPAMResourceDiscoveryAssociation.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMResourceDiscoveryAssociation.TagProperty>();
  ret.addPropertyResult("ipamId", "IpamId", (properties.IpamId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamId) : undefined));
  ret.addPropertyResult("ipamResourceDiscoveryId", "IpamResourceDiscoveryId", (properties.IpamResourceDiscoveryId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamResourceDiscoveryId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMResourceDiscoveryAssociationTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMResourceDiscoveryAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMResourceDiscoveryAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipamId", cdk.requiredValidator)(properties.ipamId));
  errors.collect(cdk.propertyValidator("ipamId", cdk.validateString)(properties.ipamId));
  errors.collect(cdk.propertyValidator("ipamResourceDiscoveryId", cdk.requiredValidator)(properties.ipamResourceDiscoveryId));
  errors.collect(cdk.propertyValidator("ipamResourceDiscoveryId", cdk.validateString)(properties.ipamResourceDiscoveryId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMResourceDiscoveryAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMResourceDiscoveryAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMResourceDiscoveryAssociationPropsValidator(properties).assertSuccess();
  return {
    "IpamId": cdk.stringToCloudFormation(properties.ipamId),
    "IpamResourceDiscoveryId": cdk.stringToCloudFormation(properties.ipamResourceDiscoveryId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMResourceDiscoveryAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMResourceDiscoveryAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMResourceDiscoveryAssociationProps>();
  ret.addPropertyResult("ipamId", "IpamId", (properties.IpamId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamId) : undefined));
  ret.addPropertyResult("ipamResourceDiscoveryId", "IpamResourceDiscoveryId", (properties.IpamResourceDiscoveryId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamResourceDiscoveryId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * In IPAM, a scope is the highest-level container within IPAM.
 *
 * An IPAM contains two default scopes. Each scope represents the IP space for a single network. The private scope is intended for all private IP address space. The public scope is intended for all public IP address space. Scopes enable you to reuse IP addresses across multiple unconnected networks without causing IP address overlap or conflict.
 *
 * For more information, see [How IPAM works](https://docs.aws.amazon.com//vpc/latest/ipam/how-it-works-ipam.html) in the *Amazon VPC IPAM User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html
 */
export class CfnIPAMScope extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::IPAMScope";

  /**
   * Build a CfnIPAMScope from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnIPAMScope {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnIPAMScopePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnIPAMScope(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the scope.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ARN of an IPAM.
   *
   * @cloudformationAttribute IpamArn
   */
  public readonly attrIpamArn: string;

  /**
   * The ID of an IPAM scope.
   *
   * @cloudformationAttribute IpamScopeId
   */
  public readonly attrIpamScopeId: string;

  /**
   * The type of the scope.
   *
   * @cloudformationAttribute IpamScopeType
   */
  public readonly attrIpamScopeType: string;

  /**
   * Defines if the scope is the default scope or not.
   *
   * @cloudformationAttribute IsDefault
   */
  public readonly attrIsDefault: cdk.IResolvable;

  /**
   * The number of pools in a scope.
   *
   * @cloudformationAttribute PoolCount
   */
  public readonly attrPoolCount: cdk.IResolvable;

  /**
   * The description of the scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-description
   */
  public description?: string;

  /**
   * The ID of the IPAM for which you're creating this scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-ipamid
   */
  public ipamId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The key/value combination of a tag assigned to the resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnIPAMScopeProps) {
    super(scope, id, {
      "type": CfnIPAMScope.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipamId", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamArn = cdk.Token.asString(this.getAtt("IpamArn", cdk.ResolutionTypeHint.STRING));
    this.attrIpamScopeId = cdk.Token.asString(this.getAtt("IpamScopeId", cdk.ResolutionTypeHint.STRING));
    this.attrIpamScopeType = cdk.Token.asString(this.getAtt("IpamScopeType", cdk.ResolutionTypeHint.STRING));
    this.attrIsDefault = this.getAtt("IsDefault");
    this.attrPoolCount = this.getAtt("PoolCount", cdk.ResolutionTypeHint.NUMBER);
    this.description = props.description;
    this.ipamId = props.ipamId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::IPAMScope", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "ipamId": this.ipamId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnIPAMScope.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnIPAMScopePropsToCloudFormation(props);
  }
}

export namespace CfnIPAMScope {
  /**
   * A key-value pair to associate with a resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamscope-tag.html
   */
  export interface TagProperty {
    /**
     * The description of the scope.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamscope-tag.html#cfn-ec2-ipamscope-tag-description
     */
    readonly description?: string;

    /**
     * The ID of the IPAM for which you're creating this scope.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamscope-tag.html#cfn-ec2-ipamscope-tag-ipamid
     */
    readonly ipamId: string;

    /**
     * The key/value combination of a tag assigned to the resource.
     *
     * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key \`Owner\` and the value \`TeamA\` , specify \`tag:Owner\` for the filter name and \`TeamA\` for the filter value.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamscope-tag.html#cfn-ec2-ipamscope-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnIPAMScope.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnIPAMScope\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html
 */
export interface CfnIPAMScopeProps {
  /**
   * The description of the scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-description
   */
  readonly description?: string;

  /**
   * The ID of the IPAM for which you're creating this scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-ipamid
   */
  readonly ipamId: string;

  /**
   * The key/value combination of a tag assigned to the resource.
   *
   * Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key \`Owner\` and the value \`TeamA\` , specify \`tag:Owner\` for the filter name and \`TeamA\` for the filter value.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMScopeTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("ipamId", cdk.requiredValidator)(properties.ipamId));
  errors.collect(cdk.propertyValidator("ipamId", cdk.validateString)(properties.ipamId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnIPAMScopeTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMScopeTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMScopeTagPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "IpamId": cdk.stringToCloudFormation(properties.ipamId),
    "Tags": cdk.listMapper(convertCfnIPAMScopeTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMScopeTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnIPAMScope.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMScope.TagProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("ipamId", "IpamId", (properties.IpamId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnIPAMScopeTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnIPAMScopeProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnIPAMScopeProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnIPAMScopePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("ipamId", cdk.requiredValidator)(properties.ipamId));
  errors.collect(cdk.propertyValidator("ipamId", cdk.validateString)(properties.ipamId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnIPAMScopeProps\\"");
}

// @ts-ignore TS6133
function convertCfnIPAMScopePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnIPAMScopePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "IpamId": cdk.stringToCloudFormation(properties.ipamId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnIPAMScopePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnIPAMScopeProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnIPAMScopeProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("ipamId", "IpamId", (properties.IpamId != null ? cfn_parse.FromCloudFormation.getString(properties.IpamId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a key pair for use with an Amazon Elastic Compute Cloud instance as follows:.
 *
 * - To import an existing key pair, include the \`PublicKeyMaterial\` property.
 * - To create a new key pair, omit the \`PublicKeyMaterial\` property.
 *
 * When you import an existing key pair, you specify the public key material for the key. We assume that you have the private key material for the key. AWS CloudFormation does not create or return the private key material when you import a key pair.
 *
 * When you create a new key pair, the private key is saved to AWS Systems Manager Parameter Store, using a parameter with the following name: \`/ec2/keypair/{key_pair_id}\` . For more information about retrieving private key, and the required permissions, see [Create a key pair using AWS CloudFormation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/create-key-pairs.html#create-key-pair-cloudformation) in the *Amazon EC2 User Guide* .
 *
 * When AWS CloudFormation deletes a key pair that was created or imported by a stack, it also deletes the parameter that was used to store the private key material in Parameter Store.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html
 */
export class CfnKeyPair extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::KeyPair";

  /**
   * Build a CfnKeyPair from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnKeyPair {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnKeyPairPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnKeyPair(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * If you created the key pair using Amazon EC2:
   *
   * - For RSA key pairs, the key fingerprint is the SHA-1 digest of the DER encoded private key.
   * - For ED25519 key pairs, the key fingerprint is the base64-encoded SHA-256 digest, which is the default for OpenSSH, starting with [OpenSSH 6.8](https://docs.aws.amazon.com/http://www.openssh.com/txt/release-6.8) .
   *
   * If you imported the key pair to Amazon EC2:
   *
   * - For RSA key pairs, the key fingerprint is the MD5 public key fingerprint as specified in section 4 of RFC 4716.
   * - For ED25519 key pairs, the key fingerprint is the base64-encoded SHA-256 digest, which is the default for OpenSSH, starting with [OpenSSH 6.8](https://docs.aws.amazon.com/http://www.openssh.com/txt/release-6.8) .
   *
   * @cloudformationAttribute KeyFingerprint
   */
  public readonly attrKeyFingerprint: string;

  /**
   * The ID of the key pair.
   *
   * @cloudformationAttribute KeyPairId
   */
  public readonly attrKeyPairId: string;

  /**
   * A unique name for the key pair.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keyname
   */
  public keyName: string;

  /**
   * The type of key pair. Note that ED25519 keys are not supported for Windows instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keytype
   */
  public keyType?: string;

  /**
   * The public key material.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-publickeymaterial
   */
  public publicKeyMaterial?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply to the key pair.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnKeyPairProps) {
    super(scope, id, {
      "type": CfnKeyPair.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "keyName", this);

    this.attrKeyFingerprint = cdk.Token.asString(this.getAtt("KeyFingerprint", cdk.ResolutionTypeHint.STRING));
    this.attrKeyPairId = cdk.Token.asString(this.getAtt("KeyPairId", cdk.ResolutionTypeHint.STRING));
    this.keyName = props.keyName;
    this.keyType = props.keyType;
    this.publicKeyMaterial = props.publicKeyMaterial;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::KeyPair", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "keyName": this.keyName,
      "keyType": this.keyType,
      "publicKeyMaterial": this.publicKeyMaterial,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnKeyPair.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnKeyPairPropsToCloudFormation(props);
  }
}

export namespace CfnKeyPair {
  /**
   * A key-value pair to associate with a resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-keypair-tag.html
   */
  export interface TagProperty {
    /**
     * A unique name for the key pair.
     *
     * Constraints: Up to 255 ASCII characters
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-keypair-tag.html#cfn-ec2-keypair-tag-keyname
     */
    readonly keyName: string;

    /**
     * The type of key pair. Note that ED25519 keys are not supported for Windows instances.
     *
     * If the \`PublicKeyMaterial\` property is specified, the \`KeyType\` property is ignored, and the key type is inferred from the \`PublicKeyMaterial\` value.
     *
     * Default: \`rsa\`
     *
     * @default - "rsa"
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-keypair-tag.html#cfn-ec2-keypair-tag-keytype
     */
    readonly keyType?: string;

    /**
     * The public key material.
     *
     * The \`PublicKeyMaterial\` property is used to import a key pair. If this property is not specified, then a new key pair will be created.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-keypair-tag.html#cfn-ec2-keypair-tag-publickeymaterial
     */
    readonly publicKeyMaterial?: string;

    /**
     * The tags to apply to the key pair.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-keypair-tag.html#cfn-ec2-keypair-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnKeyPair.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnKeyPair\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html
 */
export interface CfnKeyPairProps {
  /**
   * A unique name for the key pair.
   *
   * Constraints: Up to 255 ASCII characters
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keyname
   */
  readonly keyName: string;

  /**
   * The type of key pair. Note that ED25519 keys are not supported for Windows instances.
   *
   * If the \`PublicKeyMaterial\` property is specified, the \`KeyType\` property is ignored, and the key type is inferred from the \`PublicKeyMaterial\` value.
   *
   * Default: \`rsa\`
   *
   * @default - "rsa"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keytype
   */
  readonly keyType?: string;

  /**
   * The public key material.
   *
   * The \`PublicKeyMaterial\` property is used to import a key pair. If this property is not specified, then a new key pair will be created.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-publickeymaterial
   */
  readonly publicKeyMaterial?: string;

  /**
   * The tags to apply to the key pair.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnKeyPairTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("keyName", cdk.requiredValidator)(properties.keyName));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("keyType", cdk.validateString)(properties.keyType));
  errors.collect(cdk.propertyValidator("publicKeyMaterial", cdk.validateString)(properties.publicKeyMaterial));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnKeyPairTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnKeyPairTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnKeyPairTagPropertyValidator(properties).assertSuccess();
  return {
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "KeyType": cdk.stringToCloudFormation(properties.keyType),
    "PublicKeyMaterial": cdk.stringToCloudFormation(properties.publicKeyMaterial),
    "Tags": cdk.listMapper(convertCfnKeyPairTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnKeyPairTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnKeyPair.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnKeyPair.TagProperty>();
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("keyType", "KeyType", (properties.KeyType != null ? cfn_parse.FromCloudFormation.getString(properties.KeyType) : undefined));
  ret.addPropertyResult("publicKeyMaterial", "PublicKeyMaterial", (properties.PublicKeyMaterial != null ? cfn_parse.FromCloudFormation.getString(properties.PublicKeyMaterial) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnKeyPairTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnKeyPairProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnKeyPairProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnKeyPairPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("keyName", cdk.requiredValidator)(properties.keyName));
  errors.collect(cdk.propertyValidator("keyName", cdk.validateString)(properties.keyName));
  errors.collect(cdk.propertyValidator("keyType", cdk.validateString)(properties.keyType));
  errors.collect(cdk.propertyValidator("publicKeyMaterial", cdk.validateString)(properties.publicKeyMaterial));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnKeyPairProps\\"");
}

// @ts-ignore TS6133
function convertCfnKeyPairPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnKeyPairPropsValidator(properties).assertSuccess();
  return {
    "KeyName": cdk.stringToCloudFormation(properties.keyName),
    "KeyType": cdk.stringToCloudFormation(properties.keyType),
    "PublicKeyMaterial": cdk.stringToCloudFormation(properties.publicKeyMaterial),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnKeyPairPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnKeyPairProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnKeyPairProps>();
  ret.addPropertyResult("keyName", "KeyName", (properties.KeyName != null ? cfn_parse.FromCloudFormation.getString(properties.KeyName) : undefined));
  ret.addPropertyResult("keyType", "KeyType", (properties.KeyType != null ? cfn_parse.FromCloudFormation.getString(properties.KeyType) : undefined));
  ret.addPropertyResult("publicKeyMaterial", "PublicKeyMaterial", (properties.PublicKeyMaterial != null ? cfn_parse.FromCloudFormation.getString(properties.PublicKeyMaterial) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies the properties for creating a launch template.
 *
 * The minimum required properties for specifying a launch template are as follows:
 *
 * - You must specify at least one property for the launch template data.
 * - You do not need to specify a name for the launch template. If you do not specify a name, AWS CloudFormation creates the name for you.
 *
 * A launch template can contain some or all of the configuration information to launch an instance. When you launch an instance using a launch template, instance properties that are not specified in the launch template use default values, except the \`ImageId\` property, which has no default value. If you do not specify an AMI ID for the launch template \`ImageId\` property, you must specify an AMI ID for the instance \`ImageId\` property.
 *
 * For more information, see [Launch an instance from a launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html) in the *Amazon EC2 User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html
 */
export class CfnLaunchTemplate extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LaunchTemplate";

  /**
   * Build a CfnLaunchTemplate from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLaunchTemplate {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLaunchTemplatePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLaunchTemplate(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The default version of the launch template, such as 2.
   *
   * The default version of a launch template cannot be specified in AWS CloudFormation . The default version can be set in the Amazon EC2 console or by using the \`modify-launch-template\` AWS CLI command.
   *
   * @cloudformationAttribute DefaultVersionNumber
   */
  public readonly attrDefaultVersionNumber: string;

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The latest version of the launch template, such as \`5\` .
   *
   * @cloudformationAttribute LatestVersionNumber
   */
  public readonly attrLatestVersionNumber: string;

  /**
   * The information for the launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatedata
   */
  public launchTemplateData: cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateDataProperty;

  /**
   * A name for the launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatename
   */
  public launchTemplateName?: string;

  /**
   * The tags to apply to the launch template on creation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications
   */
  public tagSpecifications?: Array<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty> | cdk.IResolvable;

  /**
   * A description for the first version of the launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-versiondescription
   */
  public versionDescription?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLaunchTemplateProps) {
    super(scope, id, {
      "type": CfnLaunchTemplate.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "launchTemplateData", this);

    this.attrDefaultVersionNumber = cdk.Token.asString(this.getAtt("DefaultVersionNumber", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrLatestVersionNumber = cdk.Token.asString(this.getAtt("LatestVersionNumber", cdk.ResolutionTypeHint.STRING));
    this.launchTemplateData = props.launchTemplateData;
    this.launchTemplateName = props.launchTemplateName;
    this.tagSpecifications = props.tagSpecifications;
    this.versionDescription = props.versionDescription;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "launchTemplateData": this.launchTemplateData,
      "launchTemplateName": this.launchTemplateName,
      "tagSpecifications": this.tagSpecifications,
      "versionDescription": this.versionDescription
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLaunchTemplate.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLaunchTemplatePropsToCloudFormation(props);
  }
}

export namespace CfnLaunchTemplate {
  /**
   * The information to include in the launch template.
   *
   * > You must specify at least one parameter for the launch template data.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html
   */
  export interface LaunchTemplateDataProperty {
    /**
     * The information for the launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-launchtemplatedata
     */
    readonly launchTemplateData: cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateDataProperty;

    /**
     * A name for the launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-launchtemplatename
     */
    readonly launchTemplateName?: string;

    /**
     * The tags to apply to the launch template on creation.
     *
     * To tag the launch template, the resource type must be \`launch-template\` .
     *
     * > To specify the tags for the resources that are created when an instance is launched, you must use the \`TagSpecifications\` parameter in the [launch template data](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestLaunchTemplateData.html) structure.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty> | cdk.IResolvable;

    /**
     * A description for the first version of the launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-versiondescription
     */
    readonly versionDescription?: string;
  }

  /**
   * Specifies the tags to apply to the launch template during creation.
   *
   * \`LaunchTemplateTagSpecification\` is a property of [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html
   */
  export interface LaunchTemplateTagSpecificationProperty {
    /**
     * The information for the launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-launchtemplatedata
     */
    readonly launchTemplateData: cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateDataProperty;

    /**
     * A name for the launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-launchtemplatename
     */
    readonly launchTemplateName?: string;

    /**
     * The tags to apply to the launch template on creation.
     *
     * To tag the launch template, the resource type must be \`launch-template\` .
     *
     * > To specify the tags for the resources that are created when an instance is launched, you must use the \`TagSpecifications\` parameter in the [launch template data](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestLaunchTemplateData.html) structure.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-tagspecifications
     */
    readonly tagSpecifications?: Array<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty> | cdk.IResolvable;

    /**
     * A description for the first version of the launch template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-versiondescription
     */
    readonly versionDescription?: string;
  }
}

/**
 * Properties for defining a \`CfnLaunchTemplate\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html
 */
export interface CfnLaunchTemplateProps {
  /**
   * The information for the launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatedata
   */
  readonly launchTemplateData: cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateDataProperty;

  /**
   * A name for the launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatename
   */
  readonly launchTemplateName?: string;

  /**
   * The tags to apply to the launch template on creation.
   *
   * To tag the launch template, the resource type must be \`launch-template\` .
   *
   * > To specify the tags for the resources that are created when an instance is launched, you must use the \`TagSpecifications\` parameter in the [launch template data](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestLaunchTemplateData.html) structure.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications
   */
  readonly tagSpecifications?: Array<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty> | cdk.IResolvable;

  /**
   * A description for the first version of the launch template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-versiondescription
   */
  readonly versionDescription?: string;
}

/**
 * Determine whether the given properties match those of a \`LaunchTemplateTagSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LaunchTemplateTagSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateData", cdk.requiredValidator)(properties.launchTemplateData));
  errors.collect(cdk.propertyValidator("launchTemplateData", CfnLaunchTemplateLaunchTemplateDataPropertyValidator)(properties.launchTemplateData));
  errors.collect(cdk.propertyValidator("launchTemplateName", cdk.validateString)(properties.launchTemplateName));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  return errors.wrap("supplied properties not correct for \\"LaunchTemplateTagSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateLaunchTemplateTagSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "LaunchTemplateData": convertCfnLaunchTemplateLaunchTemplateDataPropertyToCloudFormation(properties.launchTemplateData),
    "LaunchTemplateName": cdk.stringToCloudFormation(properties.launchTemplateName),
    "TagSpecifications": cdk.listMapper(convertCfnLaunchTemplateLaunchTemplateTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty>();
  ret.addPropertyResult("launchTemplateData", "LaunchTemplateData", (properties.LaunchTemplateData != null ? CfnLaunchTemplateLaunchTemplateDataPropertyFromCloudFormation(properties.LaunchTemplateData) : undefined));
  ret.addPropertyResult("launchTemplateName", "LaunchTemplateName", (properties.LaunchTemplateName != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateName) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LaunchTemplateDataProperty\`
 *
 * @param properties - the TypeScript properties of a \`LaunchTemplateDataProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateDataPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateData", cdk.requiredValidator)(properties.launchTemplateData));
  errors.collect(cdk.propertyValidator("launchTemplateData", CfnLaunchTemplateLaunchTemplateDataPropertyValidator)(properties.launchTemplateData));
  errors.collect(cdk.propertyValidator("launchTemplateName", cdk.validateString)(properties.launchTemplateName));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  return errors.wrap("supplied properties not correct for \\"LaunchTemplateDataProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplateLaunchTemplateDataPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplateLaunchTemplateDataPropertyValidator(properties).assertSuccess();
  return {
    "LaunchTemplateData": convertCfnLaunchTemplateLaunchTemplateDataPropertyToCloudFormation(properties.launchTemplateData),
    "LaunchTemplateName": cdk.stringToCloudFormation(properties.launchTemplateName),
    "TagSpecifications": cdk.listMapper(convertCfnLaunchTemplateLaunchTemplateTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplateLaunchTemplateDataPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLaunchTemplate.LaunchTemplateDataProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplate.LaunchTemplateDataProperty>();
  ret.addPropertyResult("launchTemplateData", "LaunchTemplateData", (properties.LaunchTemplateData != null ? CfnLaunchTemplateLaunchTemplateDataPropertyFromCloudFormation(properties.LaunchTemplateData) : undefined));
  ret.addPropertyResult("launchTemplateName", "LaunchTemplateName", (properties.LaunchTemplateName != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateName) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnLaunchTemplateProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLaunchTemplateProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLaunchTemplatePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("launchTemplateData", cdk.requiredValidator)(properties.launchTemplateData));
  errors.collect(cdk.propertyValidator("launchTemplateData", CfnLaunchTemplateLaunchTemplateDataPropertyValidator)(properties.launchTemplateData));
  errors.collect(cdk.propertyValidator("launchTemplateName", cdk.validateString)(properties.launchTemplateName));
  errors.collect(cdk.propertyValidator("tagSpecifications", cdk.listValidator(CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyValidator))(properties.tagSpecifications));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  return errors.wrap("supplied properties not correct for \\"CfnLaunchTemplateProps\\"");
}

// @ts-ignore TS6133
function convertCfnLaunchTemplatePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLaunchTemplatePropsValidator(properties).assertSuccess();
  return {
    "LaunchTemplateData": convertCfnLaunchTemplateLaunchTemplateDataPropertyToCloudFormation(properties.launchTemplateData),
    "LaunchTemplateName": cdk.stringToCloudFormation(properties.launchTemplateName),
    "TagSpecifications": cdk.listMapper(convertCfnLaunchTemplateLaunchTemplateTagSpecificationPropertyToCloudFormation)(properties.tagSpecifications),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription)
  };
}

// @ts-ignore TS6133
function CfnLaunchTemplatePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLaunchTemplateProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLaunchTemplateProps>();
  ret.addPropertyResult("launchTemplateData", "LaunchTemplateData", (properties.LaunchTemplateData != null ? CfnLaunchTemplateLaunchTemplateDataPropertyFromCloudFormation(properties.LaunchTemplateData) : undefined));
  ret.addPropertyResult("launchTemplateName", "LaunchTemplateName", (properties.LaunchTemplateName != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchTemplateName) : undefined));
  ret.addPropertyResult("tagSpecifications", "TagSpecifications", (properties.TagSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnLaunchTemplateLaunchTemplateTagSpecificationPropertyFromCloudFormation)(properties.TagSpecifications) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a static route for the specified local gateway route table. You must specify one of the following targets:.
 *
 * - \`LocalGatewayVirtualInterfaceGroupId\`
 * - \`NetworkInterfaceId\`
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html
 */
export class CfnLocalGatewayRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LocalGatewayRoute";

  /**
   * Build a CfnLocalGatewayRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLocalGatewayRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLocalGatewayRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLocalGatewayRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The state of the local gateway route table.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The type of local gateway route.
   *
   * @cloudformationAttribute Type
   */
  public readonly attrType: string;

  /**
   * The CIDR block used for destination matches.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-destinationcidrblock
   */
  public destinationCidrBlock?: string;

  /**
   * The ID of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayroutetableid
   */
  public localGatewayRouteTableId?: string;

  /**
   * The ID of the virtual interface group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayvirtualinterfacegroupid
   */
  public localGatewayVirtualInterfaceGroupId?: string;

  /**
   * The ID of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-networkinterfaceid
   */
  public networkInterfaceId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLocalGatewayRouteProps = {}) {
    super(scope, id, {
      "type": CfnLocalGatewayRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrType = cdk.Token.asString(this.getAtt("Type", cdk.ResolutionTypeHint.STRING));
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.localGatewayRouteTableId = props.localGatewayRouteTableId;
    this.localGatewayVirtualInterfaceGroupId = props.localGatewayVirtualInterfaceGroupId;
    this.networkInterfaceId = props.networkInterfaceId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "destinationCidrBlock": this.destinationCidrBlock,
      "localGatewayRouteTableId": this.localGatewayRouteTableId,
      "localGatewayVirtualInterfaceGroupId": this.localGatewayVirtualInterfaceGroupId,
      "networkInterfaceId": this.networkInterfaceId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLocalGatewayRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLocalGatewayRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnLocalGatewayRoute\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html
 */
export interface CfnLocalGatewayRouteProps {
  /**
   * The CIDR block used for destination matches.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-destinationcidrblock
   */
  readonly destinationCidrBlock?: string;

  /**
   * The ID of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayroutetableid
   */
  readonly localGatewayRouteTableId?: string;

  /**
   * The ID of the virtual interface group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayvirtualinterfacegroupid
   */
  readonly localGatewayVirtualInterfaceGroupId?: string;

  /**
   * The ID of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-networkinterfaceid
   */
  readonly networkInterfaceId?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnLocalGatewayRouteProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLocalGatewayRouteProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.validateString)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayVirtualInterfaceGroupId", cdk.validateString)(properties.localGatewayVirtualInterfaceGroupId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  return errors.wrap("supplied properties not correct for \\"CfnLocalGatewayRouteProps\\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRoutePropsValidator(properties).assertSuccess();
  return {
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "LocalGatewayRouteTableId": cdk.stringToCloudFormation(properties.localGatewayRouteTableId),
    "LocalGatewayVirtualInterfaceGroupId": cdk.stringToCloudFormation(properties.localGatewayVirtualInterfaceGroupId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLocalGatewayRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteProps>();
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("localGatewayRouteTableId", "LocalGatewayRouteTableId", (properties.LocalGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayRouteTableId) : undefined));
  ret.addPropertyResult("localGatewayVirtualInterfaceGroupId", "LocalGatewayVirtualInterfaceGroupId", (properties.LocalGatewayVirtualInterfaceGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayVirtualInterfaceGroupId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a local gateway route table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html
 */
export class CfnLocalGatewayRouteTable extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LocalGatewayRouteTable";

  /**
   * Build a CfnLocalGatewayRouteTable from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLocalGatewayRouteTable {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLocalGatewayRouteTablePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLocalGatewayRouteTable(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Name (ARN) of the local gateway route table.
   *
   * @cloudformationAttribute LocalGatewayRouteTableArn
   */
  public readonly attrLocalGatewayRouteTableArn: string;

  /**
   * The ID of the local gateway route table.
   *
   * @cloudformationAttribute LocalGatewayRouteTableId
   */
  public readonly attrLocalGatewayRouteTableId: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @cloudformationAttribute OutpostArn
   */
  public readonly attrOutpostArn: string;

  /**
   * The ID of the AWS account that owns the local gateway route table.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The state of the local gateway route table.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The ID of the local gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-localgatewayid
   */
  public localGatewayId: string;

  /**
   * The mode of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-mode
   */
  public mode?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags assigned to the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLocalGatewayRouteTableProps) {
    super(scope, id, {
      "type": CfnLocalGatewayRouteTable.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "localGatewayId", this);

    this.attrLocalGatewayRouteTableArn = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableArn", cdk.ResolutionTypeHint.STRING));
    this.attrLocalGatewayRouteTableId = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableId", cdk.ResolutionTypeHint.STRING));
    this.attrOutpostArn = cdk.Token.asString(this.getAtt("OutpostArn", cdk.ResolutionTypeHint.STRING));
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.localGatewayId = props.localGatewayId;
    this.mode = props.mode;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::LocalGatewayRouteTable", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "localGatewayId": this.localGatewayId,
      "mode": this.mode,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLocalGatewayRouteTable.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLocalGatewayRouteTablePropsToCloudFormation(props);
  }
}

export namespace CfnLocalGatewayRouteTable {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-localgatewayroutetable-tag.html
   */
  export interface TagProperty {
    /**
     * The ID of the local gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-localgatewayroutetable-tag.html#cfn-ec2-localgatewayroutetable-tag-localgatewayid
     */
    readonly localGatewayId: string;

    /**
     * The mode of the local gateway route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-localgatewayroutetable-tag.html#cfn-ec2-localgatewayroutetable-tag-mode
     */
    readonly mode?: string;

    /**
     * The tags assigned to the local gateway route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-localgatewayroutetable-tag.html#cfn-ec2-localgatewayroutetable-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnLocalGatewayRouteTable.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnLocalGatewayRouteTable\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html
 */
export interface CfnLocalGatewayRouteTableProps {
  /**
   * The ID of the local gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-localgatewayid
   */
  readonly localGatewayId: string;

  /**
   * The mode of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-mode
   */
  readonly mode?: string;

  /**
   * The tags assigned to the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRouteTableTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("localGatewayId", cdk.requiredValidator)(properties.localGatewayId));
  errors.collect(cdk.propertyValidator("localGatewayId", cdk.validateString)(properties.localGatewayId));
  errors.collect(cdk.propertyValidator("mode", cdk.validateString)(properties.mode));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnLocalGatewayRouteTableTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRouteTableTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRouteTableTagPropertyValidator(properties).assertSuccess();
  return {
    "LocalGatewayId": cdk.stringToCloudFormation(properties.localGatewayId),
    "Mode": cdk.stringToCloudFormation(properties.mode),
    "Tags": cdk.listMapper(convertCfnLocalGatewayRouteTableTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRouteTableTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLocalGatewayRouteTable.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteTable.TagProperty>();
  ret.addPropertyResult("localGatewayId", "LocalGatewayId", (properties.LocalGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayId) : undefined));
  ret.addPropertyResult("mode", "Mode", (properties.Mode != null ? cfn_parse.FromCloudFormation.getString(properties.Mode) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnLocalGatewayRouteTableTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnLocalGatewayRouteTableProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLocalGatewayRouteTableProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRouteTablePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("localGatewayId", cdk.requiredValidator)(properties.localGatewayId));
  errors.collect(cdk.propertyValidator("localGatewayId", cdk.validateString)(properties.localGatewayId));
  errors.collect(cdk.propertyValidator("mode", cdk.validateString)(properties.mode));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnLocalGatewayRouteTableProps\\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRouteTablePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRouteTablePropsValidator(properties).assertSuccess();
  return {
    "LocalGatewayId": cdk.stringToCloudFormation(properties.localGatewayId),
    "Mode": cdk.stringToCloudFormation(properties.mode),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRouteTablePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLocalGatewayRouteTableProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteTableProps>();
  ret.addPropertyResult("localGatewayId", "LocalGatewayId", (properties.LocalGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayId) : undefined));
  ret.addPropertyResult("mode", "Mode", (properties.Mode != null ? cfn_parse.FromCloudFormation.getString(properties.Mode) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes an association between a local gateway route table and a virtual interface group.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html
 */
export class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation";

  /**
   * Build a CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the local gateway.
   *
   * @cloudformationAttribute LocalGatewayId
   */
  public readonly attrLocalGatewayId: string;

  /**
   * The Amazon Resource Name (ARN) of the local gateway route table for the virtual interface group.
   *
   * @cloudformationAttribute LocalGatewayRouteTableArn
   */
  public readonly attrLocalGatewayRouteTableArn: string;

  /**
   * The ID of the association.
   *
   * @cloudformationAttribute LocalGatewayRouteTableVirtualInterfaceGroupAssociationId
   */
  public readonly attrLocalGatewayRouteTableVirtualInterfaceGroupAssociationId: string;

  /**
   * The ID of the AWS account that owns the local gateway virtual interface group association.
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The state of the association.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The ID of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-localgatewayroutetableid
   */
  public localGatewayRouteTableId: string;

  /**
   * The ID of the virtual interface group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-localgatewayvirtualinterfacegroupid
   */
  public localGatewayVirtualInterfaceGroupId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags assigned to the association.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps) {
    super(scope, id, {
      "type": CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "localGatewayRouteTableId", this);
    cdk.requireProperty(props, "localGatewayVirtualInterfaceGroupId", this);

    this.attrLocalGatewayId = cdk.Token.asString(this.getAtt("LocalGatewayId", cdk.ResolutionTypeHint.STRING));
    this.attrLocalGatewayRouteTableArn = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableArn", cdk.ResolutionTypeHint.STRING));
    this.attrLocalGatewayRouteTableVirtualInterfaceGroupAssociationId = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableVirtualInterfaceGroupAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.localGatewayRouteTableId = props.localGatewayRouteTableId;
    this.localGatewayVirtualInterfaceGroupId = props.localGatewayVirtualInterfaceGroupId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "localGatewayRouteTableId": this.localGatewayRouteTableId,
      "localGatewayVirtualInterfaceGroupId": this.localGatewayVirtualInterfaceGroupId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsToCloudFormation(props);
  }
}

export namespace CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tag.html
   */
  export interface TagProperty {
    /**
     * The ID of the local gateway route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tag.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tag-localgatewayroutetableid
     */
    readonly localGatewayRouteTableId: string;

    /**
     * The ID of the virtual interface group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tag.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tag-localgatewayvirtualinterfacegroupid
     */
    readonly localGatewayVirtualInterfaceGroupId: string;

    /**
     * The tags assigned to the association.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tag.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html
 */
export interface CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps {
  /**
   * The ID of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-localgatewayroutetableid
   */
  readonly localGatewayRouteTableId: string;

  /**
   * The ID of the virtual interface group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-localgatewayvirtualinterfacegroupid
   */
  readonly localGatewayVirtualInterfaceGroupId: string;

  /**
   * The tags assigned to the association.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.requiredValidator)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.validateString)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayVirtualInterfaceGroupId", cdk.requiredValidator)(properties.localGatewayVirtualInterfaceGroupId));
  errors.collect(cdk.propertyValidator("localGatewayVirtualInterfaceGroupId", cdk.validateString)(properties.localGatewayVirtualInterfaceGroupId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationTagPropertyValidator(properties).assertSuccess();
  return {
    "LocalGatewayRouteTableId": cdk.stringToCloudFormation(properties.localGatewayRouteTableId),
    "LocalGatewayVirtualInterfaceGroupId": cdk.stringToCloudFormation(properties.localGatewayVirtualInterfaceGroupId),
    "Tags": cdk.listMapper(convertCfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation.TagProperty>();
  ret.addPropertyResult("localGatewayRouteTableId", "LocalGatewayRouteTableId", (properties.LocalGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayRouteTableId) : undefined));
  ret.addPropertyResult("localGatewayVirtualInterfaceGroupId", "LocalGatewayVirtualInterfaceGroupId", (properties.LocalGatewayVirtualInterfaceGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayVirtualInterfaceGroupId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.requiredValidator)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.validateString)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayVirtualInterfaceGroupId", cdk.requiredValidator)(properties.localGatewayVirtualInterfaceGroupId));
  errors.collect(cdk.propertyValidator("localGatewayVirtualInterfaceGroupId", cdk.validateString)(properties.localGatewayVirtualInterfaceGroupId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsValidator(properties).assertSuccess();
  return {
    "LocalGatewayRouteTableId": cdk.stringToCloudFormation(properties.localGatewayRouteTableId),
    "LocalGatewayVirtualInterfaceGroupId": cdk.stringToCloudFormation(properties.localGatewayVirtualInterfaceGroupId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps>();
  ret.addPropertyResult("localGatewayRouteTableId", "LocalGatewayRouteTableId", (properties.LocalGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayRouteTableId) : undefined));
  ret.addPropertyResult("localGatewayVirtualInterfaceGroupId", "LocalGatewayVirtualInterfaceGroupId", (properties.LocalGatewayVirtualInterfaceGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayVirtualInterfaceGroupId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates the specified VPC with the specified local gateway route table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html
 */
export class CfnLocalGatewayRouteTableVPCAssociation extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::LocalGatewayRouteTableVPCAssociation";

  /**
   * Build a CfnLocalGatewayRouteTableVPCAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLocalGatewayRouteTableVPCAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLocalGatewayRouteTableVPCAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLocalGatewayRouteTableVPCAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the local gateway.
   *
   * @cloudformationAttribute LocalGatewayId
   */
  public readonly attrLocalGatewayId: string;

  /**
   * The ID of the association.
   *
   * @cloudformationAttribute LocalGatewayRouteTableVpcAssociationId
   */
  public readonly attrLocalGatewayRouteTableVpcAssociationId: string;

  /**
   * The state of the association.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The ID of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-localgatewayroutetableid
   */
  public localGatewayRouteTableId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags assigned to the association.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-vpcid
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLocalGatewayRouteTableVPCAssociationProps) {
    super(scope, id, {
      "type": CfnLocalGatewayRouteTableVPCAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "localGatewayRouteTableId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrLocalGatewayId = cdk.Token.asString(this.getAtt("LocalGatewayId", cdk.ResolutionTypeHint.STRING));
    this.attrLocalGatewayRouteTableVpcAssociationId = cdk.Token.asString(this.getAtt("LocalGatewayRouteTableVpcAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.localGatewayRouteTableId = props.localGatewayRouteTableId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::LocalGatewayRouteTableVPCAssociation", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "localGatewayRouteTableId": this.localGatewayRouteTableId,
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLocalGatewayRouteTableVPCAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLocalGatewayRouteTableVPCAssociationPropsToCloudFormation(props);
  }
}

export namespace CfnLocalGatewayRouteTableVPCAssociation {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-localgatewayroutetablevpcassociation-tag.html
   */
  export interface TagProperty {
    /**
     * The ID of the local gateway route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-localgatewayroutetablevpcassociation-tag.html#cfn-ec2-localgatewayroutetablevpcassociation-tag-localgatewayroutetableid
     */
    readonly localGatewayRouteTableId: string;

    /**
     * The tags assigned to the association.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-localgatewayroutetablevpcassociation-tag.html#cfn-ec2-localgatewayroutetablevpcassociation-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnLocalGatewayRouteTableVPCAssociation.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-localgatewayroutetablevpcassociation-tag.html#cfn-ec2-localgatewayroutetablevpcassociation-tag-vpcid
     */
    readonly vpcId: string;
  }
}

/**
 * Properties for defining a \`CfnLocalGatewayRouteTableVPCAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html
 */
export interface CfnLocalGatewayRouteTableVPCAssociationProps {
  /**
   * The ID of the local gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-localgatewayroutetableid
   */
  readonly localGatewayRouteTableId: string;

  /**
   * The tags assigned to the association.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVPCAssociationTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.requiredValidator)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.validateString)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnLocalGatewayRouteTableVPCAssociationTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRouteTableVPCAssociationTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRouteTableVPCAssociationTagPropertyValidator(properties).assertSuccess();
  return {
    "LocalGatewayRouteTableId": cdk.stringToCloudFormation(properties.localGatewayRouteTableId),
    "Tags": cdk.listMapper(convertCfnLocalGatewayRouteTableVPCAssociationTagPropertyToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVPCAssociationTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnLocalGatewayRouteTableVPCAssociation.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteTableVPCAssociation.TagProperty>();
  ret.addPropertyResult("localGatewayRouteTableId", "LocalGatewayRouteTableId", (properties.LocalGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayRouteTableId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnLocalGatewayRouteTableVPCAssociationTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnLocalGatewayRouteTableVPCAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLocalGatewayRouteTableVPCAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVPCAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.requiredValidator)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("localGatewayRouteTableId", cdk.validateString)(properties.localGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnLocalGatewayRouteTableVPCAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnLocalGatewayRouteTableVPCAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLocalGatewayRouteTableVPCAssociationPropsValidator(properties).assertSuccess();
  return {
    "LocalGatewayRouteTableId": cdk.stringToCloudFormation(properties.localGatewayRouteTableId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnLocalGatewayRouteTableVPCAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLocalGatewayRouteTableVPCAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLocalGatewayRouteTableVPCAssociationProps>();
  ret.addPropertyResult("localGatewayRouteTableId", "LocalGatewayRouteTableId", (properties.LocalGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayRouteTableId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a network address translation (NAT) gateway in the specified subnet.
 *
 * You can create either a public NAT gateway or a private NAT gateway. The default is a public NAT gateway. If you create a public NAT gateway, you must specify an elastic IP address.
 *
 * With a NAT gateway, instances in a private subnet can connect to the internet, other AWS services, or an on-premises network using the IP address of the NAT gateway.
 *
 * If you add a default route ( \`AWS::EC2::Route\` resource) that points to a NAT gateway, specify the NAT gateway ID for the route's \`NatGatewayId\` property.
 *
 * For more information, see [NAT Gateways](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html) in the *Amazon VPC User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html
 */
export class CfnNatGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NatGateway";

  /**
   * Build a CfnNatGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNatGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNatGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNatGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the NAT gateway.
   *
   * @cloudformationAttribute NatGatewayId
   */
  public readonly attrNatGatewayId: string;

  /**
   * [Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-allocationid
   */
  public allocationId?: string;

  /**
   * Indicates whether the NAT gateway supports public or private connectivity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-connectivitytype
   */
  public connectivityType?: string;

  /**
   * The maximum amount of time to wait (in seconds) before forcibly releasing the IP addresses if connections are still in progress.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-maxdraindurationseconds
   */
  public maxDrainDurationSeconds?: number;

  /**
   * The private IPv4 address to assign to the NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-privateipaddress
   */
  public privateIpAddress?: string;

  /**
   * Secondary EIP allocation IDs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryallocationids
   */
  public secondaryAllocationIds?: Array<string>;

  /**
   * [Private NAT gateway only] The number of secondary private IPv4 addresses you want to assign to the NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryprivateipaddresscount
   */
  public secondaryPrivateIpAddressCount?: number;

  /**
   * Secondary private IPv4 addresses.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryprivateipaddresses
   */
  public secondaryPrivateIpAddresses?: Array<string>;

  /**
   * The ID of the subnet in which the NAT gateway is located.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-subnetid
   */
  public subnetId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNatGatewayProps) {
    super(scope, id, {
      "type": CfnNatGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetId", this);

    this.attrNatGatewayId = cdk.Token.asString(this.getAtt("NatGatewayId", cdk.ResolutionTypeHint.STRING));
    this.allocationId = props.allocationId;
    this.connectivityType = props.connectivityType;
    this.maxDrainDurationSeconds = props.maxDrainDurationSeconds;
    this.privateIpAddress = props.privateIpAddress;
    this.secondaryAllocationIds = props.secondaryAllocationIds;
    this.secondaryPrivateIpAddressCount = props.secondaryPrivateIpAddressCount;
    this.secondaryPrivateIpAddresses = props.secondaryPrivateIpAddresses;
    this.subnetId = props.subnetId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NatGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allocationId": this.allocationId,
      "connectivityType": this.connectivityType,
      "maxDrainDurationSeconds": this.maxDrainDurationSeconds,
      "privateIpAddress": this.privateIpAddress,
      "secondaryAllocationIds": this.secondaryAllocationIds,
      "secondaryPrivateIpAddressCount": this.secondaryPrivateIpAddressCount,
      "secondaryPrivateIpAddresses": this.secondaryPrivateIpAddresses,
      "subnetId": this.subnetId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNatGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNatGatewayPropsToCloudFormation(props);
  }
}

export namespace CfnNatGateway {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-tag.html
   */
  export interface TagProperty {
    /**
     * [Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.
     *
     * This property is required for a public NAT gateway and cannot be specified with a private NAT gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-tag.html#cfn-ec2-natgateway-tag-allocationid
     */
    readonly allocationId?: string;

    /**
     * Indicates whether the NAT gateway supports public or private connectivity.
     *
     * The default is public connectivity.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-tag.html#cfn-ec2-natgateway-tag-connectivitytype
     */
    readonly connectivityType?: string;

    /**
     * The maximum amount of time to wait (in seconds) before forcibly releasing the IP addresses if connections are still in progress.
     *
     * Default value is 350 seconds.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-tag.html#cfn-ec2-natgateway-tag-maxdraindurationseconds
     */
    readonly maxDrainDurationSeconds?: number;

    /**
     * The private IPv4 address to assign to the NAT gateway.
     *
     * If you don't provide an address, a private IPv4 address will be automatically assigned.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-tag.html#cfn-ec2-natgateway-tag-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Secondary EIP allocation IDs.
     *
     * For more information, see [Create a NAT gateway](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating) in the *Amazon VPC User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-tag.html#cfn-ec2-natgateway-tag-secondaryallocationids
     */
    readonly secondaryAllocationIds?: Array<string>;

    /**
     * [Private NAT gateway only] The number of secondary private IPv4 addresses you want to assign to the NAT gateway.
     *
     * For more information about secondary addresses, see [Create a NAT gateway](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating) in the *Amazon Virtual Private Cloud User Guide* .
     *
     * > \`SecondaryPrivateIpAddressCount\` and \`SecondaryPrivateIpAddresses\` cannot be set at the same time.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-tag.html#cfn-ec2-natgateway-tag-secondaryprivateipaddresscount
     */
    readonly secondaryPrivateIpAddressCount?: number;

    /**
     * Secondary private IPv4 addresses.
     *
     * For more information about secondary addresses, see [Create a NAT gateway](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating) in the *Amazon Virtual Private Cloud User Guide* .
     *
     * > \`SecondaryPrivateIpAddressCount\` and \`SecondaryPrivateIpAddresses\` cannot be set at the same time.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-tag.html#cfn-ec2-natgateway-tag-secondaryprivateipaddresses
     */
    readonly secondaryPrivateIpAddresses?: Array<string>;

    /**
     * The ID of the subnet in which the NAT gateway is located.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-tag.html#cfn-ec2-natgateway-tag-subnetid
     */
    readonly subnetId: string;

    /**
     * The tags for the NAT gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-tag.html#cfn-ec2-natgateway-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNatGateway.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnNatGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html
 */
export interface CfnNatGatewayProps {
  /**
   * [Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.
   *
   * This property is required for a public NAT gateway and cannot be specified with a private NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-allocationid
   */
  readonly allocationId?: string;

  /**
   * Indicates whether the NAT gateway supports public or private connectivity.
   *
   * The default is public connectivity.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-connectivitytype
   */
  readonly connectivityType?: string;

  /**
   * The maximum amount of time to wait (in seconds) before forcibly releasing the IP addresses if connections are still in progress.
   *
   * Default value is 350 seconds.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-maxdraindurationseconds
   */
  readonly maxDrainDurationSeconds?: number;

  /**
   * The private IPv4 address to assign to the NAT gateway.
   *
   * If you don't provide an address, a private IPv4 address will be automatically assigned.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-privateipaddress
   */
  readonly privateIpAddress?: string;

  /**
   * Secondary EIP allocation IDs.
   *
   * For more information, see [Create a NAT gateway](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating) in the *Amazon VPC User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryallocationids
   */
  readonly secondaryAllocationIds?: Array<string>;

  /**
   * [Private NAT gateway only] The number of secondary private IPv4 addresses you want to assign to the NAT gateway.
   *
   * For more information about secondary addresses, see [Create a NAT gateway](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * > \`SecondaryPrivateIpAddressCount\` and \`SecondaryPrivateIpAddresses\` cannot be set at the same time.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryprivateipaddresscount
   */
  readonly secondaryPrivateIpAddressCount?: number;

  /**
   * Secondary private IPv4 addresses.
   *
   * For more information about secondary addresses, see [Create a NAT gateway](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * > \`SecondaryPrivateIpAddressCount\` and \`SecondaryPrivateIpAddresses\` cannot be set at the same time.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryprivateipaddresses
   */
  readonly secondaryPrivateIpAddresses?: Array<string>;

  /**
   * The ID of the subnet in which the NAT gateway is located.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-subnetid
   */
  readonly subnetId: string;

  /**
   * The tags for the NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNatGatewayTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationId", cdk.validateString)(properties.allocationId));
  errors.collect(cdk.propertyValidator("connectivityType", cdk.validateString)(properties.connectivityType));
  errors.collect(cdk.propertyValidator("maxDrainDurationSeconds", cdk.validateNumber)(properties.maxDrainDurationSeconds));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("secondaryAllocationIds", cdk.listValidator(cdk.validateString))(properties.secondaryAllocationIds));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddresses", cdk.listValidator(cdk.validateString))(properties.secondaryPrivateIpAddresses));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNatGatewayTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNatGatewayTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNatGatewayTagPropertyValidator(properties).assertSuccess();
  return {
    "AllocationId": cdk.stringToCloudFormation(properties.allocationId),
    "ConnectivityType": cdk.stringToCloudFormation(properties.connectivityType),
    "MaxDrainDurationSeconds": cdk.numberToCloudFormation(properties.maxDrainDurationSeconds),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "SecondaryAllocationIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.secondaryAllocationIds),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SecondaryPrivateIpAddresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.secondaryPrivateIpAddresses),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnNatGatewayTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNatGatewayTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNatGateway.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNatGateway.TagProperty>();
  ret.addPropertyResult("allocationId", "AllocationId", (properties.AllocationId != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationId) : undefined));
  ret.addPropertyResult("connectivityType", "ConnectivityType", (properties.ConnectivityType != null ? cfn_parse.FromCloudFormation.getString(properties.ConnectivityType) : undefined));
  ret.addPropertyResult("maxDrainDurationSeconds", "MaxDrainDurationSeconds", (properties.MaxDrainDurationSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxDrainDurationSeconds) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("secondaryAllocationIds", "SecondaryAllocationIds", (properties.SecondaryAllocationIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecondaryAllocationIds) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddresses", "SecondaryPrivateIpAddresses", (properties.SecondaryPrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecondaryPrivateIpAddresses) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNatGatewayTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNatGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNatGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNatGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allocationId", cdk.validateString)(properties.allocationId));
  errors.collect(cdk.propertyValidator("connectivityType", cdk.validateString)(properties.connectivityType));
  errors.collect(cdk.propertyValidator("maxDrainDurationSeconds", cdk.validateNumber)(properties.maxDrainDurationSeconds));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("secondaryAllocationIds", cdk.listValidator(cdk.validateString))(properties.secondaryAllocationIds));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddresses", cdk.listValidator(cdk.validateString))(properties.secondaryPrivateIpAddresses));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnNatGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnNatGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNatGatewayPropsValidator(properties).assertSuccess();
  return {
    "AllocationId": cdk.stringToCloudFormation(properties.allocationId),
    "ConnectivityType": cdk.stringToCloudFormation(properties.connectivityType),
    "MaxDrainDurationSeconds": cdk.numberToCloudFormation(properties.maxDrainDurationSeconds),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "SecondaryAllocationIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.secondaryAllocationIds),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SecondaryPrivateIpAddresses": cdk.listMapper(cdk.stringToCloudFormation)(properties.secondaryPrivateIpAddresses),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNatGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNatGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNatGatewayProps>();
  ret.addPropertyResult("allocationId", "AllocationId", (properties.AllocationId != null ? cfn_parse.FromCloudFormation.getString(properties.AllocationId) : undefined));
  ret.addPropertyResult("connectivityType", "ConnectivityType", (properties.ConnectivityType != null ? cfn_parse.FromCloudFormation.getString(properties.ConnectivityType) : undefined));
  ret.addPropertyResult("maxDrainDurationSeconds", "MaxDrainDurationSeconds", (properties.MaxDrainDurationSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxDrainDurationSeconds) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("secondaryAllocationIds", "SecondaryAllocationIds", (properties.SecondaryAllocationIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecondaryAllocationIds) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddresses", "SecondaryPrivateIpAddresses", (properties.SecondaryPrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecondaryPrivateIpAddresses) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a network ACL for your VPC.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html
 */
export class CfnNetworkAcl extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkAcl";

  /**
   * Build a CfnNetworkAcl from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkAcl {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkAclPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkAcl(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the network ACL.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the network ACL.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC for the network ACL.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-vpcid
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkAclProps) {
    super(scope, id, {
      "type": CfnNetworkAcl.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkAcl", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkAcl.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkAclPropsToCloudFormation(props);
  }
}

export namespace CfnNetworkAcl {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkacl-tag.html
   */
  export interface TagProperty {
    /**
     * The tags for the network ACL.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkacl-tag.html#cfn-ec2-networkacl-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkAcl.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the VPC for the network ACL.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkacl-tag.html#cfn-ec2-networkacl-tag-vpcid
     */
    readonly vpcId: string;
  }
}

/**
 * Properties for defining a \`CfnNetworkAcl\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html
 */
export interface CfnNetworkAclProps {
  /**
   * The tags for the network ACL.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC for the network ACL.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkAclTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclTagPropertyValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(convertCfnNetworkAclTagPropertyToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkAcl.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAcl.TagProperty>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkAclTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkAclProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkAclProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkAclProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclPropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkAclProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAclProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an entry, known as a rule, in a network ACL with a rule number you specify.
 *
 * Each network ACL has a set of numbered ingress rules and a separate set of numbered egress rules.
 *
 * For information about the protocol value, see [Protocol Numbers](https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) on the Internet Assigned Numbers Authority (IANA) website.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html
 */
export class CfnNetworkAclEntry extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkAclEntry";

  /**
   * Build a CfnNetworkAclEntry from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkAclEntry {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkAclEntryPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkAclEntry(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the network ACL entry.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the \`CidrBlock\` or \`Ipv6CidrBlock\` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-cidrblock
   */
  public cidrBlock?: string;

  /**
   * Whether this rule applies to egress traffic from the subnet ( \`true\` ) or ingress traffic to the subnet ( \`false\` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-egress
   */
  public egress?: boolean | cdk.IResolvable;

  /**
   * The Internet Control Message Protocol (ICMP) code and type.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-icmp
   */
  public icmp?: CfnNetworkAclEntry.IcmpProperty | cdk.IResolvable;

  /**
   * The IPv6 network range to allow or deny, in CIDR notation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ipv6cidrblock
   */
  public ipv6CidrBlock?: string;

  /**
   * The ID of the ACL for the entry.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-networkaclid
   */
  public networkAclId: string;

  /**
   * The range of port numbers for the UDP/TCP protocol.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-portrange
   */
  public portRange?: cdk.IResolvable | CfnNetworkAclEntry.PortRangeProperty;

  /**
   * The IP protocol that the rule applies to.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-protocol
   */
  public protocol: number;

  /**
   * Whether to allow or deny traffic that matches the rule;
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ruleaction
   */
  public ruleAction: string;

  /**
   * Rule number to assign to the entry, such as 100.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-rulenumber
   */
  public ruleNumber: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkAclEntryProps) {
    super(scope, id, {
      "type": CfnNetworkAclEntry.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkAclId", this);
    cdk.requireProperty(props, "protocol", this);
    cdk.requireProperty(props, "ruleAction", this);
    cdk.requireProperty(props, "ruleNumber", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.cidrBlock = props.cidrBlock;
    this.egress = props.egress;
    this.icmp = props.icmp;
    this.ipv6CidrBlock = props.ipv6CidrBlock;
    this.networkAclId = props.networkAclId;
    this.portRange = props.portRange;
    this.protocol = props.protocol;
    this.ruleAction = props.ruleAction;
    this.ruleNumber = props.ruleNumber;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidrBlock": this.cidrBlock,
      "egress": this.egress,
      "icmp": this.icmp,
      "ipv6CidrBlock": this.ipv6CidrBlock,
      "networkAclId": this.networkAclId,
      "portRange": this.portRange,
      "protocol": this.protocol,
      "ruleAction": this.ruleAction,
      "ruleNumber": this.ruleNumber
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkAclEntry.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkAclEntryPropsToCloudFormation(props);
  }
}

export namespace CfnNetworkAclEntry {
  /**
   * Describes a range of ports.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html
   */
  export interface PortRangeProperty {
    /**
     * The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the \`CidrBlock\` or \`Ipv6CidrBlock\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-cidrblock
     */
    readonly cidrBlock?: string;

    /**
     * Whether this rule applies to egress traffic from the subnet ( \`true\` ) or ingress traffic to the subnet ( \`false\` ).
     *
     * By default, AWS CloudFormation specifies \`false\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-egress
     */
    readonly egress?: boolean | cdk.IResolvable;

    /**
     * The Internet Control Message Protocol (ICMP) code and type.
     *
     * Requirement is conditional: Required if specifying 1 (ICMP) for the protocol parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-icmp
     */
    readonly icmp?: CfnNetworkAclEntry.IcmpProperty | cdk.IResolvable;

    /**
     * The IPv6 network range to allow or deny, in CIDR notation.
     *
     * Requirement is conditional: You must specify the \`CidrBlock\` or \`Ipv6CidrBlock\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-ipv6cidrblock
     */
    readonly ipv6CidrBlock?: string;

    /**
     * The ID of the ACL for the entry.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-networkaclid
     */
    readonly networkAclId: string;

    /**
     * The range of port numbers for the UDP/TCP protocol.
     *
     * Conditional required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-portrange
     */
    readonly portRange?: cdk.IResolvable | CfnNetworkAclEntry.PortRangeProperty;

    /**
     * The IP protocol that the rule applies to.
     *
     * You must specify -1 or a protocol number. You can specify -1 for all protocols.
     *
     * > If you specify -1, all ports are opened and the \`PortRange\` property is ignored.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-protocol
     */
    readonly protocol: number;

    /**
     * Whether to allow or deny traffic that matches the rule;
     *
     * valid values are "allow" or "deny".
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-ruleaction
     */
    readonly ruleAction: string;

    /**
     * Rule number to assign to the entry, such as 100.
     *
     * ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-rulenumber
     */
    readonly ruleNumber: number;
  }

  /**
   * Describes the ICMP type and code.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html
   */
  export interface IcmpProperty {
    /**
     * The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the \`CidrBlock\` or \`Ipv6CidrBlock\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-cidrblock
     */
    readonly cidrBlock?: string;

    /**
     * Whether this rule applies to egress traffic from the subnet ( \`true\` ) or ingress traffic to the subnet ( \`false\` ).
     *
     * By default, AWS CloudFormation specifies \`false\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-egress
     */
    readonly egress?: boolean | cdk.IResolvable;

    /**
     * The Internet Control Message Protocol (ICMP) code and type.
     *
     * Requirement is conditional: Required if specifying 1 (ICMP) for the protocol parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-icmp
     */
    readonly icmp?: CfnNetworkAclEntry.IcmpProperty | cdk.IResolvable;

    /**
     * The IPv6 network range to allow or deny, in CIDR notation.
     *
     * Requirement is conditional: You must specify the \`CidrBlock\` or \`Ipv6CidrBlock\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-ipv6cidrblock
     */
    readonly ipv6CidrBlock?: string;

    /**
     * The ID of the ACL for the entry.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-networkaclid
     */
    readonly networkAclId: string;

    /**
     * The range of port numbers for the UDP/TCP protocol.
     *
     * Conditional required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-portrange
     */
    readonly portRange?: cdk.IResolvable | CfnNetworkAclEntry.PortRangeProperty;

    /**
     * The IP protocol that the rule applies to.
     *
     * You must specify -1 or a protocol number. You can specify -1 for all protocols.
     *
     * > If you specify -1, all ports are opened and the \`PortRange\` property is ignored.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-protocol
     */
    readonly protocol: number;

    /**
     * Whether to allow or deny traffic that matches the rule;
     *
     * valid values are "allow" or "deny".
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-ruleaction
     */
    readonly ruleAction: string;

    /**
     * Rule number to assign to the entry, such as 100.
     *
     * ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-rulenumber
     */
    readonly ruleNumber: number;
  }
}

/**
 * Properties for defining a \`CfnNetworkAclEntry\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html
 */
export interface CfnNetworkAclEntryProps {
  /**
   * The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the \`CidrBlock\` or \`Ipv6CidrBlock\` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-cidrblock
   */
  readonly cidrBlock?: string;

  /**
   * Whether this rule applies to egress traffic from the subnet ( \`true\` ) or ingress traffic to the subnet ( \`false\` ).
   *
   * By default, AWS CloudFormation specifies \`false\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-egress
   */
  readonly egress?: boolean | cdk.IResolvable;

  /**
   * The Internet Control Message Protocol (ICMP) code and type.
   *
   * Requirement is conditional: Required if specifying 1 (ICMP) for the protocol parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-icmp
   */
  readonly icmp?: CfnNetworkAclEntry.IcmpProperty | cdk.IResolvable;

  /**
   * The IPv6 network range to allow or deny, in CIDR notation.
   *
   * Requirement is conditional: You must specify the \`CidrBlock\` or \`Ipv6CidrBlock\` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ipv6cidrblock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * The ID of the ACL for the entry.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-networkaclid
   */
  readonly networkAclId: string;

  /**
   * The range of port numbers for the UDP/TCP protocol.
   *
   * Conditional required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-portrange
   */
  readonly portRange?: cdk.IResolvable | CfnNetworkAclEntry.PortRangeProperty;

  /**
   * The IP protocol that the rule applies to.
   *
   * You must specify -1 or a protocol number. You can specify -1 for all protocols.
   *
   * > If you specify -1, all ports are opened and the \`PortRange\` property is ignored.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-protocol
   */
  readonly protocol: number;

  /**
   * Whether to allow or deny traffic that matches the rule;
   *
   * valid values are "allow" or "deny".
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ruleaction
   */
  readonly ruleAction: string;

  /**
   * Rule number to assign to the entry, such as 100.
   *
   * ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-rulenumber
   */
  readonly ruleNumber: number;
}

/**
 * Determine whether the given properties match those of a \`IcmpProperty\`
 *
 * @param properties - the TypeScript properties of a \`IcmpProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclEntryIcmpPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("egress", cdk.validateBoolean)(properties.egress));
  errors.collect(cdk.propertyValidator("icmp", CfnNetworkAclEntryIcmpPropertyValidator)(properties.icmp));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.requiredValidator)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.validateString)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("portRange", CfnNetworkAclEntryPortRangePropertyValidator)(properties.portRange));
  errors.collect(cdk.propertyValidator("protocol", cdk.requiredValidator)(properties.protocol));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateNumber)(properties.protocol));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.requiredValidator)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.validateString)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.requiredValidator)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.validateNumber)(properties.ruleNumber));
  return errors.wrap("supplied properties not correct for \\"IcmpProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclEntryIcmpPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclEntryIcmpPropertyValidator(properties).assertSuccess();
  return {
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "Egress": cdk.booleanToCloudFormation(properties.egress),
    "Icmp": convertCfnNetworkAclEntryIcmpPropertyToCloudFormation(properties.icmp),
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "NetworkAclId": cdk.stringToCloudFormation(properties.networkAclId),
    "PortRange": convertCfnNetworkAclEntryPortRangePropertyToCloudFormation(properties.portRange),
    "Protocol": cdk.numberToCloudFormation(properties.protocol),
    "RuleAction": cdk.stringToCloudFormation(properties.ruleAction),
    "RuleNumber": cdk.numberToCloudFormation(properties.ruleNumber)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclEntryIcmpPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkAclEntry.IcmpProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAclEntry.IcmpProperty>();
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("egress", "Egress", (properties.Egress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Egress) : undefined));
  ret.addPropertyResult("icmp", "Icmp", (properties.Icmp != null ? CfnNetworkAclEntryIcmpPropertyFromCloudFormation(properties.Icmp) : undefined));
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("networkAclId", "NetworkAclId", (properties.NetworkAclId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkAclId) : undefined));
  ret.addPropertyResult("portRange", "PortRange", (properties.PortRange != null ? CfnNetworkAclEntryPortRangePropertyFromCloudFormation(properties.PortRange) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getNumber(properties.Protocol) : undefined));
  ret.addPropertyResult("ruleAction", "RuleAction", (properties.RuleAction != null ? cfn_parse.FromCloudFormation.getString(properties.RuleAction) : undefined));
  ret.addPropertyResult("ruleNumber", "RuleNumber", (properties.RuleNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.RuleNumber) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PortRangeProperty\`
 *
 * @param properties - the TypeScript properties of a \`PortRangeProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclEntryPortRangePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("egress", cdk.validateBoolean)(properties.egress));
  errors.collect(cdk.propertyValidator("icmp", CfnNetworkAclEntryIcmpPropertyValidator)(properties.icmp));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.requiredValidator)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.validateString)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("portRange", CfnNetworkAclEntryPortRangePropertyValidator)(properties.portRange));
  errors.collect(cdk.propertyValidator("protocol", cdk.requiredValidator)(properties.protocol));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateNumber)(properties.protocol));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.requiredValidator)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.validateString)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.requiredValidator)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.validateNumber)(properties.ruleNumber));
  return errors.wrap("supplied properties not correct for \\"PortRangeProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclEntryPortRangePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclEntryPortRangePropertyValidator(properties).assertSuccess();
  return {
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "Egress": cdk.booleanToCloudFormation(properties.egress),
    "Icmp": convertCfnNetworkAclEntryIcmpPropertyToCloudFormation(properties.icmp),
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "NetworkAclId": cdk.stringToCloudFormation(properties.networkAclId),
    "PortRange": convertCfnNetworkAclEntryPortRangePropertyToCloudFormation(properties.portRange),
    "Protocol": cdk.numberToCloudFormation(properties.protocol),
    "RuleAction": cdk.stringToCloudFormation(properties.ruleAction),
    "RuleNumber": cdk.numberToCloudFormation(properties.ruleNumber)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclEntryPortRangePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkAclEntry.PortRangeProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAclEntry.PortRangeProperty>();
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("egress", "Egress", (properties.Egress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Egress) : undefined));
  ret.addPropertyResult("icmp", "Icmp", (properties.Icmp != null ? CfnNetworkAclEntryIcmpPropertyFromCloudFormation(properties.Icmp) : undefined));
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("networkAclId", "NetworkAclId", (properties.NetworkAclId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkAclId) : undefined));
  ret.addPropertyResult("portRange", "PortRange", (properties.PortRange != null ? CfnNetworkAclEntryPortRangePropertyFromCloudFormation(properties.PortRange) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getNumber(properties.Protocol) : undefined));
  ret.addPropertyResult("ruleAction", "RuleAction", (properties.RuleAction != null ? cfn_parse.FromCloudFormation.getString(properties.RuleAction) : undefined));
  ret.addPropertyResult("ruleNumber", "RuleNumber", (properties.RuleNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.RuleNumber) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkAclEntryProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkAclEntryProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkAclEntryPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("egress", cdk.validateBoolean)(properties.egress));
  errors.collect(cdk.propertyValidator("icmp", CfnNetworkAclEntryIcmpPropertyValidator)(properties.icmp));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.requiredValidator)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.validateString)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("portRange", CfnNetworkAclEntryPortRangePropertyValidator)(properties.portRange));
  errors.collect(cdk.propertyValidator("protocol", cdk.requiredValidator)(properties.protocol));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateNumber)(properties.protocol));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.requiredValidator)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.validateString)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.requiredValidator)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.validateNumber)(properties.ruleNumber));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkAclEntryProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkAclEntryPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkAclEntryPropsValidator(properties).assertSuccess();
  return {
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "Egress": cdk.booleanToCloudFormation(properties.egress),
    "Icmp": convertCfnNetworkAclEntryIcmpPropertyToCloudFormation(properties.icmp),
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "NetworkAclId": cdk.stringToCloudFormation(properties.networkAclId),
    "PortRange": convertCfnNetworkAclEntryPortRangePropertyToCloudFormation(properties.portRange),
    "Protocol": cdk.numberToCloudFormation(properties.protocol),
    "RuleAction": cdk.stringToCloudFormation(properties.ruleAction),
    "RuleNumber": cdk.numberToCloudFormation(properties.ruleNumber)
  };
}

// @ts-ignore TS6133
function CfnNetworkAclEntryPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkAclEntryProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkAclEntryProps>();
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("egress", "Egress", (properties.Egress != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Egress) : undefined));
  ret.addPropertyResult("icmp", "Icmp", (properties.Icmp != null ? CfnNetworkAclEntryIcmpPropertyFromCloudFormation(properties.Icmp) : undefined));
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("networkAclId", "NetworkAclId", (properties.NetworkAclId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkAclId) : undefined));
  ret.addPropertyResult("portRange", "PortRange", (properties.PortRange != null ? CfnNetworkAclEntryPortRangePropertyFromCloudFormation(properties.PortRange) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getNumber(properties.Protocol) : undefined));
  ret.addPropertyResult("ruleAction", "RuleAction", (properties.RuleAction != null ? cfn_parse.FromCloudFormation.getString(properties.RuleAction) : undefined));
  ret.addPropertyResult("ruleNumber", "RuleNumber", (properties.RuleNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.RuleNumber) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a Network Access Scope.
 *
 * A Network Access Scope defines outbound (egress) and inbound (ingress) traffic patterns, including sources, destinations, paths, and traffic types.
 *
 * Network Access Analyzer identifies unintended network access to your resources on AWS . When you start an analysis on a Network Access Scope, Network Access Analyzer produces findings. For more information, see the [Network Access Analyzer User Guide](https://docs.aws.amazon.com/vpc/latest/network-access-analyzer/) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html
 */
export class CfnNetworkInsightsAccessScope extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInsightsAccessScope";

  /**
   * Build a CfnNetworkInsightsAccessScope from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInsightsAccessScope {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInsightsAccessScopePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInsightsAccessScope(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation date.
   *
   * @cloudformationAttribute CreatedDate
   */
  public readonly attrCreatedDate: string;

  /**
   * The ARN of the Network Access Scope.
   *
   * @cloudformationAttribute NetworkInsightsAccessScopeArn
   */
  public readonly attrNetworkInsightsAccessScopeArn: string;

  /**
   * The ID of the Network Access Scope.
   *
   * @cloudformationAttribute NetworkInsightsAccessScopeId
   */
  public readonly attrNetworkInsightsAccessScopeId: string;

  /**
   * The last updated date.
   *
   * @cloudformationAttribute UpdatedDate
   */
  public readonly attrUpdatedDate: string;

  /**
   * The paths to exclude.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-excludepaths
   */
  public excludePaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The paths to match.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-matchpaths
   */
  public matchPaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInsightsAccessScopeProps = {}) {
    super(scope, id, {
      "type": CfnNetworkInsightsAccessScope.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrCreatedDate = cdk.Token.asString(this.getAtt("CreatedDate", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAccessScopeArn = cdk.Token.asString(this.getAtt("NetworkInsightsAccessScopeArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAccessScopeId = cdk.Token.asString(this.getAtt("NetworkInsightsAccessScopeId", cdk.ResolutionTypeHint.STRING));
    this.attrUpdatedDate = cdk.Token.asString(this.getAtt("UpdatedDate", cdk.ResolutionTypeHint.STRING));
    this.excludePaths = props.excludePaths;
    this.matchPaths = props.matchPaths;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInsightsAccessScope", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "excludePaths": this.excludePaths,
      "matchPaths": this.matchPaths,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInsightsAccessScope.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInsightsAccessScopePropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInsightsAccessScope {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-tag.html
   */
  export interface TagProperty {
    /**
     * The paths to exclude.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-tag.html#cfn-ec2-networkinsightsaccessscope-tag-excludepaths
     */
    readonly excludePaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The paths to match.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-tag.html#cfn-ec2-networkinsightsaccessscope-tag-matchpaths
     */
    readonly matchPaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-tag.html#cfn-ec2-networkinsightsaccessscope-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkInsightsAccessScope.TagProperty> | cdk.IResolvable;
  }

  /**
   * Describes a path.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html
   */
  export interface AccessScopePathRequestProperty {
    /**
     * The paths to exclude.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-excludepaths
     */
    readonly excludePaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The paths to match.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-matchpaths
     */
    readonly matchPaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkInsightsAccessScope.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnNetworkInsightsAccessScope\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html
 */
export interface CfnNetworkInsightsAccessScopeProps {
  /**
   * The paths to exclude.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-excludepaths
   */
  readonly excludePaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The paths to match.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-matchpaths
   */
  readonly matchPaths?: Array<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`AccessScopePathRequestProperty\`
 *
 * @param properties - the TypeScript properties of a \`AccessScopePathRequestProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("excludePaths", cdk.listValidator(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator))(properties.excludePaths));
  errors.collect(cdk.propertyValidator("matchPaths", cdk.listValidator(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator))(properties.matchPaths));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkInsightsAccessScopeTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"AccessScopePathRequestProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator(properties).assertSuccess();
  return {
    "ExcludePaths": cdk.listMapper(convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation)(properties.excludePaths),
    "MatchPaths": cdk.listMapper(convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation)(properties.matchPaths),
    "Tags": cdk.listMapper(convertCfnNetworkInsightsAccessScopeTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty>();
  ret.addPropertyResult("excludePaths", "ExcludePaths", (properties.ExcludePaths != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation)(properties.ExcludePaths) : undefined));
  ret.addPropertyResult("matchPaths", "MatchPaths", (properties.MatchPaths != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation)(properties.MatchPaths) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("excludePaths", cdk.listValidator(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator))(properties.excludePaths));
  errors.collect(cdk.propertyValidator("matchPaths", cdk.listValidator(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator))(properties.matchPaths));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkInsightsAccessScopeTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopeTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopeTagPropertyValidator(properties).assertSuccess();
  return {
    "ExcludePaths": cdk.listMapper(convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation)(properties.excludePaths),
    "MatchPaths": cdk.listMapper(convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation)(properties.matchPaths),
    "Tags": cdk.listMapper(convertCfnNetworkInsightsAccessScopeTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAccessScope.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScope.TagProperty>();
  ret.addPropertyResult("excludePaths", "ExcludePaths", (properties.ExcludePaths != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation)(properties.ExcludePaths) : undefined));
  ret.addPropertyResult("matchPaths", "MatchPaths", (properties.MatchPaths != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation)(properties.MatchPaths) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInsightsAccessScopeProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInsightsAccessScopeProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("excludePaths", cdk.listValidator(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator))(properties.excludePaths));
  errors.collect(cdk.propertyValidator("matchPaths", cdk.listValidator(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyValidator))(properties.matchPaths));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInsightsAccessScopeProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopePropsValidator(properties).assertSuccess();
  return {
    "ExcludePaths": cdk.listMapper(convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation)(properties.excludePaths),
    "MatchPaths": cdk.listMapper(convertCfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyToCloudFormation)(properties.matchPaths),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAccessScopeProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScopeProps>();
  ret.addPropertyResult("excludePaths", "ExcludePaths", (properties.ExcludePaths != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation)(properties.ExcludePaths) : undefined));
  ret.addPropertyResult("matchPaths", "MatchPaths", (properties.MatchPaths != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeAccessScopePathRequestPropertyFromCloudFormation)(properties.MatchPaths) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a Network Access Scope analysis.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html
 */
export class CfnNetworkInsightsAccessScopeAnalysis extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInsightsAccessScopeAnalysis";

  /**
   * Build a CfnNetworkInsightsAccessScopeAnalysis from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInsightsAccessScopeAnalysis {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInsightsAccessScopeAnalysisPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInsightsAccessScopeAnalysis(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The number of network interfaces analyzed.
   *
   * @cloudformationAttribute AnalyzedEniCount
   */
  public readonly attrAnalyzedEniCount: cdk.IResolvable;

  /**
   * The end date of the analysis.
   *
   * @cloudformationAttribute EndDate
   */
  public readonly attrEndDate: string;

  /**
   * Indicates whether there are findings (true | false | unknown).
   *
   * @cloudformationAttribute FindingsFound
   */
  public readonly attrFindingsFound: string;

  /**
   * The ARN of the Network Access Scope analysis.
   *
   * @cloudformationAttribute NetworkInsightsAccessScopeAnalysisArn
   */
  public readonly attrNetworkInsightsAccessScopeAnalysisArn: string;

  /**
   * The ID of the Network Access Scope analysis.
   *
   * @cloudformationAttribute NetworkInsightsAccessScopeAnalysisId
   */
  public readonly attrNetworkInsightsAccessScopeAnalysisId: string;

  /**
   * The start date of the analysis.
   *
   * @cloudformationAttribute StartDate
   */
  public readonly attrStartDate: string;

  /**
   * The status of the analysis (running | succeeded | failed).
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The status message.
   *
   * @cloudformationAttribute StatusMessage
   */
  public readonly attrStatusMessage: string;

  /**
   * The ID of the Network Access Scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-networkinsightsaccessscopeid
   */
  public networkInsightsAccessScopeId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInsightsAccessScopeAnalysisProps) {
    super(scope, id, {
      "type": CfnNetworkInsightsAccessScopeAnalysis.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkInsightsAccessScopeId", this);

    this.attrAnalyzedEniCount = this.getAtt("AnalyzedEniCount", cdk.ResolutionTypeHint.NUMBER);
    this.attrEndDate = cdk.Token.asString(this.getAtt("EndDate", cdk.ResolutionTypeHint.STRING));
    this.attrFindingsFound = cdk.Token.asString(this.getAtt("FindingsFound", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAccessScopeAnalysisArn = cdk.Token.asString(this.getAtt("NetworkInsightsAccessScopeAnalysisArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAccessScopeAnalysisId = cdk.Token.asString(this.getAtt("NetworkInsightsAccessScopeAnalysisId", cdk.ResolutionTypeHint.STRING));
    this.attrStartDate = cdk.Token.asString(this.getAtt("StartDate", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("StatusMessage", cdk.ResolutionTypeHint.STRING));
    this.networkInsightsAccessScopeId = props.networkInsightsAccessScopeId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInsightsAccessScopeAnalysis", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "networkInsightsAccessScopeId": this.networkInsightsAccessScopeId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInsightsAccessScopeAnalysis.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInsightsAccessScopeAnalysisPropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInsightsAccessScopeAnalysis {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscopeanalysis-tag.html
   */
  export interface TagProperty {
    /**
     * The ID of the Network Access Scope.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscopeanalysis-tag.html#cfn-ec2-networkinsightsaccessscopeanalysis-tag-networkinsightsaccessscopeid
     */
    readonly networkInsightsAccessScopeId: string;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscopeanalysis-tag.html#cfn-ec2-networkinsightsaccessscopeanalysis-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkInsightsAccessScopeAnalysis.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnNetworkInsightsAccessScopeAnalysis\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html
 */
export interface CfnNetworkInsightsAccessScopeAnalysisProps {
  /**
   * The ID of the Network Access Scope.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-networkinsightsaccessscopeid
   */
  readonly networkInsightsAccessScopeId: string;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAnalysisTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("networkInsightsAccessScopeId", cdk.requiredValidator)(properties.networkInsightsAccessScopeId));
  errors.collect(cdk.propertyValidator("networkInsightsAccessScopeId", cdk.validateString)(properties.networkInsightsAccessScopeId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkInsightsAccessScopeAnalysisTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopeAnalysisTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopeAnalysisTagPropertyValidator(properties).assertSuccess();
  return {
    "NetworkInsightsAccessScopeId": cdk.stringToCloudFormation(properties.networkInsightsAccessScopeId),
    "Tags": cdk.listMapper(convertCfnNetworkInsightsAccessScopeAnalysisTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAnalysisTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAccessScopeAnalysis.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScopeAnalysis.TagProperty>();
  ret.addPropertyResult("networkInsightsAccessScopeId", "NetworkInsightsAccessScopeId", (properties.NetworkInsightsAccessScopeId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInsightsAccessScopeId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAccessScopeAnalysisTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInsightsAccessScopeAnalysisProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInsightsAccessScopeAnalysisProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAnalysisPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("networkInsightsAccessScopeId", cdk.requiredValidator)(properties.networkInsightsAccessScopeId));
  errors.collect(cdk.propertyValidator("networkInsightsAccessScopeId", cdk.validateString)(properties.networkInsightsAccessScopeId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInsightsAccessScopeAnalysisProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAccessScopeAnalysisPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAccessScopeAnalysisPropsValidator(properties).assertSuccess();
  return {
    "NetworkInsightsAccessScopeId": cdk.stringToCloudFormation(properties.networkInsightsAccessScopeId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAccessScopeAnalysisPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAccessScopeAnalysisProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAccessScopeAnalysisProps>();
  ret.addPropertyResult("networkInsightsAccessScopeId", "NetworkInsightsAccessScopeId", (properties.NetworkInsightsAccessScopeId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInsightsAccessScopeId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a network insights analysis.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html
 */
export class CfnNetworkInsightsAnalysis extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInsightsAnalysis";

  /**
   * Build a CfnNetworkInsightsAnalysis from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInsightsAnalysis {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInsightsAnalysisPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInsightsAnalysis(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Potential intermediate components.
   *
   * @cloudformationAttribute AlternatePathHints
   */
  public readonly attrAlternatePathHints: cdk.IResolvable;

  /**
   * The explanations. For more information, see [Reachability Analyzer explanation codes](https://docs.aws.amazon.com/vpc/latest/reachability/explanation-codes.html) .
   *
   * @cloudformationAttribute Explanations
   */
  public readonly attrExplanations: cdk.IResolvable;

  /**
   * The components in the path from source to destination.
   *
   * @cloudformationAttribute ForwardPathComponents
   */
  public readonly attrForwardPathComponents: cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the network insights analysis.
   *
   * @cloudformationAttribute NetworkInsightsAnalysisArn
   */
  public readonly attrNetworkInsightsAnalysisArn: string;

  /**
   * The ID of the network insights analysis.
   *
   * @cloudformationAttribute NetworkInsightsAnalysisId
   */
  public readonly attrNetworkInsightsAnalysisId: string;

  /**
   * Indicates whether the destination is reachable from the source.
   *
   * @cloudformationAttribute NetworkPathFound
   */
  public readonly attrNetworkPathFound: cdk.IResolvable;

  /**
   * The components in the path from destination to source.
   *
   * @cloudformationAttribute ReturnPathComponents
   */
  public readonly attrReturnPathComponents: cdk.IResolvable;

  /**
   * The time the analysis started.
   *
   * @cloudformationAttribute StartDate
   */
  public readonly attrStartDate: string;

  /**
   * The status of the network insights analysis.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The status message, if the status is \`failed\` .
   *
   * @cloudformationAttribute StatusMessage
   */
  public readonly attrStatusMessage: string;

  /**
   * The IDs of potential intermediate accounts.
   *
   * @cloudformationAttribute SuggestedAccounts
   */
  public readonly attrSuggestedAccounts: Array<string>;

  /**
   * The member accounts that contain resources that the path can traverse.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-additionalaccounts
   */
  public additionalAccounts?: Array<string>;

  /**
   * The Amazon Resource Names (ARN) of the resources that the path must traverse.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-filterinarns
   */
  public filterInArns?: Array<string>;

  /**
   * The ID of the path.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-networkinsightspathid
   */
  public networkInsightsPathId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInsightsAnalysisProps) {
    super(scope, id, {
      "type": CfnNetworkInsightsAnalysis.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkInsightsPathId", this);

    this.attrAlternatePathHints = this.getAtt("AlternatePathHints");
    this.attrExplanations = this.getAtt("Explanations");
    this.attrForwardPathComponents = this.getAtt("ForwardPathComponents");
    this.attrNetworkInsightsAnalysisArn = cdk.Token.asString(this.getAtt("NetworkInsightsAnalysisArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsAnalysisId = cdk.Token.asString(this.getAtt("NetworkInsightsAnalysisId", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkPathFound = this.getAtt("NetworkPathFound");
    this.attrReturnPathComponents = this.getAtt("ReturnPathComponents");
    this.attrStartDate = cdk.Token.asString(this.getAtt("StartDate", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("StatusMessage", cdk.ResolutionTypeHint.STRING));
    this.attrSuggestedAccounts = cdk.Token.asList(this.getAtt("SuggestedAccounts", cdk.ResolutionTypeHint.STRING_LIST));
    this.additionalAccounts = props.additionalAccounts;
    this.filterInArns = props.filterInArns;
    this.networkInsightsPathId = props.networkInsightsPathId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInsightsAnalysis", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "additionalAccounts": this.additionalAccounts,
      "filterInArns": this.filterInArns,
      "networkInsightsPathId": this.networkInsightsPathId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInsightsAnalysis.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInsightsAnalysisPropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInsightsAnalysis {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-tag.html
   */
  export interface TagProperty {
    /**
     * The member accounts that contain resources that the path can traverse.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-tag.html#cfn-ec2-networkinsightsanalysis-tag-additionalaccounts
     */
    readonly additionalAccounts?: Array<string>;

    /**
     * The Amazon Resource Names (ARN) of the resources that the path must traverse.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-tag.html#cfn-ec2-networkinsightsanalysis-tag-filterinarns
     */
    readonly filterInArns?: Array<string>;

    /**
     * The ID of the path.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-tag.html#cfn-ec2-networkinsightsanalysis-tag-networkinsightspathid
     */
    readonly networkInsightsPathId: string;

    /**
     * The tags to apply.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-tag.html#cfn-ec2-networkinsightsanalysis-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkInsightsAnalysis.TagProperty> | cdk.IResolvable;
  }

  /**
   * Describes a path component.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html
   */
  export interface PathComponentProperty {
    /**
     * The member accounts that contain resources that the path can traverse.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-additionalaccounts
     */
    readonly additionalAccounts?: Array<string>;

    /**
     * The Amazon Resource Names (ARN) of the resources that the path must traverse.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-filterinarns
     */
    readonly filterInArns?: Array<string>;

    /**
     * The ID of the path.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-networkinsightspathid
     */
    readonly networkInsightsPathId: string;

    /**
     * The tags to apply.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkInsightsAnalysis.TagProperty> | cdk.IResolvable;
  }

  /**
   * Describes an explanation code for an unreachable path.
   *
   * For more information, see [Reachability Analyzer explanation codes](https://docs.aws.amazon.com/vpc/latest/reachability/explanation-codes.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html
   */
  export interface ExplanationProperty {
    /**
     * The member accounts that contain resources that the path can traverse.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-additionalaccounts
     */
    readonly additionalAccounts?: Array<string>;

    /**
     * The Amazon Resource Names (ARN) of the resources that the path must traverse.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-filterinarns
     */
    readonly filterInArns?: Array<string>;

    /**
     * The ID of the path.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-networkinsightspathid
     */
    readonly networkInsightsPathId: string;

    /**
     * The tags to apply.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkInsightsAnalysis.TagProperty> | cdk.IResolvable;
  }

  /**
   * Describes an potential intermediate component of a feasible path.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html
   */
  export interface AlternatePathHintProperty {
    /**
     * The member accounts that contain resources that the path can traverse.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-additionalaccounts
     */
    readonly additionalAccounts?: Array<string>;

    /**
     * The Amazon Resource Names (ARN) of the resources that the path must traverse.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-filterinarns
     */
    readonly filterInArns?: Array<string>;

    /**
     * The ID of the path.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-networkinsightspathid
     */
    readonly networkInsightsPathId: string;

    /**
     * The tags to apply.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkInsightsAnalysis.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnNetworkInsightsAnalysis\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html
 */
export interface CfnNetworkInsightsAnalysisProps {
  /**
   * The member accounts that contain resources that the path can traverse.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-additionalaccounts
   */
  readonly additionalAccounts?: Array<string>;

  /**
   * The Amazon Resource Names (ARN) of the resources that the path must traverse.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-filterinarns
   */
  readonly filterInArns?: Array<string>;

  /**
   * The ID of the path.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-networkinsightspathid
   */
  readonly networkInsightsPathId: string;

  /**
   * The tags to apply.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalAccounts", cdk.listValidator(cdk.validateString))(properties.additionalAccounts));
  errors.collect(cdk.propertyValidator("filterInArns", cdk.listValidator(cdk.validateString))(properties.filterInArns));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.requiredValidator)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.validateString)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkInsightsAnalysisTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisTagPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalAccounts": cdk.listMapper(cdk.stringToCloudFormation)(properties.additionalAccounts),
    "FilterInArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.filterInArns),
    "NetworkInsightsPathId": cdk.stringToCloudFormation(properties.networkInsightsPathId),
    "Tags": cdk.listMapper(convertCfnNetworkInsightsAnalysisTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAnalysis.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.TagProperty>();
  ret.addPropertyResult("additionalAccounts", "AdditionalAccounts", (properties.AdditionalAccounts != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AdditionalAccounts) : undefined));
  ret.addPropertyResult("filterInArns", "FilterInArns", (properties.FilterInArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.FilterInArns) : undefined));
  ret.addPropertyResult("networkInsightsPathId", "NetworkInsightsPathId", (properties.NetworkInsightsPathId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInsightsPathId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PathComponentProperty\`
 *
 * @param properties - the TypeScript properties of a \`PathComponentProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPathComponentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalAccounts", cdk.listValidator(cdk.validateString))(properties.additionalAccounts));
  errors.collect(cdk.propertyValidator("filterInArns", cdk.listValidator(cdk.validateString))(properties.filterInArns));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.requiredValidator)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.validateString)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkInsightsAnalysisTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"PathComponentProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisPathComponentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisPathComponentPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalAccounts": cdk.listMapper(cdk.stringToCloudFormation)(properties.additionalAccounts),
    "FilterInArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.filterInArns),
    "NetworkInsightsPathId": cdk.stringToCloudFormation(properties.networkInsightsPathId),
    "Tags": cdk.listMapper(convertCfnNetworkInsightsAnalysisTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPathComponentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsAnalysis.PathComponentProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.PathComponentProperty>();
  ret.addPropertyResult("additionalAccounts", "AdditionalAccounts", (properties.AdditionalAccounts != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AdditionalAccounts) : undefined));
  ret.addPropertyResult("filterInArns", "FilterInArns", (properties.FilterInArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.FilterInArns) : undefined));
  ret.addPropertyResult("networkInsightsPathId", "NetworkInsightsPathId", (properties.NetworkInsightsPathId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInsightsPathId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ExplanationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ExplanationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisExplanationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalAccounts", cdk.listValidator(cdk.validateString))(properties.additionalAccounts));
  errors.collect(cdk.propertyValidator("filterInArns", cdk.listValidator(cdk.validateString))(properties.filterInArns));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.requiredValidator)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.validateString)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkInsightsAnalysisTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"ExplanationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisExplanationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisExplanationPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalAccounts": cdk.listMapper(cdk.stringToCloudFormation)(properties.additionalAccounts),
    "FilterInArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.filterInArns),
    "NetworkInsightsPathId": cdk.stringToCloudFormation(properties.networkInsightsPathId),
    "Tags": cdk.listMapper(convertCfnNetworkInsightsAnalysisTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisExplanationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.ExplanationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.ExplanationProperty>();
  ret.addPropertyResult("additionalAccounts", "AdditionalAccounts", (properties.AdditionalAccounts != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AdditionalAccounts) : undefined));
  ret.addPropertyResult("filterInArns", "FilterInArns", (properties.FilterInArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.FilterInArns) : undefined));
  ret.addPropertyResult("networkInsightsPathId", "NetworkInsightsPathId", (properties.NetworkInsightsPathId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInsightsPathId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AlternatePathHintProperty\`
 *
 * @param properties - the TypeScript properties of a \`AlternatePathHintProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAlternatePathHintPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalAccounts", cdk.listValidator(cdk.validateString))(properties.additionalAccounts));
  errors.collect(cdk.propertyValidator("filterInArns", cdk.listValidator(cdk.validateString))(properties.filterInArns));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.requiredValidator)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.validateString)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkInsightsAnalysisTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"AlternatePathHintProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisAlternatePathHintPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisAlternatePathHintPropertyValidator(properties).assertSuccess();
  return {
    "AdditionalAccounts": cdk.listMapper(cdk.stringToCloudFormation)(properties.additionalAccounts),
    "FilterInArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.filterInArns),
    "NetworkInsightsPathId": cdk.stringToCloudFormation(properties.networkInsightsPathId),
    "Tags": cdk.listMapper(convertCfnNetworkInsightsAnalysisTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisAlternatePathHintPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysis.AlternatePathHintProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysis.AlternatePathHintProperty>();
  ret.addPropertyResult("additionalAccounts", "AdditionalAccounts", (properties.AdditionalAccounts != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AdditionalAccounts) : undefined));
  ret.addPropertyResult("filterInArns", "FilterInArns", (properties.FilterInArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.FilterInArns) : undefined));
  ret.addPropertyResult("networkInsightsPathId", "NetworkInsightsPathId", (properties.NetworkInsightsPathId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInsightsPathId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsAnalysisTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInsightsAnalysisProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInsightsAnalysisProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("additionalAccounts", cdk.listValidator(cdk.validateString))(properties.additionalAccounts));
  errors.collect(cdk.propertyValidator("filterInArns", cdk.listValidator(cdk.validateString))(properties.filterInArns));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.requiredValidator)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("networkInsightsPathId", cdk.validateString)(properties.networkInsightsPathId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInsightsAnalysisProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsAnalysisPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsAnalysisPropsValidator(properties).assertSuccess();
  return {
    "AdditionalAccounts": cdk.listMapper(cdk.stringToCloudFormation)(properties.additionalAccounts),
    "FilterInArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.filterInArns),
    "NetworkInsightsPathId": cdk.stringToCloudFormation(properties.networkInsightsPathId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsAnalysisPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsAnalysisProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsAnalysisProps>();
  ret.addPropertyResult("additionalAccounts", "AdditionalAccounts", (properties.AdditionalAccounts != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AdditionalAccounts) : undefined));
  ret.addPropertyResult("filterInArns", "FilterInArns", (properties.FilterInArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.FilterInArns) : undefined));
  ret.addPropertyResult("networkInsightsPathId", "NetworkInsightsPathId", (properties.NetworkInsightsPathId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInsightsPathId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a path to analyze for reachability.
 *
 * VPC Reachability Analyzer enables you to analyze and debug network reachability between two resources in your virtual private cloud (VPC). For more information, see the [Reachability Analyzer User Guide](https://docs.aws.amazon.com/vpc/latest/reachability/what-is-reachability-analyzer.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html
 */
export class CfnNetworkInsightsPath extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInsightsPath";

  /**
   * Build a CfnNetworkInsightsPath from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInsightsPath {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInsightsPathPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInsightsPath(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The time stamp when the path was created.
   *
   * @cloudformationAttribute CreatedDate
   */
  public readonly attrCreatedDate: string;

  /**
   * The Amazon Resource Name (ARN) of the destination.
   *
   * @cloudformationAttribute DestinationArn
   */
  public readonly attrDestinationArn: string;

  /**
   * The Amazon Resource Name (ARN) of the path.
   *
   * @cloudformationAttribute NetworkInsightsPathArn
   */
  public readonly attrNetworkInsightsPathArn: string;

  /**
   * The ID of the path.
   *
   * @cloudformationAttribute NetworkInsightsPathId
   */
  public readonly attrNetworkInsightsPathId: string;

  /**
   * The Amazon Resource Name (ARN) of the source.
   *
   * @cloudformationAttribute SourceArn
   */
  public readonly attrSourceArn: string;

  /**
   * The ID or ARN of the destination.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destination
   */
  public destination?: string;

  /**
   * The IP address of the destination.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationip
   */
  public destinationIp?: string;

  /**
   * The destination port.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationport
   */
  public destinationPort?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-filteratdestination
   */
  public filterAtDestination?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-filteratsource
   */
  public filterAtSource?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

  /**
   * The protocol.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-protocol
   */
  public protocol: string;

  /**
   * The ID or ARN of the source.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-source
   */
  public source: string;

  /**
   * The IP address of the source.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-sourceip
   */
  public sourceIp?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to add to the path.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInsightsPathProps) {
    super(scope, id, {
      "type": CfnNetworkInsightsPath.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "protocol", this);
    cdk.requireProperty(props, "source", this);

    this.attrCreatedDate = cdk.Token.asString(this.getAtt("CreatedDate", cdk.ResolutionTypeHint.STRING));
    this.attrDestinationArn = cdk.Token.asString(this.getAtt("DestinationArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsPathArn = cdk.Token.asString(this.getAtt("NetworkInsightsPathArn", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInsightsPathId = cdk.Token.asString(this.getAtt("NetworkInsightsPathId", cdk.ResolutionTypeHint.STRING));
    this.attrSourceArn = cdk.Token.asString(this.getAtt("SourceArn", cdk.ResolutionTypeHint.STRING));
    this.destination = props.destination;
    this.destinationIp = props.destinationIp;
    this.destinationPort = props.destinationPort;
    this.filterAtDestination = props.filterAtDestination;
    this.filterAtSource = props.filterAtSource;
    this.protocol = props.protocol;
    this.source = props.source;
    this.sourceIp = props.sourceIp;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInsightsPath", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "destination": this.destination,
      "destinationIp": this.destinationIp,
      "destinationPort": this.destinationPort,
      "filterAtDestination": this.filterAtDestination,
      "filterAtSource": this.filterAtSource,
      "protocol": this.protocol,
      "source": this.source,
      "sourceIp": this.sourceIp,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInsightsPath.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInsightsPathPropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInsightsPath {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html
   */
  export interface PathFilterProperty {
    /**
     * The ID or ARN of the destination.
     *
     * If the resource is in another account, you must specify an ARN.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-destination
     */
    readonly destination?: string;

    /**
     * The IP address of the destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-destinationip
     */
    readonly destinationIp?: string;

    /**
     * The destination port.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-destinationport
     */
    readonly destinationPort?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-filteratdestination
     */
    readonly filterAtDestination?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-filteratsource
     */
    readonly filterAtSource?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

    /**
     * The protocol.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-protocol
     */
    readonly protocol: string;

    /**
     * The ID or ARN of the source.
     *
     * If the resource is in another account, you must specify an ARN.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-source
     */
    readonly source: string;

    /**
     * The IP address of the source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-sourceip
     */
    readonly sourceIp?: string;

    /**
     * The tags to add to the path.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkInsightsPath.TagProperty> | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-tag.html
   */
  export interface TagProperty {
    /**
     * The ID or ARN of the destination.
     *
     * If the resource is in another account, you must specify an ARN.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-tag.html#cfn-ec2-networkinsightspath-tag-destination
     */
    readonly destination?: string;

    /**
     * The IP address of the destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-tag.html#cfn-ec2-networkinsightspath-tag-destinationip
     */
    readonly destinationIp?: string;

    /**
     * The destination port.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-tag.html#cfn-ec2-networkinsightspath-tag-destinationport
     */
    readonly destinationPort?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-tag.html#cfn-ec2-networkinsightspath-tag-filteratdestination
     */
    readonly filterAtDestination?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-tag.html#cfn-ec2-networkinsightspath-tag-filteratsource
     */
    readonly filterAtSource?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

    /**
     * The protocol.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-tag.html#cfn-ec2-networkinsightspath-tag-protocol
     */
    readonly protocol: string;

    /**
     * The ID or ARN of the source.
     *
     * If the resource is in another account, you must specify an ARN.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-tag.html#cfn-ec2-networkinsightspath-tag-source
     */
    readonly source: string;

    /**
     * The IP address of the source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-tag.html#cfn-ec2-networkinsightspath-tag-sourceip
     */
    readonly sourceIp?: string;

    /**
     * The tags to add to the path.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-tag.html#cfn-ec2-networkinsightspath-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkInsightsPath.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnNetworkInsightsPath\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html
 */
export interface CfnNetworkInsightsPathProps {
  /**
   * The ID or ARN of the destination.
   *
   * If the resource is in another account, you must specify an ARN.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destination
   */
  readonly destination?: string;

  /**
   * The IP address of the destination.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationip
   */
  readonly destinationIp?: string;

  /**
   * The destination port.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationport
   */
  readonly destinationPort?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-filteratdestination
   */
  readonly filterAtDestination?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-filteratsource
   */
  readonly filterAtSource?: cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty;

  /**
   * The protocol.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-protocol
   */
  readonly protocol: string;

  /**
   * The ID or ARN of the source.
   *
   * If the resource is in another account, you must specify an ARN.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-source
   */
  readonly source: string;

  /**
   * The IP address of the source.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-sourceip
   */
  readonly sourceIp?: string;

  /**
   * The tags to add to the path.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsPathTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", cdk.validateString)(properties.destination));
  errors.collect(cdk.propertyValidator("destinationIp", cdk.validateString)(properties.destinationIp));
  errors.collect(cdk.propertyValidator("destinationPort", cdk.validateNumber)(properties.destinationPort));
  errors.collect(cdk.propertyValidator("filterAtDestination", CfnNetworkInsightsPathPathFilterPropertyValidator)(properties.filterAtDestination));
  errors.collect(cdk.propertyValidator("filterAtSource", CfnNetworkInsightsPathPathFilterPropertyValidator)(properties.filterAtSource));
  errors.collect(cdk.propertyValidator("protocol", cdk.requiredValidator)(properties.protocol));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("source", cdk.requiredValidator)(properties.source));
  errors.collect(cdk.propertyValidator("source", cdk.validateString)(properties.source));
  errors.collect(cdk.propertyValidator("sourceIp", cdk.validateString)(properties.sourceIp));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkInsightsPathTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsPathTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsPathTagPropertyValidator(properties).assertSuccess();
  return {
    "Destination": cdk.stringToCloudFormation(properties.destination),
    "DestinationIp": cdk.stringToCloudFormation(properties.destinationIp),
    "DestinationPort": cdk.numberToCloudFormation(properties.destinationPort),
    "FilterAtDestination": convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties.filterAtDestination),
    "FilterAtSource": convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties.filterAtSource),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "Source": cdk.stringToCloudFormation(properties.source),
    "SourceIp": cdk.stringToCloudFormation(properties.sourceIp),
    "Tags": cdk.listMapper(convertCfnNetworkInsightsPathTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsPathTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsPath.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsPath.TagProperty>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? cfn_parse.FromCloudFormation.getString(properties.Destination) : undefined));
  ret.addPropertyResult("destinationIp", "DestinationIp", (properties.DestinationIp != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationIp) : undefined));
  ret.addPropertyResult("destinationPort", "DestinationPort", (properties.DestinationPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.DestinationPort) : undefined));
  ret.addPropertyResult("filterAtDestination", "FilterAtDestination", (properties.FilterAtDestination != null ? CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties.FilterAtDestination) : undefined));
  ret.addPropertyResult("filterAtSource", "FilterAtSource", (properties.FilterAtSource != null ? CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties.FilterAtSource) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? cfn_parse.FromCloudFormation.getString(properties.Source) : undefined));
  ret.addPropertyResult("sourceIp", "SourceIp", (properties.SourceIp != null ? cfn_parse.FromCloudFormation.getString(properties.SourceIp) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsPathTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PathFilterProperty\`
 *
 * @param properties - the TypeScript properties of a \`PathFilterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsPathPathFilterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", cdk.validateString)(properties.destination));
  errors.collect(cdk.propertyValidator("destinationIp", cdk.validateString)(properties.destinationIp));
  errors.collect(cdk.propertyValidator("destinationPort", cdk.validateNumber)(properties.destinationPort));
  errors.collect(cdk.propertyValidator("filterAtDestination", CfnNetworkInsightsPathPathFilterPropertyValidator)(properties.filterAtDestination));
  errors.collect(cdk.propertyValidator("filterAtSource", CfnNetworkInsightsPathPathFilterPropertyValidator)(properties.filterAtSource));
  errors.collect(cdk.propertyValidator("protocol", cdk.requiredValidator)(properties.protocol));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("source", cdk.requiredValidator)(properties.source));
  errors.collect(cdk.propertyValidator("source", cdk.validateString)(properties.source));
  errors.collect(cdk.propertyValidator("sourceIp", cdk.validateString)(properties.sourceIp));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkInsightsPathTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"PathFilterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsPathPathFilterPropertyValidator(properties).assertSuccess();
  return {
    "Destination": cdk.stringToCloudFormation(properties.destination),
    "DestinationIp": cdk.stringToCloudFormation(properties.destinationIp),
    "DestinationPort": cdk.numberToCloudFormation(properties.destinationPort),
    "FilterAtDestination": convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties.filterAtDestination),
    "FilterAtSource": convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties.filterAtSource),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "Source": cdk.stringToCloudFormation(properties.source),
    "SourceIp": cdk.stringToCloudFormation(properties.sourceIp),
    "Tags": cdk.listMapper(convertCfnNetworkInsightsPathTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInsightsPath.PathFilterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsPath.PathFilterProperty>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? cfn_parse.FromCloudFormation.getString(properties.Destination) : undefined));
  ret.addPropertyResult("destinationIp", "DestinationIp", (properties.DestinationIp != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationIp) : undefined));
  ret.addPropertyResult("destinationPort", "DestinationPort", (properties.DestinationPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.DestinationPort) : undefined));
  ret.addPropertyResult("filterAtDestination", "FilterAtDestination", (properties.FilterAtDestination != null ? CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties.FilterAtDestination) : undefined));
  ret.addPropertyResult("filterAtSource", "FilterAtSource", (properties.FilterAtSource != null ? CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties.FilterAtSource) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? cfn_parse.FromCloudFormation.getString(properties.Source) : undefined));
  ret.addPropertyResult("sourceIp", "SourceIp", (properties.SourceIp != null ? cfn_parse.FromCloudFormation.getString(properties.SourceIp) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInsightsPathTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInsightsPathProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInsightsPathProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInsightsPathPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", cdk.validateString)(properties.destination));
  errors.collect(cdk.propertyValidator("destinationIp", cdk.validateString)(properties.destinationIp));
  errors.collect(cdk.propertyValidator("destinationPort", cdk.validateNumber)(properties.destinationPort));
  errors.collect(cdk.propertyValidator("filterAtDestination", CfnNetworkInsightsPathPathFilterPropertyValidator)(properties.filterAtDestination));
  errors.collect(cdk.propertyValidator("filterAtSource", CfnNetworkInsightsPathPathFilterPropertyValidator)(properties.filterAtSource));
  errors.collect(cdk.propertyValidator("protocol", cdk.requiredValidator)(properties.protocol));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateString)(properties.protocol));
  errors.collect(cdk.propertyValidator("source", cdk.requiredValidator)(properties.source));
  errors.collect(cdk.propertyValidator("source", cdk.validateString)(properties.source));
  errors.collect(cdk.propertyValidator("sourceIp", cdk.validateString)(properties.sourceIp));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInsightsPathProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInsightsPathPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInsightsPathPropsValidator(properties).assertSuccess();
  return {
    "Destination": cdk.stringToCloudFormation(properties.destination),
    "DestinationIp": cdk.stringToCloudFormation(properties.destinationIp),
    "DestinationPort": cdk.numberToCloudFormation(properties.destinationPort),
    "FilterAtDestination": convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties.filterAtDestination),
    "FilterAtSource": convertCfnNetworkInsightsPathPathFilterPropertyToCloudFormation(properties.filterAtSource),
    "Protocol": cdk.stringToCloudFormation(properties.protocol),
    "Source": cdk.stringToCloudFormation(properties.source),
    "SourceIp": cdk.stringToCloudFormation(properties.sourceIp),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInsightsPathPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInsightsPathProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInsightsPathProps>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? cfn_parse.FromCloudFormation.getString(properties.Destination) : undefined));
  ret.addPropertyResult("destinationIp", "DestinationIp", (properties.DestinationIp != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationIp) : undefined));
  ret.addPropertyResult("destinationPort", "DestinationPort", (properties.DestinationPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.DestinationPort) : undefined));
  ret.addPropertyResult("filterAtDestination", "FilterAtDestination", (properties.FilterAtDestination != null ? CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties.FilterAtDestination) : undefined));
  ret.addPropertyResult("filterAtSource", "FilterAtSource", (properties.FilterAtSource != null ? CfnNetworkInsightsPathPathFilterPropertyFromCloudFormation(properties.FilterAtSource) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getString(properties.Protocol) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? cfn_parse.FromCloudFormation.getString(properties.Source) : undefined));
  ret.addPropertyResult("sourceIp", "SourceIp", (properties.SourceIp != null ? cfn_parse.FromCloudFormation.getString(properties.SourceIp) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a network interface in an Amazon EC2 instance for AWS CloudFormation .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html
 */
export class CfnNetworkInterface extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInterface";

  /**
   * Build a CfnNetworkInterface from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInterface {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInterfacePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInterface(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the network interface.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The primary private IP address of the network interface. For example, \`10.0.0.192\` .
   *
   * @cloudformationAttribute PrimaryPrivateIpAddress
   */
  public readonly attrPrimaryPrivateIpAddress: string;

  /**
   * The secondary private IP addresses of the network interface. For example, \`["10.0.0.161", "10.0.0.162", "10.0.0.163"]\` .
   *
   * @cloudformationAttribute SecondaryPrivateIpAddresses
   */
  public readonly attrSecondaryPrivateIpAddresses: Array<string>;

  /**
   * A description for the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-description
   */
  public description?: string;

  /**
   * The security group IDs associated with this network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-groupset
   */
  public groupSet?: Array<string>;

  /**
   * The type of network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-interfacetype
   */
  public interfaceType?: string;

  /**
   * The number of IPv6 addresses to assign to a network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresscount
   */
  public ipv6AddressCount?: number;

  /**
   * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresses
   */
  public ipv6Addresses?: Array<CfnNetworkInterface.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Assigns a single private IP address to the network interface, which is used as the primary private IP address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddress
   */
  public privateIpAddress?: string;

  /**
   * Assigns private IP addresses to the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddresses
   */
  public privateIpAddresses?: Array<cdk.IResolvable | CfnNetworkInterface.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

  /**
   * The number of secondary private IPv4 addresses to assign to a network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-secondaryprivateipaddresscount
   */
  public secondaryPrivateIpAddressCount?: number;

  /**
   * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-sourcedestcheck
   */
  public sourceDestCheck?: boolean | cdk.IResolvable;

  /**
   * The ID of the subnet to associate with the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-subnetid
   */
  public subnetId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * An arbitrary set of tags (key-value pairs) for this network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInterfaceProps) {
    super(scope, id, {
      "type": CfnNetworkInterface.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrPrimaryPrivateIpAddress = cdk.Token.asString(this.getAtt("PrimaryPrivateIpAddress", cdk.ResolutionTypeHint.STRING));
    this.attrSecondaryPrivateIpAddresses = cdk.Token.asList(this.getAtt("SecondaryPrivateIpAddresses", cdk.ResolutionTypeHint.STRING_LIST));
    this.description = props.description;
    this.groupSet = props.groupSet;
    this.interfaceType = props.interfaceType;
    this.ipv6AddressCount = props.ipv6AddressCount;
    this.ipv6Addresses = props.ipv6Addresses;
    this.privateIpAddress = props.privateIpAddress;
    this.privateIpAddresses = props.privateIpAddresses;
    this.secondaryPrivateIpAddressCount = props.secondaryPrivateIpAddressCount;
    this.sourceDestCheck = props.sourceDestCheck;
    this.subnetId = props.subnetId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::NetworkInterface", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "groupSet": this.groupSet,
      "interfaceType": this.interfaceType,
      "ipv6AddressCount": this.ipv6AddressCount,
      "ipv6Addresses": this.ipv6Addresses,
      "privateIpAddress": this.privateIpAddress,
      "privateIpAddresses": this.privateIpAddresses,
      "secondaryPrivateIpAddressCount": this.secondaryPrivateIpAddressCount,
      "sourceDestCheck": this.sourceDestCheck,
      "subnetId": this.subnetId,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInterface.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInterfacePropsToCloudFormation(props);
  }
}

export namespace CfnNetworkInterface {
  /**
   * Describes a secondary private IPv4 address for a network interface.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html
   */
  export interface PrivateIpAddressSpecificationProperty {
    /**
     * A description for the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-description
     */
    readonly description?: string;

    /**
     * The security group IDs associated with this network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-groupset
     */
    readonly groupSet?: Array<string>;

    /**
     * The type of network interface.
     *
     * The default is \`interface\` . The supported values are \`efa\` and \`trunk\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-interfacetype
     */
    readonly interfaceType?: string;

    /**
     * The number of IPv6 addresses to assign to a network interface.
     *
     * Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the \`Ipv6Addresses\` property and don't specify this property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface.
     *
     * If you're specifying a number of IPv6 addresses, use the \`Ipv6AddressCount\` property and don't specify this property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnNetworkInterface.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Assigns a single private IP address to the network interface, which is used as the primary private IP address.
     *
     * If you want to specify multiple private IP address, use the \`PrivateIpAddresses\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Assigns private IP addresses to the network interface.
     *
     * You can specify a primary private IP address by setting the value of the \`Primary\` property to \`true\` in the \`PrivateIpAddressSpecification\` property. If you want EC2 to automatically assign private IP addresses, use the \`SecondaryPrivateIpAddressCount\` property and do not specify this property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-privateipaddresses
     */
    readonly privateIpAddresses?: Array<cdk.IResolvable | CfnNetworkInterface.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of secondary private IPv4 addresses to assign to a network interface.
     *
     * When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using \`privateIpAddresses\` .
     *
     * You can't specify a count of private IPv4 addresses if you've specified one of the following: specific private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-secondaryprivateipaddresscount
     */
    readonly secondaryPrivateIpAddressCount?: number;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The ID of the subnet to associate with the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-subnetid
     */
    readonly subnetId: string;

    /**
     * An arbitrary set of tags (key-value pairs) for this network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkInterface.TagProperty> | cdk.IResolvable;
  }

  /**
   * Describes the IPv6 addresses to associate with the network interface.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html
   */
  export interface InstanceIpv6AddressProperty {
    /**
     * A description for the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-description
     */
    readonly description?: string;

    /**
     * The security group IDs associated with this network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-groupset
     */
    readonly groupSet?: Array<string>;

    /**
     * The type of network interface.
     *
     * The default is \`interface\` . The supported values are \`efa\` and \`trunk\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-interfacetype
     */
    readonly interfaceType?: string;

    /**
     * The number of IPv6 addresses to assign to a network interface.
     *
     * Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the \`Ipv6Addresses\` property and don't specify this property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface.
     *
     * If you're specifying a number of IPv6 addresses, use the \`Ipv6AddressCount\` property and don't specify this property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnNetworkInterface.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Assigns a single private IP address to the network interface, which is used as the primary private IP address.
     *
     * If you want to specify multiple private IP address, use the \`PrivateIpAddresses\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Assigns private IP addresses to the network interface.
     *
     * You can specify a primary private IP address by setting the value of the \`Primary\` property to \`true\` in the \`PrivateIpAddressSpecification\` property. If you want EC2 to automatically assign private IP addresses, use the \`SecondaryPrivateIpAddressCount\` property and do not specify this property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-privateipaddresses
     */
    readonly privateIpAddresses?: Array<cdk.IResolvable | CfnNetworkInterface.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of secondary private IPv4 addresses to assign to a network interface.
     *
     * When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using \`privateIpAddresses\` .
     *
     * You can't specify a count of private IPv4 addresses if you've specified one of the following: specific private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-secondaryprivateipaddresscount
     */
    readonly secondaryPrivateIpAddressCount?: number;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The ID of the subnet to associate with the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-subnetid
     */
    readonly subnetId: string;

    /**
     * An arbitrary set of tags (key-value pairs) for this network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkInterface.TagProperty> | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-tag.html
   */
  export interface TagProperty {
    /**
     * A description for the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-tag.html#cfn-ec2-networkinterface-tag-description
     */
    readonly description?: string;

    /**
     * The security group IDs associated with this network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-tag.html#cfn-ec2-networkinterface-tag-groupset
     */
    readonly groupSet?: Array<string>;

    /**
     * The type of network interface.
     *
     * The default is \`interface\` . The supported values are \`efa\` and \`trunk\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-tag.html#cfn-ec2-networkinterface-tag-interfacetype
     */
    readonly interfaceType?: string;

    /**
     * The number of IPv6 addresses to assign to a network interface.
     *
     * Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the \`Ipv6Addresses\` property and don't specify this property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-tag.html#cfn-ec2-networkinterface-tag-ipv6addresscount
     */
    readonly ipv6AddressCount?: number;

    /**
     * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface.
     *
     * If you're specifying a number of IPv6 addresses, use the \`Ipv6AddressCount\` property and don't specify this property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-tag.html#cfn-ec2-networkinterface-tag-ipv6addresses
     */
    readonly ipv6Addresses?: Array<CfnNetworkInterface.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Assigns a single private IP address to the network interface, which is used as the primary private IP address.
     *
     * If you want to specify multiple private IP address, use the \`PrivateIpAddresses\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-tag.html#cfn-ec2-networkinterface-tag-privateipaddress
     */
    readonly privateIpAddress?: string;

    /**
     * Assigns private IP addresses to the network interface.
     *
     * You can specify a primary private IP address by setting the value of the \`Primary\` property to \`true\` in the \`PrivateIpAddressSpecification\` property. If you want EC2 to automatically assign private IP addresses, use the \`SecondaryPrivateIpAddressCount\` property and do not specify this property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-tag.html#cfn-ec2-networkinterface-tag-privateipaddresses
     */
    readonly privateIpAddresses?: Array<cdk.IResolvable | CfnNetworkInterface.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

    /**
     * The number of secondary private IPv4 addresses to assign to a network interface.
     *
     * When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using \`privateIpAddresses\` .
     *
     * You can't specify a count of private IPv4 addresses if you've specified one of the following: specific private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-tag.html#cfn-ec2-networkinterface-tag-secondaryprivateipaddresscount
     */
    readonly secondaryPrivateIpAddressCount?: number;

    /**
     * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
     *
     * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-tag.html#cfn-ec2-networkinterface-tag-sourcedestcheck
     */
    readonly sourceDestCheck?: boolean | cdk.IResolvable;

    /**
     * The ID of the subnet to associate with the network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-tag.html#cfn-ec2-networkinterface-tag-subnetid
     */
    readonly subnetId: string;

    /**
     * An arbitrary set of tags (key-value pairs) for this network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-tag.html#cfn-ec2-networkinterface-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnNetworkInterface.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnNetworkInterface\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html
 */
export interface CfnNetworkInterfaceProps {
  /**
   * A description for the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-description
   */
  readonly description?: string;

  /**
   * The security group IDs associated with this network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-groupset
   */
  readonly groupSet?: Array<string>;

  /**
   * The type of network interface.
   *
   * The default is \`interface\` . The supported values are \`efa\` and \`trunk\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-interfacetype
   */
  readonly interfaceType?: string;

  /**
   * The number of IPv6 addresses to assign to a network interface.
   *
   * Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the \`Ipv6Addresses\` property and don't specify this property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresscount
   */
  readonly ipv6AddressCount?: number;

  /**
   * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface.
   *
   * If you're specifying a number of IPv6 addresses, use the \`Ipv6AddressCount\` property and don't specify this property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresses
   */
  readonly ipv6Addresses?: Array<CfnNetworkInterface.InstanceIpv6AddressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Assigns a single private IP address to the network interface, which is used as the primary private IP address.
   *
   * If you want to specify multiple private IP address, use the \`PrivateIpAddresses\` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddress
   */
  readonly privateIpAddress?: string;

  /**
   * Assigns private IP addresses to the network interface.
   *
   * You can specify a primary private IP address by setting the value of the \`Primary\` property to \`true\` in the \`PrivateIpAddressSpecification\` property. If you want EC2 to automatically assign private IP addresses, use the \`SecondaryPrivateIpAddressCount\` property and do not specify this property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddresses
   */
  readonly privateIpAddresses?: Array<cdk.IResolvable | CfnNetworkInterface.PrivateIpAddressSpecificationProperty> | cdk.IResolvable;

  /**
   * The number of secondary private IPv4 addresses to assign to a network interface.
   *
   * When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using \`privateIpAddresses\` .
   *
   * You can't specify a count of private IPv4 addresses if you've specified one of the following: specific private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-secondaryprivateipaddresscount
   */
  readonly secondaryPrivateIpAddressCount?: number;

  /**
   * Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.
   *
   * If the value is \`true\` , source/destination checks are enabled; otherwise, they are disabled. The default value is \`true\` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-sourcedestcheck
   */
  readonly sourceDestCheck?: boolean | cdk.IResolvable;

  /**
   * The ID of the subnet to associate with the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-subnetid
   */
  readonly subnetId: string;

  /**
   * An arbitrary set of tags (key-value pairs) for this network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfaceTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("groupSet", cdk.listValidator(cdk.validateString))(properties.groupSet));
  errors.collect(cdk.propertyValidator("interfaceType", cdk.validateString)(properties.interfaceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnNetworkInterfaceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddresses", cdk.listValidator(CfnNetworkInterfacePrivateIpAddressSpecificationPropertyValidator))(properties.privateIpAddresses));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkInterfaceTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfaceTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfaceTagPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "GroupSet": cdk.listMapper(cdk.stringToCloudFormation)(properties.groupSet),
    "InterfaceType": cdk.stringToCloudFormation(properties.interfaceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnNetworkInterfaceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PrivateIpAddresses": cdk.listMapper(convertCfnNetworkInterfacePrivateIpAddressSpecificationPropertyToCloudFormation)(properties.privateIpAddresses),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnNetworkInterfaceTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfaceTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInterface.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterface.TagProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("groupSet", "GroupSet", (properties.GroupSet != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GroupSet) : undefined));
  ret.addPropertyResult("interfaceType", "InterfaceType", (properties.InterfaceType != null ? cfn_parse.FromCloudFormation.getString(properties.InterfaceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfaceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("privateIpAddresses", "PrivateIpAddresses", (properties.PrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfacePrivateIpAddressSpecificationPropertyFromCloudFormation)(properties.PrivateIpAddresses) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfaceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InstanceIpv6AddressProperty\`
 *
 * @param properties - the TypeScript properties of a \`InstanceIpv6AddressProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfaceInstanceIpv6AddressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("groupSet", cdk.listValidator(cdk.validateString))(properties.groupSet));
  errors.collect(cdk.propertyValidator("interfaceType", cdk.validateString)(properties.interfaceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnNetworkInterfaceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddresses", cdk.listValidator(CfnNetworkInterfacePrivateIpAddressSpecificationPropertyValidator))(properties.privateIpAddresses));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkInterfaceTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"InstanceIpv6AddressProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfaceInstanceIpv6AddressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfaceInstanceIpv6AddressPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "GroupSet": cdk.listMapper(cdk.stringToCloudFormation)(properties.groupSet),
    "InterfaceType": cdk.stringToCloudFormation(properties.interfaceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnNetworkInterfaceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PrivateIpAddresses": cdk.listMapper(convertCfnNetworkInterfacePrivateIpAddressSpecificationPropertyToCloudFormation)(properties.privateIpAddresses),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnNetworkInterfaceTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfaceInstanceIpv6AddressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterface.InstanceIpv6AddressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterface.InstanceIpv6AddressProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("groupSet", "GroupSet", (properties.GroupSet != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GroupSet) : undefined));
  ret.addPropertyResult("interfaceType", "InterfaceType", (properties.InterfaceType != null ? cfn_parse.FromCloudFormation.getString(properties.InterfaceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfaceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("privateIpAddresses", "PrivateIpAddresses", (properties.PrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfacePrivateIpAddressSpecificationPropertyFromCloudFormation)(properties.PrivateIpAddresses) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfaceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PrivateIpAddressSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`PrivateIpAddressSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfacePrivateIpAddressSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("groupSet", cdk.listValidator(cdk.validateString))(properties.groupSet));
  errors.collect(cdk.propertyValidator("interfaceType", cdk.validateString)(properties.interfaceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnNetworkInterfaceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddresses", cdk.listValidator(CfnNetworkInterfacePrivateIpAddressSpecificationPropertyValidator))(properties.privateIpAddresses));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnNetworkInterfaceTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"PrivateIpAddressSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfacePrivateIpAddressSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfacePrivateIpAddressSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "GroupSet": cdk.listMapper(cdk.stringToCloudFormation)(properties.groupSet),
    "InterfaceType": cdk.stringToCloudFormation(properties.interfaceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnNetworkInterfaceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PrivateIpAddresses": cdk.listMapper(convertCfnNetworkInterfacePrivateIpAddressSpecificationPropertyToCloudFormation)(properties.privateIpAddresses),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(convertCfnNetworkInterfaceTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfacePrivateIpAddressSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnNetworkInterface.PrivateIpAddressSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterface.PrivateIpAddressSpecificationProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("groupSet", "GroupSet", (properties.GroupSet != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GroupSet) : undefined));
  ret.addPropertyResult("interfaceType", "InterfaceType", (properties.InterfaceType != null ? cfn_parse.FromCloudFormation.getString(properties.InterfaceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfaceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("privateIpAddresses", "PrivateIpAddresses", (properties.PrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfacePrivateIpAddressSpecificationPropertyFromCloudFormation)(properties.PrivateIpAddresses) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfaceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInterfaceProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInterfaceProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfacePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("groupSet", cdk.listValidator(cdk.validateString))(properties.groupSet));
  errors.collect(cdk.propertyValidator("interfaceType", cdk.validateString)(properties.interfaceType));
  errors.collect(cdk.propertyValidator("ipv6AddressCount", cdk.validateNumber)(properties.ipv6AddressCount));
  errors.collect(cdk.propertyValidator("ipv6Addresses", cdk.listValidator(CfnNetworkInterfaceInstanceIpv6AddressPropertyValidator))(properties.ipv6Addresses));
  errors.collect(cdk.propertyValidator("privateIpAddress", cdk.validateString)(properties.privateIpAddress));
  errors.collect(cdk.propertyValidator("privateIpAddresses", cdk.listValidator(CfnNetworkInterfacePrivateIpAddressSpecificationPropertyValidator))(properties.privateIpAddresses));
  errors.collect(cdk.propertyValidator("secondaryPrivateIpAddressCount", cdk.validateNumber)(properties.secondaryPrivateIpAddressCount));
  errors.collect(cdk.propertyValidator("sourceDestCheck", cdk.validateBoolean)(properties.sourceDestCheck));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInterfaceProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfacePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfacePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "GroupSet": cdk.listMapper(cdk.stringToCloudFormation)(properties.groupSet),
    "InterfaceType": cdk.stringToCloudFormation(properties.interfaceType),
    "Ipv6AddressCount": cdk.numberToCloudFormation(properties.ipv6AddressCount),
    "Ipv6Addresses": cdk.listMapper(convertCfnNetworkInterfaceInstanceIpv6AddressPropertyToCloudFormation)(properties.ipv6Addresses),
    "PrivateIpAddress": cdk.stringToCloudFormation(properties.privateIpAddress),
    "PrivateIpAddresses": cdk.listMapper(convertCfnNetworkInterfacePrivateIpAddressSpecificationPropertyToCloudFormation)(properties.privateIpAddresses),
    "SecondaryPrivateIpAddressCount": cdk.numberToCloudFormation(properties.secondaryPrivateIpAddressCount),
    "SourceDestCheck": cdk.booleanToCloudFormation(properties.sourceDestCheck),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfacePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterfaceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterfaceProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("groupSet", "GroupSet", (properties.GroupSet != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GroupSet) : undefined));
  ret.addPropertyResult("interfaceType", "InterfaceType", (properties.InterfaceType != null ? cfn_parse.FromCloudFormation.getString(properties.InterfaceType) : undefined));
  ret.addPropertyResult("ipv6AddressCount", "Ipv6AddressCount", (properties.Ipv6AddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6AddressCount) : undefined));
  ret.addPropertyResult("ipv6Addresses", "Ipv6Addresses", (properties.Ipv6Addresses != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfaceInstanceIpv6AddressPropertyFromCloudFormation)(properties.Ipv6Addresses) : undefined));
  ret.addPropertyResult("privateIpAddress", "PrivateIpAddress", (properties.PrivateIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.PrivateIpAddress) : undefined));
  ret.addPropertyResult("privateIpAddresses", "PrivateIpAddresses", (properties.PrivateIpAddresses != null ? cfn_parse.FromCloudFormation.getArray(CfnNetworkInterfacePrivateIpAddressSpecificationPropertyFromCloudFormation)(properties.PrivateIpAddresses) : undefined));
  ret.addPropertyResult("secondaryPrivateIpAddressCount", "SecondaryPrivateIpAddressCount", (properties.SecondaryPrivateIpAddressCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.SecondaryPrivateIpAddressCount) : undefined));
  ret.addPropertyResult("sourceDestCheck", "SourceDestCheck", (properties.SourceDestCheck != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SourceDestCheck) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Attaches an elastic network interface (ENI) to an Amazon EC2 instance.
 *
 * You can use this resource type to attach additional network interfaces to an instance without interruption.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html
 */
export class CfnNetworkInterfaceAttachment extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInterfaceAttachment";

  /**
   * Build a CfnNetworkInterfaceAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInterfaceAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInterfaceAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInterfaceAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Whether to delete the network interface when the instance terminates.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-deleteontermination
   */
  public deleteOnTermination?: boolean | cdk.IResolvable;

  /**
   * The network interface's position in the attachment order.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-deviceindex
   */
  public deviceIndex: string;

  /**
   * The ID of the instance to which you will attach the ENI.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-instanceid
   */
  public instanceId: string;

  /**
   * The ID of the ENI that you want to attach.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-networkinterfaceid
   */
  public networkInterfaceId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInterfaceAttachmentProps) {
    super(scope, id, {
      "type": CfnNetworkInterfaceAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "deviceIndex", this);
    cdk.requireProperty(props, "instanceId", this);
    cdk.requireProperty(props, "networkInterfaceId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.deleteOnTermination = props.deleteOnTermination;
    this.deviceIndex = props.deviceIndex;
    this.instanceId = props.instanceId;
    this.networkInterfaceId = props.networkInterfaceId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "deleteOnTermination": this.deleteOnTermination,
      "deviceIndex": this.deviceIndex,
      "instanceId": this.instanceId,
      "networkInterfaceId": this.networkInterfaceId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInterfaceAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInterfaceAttachmentPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnNetworkInterfaceAttachment\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html
 */
export interface CfnNetworkInterfaceAttachmentProps {
  /**
   * Whether to delete the network interface when the instance terminates.
   *
   * By default, this value is set to \`true\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-deleteontermination
   */
  readonly deleteOnTermination?: boolean | cdk.IResolvable;

  /**
   * The network interface's position in the attachment order.
   *
   * For example, the first attached network interface has a \`DeviceIndex\` of 0.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-deviceindex
   */
  readonly deviceIndex: string;

  /**
   * The ID of the instance to which you will attach the ENI.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-instanceid
   */
  readonly instanceId: string;

  /**
   * The ID of the ENI that you want to attach.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-networkinterfaceid
   */
  readonly networkInterfaceId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInterfaceAttachmentProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInterfaceAttachmentProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfaceAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deleteOnTermination", cdk.validateBoolean)(properties.deleteOnTermination));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.requiredValidator)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("deviceIndex", cdk.validateString)(properties.deviceIndex));
  errors.collect(cdk.propertyValidator("instanceId", cdk.requiredValidator)(properties.instanceId));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInterfaceAttachmentProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfaceAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfaceAttachmentPropsValidator(properties).assertSuccess();
  return {
    "DeleteOnTermination": cdk.booleanToCloudFormation(properties.deleteOnTermination),
    "DeviceIndex": cdk.stringToCloudFormation(properties.deviceIndex),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfaceAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterfaceAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterfaceAttachmentProps>();
  ret.addPropertyResult("deleteOnTermination", "DeleteOnTermination", (properties.DeleteOnTermination != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DeleteOnTermination) : undefined));
  ret.addPropertyResult("deviceIndex", "DeviceIndex", (properties.DeviceIndex != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceIndex) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a permission for an Amazon EC2 network interface.
 *
 * For example, you can grant an AWS authorized partner account permission to attach the specified network interface to an instance in their account.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html
 */
export class CfnNetworkInterfacePermission extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkInterfacePermission";

  /**
   * Build a CfnNetworkInterfacePermission from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkInterfacePermission {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkInterfacePermissionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkInterfacePermission(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The AWS account ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-awsaccountid
   */
  public awsAccountId: string;

  /**
   * The ID of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-networkinterfaceid
   */
  public networkInterfaceId: string;

  /**
   * The type of permission to grant: \`INSTANCE-ATTACH\` or \`EIP-ASSOCIATE\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-permission
   */
  public permission: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkInterfacePermissionProps) {
    super(scope, id, {
      "type": CfnNetworkInterfacePermission.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "awsAccountId", this);
    cdk.requireProperty(props, "networkInterfaceId", this);
    cdk.requireProperty(props, "permission", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.awsAccountId = props.awsAccountId;
    this.networkInterfaceId = props.networkInterfaceId;
    this.permission = props.permission;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "awsAccountId": this.awsAccountId,
      "networkInterfaceId": this.networkInterfaceId,
      "permission": this.permission
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkInterfacePermission.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkInterfacePermissionPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnNetworkInterfacePermission\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html
 */
export interface CfnNetworkInterfacePermissionProps {
  /**
   * The AWS account ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-awsaccountid
   */
  readonly awsAccountId: string;

  /**
   * The ID of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-networkinterfaceid
   */
  readonly networkInterfaceId: string;

  /**
   * The type of permission to grant: \`INSTANCE-ATTACH\` or \`EIP-ASSOCIATE\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-permission
   */
  readonly permission: string;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkInterfacePermissionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkInterfacePermissionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkInterfacePermissionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("awsAccountId", cdk.requiredValidator)(properties.awsAccountId));
  errors.collect(cdk.propertyValidator("awsAccountId", cdk.validateString)(properties.awsAccountId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("permission", cdk.requiredValidator)(properties.permission));
  errors.collect(cdk.propertyValidator("permission", cdk.validateString)(properties.permission));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkInterfacePermissionProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkInterfacePermissionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkInterfacePermissionPropsValidator(properties).assertSuccess();
  return {
    "AwsAccountId": cdk.stringToCloudFormation(properties.awsAccountId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "Permission": cdk.stringToCloudFormation(properties.permission)
  };
}

// @ts-ignore TS6133
function CfnNetworkInterfacePermissionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkInterfacePermissionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkInterfacePermissionProps>();
  ret.addPropertyResult("awsAccountId", "AwsAccountId", (properties.AwsAccountId != null ? cfn_parse.FromCloudFormation.getString(properties.AwsAccountId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("permission", "Permission", (properties.Permission != null ? cfn_parse.FromCloudFormation.getString(properties.Permission) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes Infrastructure Performance subscriptions.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html
 */
export class CfnNetworkPerformanceMetricSubscription extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::NetworkPerformanceMetricSubscription";

  /**
   * Build a CfnNetworkPerformanceMetricSubscription from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnNetworkPerformanceMetricSubscription {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnNetworkPerformanceMetricSubscriptionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnNetworkPerformanceMetricSubscription(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Region or Availability Zone that's the target for the subscription.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-destination
   */
  public destination: string;

  /**
   * The metric used for the subscription.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-metric
   */
  public metric: string;

  /**
   * The Region or Availability Zone that's the source for the subscription.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-source
   */
  public source: string;

  /**
   * The statistic used for the subscription.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-statistic
   */
  public statistic: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnNetworkPerformanceMetricSubscriptionProps) {
    super(scope, id, {
      "type": CfnNetworkPerformanceMetricSubscription.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "destination", this);
    cdk.requireProperty(props, "metric", this);
    cdk.requireProperty(props, "source", this);
    cdk.requireProperty(props, "statistic", this);

    this.destination = props.destination;
    this.metric = props.metric;
    this.source = props.source;
    this.statistic = props.statistic;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "destination": this.destination,
      "metric": this.metric,
      "source": this.source,
      "statistic": this.statistic
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnNetworkPerformanceMetricSubscription.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnNetworkPerformanceMetricSubscriptionPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnNetworkPerformanceMetricSubscription\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html
 */
export interface CfnNetworkPerformanceMetricSubscriptionProps {
  /**
   * The Region or Availability Zone that's the target for the subscription.
   *
   * For example, \`eu-west-1\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-destination
   */
  readonly destination: string;

  /**
   * The metric used for the subscription.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-metric
   */
  readonly metric: string;

  /**
   * The Region or Availability Zone that's the source for the subscription.
   *
   * For example, \`us-east-1\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-source
   */
  readonly source: string;

  /**
   * The statistic used for the subscription.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-statistic
   */
  readonly statistic: string;
}

/**
 * Determine whether the given properties match those of a \`CfnNetworkPerformanceMetricSubscriptionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnNetworkPerformanceMetricSubscriptionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnNetworkPerformanceMetricSubscriptionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", cdk.requiredValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("destination", cdk.validateString)(properties.destination));
  errors.collect(cdk.propertyValidator("metric", cdk.requiredValidator)(properties.metric));
  errors.collect(cdk.propertyValidator("metric", cdk.validateString)(properties.metric));
  errors.collect(cdk.propertyValidator("source", cdk.requiredValidator)(properties.source));
  errors.collect(cdk.propertyValidator("source", cdk.validateString)(properties.source));
  errors.collect(cdk.propertyValidator("statistic", cdk.requiredValidator)(properties.statistic));
  errors.collect(cdk.propertyValidator("statistic", cdk.validateString)(properties.statistic));
  return errors.wrap("supplied properties not correct for \\"CfnNetworkPerformanceMetricSubscriptionProps\\"");
}

// @ts-ignore TS6133
function convertCfnNetworkPerformanceMetricSubscriptionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnNetworkPerformanceMetricSubscriptionPropsValidator(properties).assertSuccess();
  return {
    "Destination": cdk.stringToCloudFormation(properties.destination),
    "Metric": cdk.stringToCloudFormation(properties.metric),
    "Source": cdk.stringToCloudFormation(properties.source),
    "Statistic": cdk.stringToCloudFormation(properties.statistic)
  };
}

// @ts-ignore TS6133
function CfnNetworkPerformanceMetricSubscriptionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnNetworkPerformanceMetricSubscriptionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnNetworkPerformanceMetricSubscriptionProps>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? cfn_parse.FromCloudFormation.getString(properties.Destination) : undefined));
  ret.addPropertyResult("metric", "Metric", (properties.Metric != null ? cfn_parse.FromCloudFormation.getString(properties.Metric) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? cfn_parse.FromCloudFormation.getString(properties.Source) : undefined));
  ret.addPropertyResult("statistic", "Statistic", (properties.Statistic != null ? cfn_parse.FromCloudFormation.getString(properties.Statistic) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a placement group in which to launch instances.
 *
 * The strategy of the placement group determines how the instances are organized within the group.
 *
 * A \`cluster\` placement group is a logical grouping of instances within a single Availability Zone that benefit from low network latency, high network throughput. A \`spread\` placement group places instances on distinct hardware. A \`partition\` placement group places groups of instances in different partitions, where instances in one partition do not share the same hardware with instances in another partition.
 *
 * For more information, see [Placement Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html) in the *Amazon EC2 User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html
 */
export class CfnPlacementGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::PlacementGroup";

  /**
   * Build a CfnPlacementGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnPlacementGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnPlacementGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnPlacementGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The name of the placement group.
   *
   * @cloudformationAttribute GroupName
   */
  public readonly attrGroupName: string;

  /**
   * The number of partitions.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-partitioncount
   */
  public partitionCount?: number;

  /**
   * Determines how placement groups spread instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-spreadlevel
   */
  public spreadLevel?: string;

  /**
   * The placement strategy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-strategy
   */
  public strategy?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply to the new placement group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnPlacementGroupProps = {}) {
    super(scope, id, {
      "type": CfnPlacementGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrGroupName = cdk.Token.asString(this.getAtt("GroupName", cdk.ResolutionTypeHint.STRING));
    this.partitionCount = props.partitionCount;
    this.spreadLevel = props.spreadLevel;
    this.strategy = props.strategy;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::PlacementGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "partitionCount": this.partitionCount,
      "spreadLevel": this.spreadLevel,
      "strategy": this.strategy,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnPlacementGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnPlacementGroupPropsToCloudFormation(props);
  }
}

export namespace CfnPlacementGroup {
  /**
   * A key-value pair to associate with a resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-placementgroup-tag.html
   */
  export interface TagProperty {
    /**
     * The number of partitions.
     *
     * Valid only when *Strategy* is set to \`partition\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-placementgroup-tag.html#cfn-ec2-placementgroup-tag-partitioncount
     */
    readonly partitionCount?: number;

    /**
     * Determines how placement groups spread instances.
     *
     * - Host – You can use \`host\` only with Outpost placement groups.
     * - Rack – No usage restrictions.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-placementgroup-tag.html#cfn-ec2-placementgroup-tag-spreadlevel
     */
    readonly spreadLevel?: string;

    /**
     * The placement strategy.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-placementgroup-tag.html#cfn-ec2-placementgroup-tag-strategy
     */
    readonly strategy?: string;

    /**
     * The tags to apply to the new placement group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-placementgroup-tag.html#cfn-ec2-placementgroup-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnPlacementGroup.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnPlacementGroup\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html
 */
export interface CfnPlacementGroupProps {
  /**
   * The number of partitions.
   *
   * Valid only when *Strategy* is set to \`partition\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-partitioncount
   */
  readonly partitionCount?: number;

  /**
   * Determines how placement groups spread instances.
   *
   * - Host – You can use \`host\` only with Outpost placement groups.
   * - Rack – No usage restrictions.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-spreadlevel
   */
  readonly spreadLevel?: string;

  /**
   * The placement strategy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-strategy
   */
  readonly strategy?: string;

  /**
   * The tags to apply to the new placement group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnPlacementGroupTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("partitionCount", cdk.validateNumber)(properties.partitionCount));
  errors.collect(cdk.propertyValidator("spreadLevel", cdk.validateString)(properties.spreadLevel));
  errors.collect(cdk.propertyValidator("strategy", cdk.validateString)(properties.strategy));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnPlacementGroupTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnPlacementGroupTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnPlacementGroupTagPropertyValidator(properties).assertSuccess();
  return {
    "PartitionCount": cdk.numberToCloudFormation(properties.partitionCount),
    "SpreadLevel": cdk.stringToCloudFormation(properties.spreadLevel),
    "Strategy": cdk.stringToCloudFormation(properties.strategy),
    "Tags": cdk.listMapper(convertCfnPlacementGroupTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnPlacementGroupTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnPlacementGroup.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnPlacementGroup.TagProperty>();
  ret.addPropertyResult("partitionCount", "PartitionCount", (properties.PartitionCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.PartitionCount) : undefined));
  ret.addPropertyResult("spreadLevel", "SpreadLevel", (properties.SpreadLevel != null ? cfn_parse.FromCloudFormation.getString(properties.SpreadLevel) : undefined));
  ret.addPropertyResult("strategy", "Strategy", (properties.Strategy != null ? cfn_parse.FromCloudFormation.getString(properties.Strategy) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnPlacementGroupTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnPlacementGroupProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnPlacementGroupProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnPlacementGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("partitionCount", cdk.validateNumber)(properties.partitionCount));
  errors.collect(cdk.propertyValidator("spreadLevel", cdk.validateString)(properties.spreadLevel));
  errors.collect(cdk.propertyValidator("strategy", cdk.validateString)(properties.strategy));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnPlacementGroupProps\\"");
}

// @ts-ignore TS6133
function convertCfnPlacementGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnPlacementGroupPropsValidator(properties).assertSuccess();
  return {
    "PartitionCount": cdk.numberToCloudFormation(properties.partitionCount),
    "SpreadLevel": cdk.stringToCloudFormation(properties.spreadLevel),
    "Strategy": cdk.stringToCloudFormation(properties.strategy),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnPlacementGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnPlacementGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnPlacementGroupProps>();
  ret.addPropertyResult("partitionCount", "PartitionCount", (properties.PartitionCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.PartitionCount) : undefined));
  ret.addPropertyResult("spreadLevel", "SpreadLevel", (properties.SpreadLevel != null ? cfn_parse.FromCloudFormation.getString(properties.SpreadLevel) : undefined));
  ret.addPropertyResult("strategy", "Strategy", (properties.Strategy != null ? cfn_parse.FromCloudFormation.getString(properties.Strategy) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a managed prefix list.
 *
 * You can add one or more entries to the prefix list. Each entry consists of a CIDR block and an optional description.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html
 */
export class CfnPrefixList extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::PrefixList";

  /**
   * Build a CfnPrefixList from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnPrefixList {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnPrefixListPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnPrefixList(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN of the prefix list. For example, \`arn:aws:ec2:us-east-1:123456789012:prefix-list/pl-0123123123123abcd\` .
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ID of the owner of the prefix list. For example, \`123456789012\` .
   *
   * @cloudformationAttribute OwnerId
   */
  public readonly attrOwnerId: string;

  /**
   * The ID of the prefix list. For example, \`pl-0123123123123abcd\` .
   *
   * @cloudformationAttribute PrefixListId
   */
  public readonly attrPrefixListId: string;

  /**
   * The version of the prefix list. For example, \`1\` .
   *
   * @cloudformationAttribute Version
   */
  public readonly attrVersion: cdk.IResolvable;

  /**
   * The IP address type.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-addressfamily
   */
  public addressFamily: string;

  /**
   * One or more entries for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-entries
   */
  public entries?: Array<CfnPrefixList.EntryProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The maximum number of entries for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-maxentries
   */
  public maxEntries: number;

  /**
   * A name for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-prefixlistname
   */
  public prefixListName: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnPrefixListProps) {
    super(scope, id, {
      "type": CfnPrefixList.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "addressFamily", this);
    cdk.requireProperty(props, "maxEntries", this);
    cdk.requireProperty(props, "prefixListName", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrOwnerId = cdk.Token.asString(this.getAtt("OwnerId", cdk.ResolutionTypeHint.STRING));
    this.attrPrefixListId = cdk.Token.asString(this.getAtt("PrefixListId", cdk.ResolutionTypeHint.STRING));
    this.attrVersion = this.getAtt("Version", cdk.ResolutionTypeHint.NUMBER);
    this.addressFamily = props.addressFamily;
    this.entries = props.entries;
    this.maxEntries = props.maxEntries;
    this.prefixListName = props.prefixListName;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::PrefixList", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "addressFamily": this.addressFamily,
      "entries": this.entries,
      "maxEntries": this.maxEntries,
      "prefixListName": this.prefixListName,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnPrefixList.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnPrefixListPropsToCloudFormation(props);
  }
}

export namespace CfnPrefixList {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-tag.html
   */
  export interface TagProperty {
    /**
     * The IP address type.
     *
     * Valid Values: \`IPv4\` | \`IPv6\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-tag.html#cfn-ec2-prefixlist-tag-addressfamily
     */
    readonly addressFamily: string;

    /**
     * One or more entries for the prefix list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-tag.html#cfn-ec2-prefixlist-tag-entries
     */
    readonly entries?: Array<CfnPrefixList.EntryProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The maximum number of entries for the prefix list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-tag.html#cfn-ec2-prefixlist-tag-maxentries
     */
    readonly maxEntries: number;

    /**
     * A name for the prefix list.
     *
     * Constraints: Up to 255 characters in length. The name cannot start with \`com.amazonaws\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-tag.html#cfn-ec2-prefixlist-tag-prefixlistname
     */
    readonly prefixListName: string;

    /**
     * The tags for the prefix list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-tag.html#cfn-ec2-prefixlist-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnPrefixList.TagProperty> | cdk.IResolvable;
  }

  /**
   * An entry for a prefix list.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html
   */
  export interface EntryProperty {
    /**
     * The IP address type.
     *
     * Valid Values: \`IPv4\` | \`IPv6\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-addressfamily
     */
    readonly addressFamily: string;

    /**
     * One or more entries for the prefix list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-entries
     */
    readonly entries?: Array<CfnPrefixList.EntryProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The maximum number of entries for the prefix list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-maxentries
     */
    readonly maxEntries: number;

    /**
     * A name for the prefix list.
     *
     * Constraints: Up to 255 characters in length. The name cannot start with \`com.amazonaws\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-prefixlistname
     */
    readonly prefixListName: string;

    /**
     * The tags for the prefix list.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnPrefixList.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnPrefixList\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html
 */
export interface CfnPrefixListProps {
  /**
   * The IP address type.
   *
   * Valid Values: \`IPv4\` | \`IPv6\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-addressfamily
   */
  readonly addressFamily: string;

  /**
   * One or more entries for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-entries
   */
  readonly entries?: Array<CfnPrefixList.EntryProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The maximum number of entries for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-maxentries
   */
  readonly maxEntries: number;

  /**
   * A name for the prefix list.
   *
   * Constraints: Up to 255 characters in length. The name cannot start with \`com.amazonaws\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-prefixlistname
   */
  readonly prefixListName: string;

  /**
   * The tags for the prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`EntryProperty\`
 *
 * @param properties - the TypeScript properties of a \`EntryProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnPrefixListEntryPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addressFamily", cdk.requiredValidator)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("addressFamily", cdk.validateString)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("entries", cdk.listValidator(CfnPrefixListEntryPropertyValidator))(properties.entries));
  errors.collect(cdk.propertyValidator("maxEntries", cdk.requiredValidator)(properties.maxEntries));
  errors.collect(cdk.propertyValidator("maxEntries", cdk.validateNumber)(properties.maxEntries));
  errors.collect(cdk.propertyValidator("prefixListName", cdk.requiredValidator)(properties.prefixListName));
  errors.collect(cdk.propertyValidator("prefixListName", cdk.validateString)(properties.prefixListName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnPrefixListTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"EntryProperty\\"");
}

// @ts-ignore TS6133
function convertCfnPrefixListEntryPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnPrefixListEntryPropertyValidator(properties).assertSuccess();
  return {
    "AddressFamily": cdk.stringToCloudFormation(properties.addressFamily),
    "Entries": cdk.listMapper(convertCfnPrefixListEntryPropertyToCloudFormation)(properties.entries),
    "MaxEntries": cdk.numberToCloudFormation(properties.maxEntries),
    "PrefixListName": cdk.stringToCloudFormation(properties.prefixListName),
    "Tags": cdk.listMapper(convertCfnPrefixListTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnPrefixListEntryPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnPrefixList.EntryProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnPrefixList.EntryProperty>();
  ret.addPropertyResult("addressFamily", "AddressFamily", (properties.AddressFamily != null ? cfn_parse.FromCloudFormation.getString(properties.AddressFamily) : undefined));
  ret.addPropertyResult("entries", "Entries", (properties.Entries != null ? cfn_parse.FromCloudFormation.getArray(CfnPrefixListEntryPropertyFromCloudFormation)(properties.Entries) : undefined));
  ret.addPropertyResult("maxEntries", "MaxEntries", (properties.MaxEntries != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxEntries) : undefined));
  ret.addPropertyResult("prefixListName", "PrefixListName", (properties.PrefixListName != null ? cfn_parse.FromCloudFormation.getString(properties.PrefixListName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnPrefixListTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnPrefixListTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addressFamily", cdk.requiredValidator)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("addressFamily", cdk.validateString)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("entries", cdk.listValidator(CfnPrefixListEntryPropertyValidator))(properties.entries));
  errors.collect(cdk.propertyValidator("maxEntries", cdk.requiredValidator)(properties.maxEntries));
  errors.collect(cdk.propertyValidator("maxEntries", cdk.validateNumber)(properties.maxEntries));
  errors.collect(cdk.propertyValidator("prefixListName", cdk.requiredValidator)(properties.prefixListName));
  errors.collect(cdk.propertyValidator("prefixListName", cdk.validateString)(properties.prefixListName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnPrefixListTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnPrefixListTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnPrefixListTagPropertyValidator(properties).assertSuccess();
  return {
    "AddressFamily": cdk.stringToCloudFormation(properties.addressFamily),
    "Entries": cdk.listMapper(convertCfnPrefixListEntryPropertyToCloudFormation)(properties.entries),
    "MaxEntries": cdk.numberToCloudFormation(properties.maxEntries),
    "PrefixListName": cdk.stringToCloudFormation(properties.prefixListName),
    "Tags": cdk.listMapper(convertCfnPrefixListTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnPrefixListTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnPrefixList.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnPrefixList.TagProperty>();
  ret.addPropertyResult("addressFamily", "AddressFamily", (properties.AddressFamily != null ? cfn_parse.FromCloudFormation.getString(properties.AddressFamily) : undefined));
  ret.addPropertyResult("entries", "Entries", (properties.Entries != null ? cfn_parse.FromCloudFormation.getArray(CfnPrefixListEntryPropertyFromCloudFormation)(properties.Entries) : undefined));
  ret.addPropertyResult("maxEntries", "MaxEntries", (properties.MaxEntries != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxEntries) : undefined));
  ret.addPropertyResult("prefixListName", "PrefixListName", (properties.PrefixListName != null ? cfn_parse.FromCloudFormation.getString(properties.PrefixListName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnPrefixListTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnPrefixListProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnPrefixListProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnPrefixListPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addressFamily", cdk.requiredValidator)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("addressFamily", cdk.validateString)(properties.addressFamily));
  errors.collect(cdk.propertyValidator("entries", cdk.listValidator(CfnPrefixListEntryPropertyValidator))(properties.entries));
  errors.collect(cdk.propertyValidator("maxEntries", cdk.requiredValidator)(properties.maxEntries));
  errors.collect(cdk.propertyValidator("maxEntries", cdk.validateNumber)(properties.maxEntries));
  errors.collect(cdk.propertyValidator("prefixListName", cdk.requiredValidator)(properties.prefixListName));
  errors.collect(cdk.propertyValidator("prefixListName", cdk.validateString)(properties.prefixListName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnPrefixListProps\\"");
}

// @ts-ignore TS6133
function convertCfnPrefixListPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnPrefixListPropsValidator(properties).assertSuccess();
  return {
    "AddressFamily": cdk.stringToCloudFormation(properties.addressFamily),
    "Entries": cdk.listMapper(convertCfnPrefixListEntryPropertyToCloudFormation)(properties.entries),
    "MaxEntries": cdk.numberToCloudFormation(properties.maxEntries),
    "PrefixListName": cdk.stringToCloudFormation(properties.prefixListName),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnPrefixListPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnPrefixListProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnPrefixListProps>();
  ret.addPropertyResult("addressFamily", "AddressFamily", (properties.AddressFamily != null ? cfn_parse.FromCloudFormation.getString(properties.AddressFamily) : undefined));
  ret.addPropertyResult("entries", "Entries", (properties.Entries != null ? cfn_parse.FromCloudFormation.getArray(CfnPrefixListEntryPropertyFromCloudFormation)(properties.Entries) : undefined));
  ret.addPropertyResult("maxEntries", "MaxEntries", (properties.MaxEntries != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxEntries) : undefined));
  ret.addPropertyResult("prefixListName", "PrefixListName", (properties.PrefixListName != null ? cfn_parse.FromCloudFormation.getString(properties.PrefixListName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a route in a route table.
 *
 * You must specify either \`DestinationCidrBlock\` or \`DestinationIpv6CidrBlock\` , plus the ID of one of the target resources.
 *
 * If you create a route that references a transit gateway in the same template where you create the transit gateway, you must declare a dependency on the transit gateway attachment. The route table cannot use the transit gateway until it has successfully attached to the VPC. Add a [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) in the \`AWS::EC2::Route\` resource to explicitly declare a dependency on the \`AWS::EC2::TransitGatewayAttachment\` resource.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
 */
export class CfnRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Route";

  /**
   * Build a CfnRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the carrier gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-carriergatewayid
   */
  public carrierGatewayId?: string;

  /**
   * The IPv4 CIDR block used for the destination match.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationcidrblock
   */
  public destinationCidrBlock?: string;

  /**
   * The IPv6 CIDR block used for the destination match.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationipv6cidrblock
   */
  public destinationIpv6CidrBlock?: string;

  /**
   * The ID of the egress-only internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-egressonlyinternetgatewayid
   */
  public egressOnlyInternetGatewayId?: string;

  /**
   * The ID of an internet gateway or virtual private gateway attached to your VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-gatewayid
   */
  public gatewayId?: string;

  /**
   * The ID of a NAT instance in your VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-instanceid
   */
  public instanceId?: string;

  /**
   * The ID of the local gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-localgatewayid
   */
  public localGatewayId?: string;

  /**
   * The ID of a NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-natgatewayid
   */
  public natGatewayId?: string;

  /**
   * The ID of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-networkinterfaceid
   */
  public networkInterfaceId?: string;

  /**
   * The ID of the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-routetableid
   */
  public routeTableId: string;

  /**
   * The ID of a transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-transitgatewayid
   */
  public transitGatewayId?: string;

  /**
   * The ID of a VPC endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcendpointid
   */
  public vpcEndpointId?: string;

  /**
   * The ID of a VPC peering connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcpeeringconnectionid
   */
  public vpcPeeringConnectionId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnRouteProps) {
    super(scope, id, {
      "type": CfnRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "routeTableId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.carrierGatewayId = props.carrierGatewayId;
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.destinationIpv6CidrBlock = props.destinationIpv6CidrBlock;
    this.egressOnlyInternetGatewayId = props.egressOnlyInternetGatewayId;
    this.gatewayId = props.gatewayId;
    this.instanceId = props.instanceId;
    this.localGatewayId = props.localGatewayId;
    this.natGatewayId = props.natGatewayId;
    this.networkInterfaceId = props.networkInterfaceId;
    this.routeTableId = props.routeTableId;
    this.transitGatewayId = props.transitGatewayId;
    this.vpcEndpointId = props.vpcEndpointId;
    this.vpcPeeringConnectionId = props.vpcPeeringConnectionId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "carrierGatewayId": this.carrierGatewayId,
      "destinationCidrBlock": this.destinationCidrBlock,
      "destinationIpv6CidrBlock": this.destinationIpv6CidrBlock,
      "egressOnlyInternetGatewayId": this.egressOnlyInternetGatewayId,
      "gatewayId": this.gatewayId,
      "instanceId": this.instanceId,
      "localGatewayId": this.localGatewayId,
      "natGatewayId": this.natGatewayId,
      "networkInterfaceId": this.networkInterfaceId,
      "routeTableId": this.routeTableId,
      "transitGatewayId": this.transitGatewayId,
      "vpcEndpointId": this.vpcEndpointId,
      "vpcPeeringConnectionId": this.vpcPeeringConnectionId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnRoute\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
 */
export interface CfnRouteProps {
  /**
   * The ID of the carrier gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-carriergatewayid
   */
  readonly carrierGatewayId?: string;

  /**
   * The IPv4 CIDR block used for the destination match.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationcidrblock
   */
  readonly destinationCidrBlock?: string;

  /**
   * The IPv6 CIDR block used for the destination match.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationipv6cidrblock
   */
  readonly destinationIpv6CidrBlock?: string;

  /**
   * The ID of the egress-only internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-egressonlyinternetgatewayid
   */
  readonly egressOnlyInternetGatewayId?: string;

  /**
   * The ID of an internet gateway or virtual private gateway attached to your VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-gatewayid
   */
  readonly gatewayId?: string;

  /**
   * The ID of a NAT instance in your VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-instanceid
   */
  readonly instanceId?: string;

  /**
   * The ID of the local gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-localgatewayid
   */
  readonly localGatewayId?: string;

  /**
   * The ID of a NAT gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-natgatewayid
   */
  readonly natGatewayId?: string;

  /**
   * The ID of the network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-networkinterfaceid
   */
  readonly networkInterfaceId?: string;

  /**
   * The ID of the route table.
   *
   * The routing table must be associated with the same VPC that the virtual private gateway is attached to.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-routetableid
   */
  readonly routeTableId: string;

  /**
   * The ID of a transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-transitgatewayid
   */
  readonly transitGatewayId?: string;

  /**
   * The ID of a VPC endpoint.
   *
   * Supported for Gateway Load Balancer endpoints only.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcendpointid
   */
  readonly vpcEndpointId?: string;

  /**
   * The ID of a VPC peering connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcpeeringconnectionid
   */
  readonly vpcPeeringConnectionId?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnRouteProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnRouteProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("carrierGatewayId", cdk.validateString)(properties.carrierGatewayId));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationIpv6CidrBlock", cdk.validateString)(properties.destinationIpv6CidrBlock));
  errors.collect(cdk.propertyValidator("egressOnlyInternetGatewayId", cdk.validateString)(properties.egressOnlyInternetGatewayId));
  errors.collect(cdk.propertyValidator("gatewayId", cdk.validateString)(properties.gatewayId));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("localGatewayId", cdk.validateString)(properties.localGatewayId));
  errors.collect(cdk.propertyValidator("natGatewayId", cdk.validateString)(properties.natGatewayId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.requiredValidator)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.validateString)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcEndpointId", cdk.validateString)(properties.vpcEndpointId));
  errors.collect(cdk.propertyValidator("vpcPeeringConnectionId", cdk.validateString)(properties.vpcPeeringConnectionId));
  return errors.wrap("supplied properties not correct for \\"CfnRouteProps\\"");
}

// @ts-ignore TS6133
function convertCfnRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRoutePropsValidator(properties).assertSuccess();
  return {
    "CarrierGatewayId": cdk.stringToCloudFormation(properties.carrierGatewayId),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "DestinationIpv6CidrBlock": cdk.stringToCloudFormation(properties.destinationIpv6CidrBlock),
    "EgressOnlyInternetGatewayId": cdk.stringToCloudFormation(properties.egressOnlyInternetGatewayId),
    "GatewayId": cdk.stringToCloudFormation(properties.gatewayId),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "LocalGatewayId": cdk.stringToCloudFormation(properties.localGatewayId),
    "NatGatewayId": cdk.stringToCloudFormation(properties.natGatewayId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "RouteTableId": cdk.stringToCloudFormation(properties.routeTableId),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcEndpointId": cdk.stringToCloudFormation(properties.vpcEndpointId),
    "VpcPeeringConnectionId": cdk.stringToCloudFormation(properties.vpcPeeringConnectionId)
  };
}

// @ts-ignore TS6133
function CfnRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRouteProps>();
  ret.addPropertyResult("carrierGatewayId", "CarrierGatewayId", (properties.CarrierGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.CarrierGatewayId) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("destinationIpv6CidrBlock", "DestinationIpv6CidrBlock", (properties.DestinationIpv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationIpv6CidrBlock) : undefined));
  ret.addPropertyResult("egressOnlyInternetGatewayId", "EgressOnlyInternetGatewayId", (properties.EgressOnlyInternetGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.EgressOnlyInternetGatewayId) : undefined));
  ret.addPropertyResult("gatewayId", "GatewayId", (properties.GatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.GatewayId) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("localGatewayId", "LocalGatewayId", (properties.LocalGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.LocalGatewayId) : undefined));
  ret.addPropertyResult("natGatewayId", "NatGatewayId", (properties.NatGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.NatGatewayId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("routeTableId", "RouteTableId", (properties.RouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.RouteTableId) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcEndpointId", "VpcEndpointId", (properties.VpcEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcEndpointId) : undefined));
  ret.addPropertyResult("vpcPeeringConnectionId", "VpcPeeringConnectionId", (properties.VpcPeeringConnectionId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcPeeringConnectionId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a route table for the specified VPC.
 *
 * After you create a route table, you can add routes and associate the table with a subnet.
 *
 * For more information, see [Route Tables](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html) in the *Amazon VPC User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html
 */
export class CfnRouteTable extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::RouteTable";

  /**
   * Build a CfnRouteTable from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnRouteTable {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnRouteTablePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnRouteTable(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the route table.
   *
   * @cloudformationAttribute RouteTableId
   */
  public readonly attrRouteTableId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-vpcid
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnRouteTableProps) {
    super(scope, id, {
      "type": CfnRouteTable.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrRouteTableId = cdk.Token.asString(this.getAtt("RouteTableId", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::RouteTable", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnRouteTable.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnRouteTablePropsToCloudFormation(props);
  }
}

export namespace CfnRouteTable {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-routetable-tag.html
   */
  export interface TagProperty {
    /**
     * Any tags assigned to the route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-routetable-tag.html#cfn-ec2-routetable-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnRouteTable.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-routetable-tag.html#cfn-ec2-routetable-tag-vpcid
     */
    readonly vpcId: string;
  }
}

/**
 * Properties for defining a \`CfnRouteTable\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html
 */
export interface CfnRouteTableProps {
  /**
   * Any tags assigned to the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRouteTableTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnRouteTableTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnRouteTableTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRouteTableTagPropertyValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(convertCfnRouteTableTagPropertyToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnRouteTableTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnRouteTable.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRouteTable.TagProperty>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnRouteTableTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnRouteTableProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnRouteTableProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRouteTablePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnRouteTableProps\\"");
}

// @ts-ignore TS6133
function convertCfnRouteTablePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRouteTablePropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnRouteTablePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnRouteTableProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRouteTableProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a security group.
 *
 * To create a security group, use the [VpcId](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-vpcid) property to specify the VPC for which to create the security group.
 *
 * If you do not specify an egress rule, we add egress rules that allow IPv4 and IPv6 traffic on all ports and protocols to any destination. We do not add these rules if you specify your own egress rules. If you later remove your egress rules, we restore the default egress rules.
 *
 * This type supports updates. For more information about updating stacks, see [AWS CloudFormation Stacks Updates](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html) .
 *
 * > To cross-reference two security groups in the ingress and egress rules of those security groups, use the [AWS::EC2::SecurityGroupEgress](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html) and [AWS::EC2::SecurityGroupIngress](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-ingress.html) resources to define your rules. Do not use the embedded ingress and egress rules in the \`AWS::EC2::SecurityGroup\` . Doing so creates a circular dependency, which AWS CloudFormation doesn't allow.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html
 */
export class CfnSecurityGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SecurityGroup";

  /**
   * Build a CfnSecurityGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSecurityGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSecurityGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSecurityGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The group ID of the specified security group, such as \`sg-94b3a1f6\` .
   *
   * @cloudformationAttribute GroupId
   */
  public readonly attrGroupId: string;

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The physical ID of the VPC. You can obtain the physical ID by using a reference to an [AWS::EC2::VPC](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html) , such as: \`{ "Ref" : "myVPC" }\` .
   *
   * @cloudformationAttribute VpcId
   */
  public readonly attrVpcId: string;

  /**
   * A description for the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-groupdescription
   */
  public groupDescription: string;

  /**
   * The name of the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-groupname
   */
  public groupName?: string;

  /**
   * The outbound rules associated with the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-securitygroupegress
   */
  public securityGroupEgress?: Array<CfnSecurityGroup.EgressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The inbound rules associated with the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-securitygroupingress
   */
  public securityGroupIngress?: Array<CfnSecurityGroup.IngressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC for the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-vpcid
   */
  public vpcId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSecurityGroupProps) {
    super(scope, id, {
      "type": CfnSecurityGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "groupDescription", this);

    this.attrGroupId = cdk.Token.asString(this.getAtt("GroupId", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrVpcId = cdk.Token.asString(this.getAtt("VpcId", cdk.ResolutionTypeHint.STRING));
    this.groupDescription = props.groupDescription;
    this.groupName = props.groupName;
    this.securityGroupEgress = props.securityGroupEgress;
    this.securityGroupIngress = props.securityGroupIngress;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::SecurityGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "groupDescription": this.groupDescription,
      "groupName": this.groupName,
      "securityGroupEgress": this.securityGroupEgress,
      "securityGroupIngress": this.securityGroupIngress,
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSecurityGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSecurityGroupPropsToCloudFormation(props);
  }
}

export namespace CfnSecurityGroup {
  /**
   * Adds an inbound rule to a security group.
   *
   * An inbound rule permits instances to receive traffic from the specified IPv4 or IPv6 CIDR address range, or from the instances associated with the specified security group.
   *
   * You must specify only one of the following properties: \`CidrIp\` , \`CidrIpv6\` , \`SourcePrefixListId\` , \`SourceSecurityGroupId\` , or \`SourceSecurityGroupName\` .
   *
   * You specify a protocol for each rule (for example, TCP). For TCP and UDP, you must also specify a port or port range. For ICMP/ICMPv6, you must also specify the ICMP/ICMPv6 type and code. You can use -1 to mean all types or all codes.
   *
   * You must specify a source security group ( \`SourcePrefixListId\` , \`SourceSecurityGroupId\` , or \`SourceSecurityGroupName\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.
   *
   * Rule changes are propagated to instances within the security group as quickly as possible. However, a small delay might occur.
   *
   * The EC2 Security Group Rule is an embedded property of the \`AWS::EC2::SecurityGroup\` type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html
   */
  export interface IngressProperty {
    /**
     * A description for the security group.
     *
     * Constraints: Up to 255 characters in length
     *
     * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-groupdescription
     */
    readonly groupDescription: string;

    /**
     * The name of the security group.
     *
     * Constraints: Up to 255 characters in length. Cannot start with \`sg-\` .
     *
     * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-groupname
     */
    readonly groupName?: string;

    /**
     * The outbound rules associated with the security group.
     *
     * There is a short interruption during which you cannot connect to the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-securitygroupegress
     */
    readonly securityGroupEgress?: Array<CfnSecurityGroup.EgressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The inbound rules associated with the security group.
     *
     * There is a short interruption during which you cannot connect to the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-securitygroupingress
     */
    readonly securityGroupIngress?: Array<CfnSecurityGroup.IngressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Any tags assigned to the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnSecurityGroup.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the VPC for the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-vpcid
     */
    readonly vpcId?: string;
  }

  /**
   * Adds the specified egress rules to a security group for use with a VPC.
   *
   * An outbound rule permits instances to send traffic to the specified destination IPv4 or IPv6 CIDR address ranges, or to the specified destination security groups for the same VPC.
   *
   * You specify a protocol for each rule (for example, TCP). For the TCP and UDP protocols, you must also specify the destination port or port range. For the ICMP protocol, you must also specify the ICMP type and code. You can use -1 for the type or code to mean all types or all codes.
   *
   * You must specify only one of the following properties: \`CidrIp\` , \`CidrIpv6\` , \`DestinationPrefixListId\` , or \`DestinationSecurityGroupId\` .
   *
   * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.
   *
   * Rule changes are propagated to affected instances as quickly as possible. However, a small delay might occur.
   *
   * For more information about VPC security group limits, see [Amazon VPC Limits](https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html) .
   *
   * Use \`SecurityGroup.Ingress\` and \`SecurityGroup.Egress\` only when necessary, typically to allow security groups to reference each other in ingress and egress rules. Otherwise, use the embedded ingress and egress rules of the security group. For more information, see [Amazon EC2 Security Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html) .
   *
   * The EC2 Security Group Rule is an embedded property of the \`AWS::EC2::SecurityGroup\` type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html
   */
  export interface EgressProperty {
    /**
     * A description for the security group.
     *
     * Constraints: Up to 255 characters in length
     *
     * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-groupdescription
     */
    readonly groupDescription: string;

    /**
     * The name of the security group.
     *
     * Constraints: Up to 255 characters in length. Cannot start with \`sg-\` .
     *
     * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-groupname
     */
    readonly groupName?: string;

    /**
     * The outbound rules associated with the security group.
     *
     * There is a short interruption during which you cannot connect to the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-securitygroupegress
     */
    readonly securityGroupEgress?: Array<CfnSecurityGroup.EgressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The inbound rules associated with the security group.
     *
     * There is a short interruption during which you cannot connect to the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-securitygroupingress
     */
    readonly securityGroupIngress?: Array<CfnSecurityGroup.IngressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Any tags assigned to the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnSecurityGroup.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the VPC for the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-vpcid
     */
    readonly vpcId?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-tag.html
   */
  export interface TagProperty {
    /**
     * A description for the security group.
     *
     * Constraints: Up to 255 characters in length
     *
     * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-tag.html#cfn-ec2-securitygroup-tag-groupdescription
     */
    readonly groupDescription: string;

    /**
     * The name of the security group.
     *
     * Constraints: Up to 255 characters in length. Cannot start with \`sg-\` .
     *
     * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-tag.html#cfn-ec2-securitygroup-tag-groupname
     */
    readonly groupName?: string;

    /**
     * The outbound rules associated with the security group.
     *
     * There is a short interruption during which you cannot connect to the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-tag.html#cfn-ec2-securitygroup-tag-securitygroupegress
     */
    readonly securityGroupEgress?: Array<CfnSecurityGroup.EgressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * The inbound rules associated with the security group.
     *
     * There is a short interruption during which you cannot connect to the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-tag.html#cfn-ec2-securitygroup-tag-securitygroupingress
     */
    readonly securityGroupIngress?: Array<CfnSecurityGroup.IngressProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Any tags assigned to the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-tag.html#cfn-ec2-securitygroup-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnSecurityGroup.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the VPC for the security group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-tag.html#cfn-ec2-securitygroup-tag-vpcid
     */
    readonly vpcId?: string;
  }
}

/**
 * Properties for defining a \`CfnSecurityGroup\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html
 */
export interface CfnSecurityGroupProps {
  /**
   * A description for the security group.
   *
   * Constraints: Up to 255 characters in length
   *
   * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-groupdescription
   */
  readonly groupDescription: string;

  /**
   * The name of the security group.
   *
   * Constraints: Up to 255 characters in length. Cannot start with \`sg-\` .
   *
   * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-groupname
   */
  readonly groupName?: string;

  /**
   * The outbound rules associated with the security group.
   *
   * There is a short interruption during which you cannot connect to the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-securitygroupegress
   */
  readonly securityGroupEgress?: Array<CfnSecurityGroup.EgressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * The inbound rules associated with the security group.
   *
   * There is a short interruption during which you cannot connect to the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-securitygroupingress
   */
  readonly securityGroupIngress?: Array<CfnSecurityGroup.IngressProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * Any tags assigned to the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC for the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-vpcid
   */
  readonly vpcId?: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupDescription", cdk.requiredValidator)(properties.groupDescription));
  errors.collect(cdk.propertyValidator("groupDescription", cdk.validateString)(properties.groupDescription));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("securityGroupEgress", cdk.listValidator(CfnSecurityGroupEgressPropertyValidator))(properties.securityGroupEgress));
  errors.collect(cdk.propertyValidator("securityGroupIngress", cdk.listValidator(CfnSecurityGroupIngressPropertyValidator))(properties.securityGroupIngress));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnSecurityGroupTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupTagPropertyValidator(properties).assertSuccess();
  return {
    "GroupDescription": cdk.stringToCloudFormation(properties.groupDescription),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "SecurityGroupEgress": cdk.listMapper(convertCfnSecurityGroupEgressPropertyToCloudFormation)(properties.securityGroupEgress),
    "SecurityGroupIngress": cdk.listMapper(convertCfnSecurityGroupIngressPropertyToCloudFormation)(properties.securityGroupIngress),
    "Tags": cdk.listMapper(convertCfnSecurityGroupTagPropertyToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSecurityGroup.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroup.TagProperty>();
  ret.addPropertyResult("groupDescription", "GroupDescription", (properties.GroupDescription != null ? cfn_parse.FromCloudFormation.getString(properties.GroupDescription) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("securityGroupEgress", "SecurityGroupEgress", (properties.SecurityGroupEgress != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupEgressPropertyFromCloudFormation)(properties.SecurityGroupEgress) : undefined));
  ret.addPropertyResult("securityGroupIngress", "SecurityGroupIngress", (properties.SecurityGroupIngress != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupIngressPropertyFromCloudFormation)(properties.SecurityGroupIngress) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EgressProperty\`
 *
 * @param properties - the TypeScript properties of a \`EgressProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupEgressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupDescription", cdk.requiredValidator)(properties.groupDescription));
  errors.collect(cdk.propertyValidator("groupDescription", cdk.validateString)(properties.groupDescription));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("securityGroupEgress", cdk.listValidator(CfnSecurityGroupEgressPropertyValidator))(properties.securityGroupEgress));
  errors.collect(cdk.propertyValidator("securityGroupIngress", cdk.listValidator(CfnSecurityGroupIngressPropertyValidator))(properties.securityGroupIngress));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnSecurityGroupTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"EgressProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupEgressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupEgressPropertyValidator(properties).assertSuccess();
  return {
    "GroupDescription": cdk.stringToCloudFormation(properties.groupDescription),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "SecurityGroupEgress": cdk.listMapper(convertCfnSecurityGroupEgressPropertyToCloudFormation)(properties.securityGroupEgress),
    "SecurityGroupIngress": cdk.listMapper(convertCfnSecurityGroupIngressPropertyToCloudFormation)(properties.securityGroupIngress),
    "Tags": cdk.listMapper(convertCfnSecurityGroupTagPropertyToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupEgressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroup.EgressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroup.EgressProperty>();
  ret.addPropertyResult("groupDescription", "GroupDescription", (properties.GroupDescription != null ? cfn_parse.FromCloudFormation.getString(properties.GroupDescription) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("securityGroupEgress", "SecurityGroupEgress", (properties.SecurityGroupEgress != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupEgressPropertyFromCloudFormation)(properties.SecurityGroupEgress) : undefined));
  ret.addPropertyResult("securityGroupIngress", "SecurityGroupIngress", (properties.SecurityGroupIngress != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupIngressPropertyFromCloudFormation)(properties.SecurityGroupIngress) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`IngressProperty\`
 *
 * @param properties - the TypeScript properties of a \`IngressProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupIngressPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupDescription", cdk.requiredValidator)(properties.groupDescription));
  errors.collect(cdk.propertyValidator("groupDescription", cdk.validateString)(properties.groupDescription));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("securityGroupEgress", cdk.listValidator(CfnSecurityGroupEgressPropertyValidator))(properties.securityGroupEgress));
  errors.collect(cdk.propertyValidator("securityGroupIngress", cdk.listValidator(CfnSecurityGroupIngressPropertyValidator))(properties.securityGroupIngress));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnSecurityGroupTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"IngressProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupIngressPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupIngressPropertyValidator(properties).assertSuccess();
  return {
    "GroupDescription": cdk.stringToCloudFormation(properties.groupDescription),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "SecurityGroupEgress": cdk.listMapper(convertCfnSecurityGroupEgressPropertyToCloudFormation)(properties.securityGroupEgress),
    "SecurityGroupIngress": cdk.listMapper(convertCfnSecurityGroupIngressPropertyToCloudFormation)(properties.securityGroupIngress),
    "Tags": cdk.listMapper(convertCfnSecurityGroupTagPropertyToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupIngressPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroup.IngressProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroup.IngressProperty>();
  ret.addPropertyResult("groupDescription", "GroupDescription", (properties.GroupDescription != null ? cfn_parse.FromCloudFormation.getString(properties.GroupDescription) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("securityGroupEgress", "SecurityGroupEgress", (properties.SecurityGroupEgress != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupEgressPropertyFromCloudFormation)(properties.SecurityGroupEgress) : undefined));
  ret.addPropertyResult("securityGroupIngress", "SecurityGroupIngress", (properties.SecurityGroupIngress != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupIngressPropertyFromCloudFormation)(properties.SecurityGroupIngress) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSecurityGroupProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSecurityGroupProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupDescription", cdk.requiredValidator)(properties.groupDescription));
  errors.collect(cdk.propertyValidator("groupDescription", cdk.validateString)(properties.groupDescription));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("securityGroupEgress", cdk.listValidator(CfnSecurityGroupEgressPropertyValidator))(properties.securityGroupEgress));
  errors.collect(cdk.propertyValidator("securityGroupIngress", cdk.listValidator(CfnSecurityGroupIngressPropertyValidator))(properties.securityGroupIngress));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnSecurityGroupProps\\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupPropsValidator(properties).assertSuccess();
  return {
    "GroupDescription": cdk.stringToCloudFormation(properties.groupDescription),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "SecurityGroupEgress": cdk.listMapper(convertCfnSecurityGroupEgressPropertyToCloudFormation)(properties.securityGroupEgress),
    "SecurityGroupIngress": cdk.listMapper(convertCfnSecurityGroupIngressPropertyToCloudFormation)(properties.securityGroupIngress),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroupProps>();
  ret.addPropertyResult("groupDescription", "GroupDescription", (properties.GroupDescription != null ? cfn_parse.FromCloudFormation.getString(properties.GroupDescription) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("securityGroupEgress", "SecurityGroupEgress", (properties.SecurityGroupEgress != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupEgressPropertyFromCloudFormation)(properties.SecurityGroupEgress) : undefined));
  ret.addPropertyResult("securityGroupIngress", "SecurityGroupIngress", (properties.SecurityGroupIngress != null ? cfn_parse.FromCloudFormation.getArray(CfnSecurityGroupIngressPropertyFromCloudFormation)(properties.SecurityGroupIngress) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds the specified egress rules to a security group.
 *
 * An outbound rule permits instances to send traffic to the specified destination IPv4 or IPv6 CIDR address ranges, or to the specified destination security groups for the same VPC.
 *
 * You specify a protocol for each rule (for example, TCP). For the TCP and UDP protocols, you must also specify the destination port or port range. For the ICMP protocol, you must also specify the ICMP type and code. You can use -1 for the type or code to mean all types or all codes.
 *
 * You must specify only one of the following properties: \`CidrIp\` , \`CidrIpv6\` , \`DestinationPrefixListId\` , or \`DestinationSecurityGroupId\` .
 *
 * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.
 *
 * Rule changes are propagated to affected instances as quickly as possible. However, a small delay might occur.
 *
 * For more information about VPC security group limits, see [Amazon VPC Limits](https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html) .
 *
 * Use \`AWS::EC2::SecurityGroupIngress\` and \`AWS::EC2::SecurityGroupEgress\` only when necessary, typically to allow security groups to reference each other in ingress and egress rules. Otherwise, use the embedded ingress and egress rules of the security group. For more information, see [Amazon EC2 Security Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html
 */
export class CfnSecurityGroupEgress extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SecurityGroupEgress";

  /**
   * Build a CfnSecurityGroupEgress from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSecurityGroupEgress {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSecurityGroupEgressPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSecurityGroupEgress(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IPv4 address range, in CIDR format.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-cidrip
   */
  public cidrIp?: string;

  /**
   * The IPv6 address range, in CIDR format.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-cidripv6
   */
  public cidrIpv6?: string;

  /**
   * The description of an egress (outbound) security group rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-description
   */
  public description?: string;

  /**
   * The prefix list IDs for an AWS service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-destinationprefixlistid
   */
  public destinationPrefixListId?: string;

  /**
   * The ID of the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-destinationsecuritygroupid
   */
  public destinationSecurityGroupId?: string;

  /**
   * If the protocol is TCP or UDP, this is the start of the port range.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-fromport
   */
  public fromPort?: number;

  /**
   * The ID of the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-groupid
   */
  public groupId: string;

  /**
   * The IP protocol name ( \`tcp\` , \`udp\` , \`icmp\` , \`icmpv6\` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-ipprotocol
   */
  public ipProtocol: string;

  /**
   * If the protocol is TCP or UDP, this is the end of the port range.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-toport
   */
  public toPort?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSecurityGroupEgressProps) {
    super(scope, id, {
      "type": CfnSecurityGroupEgress.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "groupId", this);
    cdk.requireProperty(props, "ipProtocol", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.cidrIp = props.cidrIp;
    this.cidrIpv6 = props.cidrIpv6;
    this.description = props.description;
    this.destinationPrefixListId = props.destinationPrefixListId;
    this.destinationSecurityGroupId = props.destinationSecurityGroupId;
    this.fromPort = props.fromPort;
    this.groupId = props.groupId;
    this.ipProtocol = props.ipProtocol;
    this.toPort = props.toPort;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidrIp": this.cidrIp,
      "cidrIpv6": this.cidrIpv6,
      "description": this.description,
      "destinationPrefixListId": this.destinationPrefixListId,
      "destinationSecurityGroupId": this.destinationSecurityGroupId,
      "fromPort": this.fromPort,
      "groupId": this.groupId,
      "ipProtocol": this.ipProtocol,
      "toPort": this.toPort
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSecurityGroupEgress.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSecurityGroupEgressPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSecurityGroupEgress\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html
 */
export interface CfnSecurityGroupEgressProps {
  /**
   * The IPv4 address range, in CIDR format.
   *
   * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
   *
   * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-cidrip
   */
  readonly cidrIp?: string;

  /**
   * The IPv6 address range, in CIDR format.
   *
   * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
   *
   * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-cidripv6
   */
  readonly cidrIpv6?: string;

  /**
   * The description of an egress (outbound) security group rule.
   *
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-description
   */
  readonly description?: string;

  /**
   * The prefix list IDs for an AWS service.
   *
   * This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.
   *
   * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-destinationprefixlistid
   */
  readonly destinationPrefixListId?: string;

  /**
   * The ID of the security group.
   *
   * You must specify a destination security group ( \`DestinationPrefixListId\` or \`DestinationSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-destinationsecuritygroupid
   */
  readonly destinationSecurityGroupId?: string;

  /**
   * If the protocol is TCP or UDP, this is the start of the port range.
   *
   * If the protocol is ICMP or ICMPv6, this is the type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-fromport
   */
  readonly fromPort?: number;

  /**
   * The ID of the security group.
   *
   * You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-groupid
   */
  readonly groupId: string;

  /**
   * The IP protocol name ( \`tcp\` , \`udp\` , \`icmp\` , \`icmpv6\` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
   *
   * Use \`-1\` to specify all protocols. When authorizing security group rules, specifying \`-1\` or a protocol number other than \`tcp\` , \`udp\` , \`icmp\` , or \`icmpv6\` allows traffic on all ports, regardless of any port range you specify. For \`tcp\` , \`udp\` , and \`icmp\` , you must specify a port range. For \`icmpv6\` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-ipprotocol
   */
  readonly ipProtocol: string;

  /**
   * If the protocol is TCP or UDP, this is the end of the port range.
   *
   * If the protocol is ICMP or ICMPv6, this is the code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-toport
   */
  readonly toPort?: number;
}

/**
 * Determine whether the given properties match those of a \`CfnSecurityGroupEgressProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSecurityGroupEgressProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupEgressPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrIp", cdk.validateString)(properties.cidrIp));
  errors.collect(cdk.propertyValidator("cidrIpv6", cdk.validateString)(properties.cidrIpv6));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("destinationPrefixListId", cdk.validateString)(properties.destinationPrefixListId));
  errors.collect(cdk.propertyValidator("destinationSecurityGroupId", cdk.validateString)(properties.destinationSecurityGroupId));
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("groupId", cdk.requiredValidator)(properties.groupId));
  errors.collect(cdk.propertyValidator("groupId", cdk.validateString)(properties.groupId));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.requiredValidator)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.validateString)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \\"CfnSecurityGroupEgressProps\\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupEgressPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupEgressPropsValidator(properties).assertSuccess();
  return {
    "CidrIp": cdk.stringToCloudFormation(properties.cidrIp),
    "CidrIpv6": cdk.stringToCloudFormation(properties.cidrIpv6),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DestinationPrefixListId": cdk.stringToCloudFormation(properties.destinationPrefixListId),
    "DestinationSecurityGroupId": cdk.stringToCloudFormation(properties.destinationSecurityGroupId),
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "GroupId": cdk.stringToCloudFormation(properties.groupId),
    "IpProtocol": cdk.stringToCloudFormation(properties.ipProtocol),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupEgressPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroupEgressProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroupEgressProps>();
  ret.addPropertyResult("cidrIp", "CidrIp", (properties.CidrIp != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIp) : undefined));
  ret.addPropertyResult("cidrIpv6", "CidrIpv6", (properties.CidrIpv6 != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIpv6) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("destinationPrefixListId", "DestinationPrefixListId", (properties.DestinationPrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationPrefixListId) : undefined));
  ret.addPropertyResult("destinationSecurityGroupId", "DestinationSecurityGroupId", (properties.DestinationSecurityGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationSecurityGroupId) : undefined));
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("groupId", "GroupId", (properties.GroupId != null ? cfn_parse.FromCloudFormation.getString(properties.GroupId) : undefined));
  ret.addPropertyResult("ipProtocol", "IpProtocol", (properties.IpProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.IpProtocol) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds an inbound rule to a security group.
 *
 * An inbound rule permits instances to receive traffic from the specified IPv4 or IPv6 CIDR address range, or from the instances associated with the specified security group.
 *
 * You must specify only one of the following properties: \`CidrIp\` , \`CidrIpv6\` , \`SourcePrefixListId\` , \`SourceSecurityGroupId\` , or \`SourceSecurityGroupName\` .
 *
 * You specify a protocol for each rule (for example, TCP). For TCP and UDP, you must also specify a port or port range. For ICMP/ICMPv6, you must also specify the ICMP/ICMPv6 type and code. You can use -1 to mean all types or all codes.
 *
 * You must specify a source security group ( \`SourcePrefixListId\` , \`SourceSecurityGroupId\` , or \`SourceSecurityGroupName\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.
 *
 * Rule changes are propagated to instances within the security group as quickly as possible. However, a small delay might occur.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html
 */
export class CfnSecurityGroupIngress extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SecurityGroupIngress";

  /**
   * Build a CfnSecurityGroupIngress from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSecurityGroupIngress {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSecurityGroupIngressPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSecurityGroupIngress(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IPv4 address range, in CIDR format.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-cidrip
   */
  public cidrIp?: string;

  /**
   * The IPv6 address range, in CIDR format.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-cidripv6
   */
  public cidrIpv6?: string;

  /**
   * Updates the description of an ingress (inbound) security group rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-description
   */
  public description?: string;

  /**
   * The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-fromport
   */
  public fromPort?: number;

  /**
   * The ID of the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-groupid
   */
  public groupId?: string;

  /**
   * The name of the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-groupname
   */
  public groupName?: string;

  /**
   * The IP protocol name ( \`tcp\` , \`udp\` , \`icmp\` , \`icmpv6\` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-ipprotocol
   */
  public ipProtocol: string;

  /**
   * The ID of a prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourceprefixlistid
   */
  public sourcePrefixListId?: string;

  /**
   * The ID of the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupid
   */
  public sourceSecurityGroupId?: string;

  /**
   * [Default VPC] The name of the source security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupname
   */
  public sourceSecurityGroupName?: string;

  /**
   * [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupownerid
   */
  public sourceSecurityGroupOwnerId?: string;

  /**
   * The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-toport
   */
  public toPort?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSecurityGroupIngressProps) {
    super(scope, id, {
      "type": CfnSecurityGroupIngress.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipProtocol", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.cidrIp = props.cidrIp;
    this.cidrIpv6 = props.cidrIpv6;
    this.description = props.description;
    this.fromPort = props.fromPort;
    this.groupId = props.groupId;
    this.groupName = props.groupName;
    this.ipProtocol = props.ipProtocol;
    this.sourcePrefixListId = props.sourcePrefixListId;
    this.sourceSecurityGroupId = props.sourceSecurityGroupId;
    this.sourceSecurityGroupName = props.sourceSecurityGroupName;
    this.sourceSecurityGroupOwnerId = props.sourceSecurityGroupOwnerId;
    this.toPort = props.toPort;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidrIp": this.cidrIp,
      "cidrIpv6": this.cidrIpv6,
      "description": this.description,
      "fromPort": this.fromPort,
      "groupId": this.groupId,
      "groupName": this.groupName,
      "ipProtocol": this.ipProtocol,
      "sourcePrefixListId": this.sourcePrefixListId,
      "sourceSecurityGroupId": this.sourceSecurityGroupId,
      "sourceSecurityGroupName": this.sourceSecurityGroupName,
      "sourceSecurityGroupOwnerId": this.sourceSecurityGroupOwnerId,
      "toPort": this.toPort
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSecurityGroupIngress.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSecurityGroupIngressPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSecurityGroupIngress\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html
 */
export interface CfnSecurityGroupIngressProps {
  /**
   * The IPv4 address range, in CIDR format.
   *
   * You must specify a source security group ( \`SourcePrefixListId\` or \`SourceSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
   *
   * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-cidrip
   */
  readonly cidrIp?: string;

  /**
   * The IPv6 address range, in CIDR format.
   *
   * You must specify a source security group ( \`SourcePrefixListId\` or \`SourceSecurityGroupId\` ) or a CIDR range ( \`CidrIp\` or \`CidrIpv6\` ).
   *
   * For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-cidripv6
   */
  readonly cidrIpv6?: string;

  /**
   * Updates the description of an ingress (inbound) security group rule.
   *
   * You can replace an existing description, or add a description to a rule that did not have one previously.
   *
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-description
   */
  readonly description?: string;

  /**
   * The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.
   *
   * A value of \`-1\` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * Use this for ICMP and any protocol that uses ports.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-fromport
   */
  readonly fromPort?: number;

  /**
   * The ID of the security group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-groupid
   */
  readonly groupId?: string;

  /**
   * The name of the security group.
   *
   * Constraints: Up to 255 characters in length. Cannot start with \`sg-\` .
   *
   * Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-groupname
   */
  readonly groupName?: string;

  /**
   * The IP protocol name ( \`tcp\` , \`udp\` , \`icmp\` , \`icmpv6\` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
   *
   * Use \`-1\` to specify all protocols. When authorizing security group rules, specifying \`-1\` or a protocol number other than \`tcp\` , \`udp\` , \`icmp\` , or \`icmpv6\` allows traffic on all ports, regardless of any port range you specify. For \`tcp\` , \`udp\` , and \`icmp\` , you must specify a port range. For \`icmpv6\` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-ipprotocol
   */
  readonly ipProtocol: string;

  /**
   * The ID of a prefix list.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourceprefixlistid
   */
  readonly sourcePrefixListId?: string;

  /**
   * The ID of the security group.
   *
   * You must specify either the security group ID or the security group name. For security groups in a nondefault VPC, you must specify the security group ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupid
   */
  readonly sourceSecurityGroupId?: string;

  /**
   * [Default VPC] The name of the source security group.
   *
   * You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
   *
   * For security groups in a nondefault VPC, you must specify the group ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupname
   */
  readonly sourceSecurityGroupName?: string;

  /**
   * [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account.
   *
   * You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
   *
   * If you specify \`SourceSecurityGroupName\` or \`SourceSecurityGroupId\` and that security group is owned by a different account than the account creating the stack, you must specify \`SourceSecurityGroupOwnerId\` ; otherwise, this property is optional.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupownerid
   */
  readonly sourceSecurityGroupOwnerId?: string;

  /**
   * The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.
   *
   * A value of \`-1\` indicates all ICMP/ICMPv6 codes for the specified ICMP type. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * Use this for ICMP and any protocol that uses ports.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-toport
   */
  readonly toPort?: number;
}

/**
 * Determine whether the given properties match those of a \`CfnSecurityGroupIngressProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSecurityGroupIngressProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSecurityGroupIngressPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrIp", cdk.validateString)(properties.cidrIp));
  errors.collect(cdk.propertyValidator("cidrIpv6", cdk.validateString)(properties.cidrIpv6));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("fromPort", cdk.validateNumber)(properties.fromPort));
  errors.collect(cdk.propertyValidator("groupId", cdk.validateString)(properties.groupId));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.requiredValidator)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("ipProtocol", cdk.validateString)(properties.ipProtocol));
  errors.collect(cdk.propertyValidator("sourcePrefixListId", cdk.validateString)(properties.sourcePrefixListId));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupId", cdk.validateString)(properties.sourceSecurityGroupId));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupName", cdk.validateString)(properties.sourceSecurityGroupName));
  errors.collect(cdk.propertyValidator("sourceSecurityGroupOwnerId", cdk.validateString)(properties.sourceSecurityGroupOwnerId));
  errors.collect(cdk.propertyValidator("toPort", cdk.validateNumber)(properties.toPort));
  return errors.wrap("supplied properties not correct for \\"CfnSecurityGroupIngressProps\\"");
}

// @ts-ignore TS6133
function convertCfnSecurityGroupIngressPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSecurityGroupIngressPropsValidator(properties).assertSuccess();
  return {
    "CidrIp": cdk.stringToCloudFormation(properties.cidrIp),
    "CidrIpv6": cdk.stringToCloudFormation(properties.cidrIpv6),
    "Description": cdk.stringToCloudFormation(properties.description),
    "FromPort": cdk.numberToCloudFormation(properties.fromPort),
    "GroupId": cdk.stringToCloudFormation(properties.groupId),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "IpProtocol": cdk.stringToCloudFormation(properties.ipProtocol),
    "SourcePrefixListId": cdk.stringToCloudFormation(properties.sourcePrefixListId),
    "SourceSecurityGroupId": cdk.stringToCloudFormation(properties.sourceSecurityGroupId),
    "SourceSecurityGroupName": cdk.stringToCloudFormation(properties.sourceSecurityGroupName),
    "SourceSecurityGroupOwnerId": cdk.stringToCloudFormation(properties.sourceSecurityGroupOwnerId),
    "ToPort": cdk.numberToCloudFormation(properties.toPort)
  };
}

// @ts-ignore TS6133
function CfnSecurityGroupIngressPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSecurityGroupIngressProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSecurityGroupIngressProps>();
  ret.addPropertyResult("cidrIp", "CidrIp", (properties.CidrIp != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIp) : undefined));
  ret.addPropertyResult("cidrIpv6", "CidrIpv6", (properties.CidrIpv6 != null ? cfn_parse.FromCloudFormation.getString(properties.CidrIpv6) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("fromPort", "FromPort", (properties.FromPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.FromPort) : undefined));
  ret.addPropertyResult("groupId", "GroupId", (properties.GroupId != null ? cfn_parse.FromCloudFormation.getString(properties.GroupId) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("ipProtocol", "IpProtocol", (properties.IpProtocol != null ? cfn_parse.FromCloudFormation.getString(properties.IpProtocol) : undefined));
  ret.addPropertyResult("sourcePrefixListId", "SourcePrefixListId", (properties.SourcePrefixListId != null ? cfn_parse.FromCloudFormation.getString(properties.SourcePrefixListId) : undefined));
  ret.addPropertyResult("sourceSecurityGroupId", "SourceSecurityGroupId", (properties.SourceSecurityGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupId) : undefined));
  ret.addPropertyResult("sourceSecurityGroupName", "SourceSecurityGroupName", (properties.SourceSecurityGroupName != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupName) : undefined));
  ret.addPropertyResult("sourceSecurityGroupOwnerId", "SourceSecurityGroupOwnerId", (properties.SourceSecurityGroupOwnerId != null ? cfn_parse.FromCloudFormation.getString(properties.SourceSecurityGroupOwnerId) : undefined));
  ret.addPropertyResult("toPort", "ToPort", (properties.ToPort != null ? cfn_parse.FromCloudFormation.getNumber(properties.ToPort) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a Spot Fleet request.
 *
 * The Spot Fleet request specifies the total target capacity and the On-Demand target capacity. Amazon EC2 calculates the difference between the total capacity and On-Demand capacity, and launches the difference as Spot capacity.
 *
 * You can submit a single request that includes multiple launch specifications that vary by instance type, AMI, Availability Zone, or subnet.
 *
 * By default, the Spot Fleet requests Spot Instances in the Spot Instance pool where the price per unit is the lowest. Each launch specification can include its own instance weighting that reflects the value of the instance type to your application workload.
 *
 * Alternatively, you can specify that the Spot Fleet distribute the target capacity across the Spot pools included in its launch specifications. By ensuring that the Spot Instances in your Spot Fleet are in different Spot pools, you can improve the availability of your fleet.
 *
 * You can specify tags for the Spot Fleet request and instances launched by the fleet. You cannot tag other resource types in a Spot Fleet request because only the \`spot-fleet-request\` and \`instance\` resource types are supported.
 *
 * For more information, see [Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet.html) in the *Amazon EC2 User Guide for Linux Instances* .
 *
 * > We strongly discourage using the RequestSpotFleet API because it is a legacy API with no planned investment. For options for requesting Spot Instances, see [Which is the best Spot request method to use?](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-best-practices.html#which-spot-request-method-to-use) in the *Amazon EC2 User Guide for Linux Instances* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html
 */
export class CfnSpotFleet extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SpotFleet";

  /**
   * Build a CfnSpotFleet from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSpotFleet {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSpotFleetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSpotFleet(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the Spot Fleet.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Describes the configuration of a Spot Fleet request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata
   */
  public spotFleetRequestConfigData: cdk.IResolvable | CfnSpotFleet.SpotFleetRequestConfigDataProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSpotFleetProps) {
    super(scope, id, {
      "type": CfnSpotFleet.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "spotFleetRequestConfigData", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.spotFleetRequestConfigData = props.spotFleetRequestConfigData;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "spotFleetRequestConfigData": this.spotFleetRequestConfigData
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSpotFleet.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSpotFleetPropsToCloudFormation(props);
  }
}

export namespace CfnSpotFleet {
  /**
   * Specifies the configuration of a Spot Fleet request.
   *
   * For more information, see [Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet.html) in the *Amazon EC2 User Guide* .
   *
   * You must specify either \`LaunchSpecifications\` or \`LaunchTemplateConfigs\` .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html
   */
  export interface SpotFleetRequestConfigDataProperty {
    /**
     * Describes the configuration of a Spot Fleet request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotfleetrequestconfigdata
     */
    readonly spotFleetRequestConfigData: cdk.IResolvable | CfnSpotFleet.SpotFleetRequestConfigDataProperty;
  }
}

/**
 * Properties for defining a \`CfnSpotFleet\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html
 */
export interface CfnSpotFleetProps {
  /**
   * Describes the configuration of a Spot Fleet request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata
   */
  readonly spotFleetRequestConfigData: cdk.IResolvable | CfnSpotFleet.SpotFleetRequestConfigDataProperty;
}

/**
 * Determine whether the given properties match those of a \`SpotFleetRequestConfigDataProperty\`
 *
 * @param properties - the TypeScript properties of a \`SpotFleetRequestConfigDataProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetSpotFleetRequestConfigDataPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("spotFleetRequestConfigData", cdk.requiredValidator)(properties.spotFleetRequestConfigData));
  errors.collect(cdk.propertyValidator("spotFleetRequestConfigData", CfnSpotFleetSpotFleetRequestConfigDataPropertyValidator)(properties.spotFleetRequestConfigData));
  return errors.wrap("supplied properties not correct for \\"SpotFleetRequestConfigDataProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetSpotFleetRequestConfigDataPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetSpotFleetRequestConfigDataPropertyValidator(properties).assertSuccess();
  return {
    "SpotFleetRequestConfigData": convertCfnSpotFleetSpotFleetRequestConfigDataPropertyToCloudFormation(properties.spotFleetRequestConfigData)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetSpotFleetRequestConfigDataPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSpotFleet.SpotFleetRequestConfigDataProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleet.SpotFleetRequestConfigDataProperty>();
  ret.addPropertyResult("spotFleetRequestConfigData", "SpotFleetRequestConfigData", (properties.SpotFleetRequestConfigData != null ? CfnSpotFleetSpotFleetRequestConfigDataPropertyFromCloudFormation(properties.SpotFleetRequestConfigData) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSpotFleetProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSpotFleetProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSpotFleetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("spotFleetRequestConfigData", cdk.requiredValidator)(properties.spotFleetRequestConfigData));
  errors.collect(cdk.propertyValidator("spotFleetRequestConfigData", CfnSpotFleetSpotFleetRequestConfigDataPropertyValidator)(properties.spotFleetRequestConfigData));
  return errors.wrap("supplied properties not correct for \\"CfnSpotFleetProps\\"");
}

// @ts-ignore TS6133
function convertCfnSpotFleetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSpotFleetPropsValidator(properties).assertSuccess();
  return {
    "SpotFleetRequestConfigData": convertCfnSpotFleetSpotFleetRequestConfigDataPropertyToCloudFormation(properties.spotFleetRequestConfigData)
  };
}

// @ts-ignore TS6133
function CfnSpotFleetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSpotFleetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSpotFleetProps>();
  ret.addPropertyResult("spotFleetRequestConfigData", "SpotFleetRequestConfigData", (properties.SpotFleetRequestConfigData != null ? CfnSpotFleetSpotFleetRequestConfigDataPropertyFromCloudFormation(properties.SpotFleetRequestConfigData) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a subnet for the specified VPC.
 *
 * For an IPv4 only subnet, specify an IPv4 CIDR block. If the VPC has an IPv6 CIDR block, you can create an IPv6 only subnet or a dual stack subnet instead. For an IPv6 only subnet, specify an IPv6 CIDR block. For a dual stack subnet, specify both an IPv4 CIDR block and an IPv6 CIDR block.
 *
 * For more information, see [Subnets for your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/configure-subnets.html) in the *Amazon VPC User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
 */
export class CfnSubnet extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Subnet";

  /**
   * Build a CfnSubnet from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSubnet {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSubnetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSubnet(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Availability Zone of this subnet. For example:
   *
   * \`{ "Fn::GetAtt" : [ "mySubnet", "AvailabilityZone" ] }\`
   *
   * @cloudformationAttribute AvailabilityZone
   */
  public readonly attrAvailabilityZone: string;

  /**
   * The IPv6 CIDR blocks that are associated with the subnet, such as \`[ 2001:db8:1234:1a00::/64 ]\` .
   *
   * @cloudformationAttribute Ipv6CidrBlocks
   */
  public readonly attrIpv6CidrBlocks: Array<string>;

  /**
   * The ID of the network ACL that is associated with the subnet's VPC, such as \`acl-5fb85d36\` .
   *
   * @cloudformationAttribute NetworkAclAssociationId
   */
  public readonly attrNetworkAclAssociationId: string;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @cloudformationAttribute OutpostArn
   */
  public readonly attrOutpostArn: string;

  /**
   * The ID of the subnet.
   *
   * @cloudformationAttribute SubnetId
   */
  public readonly attrSubnetId: string;

  /**
   * The ID of the subnet's VPC, such as \`vpc-11ad4878\` .
   *
   * @cloudformationAttribute VpcId
   */
  public readonly attrVpcId: string;

  /**
   * Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is \`false\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-assignipv6addressoncreation
   */
  public assignIpv6AddressOnCreation?: boolean | cdk.IResolvable;

  /**
   * The Availability Zone of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzone
   */
  public availabilityZone?: string;

  /**
   * The AZ ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzoneid
   */
  public availabilityZoneId?: string;

  /**
   * The IPv4 CIDR block assigned to the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-cidrblock
   */
  public cidrBlock?: string;

  /**
   * Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-enabledns64
   */
  public enableDns64?: boolean | cdk.IResolvable;

  /**
   * The IPv6 CIDR block.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6cidrblock
   */
  public ipv6CidrBlock?: string;

  /**
   * Indicates whether this is an IPv6 only subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6native
   */
  public ipv6Native?: boolean | cdk.IResolvable;

  /**
   * Indicates whether instances launched in this subnet receive a public IPv4 address.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-mappubliciponlaunch
   */
  public mapPublicIpOnLaunch?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-outpostarn
   */
  public outpostArn?: string;

  /**
   * The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch
   */
  public privateDnsNameOptionsOnLaunch?: any | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC the subnet is in.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-vpcid
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSubnetProps) {
    super(scope, id, {
      "type": CfnSubnet.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrAvailabilityZone = cdk.Token.asString(this.getAtt("AvailabilityZone", cdk.ResolutionTypeHint.STRING));
    this.attrIpv6CidrBlocks = cdk.Token.asList(this.getAtt("Ipv6CidrBlocks", cdk.ResolutionTypeHint.STRING_LIST));
    this.attrNetworkAclAssociationId = cdk.Token.asString(this.getAtt("NetworkAclAssociationId", cdk.ResolutionTypeHint.STRING));
    this.attrOutpostArn = cdk.Token.asString(this.getAtt("OutpostArn", cdk.ResolutionTypeHint.STRING));
    this.attrSubnetId = cdk.Token.asString(this.getAtt("SubnetId", cdk.ResolutionTypeHint.STRING));
    this.attrVpcId = cdk.Token.asString(this.getAtt("VpcId", cdk.ResolutionTypeHint.STRING));
    this.assignIpv6AddressOnCreation = props.assignIpv6AddressOnCreation;
    this.availabilityZone = props.availabilityZone;
    this.availabilityZoneId = props.availabilityZoneId;
    this.cidrBlock = props.cidrBlock;
    this.enableDns64 = props.enableDns64;
    this.ipv6CidrBlock = props.ipv6CidrBlock;
    this.ipv6Native = props.ipv6Native;
    this.mapPublicIpOnLaunch = props.mapPublicIpOnLaunch;
    this.outpostArn = props.outpostArn;
    this.privateDnsNameOptionsOnLaunch = props.privateDnsNameOptionsOnLaunch;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::Subnet", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "assignIpv6AddressOnCreation": this.assignIpv6AddressOnCreation,
      "availabilityZone": this.availabilityZone,
      "availabilityZoneId": this.availabilityZoneId,
      "cidrBlock": this.cidrBlock,
      "enableDns64": this.enableDns64,
      "ipv6CidrBlock": this.ipv6CidrBlock,
      "ipv6Native": this.ipv6Native,
      "mapPublicIpOnLaunch": this.mapPublicIpOnLaunch,
      "outpostArn": this.outpostArn,
      "privateDnsNameOptionsOnLaunch": this.privateDnsNameOptionsOnLaunch,
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSubnet.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSubnetPropsToCloudFormation(props);
  }
}

export namespace CfnSubnet {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html
   */
  export interface TagProperty {
    /**
     * Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is \`false\` .
     *
     * If you specify \`AssignIpv6AddressOnCreation\` , you must also specify \`Ipv6CidrBlock\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html#cfn-ec2-subnet-tag-assignipv6addressoncreation
     */
    readonly assignIpv6AddressOnCreation?: boolean | cdk.IResolvable;

    /**
     * The Availability Zone of the subnet.
     *
     * If you update this property, you must also update the \`CidrBlock\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html#cfn-ec2-subnet-tag-availabilityzone
     */
    readonly availabilityZone?: string;

    /**
     * The AZ ID of the subnet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html#cfn-ec2-subnet-tag-availabilityzoneid
     */
    readonly availabilityZoneId?: string;

    /**
     * The IPv4 CIDR block assigned to the subnet.
     *
     * If you update this property, we create a new subnet, and then delete the existing one.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html#cfn-ec2-subnet-tag-cidrblock
     */
    readonly cidrBlock?: string;

    /**
     * Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations.
     *
     * For more information, see [DNS64 and NAT64](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-nat64-dns64) in the *Amazon Virtual Private Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html#cfn-ec2-subnet-tag-enabledns64
     */
    readonly enableDns64?: boolean | cdk.IResolvable;

    /**
     * The IPv6 CIDR block.
     *
     * If you specify \`AssignIpv6AddressOnCreation\` , you must also specify \`Ipv6CidrBlock\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html#cfn-ec2-subnet-tag-ipv6cidrblock
     */
    readonly ipv6CidrBlock?: string;

    /**
     * Indicates whether this is an IPv6 only subnet.
     *
     * For more information, see [Subnet basics](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics) in the *Amazon Virtual Private Cloud User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html#cfn-ec2-subnet-tag-ipv6native
     */
    readonly ipv6Native?: boolean | cdk.IResolvable;

    /**
     * Indicates whether instances launched in this subnet receive a public IPv4 address.
     *
     * The default value is \`false\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html#cfn-ec2-subnet-tag-mappubliciponlaunch
     */
    readonly mapPublicIpOnLaunch?: boolean | cdk.IResolvable;

    /**
     * The Amazon Resource Name (ARN) of the Outpost.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html#cfn-ec2-subnet-tag-outpostarn
     */
    readonly outpostArn?: string;

    /**
     * The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled.
     *
     * For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * Available options:
     *
     * - EnableResourceNameDnsAAAARecord (true | false)
     * - EnableResourceNameDnsARecord (true | false)
     * - HostnameType (ip-name | resource-name)
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html#cfn-ec2-subnet-tag-privatednsnameoptionsonlaunch
     */
    readonly privateDnsNameOptionsOnLaunch?: any | cdk.IResolvable;

    /**
     * Any tags assigned to the subnet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html#cfn-ec2-subnet-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnSubnet.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the VPC the subnet is in.
     *
     * If you update this property, you must also update the \`CidrBlock\` property.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-tag.html#cfn-ec2-subnet-tag-vpcid
     */
    readonly vpcId: string;
  }
}

/**
 * Properties for defining a \`CfnSubnet\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
 */
export interface CfnSubnetProps {
  /**
   * Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is \`false\` .
   *
   * If you specify \`AssignIpv6AddressOnCreation\` , you must also specify \`Ipv6CidrBlock\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-assignipv6addressoncreation
   */
  readonly assignIpv6AddressOnCreation?: boolean | cdk.IResolvable;

  /**
   * The Availability Zone of the subnet.
   *
   * If you update this property, you must also update the \`CidrBlock\` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzone
   */
  readonly availabilityZone?: string;

  /**
   * The AZ ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzoneid
   */
  readonly availabilityZoneId?: string;

  /**
   * The IPv4 CIDR block assigned to the subnet.
   *
   * If you update this property, we create a new subnet, and then delete the existing one.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-cidrblock
   */
  readonly cidrBlock?: string;

  /**
   * Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations.
   *
   * For more information, see [DNS64 and NAT64](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-nat64-dns64) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-enabledns64
   */
  readonly enableDns64?: boolean | cdk.IResolvable;

  /**
   * The IPv6 CIDR block.
   *
   * If you specify \`AssignIpv6AddressOnCreation\` , you must also specify \`Ipv6CidrBlock\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6cidrblock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * Indicates whether this is an IPv6 only subnet.
   *
   * For more information, see [Subnet basics](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics) in the *Amazon Virtual Private Cloud User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6native
   */
  readonly ipv6Native?: boolean | cdk.IResolvable;

  /**
   * Indicates whether instances launched in this subnet receive a public IPv4 address.
   *
   * The default value is \`false\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-mappubliciponlaunch
   */
  readonly mapPublicIpOnLaunch?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-outpostarn
   */
  readonly outpostArn?: string;

  /**
   * The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled.
   *
   * For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * Available options:
   *
   * - EnableResourceNameDnsAAAARecord (true | false)
   * - EnableResourceNameDnsARecord (true | false)
   * - HostnameType (ip-name | resource-name)
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch
   */
  readonly privateDnsNameOptionsOnLaunch?: any | cdk.IResolvable;

  /**
   * Any tags assigned to the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC the subnet is in.
   *
   * If you update this property, you must also update the \`CidrBlock\` property.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("assignIpv6AddressOnCreation", cdk.validateBoolean)(properties.assignIpv6AddressOnCreation));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZoneId", cdk.validateString)(properties.availabilityZoneId));
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("enableDns64", cdk.validateBoolean)(properties.enableDns64));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("ipv6Native", cdk.validateBoolean)(properties.ipv6Native));
  errors.collect(cdk.propertyValidator("mapPublicIpOnLaunch", cdk.validateBoolean)(properties.mapPublicIpOnLaunch));
  errors.collect(cdk.propertyValidator("outpostArn", cdk.validateString)(properties.outpostArn));
  errors.collect(cdk.propertyValidator("privateDnsNameOptionsOnLaunch", cdk.validateObject)(properties.privateDnsNameOptionsOnLaunch));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnSubnetTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSubnetTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetTagPropertyValidator(properties).assertSuccess();
  return {
    "AssignIpv6AddressOnCreation": cdk.booleanToCloudFormation(properties.assignIpv6AddressOnCreation),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "AvailabilityZoneId": cdk.stringToCloudFormation(properties.availabilityZoneId),
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "EnableDns64": cdk.booleanToCloudFormation(properties.enableDns64),
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "Ipv6Native": cdk.booleanToCloudFormation(properties.ipv6Native),
    "MapPublicIpOnLaunch": cdk.booleanToCloudFormation(properties.mapPublicIpOnLaunch),
    "OutpostArn": cdk.stringToCloudFormation(properties.outpostArn),
    "PrivateDnsNameOptionsOnLaunch": cdk.objectToCloudFormation(properties.privateDnsNameOptionsOnLaunch),
    "Tags": cdk.listMapper(convertCfnSubnetTagPropertyToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnSubnetTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSubnet.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnet.TagProperty>();
  ret.addPropertyResult("assignIpv6AddressOnCreation", "AssignIpv6AddressOnCreation", (properties.AssignIpv6AddressOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssignIpv6AddressOnCreation) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("availabilityZoneId", "AvailabilityZoneId", (properties.AvailabilityZoneId != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZoneId) : undefined));
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("enableDns64", "EnableDns64", (properties.EnableDns64 != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableDns64) : undefined));
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("ipv6Native", "Ipv6Native", (properties.Ipv6Native != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Ipv6Native) : undefined));
  ret.addPropertyResult("mapPublicIpOnLaunch", "MapPublicIpOnLaunch", (properties.MapPublicIpOnLaunch != null ? cfn_parse.FromCloudFormation.getBoolean(properties.MapPublicIpOnLaunch) : undefined));
  ret.addPropertyResult("outpostArn", "OutpostArn", (properties.OutpostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutpostArn) : undefined));
  ret.addPropertyResult("privateDnsNameOptionsOnLaunch", "PrivateDnsNameOptionsOnLaunch", (properties.PrivateDnsNameOptionsOnLaunch != null ? cfn_parse.FromCloudFormation.getAny(properties.PrivateDnsNameOptionsOnLaunch) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnSubnetTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSubnetProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSubnetProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("assignIpv6AddressOnCreation", cdk.validateBoolean)(properties.assignIpv6AddressOnCreation));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZoneId", cdk.validateString)(properties.availabilityZoneId));
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("enableDns64", cdk.validateBoolean)(properties.enableDns64));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("ipv6Native", cdk.validateBoolean)(properties.ipv6Native));
  errors.collect(cdk.propertyValidator("mapPublicIpOnLaunch", cdk.validateBoolean)(properties.mapPublicIpOnLaunch));
  errors.collect(cdk.propertyValidator("outpostArn", cdk.validateString)(properties.outpostArn));
  errors.collect(cdk.propertyValidator("privateDnsNameOptionsOnLaunch", cdk.validateObject)(properties.privateDnsNameOptionsOnLaunch));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnSubnetProps\\"");
}

// @ts-ignore TS6133
function convertCfnSubnetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetPropsValidator(properties).assertSuccess();
  return {
    "AssignIpv6AddressOnCreation": cdk.booleanToCloudFormation(properties.assignIpv6AddressOnCreation),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "AvailabilityZoneId": cdk.stringToCloudFormation(properties.availabilityZoneId),
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "EnableDns64": cdk.booleanToCloudFormation(properties.enableDns64),
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "Ipv6Native": cdk.booleanToCloudFormation(properties.ipv6Native),
    "MapPublicIpOnLaunch": cdk.booleanToCloudFormation(properties.mapPublicIpOnLaunch),
    "OutpostArn": cdk.stringToCloudFormation(properties.outpostArn),
    "PrivateDnsNameOptionsOnLaunch": cdk.objectToCloudFormation(properties.privateDnsNameOptionsOnLaunch),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnSubnetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSubnetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnetProps>();
  ret.addPropertyResult("assignIpv6AddressOnCreation", "AssignIpv6AddressOnCreation", (properties.AssignIpv6AddressOnCreation != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AssignIpv6AddressOnCreation) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("availabilityZoneId", "AvailabilityZoneId", (properties.AvailabilityZoneId != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZoneId) : undefined));
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("enableDns64", "EnableDns64", (properties.EnableDns64 != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableDns64) : undefined));
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("ipv6Native", "Ipv6Native", (properties.Ipv6Native != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Ipv6Native) : undefined));
  ret.addPropertyResult("mapPublicIpOnLaunch", "MapPublicIpOnLaunch", (properties.MapPublicIpOnLaunch != null ? cfn_parse.FromCloudFormation.getBoolean(properties.MapPublicIpOnLaunch) : undefined));
  ret.addPropertyResult("outpostArn", "OutpostArn", (properties.OutpostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutpostArn) : undefined));
  ret.addPropertyResult("privateDnsNameOptionsOnLaunch", "PrivateDnsNameOptionsOnLaunch", (properties.PrivateDnsNameOptionsOnLaunch != null ? cfn_parse.FromCloudFormation.getAny(properties.PrivateDnsNameOptionsOnLaunch) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a CIDR block with your subnet.
 *
 * You can associate a single IPv6 CIDR block with your subnet. An IPv6 CIDR block must have a prefix length of /64.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html
 */
export class CfnSubnetCidrBlock extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SubnetCidrBlock";

  /**
   * Build a CfnSubnetCidrBlock from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSubnetCidrBlock {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSubnetCidrBlockPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSubnetCidrBlock(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6cidrblock
   */
  public ipv6CidrBlock: string;

  /**
   * The ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-subnetid
   */
  public subnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSubnetCidrBlockProps) {
    super(scope, id, {
      "type": CfnSubnetCidrBlock.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "ipv6CidrBlock", this);
    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.ipv6CidrBlock = props.ipv6CidrBlock;
    this.subnetId = props.subnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "ipv6CidrBlock": this.ipv6CidrBlock,
      "subnetId": this.subnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSubnetCidrBlock.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSubnetCidrBlockPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSubnetCidrBlock\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html
 */
export interface CfnSubnetCidrBlockProps {
  /**
   * The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.
   *
   * This parameter is required for an IPv6 only subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6cidrblock
   */
  readonly ipv6CidrBlock: string;

  /**
   * The ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-subnetid
   */
  readonly subnetId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnSubnetCidrBlockProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSubnetCidrBlockProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetCidrBlockPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.requiredValidator)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \\"CfnSubnetCidrBlockProps\\"");
}

// @ts-ignore TS6133
function convertCfnSubnetCidrBlockPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetCidrBlockPropsValidator(properties).assertSuccess();
  return {
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnSubnetCidrBlockPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSubnetCidrBlockProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnetCidrBlockProps>();
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a subnet with a network ACL. For more information, see [ReplaceNetworkAclAssociation](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-ReplaceNetworkAclAssociation.html) in the *Amazon EC2 API Reference* .
 *
 * When \`AWS::EC2::SubnetNetworkAclAssociation\` resources are created during create or update operations, AWS CloudFormation adopts existing resources that share the same key properties (the properties that contribute to uniquely identify the resource). However, if the operation fails and rolls back, AWS CloudFormation deletes the previously out-of-band resources. You can protect against this behavior by using \`Retain\` deletion policies. For more information, see [DeletionPolicy Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html
 */
export class CfnSubnetNetworkAclAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SubnetNetworkAclAssociation";

  /**
   * Build a CfnSubnetNetworkAclAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSubnetNetworkAclAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSubnetNetworkAclAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSubnetNetworkAclAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Returns the value of this object's [SubnetId](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet-network-acl-assoc.html) property.
   *
   * @cloudformationAttribute AssociationId
   */
  public readonly attrAssociationId: string;

  /**
   * The ID of the network ACL.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html#cfn-ec2-subnetnetworkaclassociation-networkaclid
   */
  public networkAclId: string;

  /**
   * The ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html#cfn-ec2-subnetnetworkaclassociation-subnetid
   */
  public subnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSubnetNetworkAclAssociationProps) {
    super(scope, id, {
      "type": CfnSubnetNetworkAclAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkAclId", this);
    cdk.requireProperty(props, "subnetId", this);

    this.attrAssociationId = cdk.Token.asString(this.getAtt("AssociationId", cdk.ResolutionTypeHint.STRING));
    this.networkAclId = props.networkAclId;
    this.subnetId = props.subnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "networkAclId": this.networkAclId,
      "subnetId": this.subnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSubnetNetworkAclAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSubnetNetworkAclAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSubnetNetworkAclAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html
 */
export interface CfnSubnetNetworkAclAssociationProps {
  /**
   * The ID of the network ACL.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html#cfn-ec2-subnetnetworkaclassociation-networkaclid
   */
  readonly networkAclId: string;

  /**
   * The ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html#cfn-ec2-subnetnetworkaclassociation-subnetid
   */
  readonly subnetId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnSubnetNetworkAclAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSubnetNetworkAclAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetNetworkAclAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("networkAclId", cdk.requiredValidator)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("networkAclId", cdk.validateString)(properties.networkAclId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \\"CfnSubnetNetworkAclAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnSubnetNetworkAclAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetNetworkAclAssociationPropsValidator(properties).assertSuccess();
  return {
    "NetworkAclId": cdk.stringToCloudFormation(properties.networkAclId),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnSubnetNetworkAclAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSubnetNetworkAclAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnetNetworkAclAssociationProps>();
  ret.addPropertyResult("networkAclId", "NetworkAclId", (properties.NetworkAclId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkAclId) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a subnet with a route table.
 *
 * The subnet and route table must be in the same VPC. This association causes traffic originating from the subnet to be routed according to the routes in the route table. A route table can be associated with multiple subnets. To create a route table, see [AWS::EC2::RouteTable](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html
 */
export class CfnSubnetRouteTableAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::SubnetRouteTableAssociation";

  /**
   * Build a CfnSubnetRouteTableAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSubnetRouteTableAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSubnetRouteTableAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSubnetRouteTableAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the subnet route table association.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-routetableid
   */
  public routeTableId: string;

  /**
   * The ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-subnetid
   */
  public subnetId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSubnetRouteTableAssociationProps) {
    super(scope, id, {
      "type": CfnSubnetRouteTableAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "routeTableId", this);
    cdk.requireProperty(props, "subnetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.routeTableId = props.routeTableId;
    this.subnetId = props.subnetId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "routeTableId": this.routeTableId,
      "subnetId": this.subnetId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSubnetRouteTableAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSubnetRouteTableAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSubnetRouteTableAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html
 */
export interface CfnSubnetRouteTableAssociationProps {
  /**
   * The ID of the route table.
   *
   * The physical ID changes when the route table ID is changed.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-routetableid
   */
  readonly routeTableId: string;

  /**
   * The ID of the subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-subnetid
   */
  readonly subnetId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnSubnetRouteTableAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSubnetRouteTableAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSubnetRouteTableAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("routeTableId", cdk.requiredValidator)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("routeTableId", cdk.validateString)(properties.routeTableId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  return errors.wrap("supplied properties not correct for \\"CfnSubnetRouteTableAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnSubnetRouteTableAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSubnetRouteTableAssociationPropsValidator(properties).assertSuccess();
  return {
    "RouteTableId": cdk.stringToCloudFormation(properties.routeTableId),
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId)
  };
}

// @ts-ignore TS6133
function CfnSubnetRouteTableAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSubnetRouteTableAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSubnetRouteTableAssociationProps>();
  ret.addPropertyResult("routeTableId", "RouteTableId", (properties.RouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.RouteTableId) : undefined));
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a Traffic Mirror filter.
 *
 * A Traffic Mirror filter is a set of rules that defines the traffic to mirror.
 *
 * By default, no traffic is mirrored. To mirror traffic, use [AWS::EC2::TrafficMirrorFilterRule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html) to add Traffic Mirror rules to the filter. The rules you add define what traffic gets mirrored.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html
 */
export class CfnTrafficMirrorFilter extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TrafficMirrorFilter";

  /**
   * Build a CfnTrafficMirrorFilter from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTrafficMirrorFilter {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTrafficMirrorFilterPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTrafficMirrorFilter(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The description of the Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-description
   */
  public description?: string;

  /**
   * The network service traffic that is associated with the Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-networkservices
   */
  public networkServices?: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to assign to a Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTrafficMirrorFilterProps = {}) {
    super(scope, id, {
      "type": CfnTrafficMirrorFilter.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.networkServices = props.networkServices;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TrafficMirrorFilter", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "networkServices": this.networkServices,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTrafficMirrorFilter.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTrafficMirrorFilterPropsToCloudFormation(props);
  }
}

export namespace CfnTrafficMirrorFilter {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilter-tag.html
   */
  export interface TagProperty {
    /**
     * The description of the Traffic Mirror filter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilter-tag.html#cfn-ec2-trafficmirrorfilter-tag-description
     */
    readonly description?: string;

    /**
     * The network service traffic that is associated with the Traffic Mirror filter.
     *
     * Valid values are \`amazon-dns\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilter-tag.html#cfn-ec2-trafficmirrorfilter-tag-networkservices
     */
    readonly networkServices?: Array<string>;

    /**
     * The tags to assign to a Traffic Mirror filter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilter-tag.html#cfn-ec2-trafficmirrorfilter-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnTrafficMirrorFilter.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnTrafficMirrorFilter\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html
 */
export interface CfnTrafficMirrorFilterProps {
  /**
   * The description of the Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-description
   */
  readonly description?: string;

  /**
   * The network service traffic that is associated with the Traffic Mirror filter.
   *
   * Valid values are \`amazon-dns\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-networkservices
   */
  readonly networkServices?: Array<string>;

  /**
   * The tags to assign to a Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorFilterTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("networkServices", cdk.listValidator(cdk.validateString))(properties.networkServices));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnTrafficMirrorFilterTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorFilterTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorFilterTagPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "NetworkServices": cdk.listMapper(cdk.stringToCloudFormation)(properties.networkServices),
    "Tags": cdk.listMapper(convertCfnTrafficMirrorFilterTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorFilterTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTrafficMirrorFilter.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorFilter.TagProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("networkServices", "NetworkServices", (properties.NetworkServices != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NetworkServices) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnTrafficMirrorFilterTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTrafficMirrorFilterProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTrafficMirrorFilterProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorFilterPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("networkServices", cdk.listValidator(cdk.validateString))(properties.networkServices));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnTrafficMirrorFilterProps\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorFilterPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorFilterPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "NetworkServices": cdk.listMapper(cdk.stringToCloudFormation)(properties.networkServices),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorFilterPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTrafficMirrorFilterProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorFilterProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("networkServices", "NetworkServices", (properties.NetworkServices != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NetworkServices) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a Traffic Mirror filter rule.
 *
 * A Traffic Mirror rule defines the Traffic Mirror source traffic to mirror.
 *
 * You need the Traffic Mirror filter ID when you create the rule.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html
 */
export class CfnTrafficMirrorFilterRule extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TrafficMirrorFilterRule";

  /**
   * Build a CfnTrafficMirrorFilterRule from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTrafficMirrorFilterRule {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTrafficMirrorFilterRulePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTrafficMirrorFilterRule(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The description of the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-description
   */
  public description?: string;

  /**
   * The destination CIDR block to assign to the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationcidrblock
   */
  public destinationCidrBlock: string;

  /**
   * The destination port range.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationportrange
   */
  public destinationPortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

  /**
   * The protocol, for example UDP, to assign to the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-protocol
   */
  public protocol?: number;

  /**
   * The action to take on the filtered traffic.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-ruleaction
   */
  public ruleAction: string;

  /**
   * The number of the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-rulenumber
   */
  public ruleNumber: number;

  /**
   * The source CIDR block to assign to the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourcecidrblock
   */
  public sourceCidrBlock: string;

  /**
   * The source port range.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourceportrange
   */
  public sourcePortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

  /**
   * The type of traffic.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficdirection
   */
  public trafficDirection: string;

  /**
   * The ID of the filter that this rule is associated with.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorfilterid
   */
  public trafficMirrorFilterId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTrafficMirrorFilterRuleProps) {
    super(scope, id, {
      "type": CfnTrafficMirrorFilterRule.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "destinationCidrBlock", this);
    cdk.requireProperty(props, "ruleAction", this);
    cdk.requireProperty(props, "ruleNumber", this);
    cdk.requireProperty(props, "sourceCidrBlock", this);
    cdk.requireProperty(props, "trafficDirection", this);
    cdk.requireProperty(props, "trafficMirrorFilterId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.destinationPortRange = props.destinationPortRange;
    this.protocol = props.protocol;
    this.ruleAction = props.ruleAction;
    this.ruleNumber = props.ruleNumber;
    this.sourceCidrBlock = props.sourceCidrBlock;
    this.sourcePortRange = props.sourcePortRange;
    this.trafficDirection = props.trafficDirection;
    this.trafficMirrorFilterId = props.trafficMirrorFilterId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "destinationCidrBlock": this.destinationCidrBlock,
      "destinationPortRange": this.destinationPortRange,
      "protocol": this.protocol,
      "ruleAction": this.ruleAction,
      "ruleNumber": this.ruleNumber,
      "sourceCidrBlock": this.sourceCidrBlock,
      "sourcePortRange": this.sourcePortRange,
      "trafficDirection": this.trafficDirection,
      "trafficMirrorFilterId": this.trafficMirrorFilterId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTrafficMirrorFilterRule.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTrafficMirrorFilterRulePropsToCloudFormation(props);
  }
}

export namespace CfnTrafficMirrorFilterRule {
  /**
   * Describes the Traffic Mirror port range.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html
   */
  export interface TrafficMirrorPortRangeProperty {
    /**
     * The description of the Traffic Mirror rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-description
     */
    readonly description?: string;

    /**
     * The destination CIDR block to assign to the Traffic Mirror rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-destinationcidrblock
     */
    readonly destinationCidrBlock: string;

    /**
     * The destination port range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-destinationportrange
     */
    readonly destinationPortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

    /**
     * The protocol, for example UDP, to assign to the Traffic Mirror rule.
     *
     * For information about the protocol value, see [Protocol Numbers](https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) on the Internet Assigned Numbers Authority (IANA) website.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-protocol
     */
    readonly protocol?: number;

    /**
     * The action to take on the filtered traffic.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-ruleaction
     */
    readonly ruleAction: string;

    /**
     * The number of the Traffic Mirror rule.
     *
     * This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-rulenumber
     */
    readonly ruleNumber: number;

    /**
     * The source CIDR block to assign to the Traffic Mirror rule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-sourcecidrblock
     */
    readonly sourceCidrBlock: string;

    /**
     * The source port range.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-sourceportrange
     */
    readonly sourcePortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

    /**
     * The type of traffic.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-trafficdirection
     */
    readonly trafficDirection: string;

    /**
     * The ID of the filter that this rule is associated with.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-trafficmirrorfilterid
     */
    readonly trafficMirrorFilterId: string;
  }
}

/**
 * Properties for defining a \`CfnTrafficMirrorFilterRule\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html
 */
export interface CfnTrafficMirrorFilterRuleProps {
  /**
   * The description of the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-description
   */
  readonly description?: string;

  /**
   * The destination CIDR block to assign to the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationcidrblock
   */
  readonly destinationCidrBlock: string;

  /**
   * The destination port range.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationportrange
   */
  readonly destinationPortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

  /**
   * The protocol, for example UDP, to assign to the Traffic Mirror rule.
   *
   * For information about the protocol value, see [Protocol Numbers](https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) on the Internet Assigned Numbers Authority (IANA) website.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-protocol
   */
  readonly protocol?: number;

  /**
   * The action to take on the filtered traffic.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-ruleaction
   */
  readonly ruleAction: string;

  /**
   * The number of the Traffic Mirror rule.
   *
   * This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-rulenumber
   */
  readonly ruleNumber: number;

  /**
   * The source CIDR block to assign to the Traffic Mirror rule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourcecidrblock
   */
  readonly sourceCidrBlock: string;

  /**
   * The source port range.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourceportrange
   */
  readonly sourcePortRange?: cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty;

  /**
   * The type of traffic.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficdirection
   */
  readonly trafficDirection: string;

  /**
   * The ID of the filter that this rule is associated with.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorfilterid
   */
  readonly trafficMirrorFilterId: string;
}

/**
 * Determine whether the given properties match those of a \`TrafficMirrorPortRangeProperty\`
 *
 * @param properties - the TypeScript properties of a \`TrafficMirrorPortRangeProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.requiredValidator)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationPortRange", CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator)(properties.destinationPortRange));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateNumber)(properties.protocol));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.requiredValidator)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.validateString)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.requiredValidator)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.validateNumber)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("sourceCidrBlock", cdk.requiredValidator)(properties.sourceCidrBlock));
  errors.collect(cdk.propertyValidator("sourceCidrBlock", cdk.validateString)(properties.sourceCidrBlock));
  errors.collect(cdk.propertyValidator("sourcePortRange", CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator)(properties.sourcePortRange));
  errors.collect(cdk.propertyValidator("trafficDirection", cdk.requiredValidator)(properties.trafficDirection));
  errors.collect(cdk.propertyValidator("trafficDirection", cdk.validateString)(properties.trafficDirection));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.requiredValidator)(properties.trafficMirrorFilterId));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.validateString)(properties.trafficMirrorFilterId));
  return errors.wrap("supplied properties not correct for \\"TrafficMirrorPortRangeProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "DestinationPortRange": convertCfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyToCloudFormation(properties.destinationPortRange),
    "Protocol": cdk.numberToCloudFormation(properties.protocol),
    "RuleAction": cdk.stringToCloudFormation(properties.ruleAction),
    "RuleNumber": cdk.numberToCloudFormation(properties.ruleNumber),
    "SourceCidrBlock": cdk.stringToCloudFormation(properties.sourceCidrBlock),
    "SourcePortRange": convertCfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyToCloudFormation(properties.sourcePortRange),
    "TrafficDirection": cdk.stringToCloudFormation(properties.trafficDirection),
    "TrafficMirrorFilterId": cdk.stringToCloudFormation(properties.trafficMirrorFilterId)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("destinationPortRange", "DestinationPortRange", (properties.DestinationPortRange != null ? CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyFromCloudFormation(properties.DestinationPortRange) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getNumber(properties.Protocol) : undefined));
  ret.addPropertyResult("ruleAction", "RuleAction", (properties.RuleAction != null ? cfn_parse.FromCloudFormation.getString(properties.RuleAction) : undefined));
  ret.addPropertyResult("ruleNumber", "RuleNumber", (properties.RuleNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.RuleNumber) : undefined));
  ret.addPropertyResult("sourceCidrBlock", "SourceCidrBlock", (properties.SourceCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.SourceCidrBlock) : undefined));
  ret.addPropertyResult("sourcePortRange", "SourcePortRange", (properties.SourcePortRange != null ? CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyFromCloudFormation(properties.SourcePortRange) : undefined));
  ret.addPropertyResult("trafficDirection", "TrafficDirection", (properties.TrafficDirection != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficDirection) : undefined));
  ret.addPropertyResult("trafficMirrorFilterId", "TrafficMirrorFilterId", (properties.TrafficMirrorFilterId != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficMirrorFilterId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTrafficMirrorFilterRuleProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTrafficMirrorFilterRuleProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorFilterRulePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.requiredValidator)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationPortRange", CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator)(properties.destinationPortRange));
  errors.collect(cdk.propertyValidator("protocol", cdk.validateNumber)(properties.protocol));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.requiredValidator)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleAction", cdk.validateString)(properties.ruleAction));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.requiredValidator)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("ruleNumber", cdk.validateNumber)(properties.ruleNumber));
  errors.collect(cdk.propertyValidator("sourceCidrBlock", cdk.requiredValidator)(properties.sourceCidrBlock));
  errors.collect(cdk.propertyValidator("sourceCidrBlock", cdk.validateString)(properties.sourceCidrBlock));
  errors.collect(cdk.propertyValidator("sourcePortRange", CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyValidator)(properties.sourcePortRange));
  errors.collect(cdk.propertyValidator("trafficDirection", cdk.requiredValidator)(properties.trafficDirection));
  errors.collect(cdk.propertyValidator("trafficDirection", cdk.validateString)(properties.trafficDirection));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.requiredValidator)(properties.trafficMirrorFilterId));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.validateString)(properties.trafficMirrorFilterId));
  return errors.wrap("supplied properties not correct for \\"CfnTrafficMirrorFilterRuleProps\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorFilterRulePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorFilterRulePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "DestinationPortRange": convertCfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyToCloudFormation(properties.destinationPortRange),
    "Protocol": cdk.numberToCloudFormation(properties.protocol),
    "RuleAction": cdk.stringToCloudFormation(properties.ruleAction),
    "RuleNumber": cdk.numberToCloudFormation(properties.ruleNumber),
    "SourceCidrBlock": cdk.stringToCloudFormation(properties.sourceCidrBlock),
    "SourcePortRange": convertCfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyToCloudFormation(properties.sourcePortRange),
    "TrafficDirection": cdk.stringToCloudFormation(properties.trafficDirection),
    "TrafficMirrorFilterId": cdk.stringToCloudFormation(properties.trafficMirrorFilterId)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorFilterRulePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTrafficMirrorFilterRuleProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorFilterRuleProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("destinationPortRange", "DestinationPortRange", (properties.DestinationPortRange != null ? CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyFromCloudFormation(properties.DestinationPortRange) : undefined));
  ret.addPropertyResult("protocol", "Protocol", (properties.Protocol != null ? cfn_parse.FromCloudFormation.getNumber(properties.Protocol) : undefined));
  ret.addPropertyResult("ruleAction", "RuleAction", (properties.RuleAction != null ? cfn_parse.FromCloudFormation.getString(properties.RuleAction) : undefined));
  ret.addPropertyResult("ruleNumber", "RuleNumber", (properties.RuleNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.RuleNumber) : undefined));
  ret.addPropertyResult("sourceCidrBlock", "SourceCidrBlock", (properties.SourceCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.SourceCidrBlock) : undefined));
  ret.addPropertyResult("sourcePortRange", "SourcePortRange", (properties.SourcePortRange != null ? CfnTrafficMirrorFilterRuleTrafficMirrorPortRangePropertyFromCloudFormation(properties.SourcePortRange) : undefined));
  ret.addPropertyResult("trafficDirection", "TrafficDirection", (properties.TrafficDirection != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficDirection) : undefined));
  ret.addPropertyResult("trafficMirrorFilterId", "TrafficMirrorFilterId", (properties.TrafficMirrorFilterId != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficMirrorFilterId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a Traffic Mirror session.
 *
 * A Traffic Mirror session actively copies packets from a Traffic Mirror source to a Traffic Mirror target. Create a filter, and then assign it to the session to define a subset of the traffic to mirror, for example all TCP traffic.
 *
 * The Traffic Mirror source and the Traffic Mirror target (monitoring appliances) can be in the same VPC, or in a different VPC connected via VPC peering or a transit gateway.
 *
 * By default, no traffic is mirrored. Use [AWS::EC2::TrafficMirrorFilterRule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html) to specify filter rules that specify the traffic to mirror.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html
 */
export class CfnTrafficMirrorSession extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TrafficMirrorSession";

  /**
   * Build a CfnTrafficMirrorSession from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTrafficMirrorSession {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTrafficMirrorSessionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTrafficMirrorSession(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The description of the Traffic Mirror session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-description
   */
  public description?: string;

  /**
   * The ID of the source network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-networkinterfaceid
   */
  public networkInterfaceId: string;

  /**
   * The number of bytes in each packet to mirror.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-packetlength
   */
  public packetLength?: number;

  /**
   * The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-sessionnumber
   */
  public sessionNumber: number;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to assign to a Traffic Mirror session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrorfilterid
   */
  public trafficMirrorFilterId: string;

  /**
   * The ID of the Traffic Mirror target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrortargetid
   */
  public trafficMirrorTargetId: string;

  /**
   * The VXLAN ID for the Traffic Mirror session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-virtualnetworkid
   */
  public virtualNetworkId?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTrafficMirrorSessionProps) {
    super(scope, id, {
      "type": CfnTrafficMirrorSession.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "networkInterfaceId", this);
    cdk.requireProperty(props, "sessionNumber", this);
    cdk.requireProperty(props, "trafficMirrorFilterId", this);
    cdk.requireProperty(props, "trafficMirrorTargetId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.networkInterfaceId = props.networkInterfaceId;
    this.packetLength = props.packetLength;
    this.sessionNumber = props.sessionNumber;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TrafficMirrorSession", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.trafficMirrorFilterId = props.trafficMirrorFilterId;
    this.trafficMirrorTargetId = props.trafficMirrorTargetId;
    this.virtualNetworkId = props.virtualNetworkId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "networkInterfaceId": this.networkInterfaceId,
      "packetLength": this.packetLength,
      "sessionNumber": this.sessionNumber,
      "tags": this.tags.renderTags(),
      "trafficMirrorFilterId": this.trafficMirrorFilterId,
      "trafficMirrorTargetId": this.trafficMirrorTargetId,
      "virtualNetworkId": this.virtualNetworkId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTrafficMirrorSession.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTrafficMirrorSessionPropsToCloudFormation(props);
  }
}

export namespace CfnTrafficMirrorSession {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorsession-tag.html
   */
  export interface TagProperty {
    /**
     * The description of the Traffic Mirror session.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorsession-tag.html#cfn-ec2-trafficmirrorsession-tag-description
     */
    readonly description?: string;

    /**
     * The ID of the source network interface.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorsession-tag.html#cfn-ec2-trafficmirrorsession-tag-networkinterfaceid
     */
    readonly networkInterfaceId: string;

    /**
     * The number of bytes in each packet to mirror.
     *
     * These are bytes after the VXLAN header. Do not specify this parameter when you want to mirror the entire packet. To mirror a subset of the packet, set this to the length (in bytes) that you want to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target.
     *
     * If you do not want to mirror the entire packet, use the \`PacketLength\` parameter to specify the number of bytes in each packet to mirror.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorsession-tag.html#cfn-ec2-trafficmirrorsession-tag-packetlength
     */
    readonly packetLength?: number;

    /**
     * The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions.
     *
     * The first session with a matching filter is the one that mirrors the packets.
     *
     * Valid values are 1-32766.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorsession-tag.html#cfn-ec2-trafficmirrorsession-tag-sessionnumber
     */
    readonly sessionNumber: number;

    /**
     * The tags to assign to a Traffic Mirror session.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorsession-tag.html#cfn-ec2-trafficmirrorsession-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnTrafficMirrorSession.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the Traffic Mirror filter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorsession-tag.html#cfn-ec2-trafficmirrorsession-tag-trafficmirrorfilterid
     */
    readonly trafficMirrorFilterId: string;

    /**
     * The ID of the Traffic Mirror target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorsession-tag.html#cfn-ec2-trafficmirrorsession-tag-trafficmirrortargetid
     */
    readonly trafficMirrorTargetId: string;

    /**
     * The VXLAN ID for the Traffic Mirror session.
     *
     * For more information about the VXLAN protocol, see [RFC 7348](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc7348) . If you do not specify a \`VirtualNetworkId\` , an account-wide unique id is chosen at random.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorsession-tag.html#cfn-ec2-trafficmirrorsession-tag-virtualnetworkid
     */
    readonly virtualNetworkId?: number;
  }
}

/**
 * Properties for defining a \`CfnTrafficMirrorSession\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html
 */
export interface CfnTrafficMirrorSessionProps {
  /**
   * The description of the Traffic Mirror session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-description
   */
  readonly description?: string;

  /**
   * The ID of the source network interface.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-networkinterfaceid
   */
  readonly networkInterfaceId: string;

  /**
   * The number of bytes in each packet to mirror.
   *
   * These are bytes after the VXLAN header. Do not specify this parameter when you want to mirror the entire packet. To mirror a subset of the packet, set this to the length (in bytes) that you want to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target.
   *
   * If you do not want to mirror the entire packet, use the \`PacketLength\` parameter to specify the number of bytes in each packet to mirror.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-packetlength
   */
  readonly packetLength?: number;

  /**
   * The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions.
   *
   * The first session with a matching filter is the one that mirrors the packets.
   *
   * Valid values are 1-32766.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-sessionnumber
   */
  readonly sessionNumber: number;

  /**
   * The tags to assign to a Traffic Mirror session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the Traffic Mirror filter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrorfilterid
   */
  readonly trafficMirrorFilterId: string;

  /**
   * The ID of the Traffic Mirror target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrortargetid
   */
  readonly trafficMirrorTargetId: string;

  /**
   * The VXLAN ID for the Traffic Mirror session.
   *
   * For more information about the VXLAN protocol, see [RFC 7348](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc7348) . If you do not specify a \`VirtualNetworkId\` , an account-wide unique id is chosen at random.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-virtualnetworkid
   */
  readonly virtualNetworkId?: number;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorSessionTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("packetLength", cdk.validateNumber)(properties.packetLength));
  errors.collect(cdk.propertyValidator("sessionNumber", cdk.requiredValidator)(properties.sessionNumber));
  errors.collect(cdk.propertyValidator("sessionNumber", cdk.validateNumber)(properties.sessionNumber));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnTrafficMirrorSessionTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.requiredValidator)(properties.trafficMirrorFilterId));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.validateString)(properties.trafficMirrorFilterId));
  errors.collect(cdk.propertyValidator("trafficMirrorTargetId", cdk.requiredValidator)(properties.trafficMirrorTargetId));
  errors.collect(cdk.propertyValidator("trafficMirrorTargetId", cdk.validateString)(properties.trafficMirrorTargetId));
  errors.collect(cdk.propertyValidator("virtualNetworkId", cdk.validateNumber)(properties.virtualNetworkId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorSessionTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorSessionTagPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PacketLength": cdk.numberToCloudFormation(properties.packetLength),
    "SessionNumber": cdk.numberToCloudFormation(properties.sessionNumber),
    "Tags": cdk.listMapper(convertCfnTrafficMirrorSessionTagPropertyToCloudFormation)(properties.tags),
    "TrafficMirrorFilterId": cdk.stringToCloudFormation(properties.trafficMirrorFilterId),
    "TrafficMirrorTargetId": cdk.stringToCloudFormation(properties.trafficMirrorTargetId),
    "VirtualNetworkId": cdk.numberToCloudFormation(properties.virtualNetworkId)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorSessionTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTrafficMirrorSession.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorSession.TagProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("packetLength", "PacketLength", (properties.PacketLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.PacketLength) : undefined));
  ret.addPropertyResult("sessionNumber", "SessionNumber", (properties.SessionNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.SessionNumber) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnTrafficMirrorSessionTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("trafficMirrorFilterId", "TrafficMirrorFilterId", (properties.TrafficMirrorFilterId != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficMirrorFilterId) : undefined));
  ret.addPropertyResult("trafficMirrorTargetId", "TrafficMirrorTargetId", (properties.TrafficMirrorTargetId != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficMirrorTargetId) : undefined));
  ret.addPropertyResult("virtualNetworkId", "VirtualNetworkId", (properties.VirtualNetworkId != null ? cfn_parse.FromCloudFormation.getNumber(properties.VirtualNetworkId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTrafficMirrorSessionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTrafficMirrorSessionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorSessionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("packetLength", cdk.validateNumber)(properties.packetLength));
  errors.collect(cdk.propertyValidator("sessionNumber", cdk.requiredValidator)(properties.sessionNumber));
  errors.collect(cdk.propertyValidator("sessionNumber", cdk.validateNumber)(properties.sessionNumber));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.requiredValidator)(properties.trafficMirrorFilterId));
  errors.collect(cdk.propertyValidator("trafficMirrorFilterId", cdk.validateString)(properties.trafficMirrorFilterId));
  errors.collect(cdk.propertyValidator("trafficMirrorTargetId", cdk.requiredValidator)(properties.trafficMirrorTargetId));
  errors.collect(cdk.propertyValidator("trafficMirrorTargetId", cdk.validateString)(properties.trafficMirrorTargetId));
  errors.collect(cdk.propertyValidator("virtualNetworkId", cdk.validateNumber)(properties.virtualNetworkId));
  return errors.wrap("supplied properties not correct for \\"CfnTrafficMirrorSessionProps\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorSessionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorSessionPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "PacketLength": cdk.numberToCloudFormation(properties.packetLength),
    "SessionNumber": cdk.numberToCloudFormation(properties.sessionNumber),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TrafficMirrorFilterId": cdk.stringToCloudFormation(properties.trafficMirrorFilterId),
    "TrafficMirrorTargetId": cdk.stringToCloudFormation(properties.trafficMirrorTargetId),
    "VirtualNetworkId": cdk.numberToCloudFormation(properties.virtualNetworkId)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorSessionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTrafficMirrorSessionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorSessionProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("packetLength", "PacketLength", (properties.PacketLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.PacketLength) : undefined));
  ret.addPropertyResult("sessionNumber", "SessionNumber", (properties.SessionNumber != null ? cfn_parse.FromCloudFormation.getNumber(properties.SessionNumber) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("trafficMirrorFilterId", "TrafficMirrorFilterId", (properties.TrafficMirrorFilterId != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficMirrorFilterId) : undefined));
  ret.addPropertyResult("trafficMirrorTargetId", "TrafficMirrorTargetId", (properties.TrafficMirrorTargetId != null ? cfn_parse.FromCloudFormation.getString(properties.TrafficMirrorTargetId) : undefined));
  ret.addPropertyResult("virtualNetworkId", "VirtualNetworkId", (properties.VirtualNetworkId != null ? cfn_parse.FromCloudFormation.getNumber(properties.VirtualNetworkId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a target for your Traffic Mirror session.
 *
 * A Traffic Mirror target is the destination for mirrored traffic. The Traffic Mirror source and the Traffic Mirror target (monitoring appliances) can be in the same VPC, or in different VPCs connected via VPC peering or a transit gateway.
 *
 * A Traffic Mirror target can be a network interface, a Network Load Balancer, or a Gateway Load Balancer endpoint.
 *
 * To use the target in a Traffic Mirror session, use [AWS::EC2::TrafficMirrorSession](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html
 */
export class CfnTrafficMirrorTarget extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TrafficMirrorTarget";

  /**
   * Build a CfnTrafficMirrorTarget from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTrafficMirrorTarget {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTrafficMirrorTargetPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTrafficMirrorTarget(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The description of the Traffic Mirror target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-description
   */
  public description?: string;

  /**
   * The ID of the Gateway Load Balancer endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-gatewayloadbalancerendpointid
   */
  public gatewayLoadBalancerEndpointId?: string;

  /**
   * The network interface ID that is associated with the target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkinterfaceid
   */
  public networkInterfaceId?: string;

  /**
   * The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkloadbalancerarn
   */
  public networkLoadBalancerArn?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to assign to the Traffic Mirror target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTrafficMirrorTargetProps = {}) {
    super(scope, id, {
      "type": CfnTrafficMirrorTarget.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.gatewayLoadBalancerEndpointId = props.gatewayLoadBalancerEndpointId;
    this.networkInterfaceId = props.networkInterfaceId;
    this.networkLoadBalancerArn = props.networkLoadBalancerArn;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TrafficMirrorTarget", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "gatewayLoadBalancerEndpointId": this.gatewayLoadBalancerEndpointId,
      "networkInterfaceId": this.networkInterfaceId,
      "networkLoadBalancerArn": this.networkLoadBalancerArn,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTrafficMirrorTarget.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTrafficMirrorTargetPropsToCloudFormation(props);
  }
}

export namespace CfnTrafficMirrorTarget {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrortarget-tag.html
   */
  export interface TagProperty {
    /**
     * The description of the Traffic Mirror target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrortarget-tag.html#cfn-ec2-trafficmirrortarget-tag-description
     */
    readonly description?: string;

    /**
     * The ID of the Gateway Load Balancer endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrortarget-tag.html#cfn-ec2-trafficmirrortarget-tag-gatewayloadbalancerendpointid
     */
    readonly gatewayLoadBalancerEndpointId?: string;

    /**
     * The network interface ID that is associated with the target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrortarget-tag.html#cfn-ec2-trafficmirrortarget-tag-networkinterfaceid
     */
    readonly networkInterfaceId?: string;

    /**
     * The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrortarget-tag.html#cfn-ec2-trafficmirrortarget-tag-networkloadbalancerarn
     */
    readonly networkLoadBalancerArn?: string;

    /**
     * The tags to assign to the Traffic Mirror target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrortarget-tag.html#cfn-ec2-trafficmirrortarget-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnTrafficMirrorTarget.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnTrafficMirrorTarget\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html
 */
export interface CfnTrafficMirrorTargetProps {
  /**
   * The description of the Traffic Mirror target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-description
   */
  readonly description?: string;

  /**
   * The ID of the Gateway Load Balancer endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-gatewayloadbalancerendpointid
   */
  readonly gatewayLoadBalancerEndpointId?: string;

  /**
   * The network interface ID that is associated with the target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkinterfaceid
   */
  readonly networkInterfaceId?: string;

  /**
   * The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkloadbalancerarn
   */
  readonly networkLoadBalancerArn?: string;

  /**
   * The tags to assign to the Traffic Mirror target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorTargetTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("gatewayLoadBalancerEndpointId", cdk.validateString)(properties.gatewayLoadBalancerEndpointId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkLoadBalancerArn", cdk.validateString)(properties.networkLoadBalancerArn));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnTrafficMirrorTargetTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorTargetTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorTargetTagPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "GatewayLoadBalancerEndpointId": cdk.stringToCloudFormation(properties.gatewayLoadBalancerEndpointId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "NetworkLoadBalancerArn": cdk.stringToCloudFormation(properties.networkLoadBalancerArn),
    "Tags": cdk.listMapper(convertCfnTrafficMirrorTargetTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorTargetTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTrafficMirrorTarget.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorTarget.TagProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("gatewayLoadBalancerEndpointId", "GatewayLoadBalancerEndpointId", (properties.GatewayLoadBalancerEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.GatewayLoadBalancerEndpointId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("networkLoadBalancerArn", "NetworkLoadBalancerArn", (properties.NetworkLoadBalancerArn != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkLoadBalancerArn) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnTrafficMirrorTargetTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTrafficMirrorTargetProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTrafficMirrorTargetProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTrafficMirrorTargetPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("gatewayLoadBalancerEndpointId", cdk.validateString)(properties.gatewayLoadBalancerEndpointId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkLoadBalancerArn", cdk.validateString)(properties.networkLoadBalancerArn));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnTrafficMirrorTargetProps\\"");
}

// @ts-ignore TS6133
function convertCfnTrafficMirrorTargetPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTrafficMirrorTargetPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "GatewayLoadBalancerEndpointId": cdk.stringToCloudFormation(properties.gatewayLoadBalancerEndpointId),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "NetworkLoadBalancerArn": cdk.stringToCloudFormation(properties.networkLoadBalancerArn),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnTrafficMirrorTargetPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTrafficMirrorTargetProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTrafficMirrorTargetProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("gatewayLoadBalancerEndpointId", "GatewayLoadBalancerEndpointId", (properties.GatewayLoadBalancerEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.GatewayLoadBalancerEndpointId) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("networkLoadBalancerArn", "NetworkLoadBalancerArn", (properties.NetworkLoadBalancerArn != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkLoadBalancerArn) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a transit gateway.
 *
 * You can use a transit gateway to interconnect your virtual private clouds (VPC) and on-premises networks. After the transit gateway enters the \`available\` state, you can attach your VPCs and VPN connections to the transit gateway.
 *
 * To attach your VPCs, use [AWS::EC2::TransitGatewayAttachment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html) .
 *
 * To attach a VPN connection, use [AWS::EC2::CustomerGateway](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html) to create a customer gateway and specify the ID of the customer gateway and the ID of the transit gateway in a call to [AWS::EC2::VPNConnection](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html) .
 *
 * When you create a transit gateway, we create a default transit gateway route table and use it as the default association route table and the default propagation route table. You can use [AWS::EC2::TransitGatewayRouteTable](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html) to create additional transit gateway route tables. If you disable automatic route propagation, we do not create a default transit gateway route table. You can use [AWS::EC2::TransitGatewayRouteTablePropagation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html) to propagate routes from a resource attachment to a transit gateway route table. If you disable automatic associations, you can use [AWS::EC2::TransitGatewayRouteTableAssociation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html) to associate a resource attachment with a transit gateway route table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html
 */
export class CfnTransitGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGateway";

  /**
   * Build a CfnTransitGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the transit gateway.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-amazonsideasn
   */
  public amazonSideAsn?: number;

  /**
   * The ID of the default association route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-associationdefaultroutetableid
   */
  public associationDefaultRouteTableId?: string;

  /**
   * Enable or disable automatic acceptance of attachment requests.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-autoacceptsharedattachments
   */
  public autoAcceptSharedAttachments?: string;

  /**
   * Enable or disable automatic association with the default association route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetableassociation
   */
  public defaultRouteTableAssociation?: string;

  /**
   * Enable or disable automatic propagation of routes to the default propagation route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetablepropagation
   */
  public defaultRouteTablePropagation?: string;

  /**
   * The description of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-description
   */
  public description?: string;

  /**
   * Enable or disable DNS support.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-dnssupport
   */
  public dnsSupport?: string;

  /**
   * Indicates whether multicast is enabled on the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-multicastsupport
   */
  public multicastSupport?: string;

  /**
   * The ID of the default propagation route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-propagationdefaultroutetableid
   */
  public propagationDefaultRouteTableId?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The transit gateway CIDR blocks.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-transitgatewaycidrblocks
   */
  public transitGatewayCidrBlocks?: Array<string>;

  /**
   * Enable or disable Equal Cost Multipath Protocol support.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-vpnecmpsupport
   */
  public vpnEcmpSupport?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayProps = {}) {
    super(scope, id, {
      "type": CfnTransitGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.amazonSideAsn = props.amazonSideAsn;
    this.associationDefaultRouteTableId = props.associationDefaultRouteTableId;
    this.autoAcceptSharedAttachments = props.autoAcceptSharedAttachments;
    this.defaultRouteTableAssociation = props.defaultRouteTableAssociation;
    this.defaultRouteTablePropagation = props.defaultRouteTablePropagation;
    this.description = props.description;
    this.dnsSupport = props.dnsSupport;
    this.multicastSupport = props.multicastSupport;
    this.propagationDefaultRouteTableId = props.propagationDefaultRouteTableId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayCidrBlocks = props.transitGatewayCidrBlocks;
    this.vpnEcmpSupport = props.vpnEcmpSupport;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "amazonSideAsn": this.amazonSideAsn,
      "associationDefaultRouteTableId": this.associationDefaultRouteTableId,
      "autoAcceptSharedAttachments": this.autoAcceptSharedAttachments,
      "defaultRouteTableAssociation": this.defaultRouteTableAssociation,
      "defaultRouteTablePropagation": this.defaultRouteTablePropagation,
      "description": this.description,
      "dnsSupport": this.dnsSupport,
      "multicastSupport": this.multicastSupport,
      "propagationDefaultRouteTableId": this.propagationDefaultRouteTableId,
      "tags": this.tags.renderTags(),
      "transitGatewayCidrBlocks": this.transitGatewayCidrBlocks,
      "vpnEcmpSupport": this.vpnEcmpSupport
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGateway {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html
   */
  export interface TagProperty {
    /**
     * A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
     *
     * The range is 64512 to 65534 for 16-bit ASNs. The default is 64512.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html#cfn-ec2-transitgateway-tag-amazonsideasn
     */
    readonly amazonSideAsn?: number;

    /**
     * The ID of the default association route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html#cfn-ec2-transitgateway-tag-associationdefaultroutetableid
     */
    readonly associationDefaultRouteTableId?: string;

    /**
     * Enable or disable automatic acceptance of attachment requests.
     *
     * Disabled by default.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html#cfn-ec2-transitgateway-tag-autoacceptsharedattachments
     */
    readonly autoAcceptSharedAttachments?: string;

    /**
     * Enable or disable automatic association with the default association route table.
     *
     * Enabled by default.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html#cfn-ec2-transitgateway-tag-defaultroutetableassociation
     */
    readonly defaultRouteTableAssociation?: string;

    /**
     * Enable or disable automatic propagation of routes to the default propagation route table.
     *
     * Enabled by default.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html#cfn-ec2-transitgateway-tag-defaultroutetablepropagation
     */
    readonly defaultRouteTablePropagation?: string;

    /**
     * The description of the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html#cfn-ec2-transitgateway-tag-description
     */
    readonly description?: string;

    /**
     * Enable or disable DNS support.
     *
     * Enabled by default.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html#cfn-ec2-transitgateway-tag-dnssupport
     */
    readonly dnsSupport?: string;

    /**
     * Indicates whether multicast is enabled on the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html#cfn-ec2-transitgateway-tag-multicastsupport
     */
    readonly multicastSupport?: string;

    /**
     * The ID of the default propagation route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html#cfn-ec2-transitgateway-tag-propagationdefaultroutetableid
     */
    readonly propagationDefaultRouteTableId?: string;

    /**
     * The tags for the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html#cfn-ec2-transitgateway-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnTransitGateway.TagProperty> | cdk.IResolvable;

    /**
     * The transit gateway CIDR blocks.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html#cfn-ec2-transitgateway-tag-transitgatewaycidrblocks
     */
    readonly transitGatewayCidrBlocks?: Array<string>;

    /**
     * Enable or disable Equal Cost Multipath Protocol support.
     *
     * Enabled by default.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgateway-tag.html#cfn-ec2-transitgateway-tag-vpnecmpsupport
     */
    readonly vpnEcmpSupport?: string;
  }
}

/**
 * Properties for defining a \`CfnTransitGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html
 */
export interface CfnTransitGatewayProps {
  /**
   * A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
   *
   * The range is 64512 to 65534 for 16-bit ASNs. The default is 64512.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-amazonsideasn
   */
  readonly amazonSideAsn?: number;

  /**
   * The ID of the default association route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-associationdefaultroutetableid
   */
  readonly associationDefaultRouteTableId?: string;

  /**
   * Enable or disable automatic acceptance of attachment requests.
   *
   * Disabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-autoacceptsharedattachments
   */
  readonly autoAcceptSharedAttachments?: string;

  /**
   * Enable or disable automatic association with the default association route table.
   *
   * Enabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetableassociation
   */
  readonly defaultRouteTableAssociation?: string;

  /**
   * Enable or disable automatic propagation of routes to the default propagation route table.
   *
   * Enabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetablepropagation
   */
  readonly defaultRouteTablePropagation?: string;

  /**
   * The description of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-description
   */
  readonly description?: string;

  /**
   * Enable or disable DNS support.
   *
   * Enabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-dnssupport
   */
  readonly dnsSupport?: string;

  /**
   * Indicates whether multicast is enabled on the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-multicastsupport
   */
  readonly multicastSupport?: string;

  /**
   * The ID of the default propagation route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-propagationdefaultroutetableid
   */
  readonly propagationDefaultRouteTableId?: string;

  /**
   * The tags for the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The transit gateway CIDR blocks.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-transitgatewaycidrblocks
   */
  readonly transitGatewayCidrBlocks?: Array<string>;

  /**
   * Enable or disable Equal Cost Multipath Protocol support.
   *
   * Enabled by default.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-vpnecmpsupport
   */
  readonly vpnEcmpSupport?: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amazonSideAsn", cdk.validateNumber)(properties.amazonSideAsn));
  errors.collect(cdk.propertyValidator("associationDefaultRouteTableId", cdk.validateString)(properties.associationDefaultRouteTableId));
  errors.collect(cdk.propertyValidator("autoAcceptSharedAttachments", cdk.validateString)(properties.autoAcceptSharedAttachments));
  errors.collect(cdk.propertyValidator("defaultRouteTableAssociation", cdk.validateString)(properties.defaultRouteTableAssociation));
  errors.collect(cdk.propertyValidator("defaultRouteTablePropagation", cdk.validateString)(properties.defaultRouteTablePropagation));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("dnsSupport", cdk.validateString)(properties.dnsSupport));
  errors.collect(cdk.propertyValidator("multicastSupport", cdk.validateString)(properties.multicastSupport));
  errors.collect(cdk.propertyValidator("propagationDefaultRouteTableId", cdk.validateString)(properties.propagationDefaultRouteTableId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnTransitGatewayTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayCidrBlocks", cdk.listValidator(cdk.validateString))(properties.transitGatewayCidrBlocks));
  errors.collect(cdk.propertyValidator("vpnEcmpSupport", cdk.validateString)(properties.vpnEcmpSupport));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayTagPropertyValidator(properties).assertSuccess();
  return {
    "AmazonSideAsn": cdk.numberToCloudFormation(properties.amazonSideAsn),
    "AssociationDefaultRouteTableId": cdk.stringToCloudFormation(properties.associationDefaultRouteTableId),
    "AutoAcceptSharedAttachments": cdk.stringToCloudFormation(properties.autoAcceptSharedAttachments),
    "DefaultRouteTableAssociation": cdk.stringToCloudFormation(properties.defaultRouteTableAssociation),
    "DefaultRouteTablePropagation": cdk.stringToCloudFormation(properties.defaultRouteTablePropagation),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DnsSupport": cdk.stringToCloudFormation(properties.dnsSupport),
    "MulticastSupport": cdk.stringToCloudFormation(properties.multicastSupport),
    "PropagationDefaultRouteTableId": cdk.stringToCloudFormation(properties.propagationDefaultRouteTableId),
    "Tags": cdk.listMapper(convertCfnTransitGatewayTagPropertyToCloudFormation)(properties.tags),
    "TransitGatewayCidrBlocks": cdk.listMapper(cdk.stringToCloudFormation)(properties.transitGatewayCidrBlocks),
    "VpnEcmpSupport": cdk.stringToCloudFormation(properties.vpnEcmpSupport)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGateway.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGateway.TagProperty>();
  ret.addPropertyResult("amazonSideAsn", "AmazonSideAsn", (properties.AmazonSideAsn != null ? cfn_parse.FromCloudFormation.getNumber(properties.AmazonSideAsn) : undefined));
  ret.addPropertyResult("associationDefaultRouteTableId", "AssociationDefaultRouteTableId", (properties.AssociationDefaultRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.AssociationDefaultRouteTableId) : undefined));
  ret.addPropertyResult("autoAcceptSharedAttachments", "AutoAcceptSharedAttachments", (properties.AutoAcceptSharedAttachments != null ? cfn_parse.FromCloudFormation.getString(properties.AutoAcceptSharedAttachments) : undefined));
  ret.addPropertyResult("defaultRouteTableAssociation", "DefaultRouteTableAssociation", (properties.DefaultRouteTableAssociation != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultRouteTableAssociation) : undefined));
  ret.addPropertyResult("defaultRouteTablePropagation", "DefaultRouteTablePropagation", (properties.DefaultRouteTablePropagation != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultRouteTablePropagation) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("dnsSupport", "DnsSupport", (properties.DnsSupport != null ? cfn_parse.FromCloudFormation.getString(properties.DnsSupport) : undefined));
  ret.addPropertyResult("multicastSupport", "MulticastSupport", (properties.MulticastSupport != null ? cfn_parse.FromCloudFormation.getString(properties.MulticastSupport) : undefined));
  ret.addPropertyResult("propagationDefaultRouteTableId", "PropagationDefaultRouteTableId", (properties.PropagationDefaultRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.PropagationDefaultRouteTableId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnTransitGatewayTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayCidrBlocks", "TransitGatewayCidrBlocks", (properties.TransitGatewayCidrBlocks != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.TransitGatewayCidrBlocks) : undefined));
  ret.addPropertyResult("vpnEcmpSupport", "VpnEcmpSupport", (properties.VpnEcmpSupport != null ? cfn_parse.FromCloudFormation.getString(properties.VpnEcmpSupport) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amazonSideAsn", cdk.validateNumber)(properties.amazonSideAsn));
  errors.collect(cdk.propertyValidator("associationDefaultRouteTableId", cdk.validateString)(properties.associationDefaultRouteTableId));
  errors.collect(cdk.propertyValidator("autoAcceptSharedAttachments", cdk.validateString)(properties.autoAcceptSharedAttachments));
  errors.collect(cdk.propertyValidator("defaultRouteTableAssociation", cdk.validateString)(properties.defaultRouteTableAssociation));
  errors.collect(cdk.propertyValidator("defaultRouteTablePropagation", cdk.validateString)(properties.defaultRouteTablePropagation));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("dnsSupport", cdk.validateString)(properties.dnsSupport));
  errors.collect(cdk.propertyValidator("multicastSupport", cdk.validateString)(properties.multicastSupport));
  errors.collect(cdk.propertyValidator("propagationDefaultRouteTableId", cdk.validateString)(properties.propagationDefaultRouteTableId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayCidrBlocks", cdk.listValidator(cdk.validateString))(properties.transitGatewayCidrBlocks));
  errors.collect(cdk.propertyValidator("vpnEcmpSupport", cdk.validateString)(properties.vpnEcmpSupport));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayPropsValidator(properties).assertSuccess();
  return {
    "AmazonSideAsn": cdk.numberToCloudFormation(properties.amazonSideAsn),
    "AssociationDefaultRouteTableId": cdk.stringToCloudFormation(properties.associationDefaultRouteTableId),
    "AutoAcceptSharedAttachments": cdk.stringToCloudFormation(properties.autoAcceptSharedAttachments),
    "DefaultRouteTableAssociation": cdk.stringToCloudFormation(properties.defaultRouteTableAssociation),
    "DefaultRouteTablePropagation": cdk.stringToCloudFormation(properties.defaultRouteTablePropagation),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DnsSupport": cdk.stringToCloudFormation(properties.dnsSupport),
    "MulticastSupport": cdk.stringToCloudFormation(properties.multicastSupport),
    "PropagationDefaultRouteTableId": cdk.stringToCloudFormation(properties.propagationDefaultRouteTableId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayCidrBlocks": cdk.listMapper(cdk.stringToCloudFormation)(properties.transitGatewayCidrBlocks),
    "VpnEcmpSupport": cdk.stringToCloudFormation(properties.vpnEcmpSupport)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayProps>();
  ret.addPropertyResult("amazonSideAsn", "AmazonSideAsn", (properties.AmazonSideAsn != null ? cfn_parse.FromCloudFormation.getNumber(properties.AmazonSideAsn) : undefined));
  ret.addPropertyResult("associationDefaultRouteTableId", "AssociationDefaultRouteTableId", (properties.AssociationDefaultRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.AssociationDefaultRouteTableId) : undefined));
  ret.addPropertyResult("autoAcceptSharedAttachments", "AutoAcceptSharedAttachments", (properties.AutoAcceptSharedAttachments != null ? cfn_parse.FromCloudFormation.getString(properties.AutoAcceptSharedAttachments) : undefined));
  ret.addPropertyResult("defaultRouteTableAssociation", "DefaultRouteTableAssociation", (properties.DefaultRouteTableAssociation != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultRouteTableAssociation) : undefined));
  ret.addPropertyResult("defaultRouteTablePropagation", "DefaultRouteTablePropagation", (properties.DefaultRouteTablePropagation != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultRouteTablePropagation) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("dnsSupport", "DnsSupport", (properties.DnsSupport != null ? cfn_parse.FromCloudFormation.getString(properties.DnsSupport) : undefined));
  ret.addPropertyResult("multicastSupport", "MulticastSupport", (properties.MulticastSupport != null ? cfn_parse.FromCloudFormation.getString(properties.MulticastSupport) : undefined));
  ret.addPropertyResult("propagationDefaultRouteTableId", "PropagationDefaultRouteTableId", (properties.PropagationDefaultRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.PropagationDefaultRouteTableId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayCidrBlocks", "TransitGatewayCidrBlocks", (properties.TransitGatewayCidrBlocks != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.TransitGatewayCidrBlocks) : undefined));
  ret.addPropertyResult("vpnEcmpSupport", "VpnEcmpSupport", (properties.VpnEcmpSupport != null ? cfn_parse.FromCloudFormation.getString(properties.VpnEcmpSupport) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Attaches a VPC to a transit gateway.
 *
 * If you attach a VPC with a CIDR range that overlaps the CIDR range of a VPC that is already attached, the new VPC CIDR range is not propagated to the default propagation route table.
 *
 * To send VPC traffic to an attached transit gateway, add a route to the VPC route table using [AWS::EC2::Route](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html) .
 *
 * To update tags for a VPC attachment after creation without replacing the attachment, use [AWS::EC2::TransitGatewayVpcAttachment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html) instead.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html
 */
export class CfnTransitGatewayAttachment extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayAttachment";

  /**
   * Build a CfnTransitGatewayAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the attachment.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The VPC attachment options, in JSON or YAML.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-options
   */
  public options?: any | cdk.IResolvable;

  /**
   * The IDs of one or more subnets.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-subnetids
   */
  public subnetIds: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-transitgatewayid
   */
  public transitGatewayId: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-vpcid
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayAttachmentProps) {
    super(scope, id, {
      "type": CfnTransitGatewayAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetIds", this);
    cdk.requireProperty(props, "transitGatewayId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.options = props.options;
    this.subnetIds = props.subnetIds;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayAttachment", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "options": this.options,
      "subnetIds": this.subnetIds,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayAttachmentPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayAttachment {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-tag.html
   */
  export interface TagProperty {
    /**
     * The VPC attachment options, in JSON or YAML.
     *
     * - \`ApplianceModeSupport\` - Set to \`enable\` or \`disable\` . The default is \`disable\` .
     * - \`DnsSupport\` - Set to \`enable\` or \`disable\` . The default is \`enable\` .
     * - \`Ipv6Support\` - Set to \`enable\` or \`disable\` . The default is \`disable\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-tag.html#cfn-ec2-transitgatewayattachment-tag-options
     */
    readonly options?: any | cdk.IResolvable;

    /**
     * The IDs of one or more subnets.
     *
     * You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-tag.html#cfn-ec2-transitgatewayattachment-tag-subnetids
     */
    readonly subnetIds: Array<string>;

    /**
     * The tags for the attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-tag.html#cfn-ec2-transitgatewayattachment-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnTransitGatewayAttachment.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-tag.html#cfn-ec2-transitgatewayattachment-tag-transitgatewayid
     */
    readonly transitGatewayId: string;

    /**
     * The ID of the VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-tag.html#cfn-ec2-transitgatewayattachment-tag-vpcid
     */
    readonly vpcId: string;
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayAttachment\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html
 */
export interface CfnTransitGatewayAttachmentProps {
  /**
   * The VPC attachment options, in JSON or YAML.
   *
   * - \`ApplianceModeSupport\` - Set to \`enable\` or \`disable\` . The default is \`disable\` .
   * - \`DnsSupport\` - Set to \`enable\` or \`disable\` . The default is \`enable\` .
   * - \`Ipv6Support\` - Set to \`enable\` or \`disable\` . The default is \`disable\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-options
   */
  readonly options?: any | cdk.IResolvable;

  /**
   * The IDs of one or more subnets.
   *
   * You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-subnetids
   */
  readonly subnetIds: Array<string>;

  /**
   * The tags for the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-transitgatewayid
   */
  readonly transitGatewayId: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayAttachmentTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.validateObject)(properties.options));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.requiredValidator)(properties.subnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnTransitGatewayAttachmentTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayAttachmentTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayAttachmentTagPropertyValidator(properties).assertSuccess();
  return {
    "Options": cdk.objectToCloudFormation(properties.options),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds),
    "Tags": cdk.listMapper(convertCfnTransitGatewayAttachmentTagPropertyToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayAttachmentTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayAttachment.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayAttachment.TagProperty>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? cfn_parse.FromCloudFormation.getAny(properties.Options) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnTransitGatewayAttachmentTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayAttachmentProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayAttachmentProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.validateObject)(properties.options));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.requiredValidator)(properties.subnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayAttachmentProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayAttachmentPropsValidator(properties).assertSuccess();
  return {
    "Options": cdk.objectToCloudFormation(properties.options),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayAttachmentProps>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? cfn_parse.FromCloudFormation.getAny(properties.Options) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a Connect attachment from a specified transit gateway attachment.
 *
 * A Connect attachment is a GRE-based tunnel attachment that you can use to establish a connection between a transit gateway and an appliance.
 *
 * A Connect attachment uses an existing VPC or AWS Direct Connect attachment as the underlying transport mechanism.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html
 */
export class CfnTransitGatewayConnect extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayConnect";

  /**
   * Build a CfnTransitGatewayConnect from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayConnect {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayConnectPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayConnect(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The state of the attachment.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @cloudformationAttribute TransitGatewayAttachmentId
   */
  public readonly attrTransitGatewayAttachmentId: string;

  /**
   * The ID of the transit gateway.
   *
   * @cloudformationAttribute TransitGatewayId
   */
  public readonly attrTransitGatewayId: string;

  /**
   * The Connect attachment options.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-options
   */
  public options: cdk.IResolvable | CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the attachment from which the Connect attachment was created.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-transporttransitgatewayattachmentid
   */
  public transportTransitGatewayAttachmentId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayConnectProps) {
    super(scope, id, {
      "type": CfnTransitGatewayConnect.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "options", this);
    cdk.requireProperty(props, "transportTransitGatewayAttachmentId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayAttachmentId = cdk.Token.asString(this.getAtt("TransitGatewayAttachmentId", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayId = cdk.Token.asString(this.getAtt("TransitGatewayId", cdk.ResolutionTypeHint.STRING));
    this.options = props.options;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayConnect", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transportTransitGatewayAttachmentId = props.transportTransitGatewayAttachmentId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "options": this.options,
      "tags": this.tags.renderTags(),
      "transportTransitGatewayAttachmentId": this.transportTransitGatewayAttachmentId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayConnect.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayConnectPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayConnect {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-tag.html
   */
  export interface TagProperty {
    /**
     * The Connect attachment options.
     *
     * - protocol (gre)
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-tag.html#cfn-ec2-transitgatewayconnect-tag-options
     */
    readonly options: cdk.IResolvable | CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty;

    /**
     * The tags for the attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-tag.html#cfn-ec2-transitgatewayconnect-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnTransitGatewayConnect.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the attachment from which the Connect attachment was created.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-tag.html#cfn-ec2-transitgatewayconnect-tag-transporttransitgatewayattachmentid
     */
    readonly transportTransitGatewayAttachmentId: string;
  }

  /**
   * Describes the Connect attachment options.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html
   */
  export interface TransitGatewayConnectOptionsProperty {
    /**
     * The Connect attachment options.
     *
     * - protocol (gre)
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html#cfn-ec2-transitgatewayconnect-transitgatewayconnectoptions-options
     */
    readonly options: cdk.IResolvable | CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty;

    /**
     * The tags for the attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html#cfn-ec2-transitgatewayconnect-transitgatewayconnectoptions-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnTransitGatewayConnect.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the attachment from which the Connect attachment was created.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html#cfn-ec2-transitgatewayconnect-transitgatewayconnectoptions-transporttransitgatewayattachmentid
     */
    readonly transportTransitGatewayAttachmentId: string;
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayConnect\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html
 */
export interface CfnTransitGatewayConnectProps {
  /**
   * The Connect attachment options.
   *
   * - protocol (gre)
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-options
   */
  readonly options: cdk.IResolvable | CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty;

  /**
   * The tags for the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the attachment from which the Connect attachment was created.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-transporttransitgatewayattachmentid
   */
  readonly transportTransitGatewayAttachmentId: string;
}

/**
 * Determine whether the given properties match those of a \`TransitGatewayConnectOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`TransitGatewayConnectOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.requiredValidator)(properties.options));
  errors.collect(cdk.propertyValidator("options", CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyValidator)(properties.options));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnTransitGatewayConnectTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("transportTransitGatewayAttachmentId", cdk.requiredValidator)(properties.transportTransitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transportTransitGatewayAttachmentId", cdk.validateString)(properties.transportTransitGatewayAttachmentId));
  return errors.wrap("supplied properties not correct for \\"TransitGatewayConnectOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Options": convertCfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyToCloudFormation(properties.options),
    "Tags": cdk.listMapper(convertCfnTransitGatewayConnectTagPropertyToCloudFormation)(properties.tags),
    "TransportTransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transportTransitGatewayAttachmentId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyFromCloudFormation(properties.Options) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnTransitGatewayConnectTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("transportTransitGatewayAttachmentId", "TransportTransitGatewayAttachmentId", (properties.TransportTransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransportTransitGatewayAttachmentId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayConnectTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.requiredValidator)(properties.options));
  errors.collect(cdk.propertyValidator("options", CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyValidator)(properties.options));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnTransitGatewayConnectTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("transportTransitGatewayAttachmentId", cdk.requiredValidator)(properties.transportTransitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transportTransitGatewayAttachmentId", cdk.validateString)(properties.transportTransitGatewayAttachmentId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayConnectTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayConnectTagPropertyValidator(properties).assertSuccess();
  return {
    "Options": convertCfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyToCloudFormation(properties.options),
    "Tags": cdk.listMapper(convertCfnTransitGatewayConnectTagPropertyToCloudFormation)(properties.tags),
    "TransportTransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transportTransitGatewayAttachmentId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayConnectTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayConnect.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayConnect.TagProperty>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyFromCloudFormation(properties.Options) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnTransitGatewayConnectTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("transportTransitGatewayAttachmentId", "TransportTransitGatewayAttachmentId", (properties.TransportTransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransportTransitGatewayAttachmentId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayConnectProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayConnectProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayConnectPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.requiredValidator)(properties.options));
  errors.collect(cdk.propertyValidator("options", CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyValidator)(properties.options));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transportTransitGatewayAttachmentId", cdk.requiredValidator)(properties.transportTransitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transportTransitGatewayAttachmentId", cdk.validateString)(properties.transportTransitGatewayAttachmentId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayConnectProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayConnectPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayConnectPropsValidator(properties).assertSuccess();
  return {
    "Options": convertCfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyToCloudFormation(properties.options),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransportTransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transportTransitGatewayAttachmentId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayConnectPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayConnectProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayConnectProps>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? CfnTransitGatewayConnectTransitGatewayConnectOptionsPropertyFromCloudFormation(properties.Options) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transportTransitGatewayAttachmentId", "TransportTransitGatewayAttachmentId", (properties.TransportTransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransportTransitGatewayAttachmentId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a multicast domain using the specified transit gateway.
 *
 * The transit gateway must be in the available state before you create a domain.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html
 */
export class CfnTransitGatewayMulticastDomain extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayMulticastDomain";

  /**
   * Build a CfnTransitGatewayMulticastDomain from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayMulticastDomain {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayMulticastDomainPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayMulticastDomain(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The time the multicast domain was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The state of the multicast domain.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The Amazon Resource Name (ARN) of the multicast domain.
   *
   * @cloudformationAttribute TransitGatewayMulticastDomainArn
   */
  public readonly attrTransitGatewayMulticastDomainArn: string;

  /**
   * The ID of the multicast domain.
   *
   * @cloudformationAttribute TransitGatewayMulticastDomainId
   */
  public readonly attrTransitGatewayMulticastDomainId: string;

  /**
   * The options for the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-options
   */
  public options?: any | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-transitgatewayid
   */
  public transitGatewayId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayMulticastDomainProps) {
    super(scope, id, {
      "type": CfnTransitGatewayMulticastDomain.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayMulticastDomainArn = cdk.Token.asString(this.getAtt("TransitGatewayMulticastDomainArn", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayMulticastDomainId = cdk.Token.asString(this.getAtt("TransitGatewayMulticastDomainId", cdk.ResolutionTypeHint.STRING));
    this.options = props.options;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayMulticastDomain", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "options": this.options,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayMulticastDomain.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayMulticastDomainPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayMulticastDomain {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-tag.html
   */
  export interface TagProperty {
    /**
     * The options for the transit gateway multicast domain.
     *
     * - AutoAcceptSharedAssociations (enable | disable)
     * - Igmpv2Support (enable | disable)
     * - StaticSourcesSupport (enable | disable)
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-tag.html#cfn-ec2-transitgatewaymulticastdomain-tag-options
     */
    readonly options?: any | cdk.IResolvable;

    /**
     * The tags for the transit gateway multicast domain.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-tag.html#cfn-ec2-transitgatewaymulticastdomain-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnTransitGatewayMulticastDomain.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-tag.html#cfn-ec2-transitgatewaymulticastdomain-tag-transitgatewayid
     */
    readonly transitGatewayId: string;
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayMulticastDomain\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html
 */
export interface CfnTransitGatewayMulticastDomainProps {
  /**
   * The options for the transit gateway multicast domain.
   *
   * - AutoAcceptSharedAssociations (enable | disable)
   * - Igmpv2Support (enable | disable)
   * - StaticSourcesSupport (enable | disable)
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-options
   */
  readonly options?: any | cdk.IResolvable;

  /**
   * The tags for the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-transitgatewayid
   */
  readonly transitGatewayId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.validateObject)(properties.options));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnTransitGatewayMulticastDomainTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastDomainTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastDomainTagPropertyValidator(properties).assertSuccess();
  return {
    "Options": cdk.objectToCloudFormation(properties.options),
    "Tags": cdk.listMapper(convertCfnTransitGatewayMulticastDomainTagPropertyToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayMulticastDomain.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastDomain.TagProperty>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? cfn_parse.FromCloudFormation.getAny(properties.Options) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnTransitGatewayMulticastDomainTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayMulticastDomainProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayMulticastDomainProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("options", cdk.validateObject)(properties.options));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayMulticastDomainProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastDomainPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastDomainPropsValidator(properties).assertSuccess();
  return {
    "Options": cdk.objectToCloudFormation(properties.options),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayMulticastDomainProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastDomainProps>();
  ret.addPropertyResult("options", "Options", (properties.Options != null ? cfn_parse.FromCloudFormation.getAny(properties.Options) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates the specified subnets and transit gateway attachments with the specified transit gateway multicast domain.
 *
 * The transit gateway attachment must be in the available state before you can add a resource.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html
 */
export class CfnTransitGatewayMulticastDomainAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayMulticastDomainAssociation";

  /**
   * Build a CfnTransitGatewayMulticastDomainAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayMulticastDomainAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayMulticastDomainAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayMulticastDomainAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the resource.
   *
   * @cloudformationAttribute ResourceId
   */
  public readonly attrResourceId: string;

  /**
   * The type of resource, for example a VPC attachment.
   *
   * @cloudformationAttribute ResourceType
   */
  public readonly attrResourceType: string;

  /**
   * The state of the resource.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The IDs of the subnets to associate with the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-subnetid
   */
  public subnetId: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewayattachmentid
   */
  public transitGatewayAttachmentId: string;

  /**
   * The ID of the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewaymulticastdomainid
   */
  public transitGatewayMulticastDomainId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayMulticastDomainAssociationProps) {
    super(scope, id, {
      "type": CfnTransitGatewayMulticastDomainAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetId", this);
    cdk.requireProperty(props, "transitGatewayAttachmentId", this);
    cdk.requireProperty(props, "transitGatewayMulticastDomainId", this);

    this.attrResourceId = cdk.Token.asString(this.getAtt("ResourceId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceType = cdk.Token.asString(this.getAtt("ResourceType", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.subnetId = props.subnetId;
    this.transitGatewayAttachmentId = props.transitGatewayAttachmentId;
    this.transitGatewayMulticastDomainId = props.transitGatewayMulticastDomainId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "subnetId": this.subnetId,
      "transitGatewayAttachmentId": this.transitGatewayAttachmentId,
      "transitGatewayMulticastDomainId": this.transitGatewayMulticastDomainId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayMulticastDomainAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayMulticastDomainAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayMulticastDomainAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html
 */
export interface CfnTransitGatewayMulticastDomainAssociationProps {
  /**
   * The IDs of the subnets to associate with the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-subnetid
   */
  readonly subnetId: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewayattachmentid
   */
  readonly transitGatewayAttachmentId: string;

  /**
   * The ID of the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewaymulticastdomainid
   */
  readonly transitGatewayMulticastDomainId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayMulticastDomainAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayMulticastDomainAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("subnetId", cdk.requiredValidator)(properties.subnetId));
  errors.collect(cdk.propertyValidator("subnetId", cdk.validateString)(properties.subnetId));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.requiredValidator)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.validateString)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.requiredValidator)(properties.transitGatewayMulticastDomainId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.validateString)(properties.transitGatewayMulticastDomainId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayMulticastDomainAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastDomainAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastDomainAssociationPropsValidator(properties).assertSuccess();
  return {
    "SubnetId": cdk.stringToCloudFormation(properties.subnetId),
    "TransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transitGatewayAttachmentId),
    "TransitGatewayMulticastDomainId": cdk.stringToCloudFormation(properties.transitGatewayMulticastDomainId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastDomainAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayMulticastDomainAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastDomainAssociationProps>();
  ret.addPropertyResult("subnetId", "SubnetId", (properties.SubnetId != null ? cfn_parse.FromCloudFormation.getString(properties.SubnetId) : undefined));
  ret.addPropertyResult("transitGatewayAttachmentId", "TransitGatewayAttachmentId", (properties.TransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayAttachmentId) : undefined));
  ret.addPropertyResult("transitGatewayMulticastDomainId", "TransitGatewayMulticastDomainId", (properties.TransitGatewayMulticastDomainId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayMulticastDomainId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Registers members (network interfaces) with the transit gateway multicast group.
 *
 * A member is a network interface associated with a supported EC2 instance that receives multicast traffic. For information about supported instances, see [Multicast Consideration](https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-limits.html#multicast-limits) in *Amazon VPC Transit Gateways* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html
 */
export class CfnTransitGatewayMulticastGroupMember extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayMulticastGroupMember";

  /**
   * Build a CfnTransitGatewayMulticastGroupMember from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayMulticastGroupMember {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayMulticastGroupMemberPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayMulticastGroupMember(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Information about the registered transit gateway multicast domain group members.
   *
   * @cloudformationAttribute GroupMember
   */
  public readonly attrGroupMember: cdk.IResolvable;

  /**
   * Indicates that the resource is a transit gateway multicast domain group member.
   *
   * @cloudformationAttribute GroupSource
   */
  public readonly attrGroupSource: cdk.IResolvable;

  /**
   * The type of group member, for example static.
   *
   * @cloudformationAttribute MemberType
   */
  public readonly attrMemberType: string;

  /**
   * The ID of the resource.
   *
   * @cloudformationAttribute ResourceId
   */
  public readonly attrResourceId: string;

  /**
   * The type of resource, for example a VPC attachment.
   *
   * @cloudformationAttribute ResourceType
   */
  public readonly attrResourceType: string;

  /**
   * The type of source.
   *
   * @cloudformationAttribute SourceType
   */
  public readonly attrSourceType: string;

  /**
   * The ID of the subnet.
   *
   * @cloudformationAttribute SubnetId
   */
  public readonly attrSubnetId: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @cloudformationAttribute TransitGatewayAttachmentId
   */
  public readonly attrTransitGatewayAttachmentId: string;

  /**
   * The IP address assigned to the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-groupipaddress
   */
  public groupIpAddress: string;

  /**
   * The group members' network interface IDs to register with the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-networkinterfaceid
   */
  public networkInterfaceId: string;

  /**
   * The ID of the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-transitgatewaymulticastdomainid
   */
  public transitGatewayMulticastDomainId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayMulticastGroupMemberProps) {
    super(scope, id, {
      "type": CfnTransitGatewayMulticastGroupMember.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "groupIpAddress", this);
    cdk.requireProperty(props, "networkInterfaceId", this);
    cdk.requireProperty(props, "transitGatewayMulticastDomainId", this);

    this.attrGroupMember = this.getAtt("GroupMember");
    this.attrGroupSource = this.getAtt("GroupSource");
    this.attrMemberType = cdk.Token.asString(this.getAtt("MemberType", cdk.ResolutionTypeHint.STRING));
    this.attrResourceId = cdk.Token.asString(this.getAtt("ResourceId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceType = cdk.Token.asString(this.getAtt("ResourceType", cdk.ResolutionTypeHint.STRING));
    this.attrSourceType = cdk.Token.asString(this.getAtt("SourceType", cdk.ResolutionTypeHint.STRING));
    this.attrSubnetId = cdk.Token.asString(this.getAtt("SubnetId", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayAttachmentId = cdk.Token.asString(this.getAtt("TransitGatewayAttachmentId", cdk.ResolutionTypeHint.STRING));
    this.groupIpAddress = props.groupIpAddress;
    this.networkInterfaceId = props.networkInterfaceId;
    this.transitGatewayMulticastDomainId = props.transitGatewayMulticastDomainId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "groupIpAddress": this.groupIpAddress,
      "networkInterfaceId": this.networkInterfaceId,
      "transitGatewayMulticastDomainId": this.transitGatewayMulticastDomainId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayMulticastGroupMember.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayMulticastGroupMemberPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayMulticastGroupMember\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html
 */
export interface CfnTransitGatewayMulticastGroupMemberProps {
  /**
   * The IP address assigned to the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-groupipaddress
   */
  readonly groupIpAddress: string;

  /**
   * The group members' network interface IDs to register with the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-networkinterfaceid
   */
  readonly networkInterfaceId: string;

  /**
   * The ID of the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-transitgatewaymulticastdomainid
   */
  readonly transitGatewayMulticastDomainId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayMulticastGroupMemberProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayMulticastGroupMemberProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastGroupMemberPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupIpAddress", cdk.requiredValidator)(properties.groupIpAddress));
  errors.collect(cdk.propertyValidator("groupIpAddress", cdk.validateString)(properties.groupIpAddress));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.requiredValidator)(properties.transitGatewayMulticastDomainId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.validateString)(properties.transitGatewayMulticastDomainId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayMulticastGroupMemberProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastGroupMemberPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastGroupMemberPropsValidator(properties).assertSuccess();
  return {
    "GroupIpAddress": cdk.stringToCloudFormation(properties.groupIpAddress),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "TransitGatewayMulticastDomainId": cdk.stringToCloudFormation(properties.transitGatewayMulticastDomainId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastGroupMemberPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayMulticastGroupMemberProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastGroupMemberProps>();
  ret.addPropertyResult("groupIpAddress", "GroupIpAddress", (properties.GroupIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.GroupIpAddress) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("transitGatewayMulticastDomainId", "TransitGatewayMulticastDomainId", (properties.TransitGatewayMulticastDomainId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayMulticastDomainId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Registers sources (network interfaces) with the specified transit gateway multicast domain.
 *
 * A multicast source is a network interface attached to a supported instance that sends multicast traffic. For information about supported instances, see [Multicast Considerations](https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-limits.html#multicast-limits) in *Amazon VPC Transit Gateways* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html
 */
export class CfnTransitGatewayMulticastGroupSource extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayMulticastGroupSource";

  /**
   * Build a CfnTransitGatewayMulticastGroupSource from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayMulticastGroupSource {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayMulticastGroupSourcePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayMulticastGroupSource(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Information about the registered transit gateway multicast domain group members.
   *
   * @cloudformationAttribute GroupMember
   */
  public readonly attrGroupMember: cdk.IResolvable;

  /**
   * Indicates that the resource is a transit gateway group member.
   *
   * @cloudformationAttribute GroupSource
   */
  public readonly attrGroupSource: cdk.IResolvable;

  /**
   * The type of group member, for example static.
   *
   * @cloudformationAttribute MemberType
   */
  public readonly attrMemberType: string;

  /**
   * The ID of the resource.
   *
   * @cloudformationAttribute ResourceId
   */
  public readonly attrResourceId: string;

  /**
   * The type of resource, for example a VPC attachment.
   *
   * @cloudformationAttribute ResourceType
   */
  public readonly attrResourceType: string;

  /**
   * The type of source.
   *
   * @cloudformationAttribute SourceType
   */
  public readonly attrSourceType: string;

  /**
   * The ID of the subnet.
   *
   * @cloudformationAttribute SubnetId
   */
  public readonly attrSubnetId: string;

  /**
   * The ID of the transit gateway attachment.
   *
   * @cloudformationAttribute TransitGatewayAttachmentId
   */
  public readonly attrTransitGatewayAttachmentId: string;

  /**
   * The IP address assigned to the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-groupipaddress
   */
  public groupIpAddress: string;

  /**
   * The group sources' network interface IDs to register with the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-networkinterfaceid
   */
  public networkInterfaceId: string;

  /**
   * The ID of the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-transitgatewaymulticastdomainid
   */
  public transitGatewayMulticastDomainId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayMulticastGroupSourceProps) {
    super(scope, id, {
      "type": CfnTransitGatewayMulticastGroupSource.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "groupIpAddress", this);
    cdk.requireProperty(props, "networkInterfaceId", this);
    cdk.requireProperty(props, "transitGatewayMulticastDomainId", this);

    this.attrGroupMember = this.getAtt("GroupMember");
    this.attrGroupSource = this.getAtt("GroupSource");
    this.attrMemberType = cdk.Token.asString(this.getAtt("MemberType", cdk.ResolutionTypeHint.STRING));
    this.attrResourceId = cdk.Token.asString(this.getAtt("ResourceId", cdk.ResolutionTypeHint.STRING));
    this.attrResourceType = cdk.Token.asString(this.getAtt("ResourceType", cdk.ResolutionTypeHint.STRING));
    this.attrSourceType = cdk.Token.asString(this.getAtt("SourceType", cdk.ResolutionTypeHint.STRING));
    this.attrSubnetId = cdk.Token.asString(this.getAtt("SubnetId", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayAttachmentId = cdk.Token.asString(this.getAtt("TransitGatewayAttachmentId", cdk.ResolutionTypeHint.STRING));
    this.groupIpAddress = props.groupIpAddress;
    this.networkInterfaceId = props.networkInterfaceId;
    this.transitGatewayMulticastDomainId = props.transitGatewayMulticastDomainId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "groupIpAddress": this.groupIpAddress,
      "networkInterfaceId": this.networkInterfaceId,
      "transitGatewayMulticastDomainId": this.transitGatewayMulticastDomainId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayMulticastGroupSource.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayMulticastGroupSourcePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayMulticastGroupSource\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html
 */
export interface CfnTransitGatewayMulticastGroupSourceProps {
  /**
   * The IP address assigned to the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-groupipaddress
   */
  readonly groupIpAddress: string;

  /**
   * The group sources' network interface IDs to register with the transit gateway multicast group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-networkinterfaceid
   */
  readonly networkInterfaceId: string;

  /**
   * The ID of the transit gateway multicast domain.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-transitgatewaymulticastdomainid
   */
  readonly transitGatewayMulticastDomainId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayMulticastGroupSourceProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayMulticastGroupSourceProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayMulticastGroupSourcePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("groupIpAddress", cdk.requiredValidator)(properties.groupIpAddress));
  errors.collect(cdk.propertyValidator("groupIpAddress", cdk.validateString)(properties.groupIpAddress));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.requiredValidator)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("networkInterfaceId", cdk.validateString)(properties.networkInterfaceId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.requiredValidator)(properties.transitGatewayMulticastDomainId));
  errors.collect(cdk.propertyValidator("transitGatewayMulticastDomainId", cdk.validateString)(properties.transitGatewayMulticastDomainId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayMulticastGroupSourceProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayMulticastGroupSourcePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayMulticastGroupSourcePropsValidator(properties).assertSuccess();
  return {
    "GroupIpAddress": cdk.stringToCloudFormation(properties.groupIpAddress),
    "NetworkInterfaceId": cdk.stringToCloudFormation(properties.networkInterfaceId),
    "TransitGatewayMulticastDomainId": cdk.stringToCloudFormation(properties.transitGatewayMulticastDomainId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayMulticastGroupSourcePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayMulticastGroupSourceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayMulticastGroupSourceProps>();
  ret.addPropertyResult("groupIpAddress", "GroupIpAddress", (properties.GroupIpAddress != null ? cfn_parse.FromCloudFormation.getString(properties.GroupIpAddress) : undefined));
  ret.addPropertyResult("networkInterfaceId", "NetworkInterfaceId", (properties.NetworkInterfaceId != null ? cfn_parse.FromCloudFormation.getString(properties.NetworkInterfaceId) : undefined));
  ret.addPropertyResult("transitGatewayMulticastDomainId", "TransitGatewayMulticastDomainId", (properties.TransitGatewayMulticastDomainId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayMulticastDomainId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Requests a transit gateway peering attachment between the specified transit gateway (requester) and a peer transit gateway (accepter).
 *
 * The peer transit gateway can be in your account or a different AWS account .
 *
 * After you create the peering attachment, the owner of the accepter transit gateway must accept the attachment request.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html
 */
export class CfnTransitGatewayPeeringAttachment extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayPeeringAttachment";

  /**
   * Build a CfnTransitGatewayPeeringAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayPeeringAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayPeeringAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayPeeringAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The time the transit gateway peering attachment was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The state of the transit gateway peering attachment. Note that the \`initiating\` state has been deprecated.
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The status of the transit gateway peering attachment.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: cdk.IResolvable;

  /**
   * The status code.
   *
   * @cloudformationAttribute Status.Code
   */
  public readonly attrStatusCode: string;

  /**
   * The status message.
   *
   * @cloudformationAttribute Status.Message
   */
  public readonly attrStatusMessage: string;

  /**
   * The ID of the transit gateway peering attachment.
   *
   * @cloudformationAttribute TransitGatewayAttachmentId
   */
  public readonly attrTransitGatewayAttachmentId: string;

  /**
   * The ID of the AWS account that owns the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid
   */
  public peerAccountId: string;

  /**
   * The Region of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion
   */
  public peerRegion: string;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peertransitgatewayid
   */
  public peerTransitGatewayId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the transit gateway peering attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway peering attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewayid
   */
  public transitGatewayId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayPeeringAttachmentProps) {
    super(scope, id, {
      "type": CfnTransitGatewayPeeringAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "peerAccountId", this);
    cdk.requireProperty(props, "peerRegion", this);
    cdk.requireProperty(props, "peerTransitGatewayId", this);
    cdk.requireProperty(props, "transitGatewayId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = this.getAtt("Status");
    this.attrStatusCode = cdk.Token.asString(this.getAtt("Status.Code", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("Status.Message", cdk.ResolutionTypeHint.STRING));
    this.attrTransitGatewayAttachmentId = cdk.Token.asString(this.getAtt("TransitGatewayAttachmentId", cdk.ResolutionTypeHint.STRING));
    this.peerAccountId = props.peerAccountId;
    this.peerRegion = props.peerRegion;
    this.peerTransitGatewayId = props.peerTransitGatewayId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayPeeringAttachment", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "peerAccountId": this.peerAccountId,
      "peerRegion": this.peerRegion,
      "peerTransitGatewayId": this.peerTransitGatewayId,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayPeeringAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayPeeringAttachmentPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayPeeringAttachment {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-tag.html
   */
  export interface TagProperty {
    /**
     * The ID of the AWS account that owns the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-tag.html#cfn-ec2-transitgatewaypeeringattachment-tag-peeraccountid
     */
    readonly peerAccountId: string;

    /**
     * The Region of the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-tag.html#cfn-ec2-transitgatewaypeeringattachment-tag-peerregion
     */
    readonly peerRegion: string;

    /**
     * The ID of the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-tag.html#cfn-ec2-transitgatewaypeeringattachment-tag-peertransitgatewayid
     */
    readonly peerTransitGatewayId: string;

    /**
     * The tags for the transit gateway peering attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-tag.html#cfn-ec2-transitgatewaypeeringattachment-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnTransitGatewayPeeringAttachment.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the transit gateway peering attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-tag.html#cfn-ec2-transitgatewaypeeringattachment-tag-transitgatewayid
     */
    readonly transitGatewayId: string;
  }

  /**
   * The status of the transit gateway peering attachment.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html
   */
  export interface PeeringAttachmentStatusProperty {
    /**
     * The ID of the AWS account that owns the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-peeraccountid
     */
    readonly peerAccountId: string;

    /**
     * The Region of the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-peerregion
     */
    readonly peerRegion: string;

    /**
     * The ID of the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-peertransitgatewayid
     */
    readonly peerTransitGatewayId: string;

    /**
     * The tags for the transit gateway peering attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnTransitGatewayPeeringAttachment.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the transit gateway peering attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-transitgatewayid
     */
    readonly transitGatewayId: string;
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayPeeringAttachment\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html
 */
export interface CfnTransitGatewayPeeringAttachmentProps {
  /**
   * The ID of the AWS account that owns the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid
   */
  readonly peerAccountId: string;

  /**
   * The Region of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion
   */
  readonly peerRegion: string;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peertransitgatewayid
   */
  readonly peerTransitGatewayId: string;

  /**
   * The tags for the transit gateway peering attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway peering attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewayid
   */
  readonly transitGatewayId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("peerAccountId", cdk.requiredValidator)(properties.peerAccountId));
  errors.collect(cdk.propertyValidator("peerAccountId", cdk.validateString)(properties.peerAccountId));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.requiredValidator)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.validateString)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerTransitGatewayId", cdk.requiredValidator)(properties.peerTransitGatewayId));
  errors.collect(cdk.propertyValidator("peerTransitGatewayId", cdk.validateString)(properties.peerTransitGatewayId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnTransitGatewayPeeringAttachmentTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayPeeringAttachmentTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayPeeringAttachmentTagPropertyValidator(properties).assertSuccess();
  return {
    "PeerAccountId": cdk.stringToCloudFormation(properties.peerAccountId),
    "PeerRegion": cdk.stringToCloudFormation(properties.peerRegion),
    "PeerTransitGatewayId": cdk.stringToCloudFormation(properties.peerTransitGatewayId),
    "Tags": cdk.listMapper(convertCfnTransitGatewayPeeringAttachmentTagPropertyToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayPeeringAttachment.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayPeeringAttachment.TagProperty>();
  ret.addPropertyResult("peerAccountId", "PeerAccountId", (properties.PeerAccountId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerAccountId) : undefined));
  ret.addPropertyResult("peerRegion", "PeerRegion", (properties.PeerRegion != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRegion) : undefined));
  ret.addPropertyResult("peerTransitGatewayId", "PeerTransitGatewayId", (properties.PeerTransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerTransitGatewayId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnTransitGatewayPeeringAttachmentTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PeeringAttachmentStatusProperty\`
 *
 * @param properties - the TypeScript properties of a \`PeeringAttachmentStatusProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentPeeringAttachmentStatusPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("peerAccountId", cdk.requiredValidator)(properties.peerAccountId));
  errors.collect(cdk.propertyValidator("peerAccountId", cdk.validateString)(properties.peerAccountId));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.requiredValidator)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.validateString)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerTransitGatewayId", cdk.requiredValidator)(properties.peerTransitGatewayId));
  errors.collect(cdk.propertyValidator("peerTransitGatewayId", cdk.validateString)(properties.peerTransitGatewayId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnTransitGatewayPeeringAttachmentTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \\"PeeringAttachmentStatusProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayPeeringAttachmentPeeringAttachmentStatusPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayPeeringAttachmentPeeringAttachmentStatusPropertyValidator(properties).assertSuccess();
  return {
    "PeerAccountId": cdk.stringToCloudFormation(properties.peerAccountId),
    "PeerRegion": cdk.stringToCloudFormation(properties.peerRegion),
    "PeerTransitGatewayId": cdk.stringToCloudFormation(properties.peerTransitGatewayId),
    "Tags": cdk.listMapper(convertCfnTransitGatewayPeeringAttachmentTagPropertyToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentPeeringAttachmentStatusPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayPeeringAttachment.PeeringAttachmentStatusProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayPeeringAttachment.PeeringAttachmentStatusProperty>();
  ret.addPropertyResult("peerAccountId", "PeerAccountId", (properties.PeerAccountId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerAccountId) : undefined));
  ret.addPropertyResult("peerRegion", "PeerRegion", (properties.PeerRegion != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRegion) : undefined));
  ret.addPropertyResult("peerTransitGatewayId", "PeerTransitGatewayId", (properties.PeerTransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerTransitGatewayId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnTransitGatewayPeeringAttachmentTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayPeeringAttachmentProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayPeeringAttachmentProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("peerAccountId", cdk.requiredValidator)(properties.peerAccountId));
  errors.collect(cdk.propertyValidator("peerAccountId", cdk.validateString)(properties.peerAccountId));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.requiredValidator)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.validateString)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerTransitGatewayId", cdk.requiredValidator)(properties.peerTransitGatewayId));
  errors.collect(cdk.propertyValidator("peerTransitGatewayId", cdk.validateString)(properties.peerTransitGatewayId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayPeeringAttachmentProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayPeeringAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayPeeringAttachmentPropsValidator(properties).assertSuccess();
  return {
    "PeerAccountId": cdk.stringToCloudFormation(properties.peerAccountId),
    "PeerRegion": cdk.stringToCloudFormation(properties.peerRegion),
    "PeerTransitGatewayId": cdk.stringToCloudFormation(properties.peerTransitGatewayId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayPeeringAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayPeeringAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayPeeringAttachmentProps>();
  ret.addPropertyResult("peerAccountId", "PeerAccountId", (properties.PeerAccountId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerAccountId) : undefined));
  ret.addPropertyResult("peerRegion", "PeerRegion", (properties.PeerRegion != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRegion) : undefined));
  ret.addPropertyResult("peerTransitGatewayId", "PeerTransitGatewayId", (properties.PeerTransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerTransitGatewayId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a static route for a transit gateway route table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html
 */
export class CfnTransitGatewayRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayRoute";

  /**
   * Build a CfnTransitGatewayRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Indicates whether to drop traffic that matches this route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-blackhole
   */
  public blackhole?: boolean | cdk.IResolvable;

  /**
   * The CIDR block used for destination matches.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-destinationcidrblock
   */
  public destinationCidrBlock?: string;

  /**
   * The ID of the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayattachmentid
   */
  public transitGatewayAttachmentId?: string;

  /**
   * The ID of the transit gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayroutetableid
   */
  public transitGatewayRouteTableId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayRouteProps) {
    super(scope, id, {
      "type": CfnTransitGatewayRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayRouteTableId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.blackhole = props.blackhole;
    this.destinationCidrBlock = props.destinationCidrBlock;
    this.transitGatewayAttachmentId = props.transitGatewayAttachmentId;
    this.transitGatewayRouteTableId = props.transitGatewayRouteTableId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "blackhole": this.blackhole,
      "destinationCidrBlock": this.destinationCidrBlock,
      "transitGatewayAttachmentId": this.transitGatewayAttachmentId,
      "transitGatewayRouteTableId": this.transitGatewayRouteTableId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayRoute\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html
 */
export interface CfnTransitGatewayRouteProps {
  /**
   * Indicates whether to drop traffic that matches this route.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-blackhole
   */
  readonly blackhole?: boolean | cdk.IResolvable;

  /**
   * The CIDR block used for destination matches.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-destinationcidrblock
   */
  readonly destinationCidrBlock?: string;

  /**
   * The ID of the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayattachmentid
   */
  readonly transitGatewayAttachmentId?: string;

  /**
   * The ID of the transit gateway route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayroutetableid
   */
  readonly transitGatewayRouteTableId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayRouteProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayRouteProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("blackhole", cdk.validateBoolean)(properties.blackhole));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.validateString)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.requiredValidator)(properties.transitGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.validateString)(properties.transitGatewayRouteTableId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayRouteProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRoutePropsValidator(properties).assertSuccess();
  return {
    "Blackhole": cdk.booleanToCloudFormation(properties.blackhole),
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "TransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transitGatewayAttachmentId),
    "TransitGatewayRouteTableId": cdk.stringToCloudFormation(properties.transitGatewayRouteTableId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteProps>();
  ret.addPropertyResult("blackhole", "Blackhole", (properties.Blackhole != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Blackhole) : undefined));
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("transitGatewayAttachmentId", "TransitGatewayAttachmentId", (properties.TransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayAttachmentId) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableId", "TransitGatewayRouteTableId", (properties.TransitGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayRouteTableId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a route table for a transit gateway.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html
 */
export class CfnTransitGatewayRouteTable extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayRouteTable";

  /**
   * Build a CfnTransitGatewayRouteTable from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayRouteTable {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayRouteTablePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayRouteTable(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-transitgatewayid
   */
  public transitGatewayId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayRouteTableProps) {
    super(scope, id, {
      "type": CfnTransitGatewayRouteTable.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayRouteTable", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayRouteTable.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayRouteTablePropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayRouteTable {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayroutetable-tag.html
   */
  export interface TagProperty {
    /**
     * Any tags assigned to the route table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayroutetable-tag.html#cfn-ec2-transitgatewayroutetable-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnTransitGatewayRouteTable.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayroutetable-tag.html#cfn-ec2-transitgatewayroutetable-tag-transitgatewayid
     */
    readonly transitGatewayId: string;
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayRouteTable\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html
 */
export interface CfnTransitGatewayRouteTableProps {
  /**
   * Any tags assigned to the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-transitgatewayid
   */
  readonly transitGatewayId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRouteTableTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnTransitGatewayRouteTableTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRouteTableTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRouteTableTagPropertyValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(convertCfnTransitGatewayRouteTableTagPropertyToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRouteTableTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayRouteTable.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteTable.TagProperty>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnTransitGatewayRouteTableTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayRouteTableProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayRouteTableProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRouteTablePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayRouteTableProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRouteTablePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRouteTablePropsValidator(properties).assertSuccess();
  return {
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRouteTablePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayRouteTableProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteTableProps>();
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates the specified attachment with the specified transit gateway route table.
 *
 * You can associate one route table with an attachment.
 *
 * Before you can update the route table associated with an attachment, you must disassociate the transit gateway route table that is currently associated with the attachment. First update the stack to remove the associated transit gateway route table, and then update the stack with the ID of the new transit gateway route table to associate.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html
 */
export class CfnTransitGatewayRouteTableAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayRouteTableAssociation";

  /**
   * Build a CfnTransitGatewayRouteTableAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayRouteTableAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayRouteTableAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayRouteTableAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayattachmentid
   */
  public transitGatewayAttachmentId: string;

  /**
   * The ID of the route table for the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayroutetableid
   */
  public transitGatewayRouteTableId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayRouteTableAssociationProps) {
    super(scope, id, {
      "type": CfnTransitGatewayRouteTableAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayAttachmentId", this);
    cdk.requireProperty(props, "transitGatewayRouteTableId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.transitGatewayAttachmentId = props.transitGatewayAttachmentId;
    this.transitGatewayRouteTableId = props.transitGatewayRouteTableId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "transitGatewayAttachmentId": this.transitGatewayAttachmentId,
      "transitGatewayRouteTableId": this.transitGatewayRouteTableId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayRouteTableAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayRouteTableAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayRouteTableAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html
 */
export interface CfnTransitGatewayRouteTableAssociationProps {
  /**
   * The ID of the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayattachmentid
   */
  readonly transitGatewayAttachmentId: string;

  /**
   * The ID of the route table for the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayroutetableid
   */
  readonly transitGatewayRouteTableId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayRouteTableAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayRouteTableAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRouteTableAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.requiredValidator)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.validateString)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.requiredValidator)(properties.transitGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.validateString)(properties.transitGatewayRouteTableId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayRouteTableAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRouteTableAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRouteTableAssociationPropsValidator(properties).assertSuccess();
  return {
    "TransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transitGatewayAttachmentId),
    "TransitGatewayRouteTableId": cdk.stringToCloudFormation(properties.transitGatewayRouteTableId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRouteTableAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayRouteTableAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteTableAssociationProps>();
  ret.addPropertyResult("transitGatewayAttachmentId", "TransitGatewayAttachmentId", (properties.TransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayAttachmentId) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableId", "TransitGatewayRouteTableId", (properties.TransitGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayRouteTableId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Enables the specified attachment to propagate routes to the specified propagation route table.
 *
 * For more information about enabling transit gateway route propagation, see [EnableTransitGatewayRouteTablePropagation](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EnableTransitGatewayRouteTablePropagation.html) in the *Amazon EC2 API Reference* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html
 */
export class CfnTransitGatewayRouteTablePropagation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayRouteTablePropagation";

  /**
   * Build a CfnTransitGatewayRouteTablePropagation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayRouteTablePropagation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayRouteTablePropagationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayRouteTablePropagation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayattachmentid
   */
  public transitGatewayAttachmentId: string;

  /**
   * The ID of the propagation route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayroutetableid
   */
  public transitGatewayRouteTableId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayRouteTablePropagationProps) {
    super(scope, id, {
      "type": CfnTransitGatewayRouteTablePropagation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "transitGatewayAttachmentId", this);
    cdk.requireProperty(props, "transitGatewayRouteTableId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.transitGatewayAttachmentId = props.transitGatewayAttachmentId;
    this.transitGatewayRouteTableId = props.transitGatewayRouteTableId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "transitGatewayAttachmentId": this.transitGatewayAttachmentId,
      "transitGatewayRouteTableId": this.transitGatewayRouteTableId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayRouteTablePropagation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayRouteTablePropagationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayRouteTablePropagation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html
 */
export interface CfnTransitGatewayRouteTablePropagationProps {
  /**
   * The ID of the attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayattachmentid
   */
  readonly transitGatewayAttachmentId: string;

  /**
   * The ID of the propagation route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayroutetableid
   */
  readonly transitGatewayRouteTableId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayRouteTablePropagationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayRouteTablePropagationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayRouteTablePropagationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.requiredValidator)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayAttachmentId", cdk.validateString)(properties.transitGatewayAttachmentId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.requiredValidator)(properties.transitGatewayRouteTableId));
  errors.collect(cdk.propertyValidator("transitGatewayRouteTableId", cdk.validateString)(properties.transitGatewayRouteTableId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayRouteTablePropagationProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayRouteTablePropagationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayRouteTablePropagationPropsValidator(properties).assertSuccess();
  return {
    "TransitGatewayAttachmentId": cdk.stringToCloudFormation(properties.transitGatewayAttachmentId),
    "TransitGatewayRouteTableId": cdk.stringToCloudFormation(properties.transitGatewayRouteTableId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayRouteTablePropagationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayRouteTablePropagationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayRouteTablePropagationProps>();
  ret.addPropertyResult("transitGatewayAttachmentId", "TransitGatewayAttachmentId", (properties.TransitGatewayAttachmentId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayAttachmentId) : undefined));
  ret.addPropertyResult("transitGatewayRouteTableId", "TransitGatewayRouteTableId", (properties.TransitGatewayRouteTableId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayRouteTableId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a VPC attachment.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html
 */
export class CfnTransitGatewayVpcAttachment extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::TransitGatewayVpcAttachment";

  /**
   * Build a CfnTransitGatewayVpcAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTransitGatewayVpcAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnTransitGatewayVpcAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnTransitGatewayVpcAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the attachment.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The IDs of one or more subnets to add.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-addsubnetids
   */
  public addSubnetIds?: Array<string>;

  /**
   * The VPC attachment options, in JSON or YAML.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-options
   */
  public options?: any | cdk.IResolvable;

  /**
   * The IDs of one or more subnets to remove.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-removesubnetids
   */
  public removeSubnetIds?: Array<string>;

  /**
   * The IDs of the subnets.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids
   */
  public subnetIds: Array<string>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the VPC attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-transitgatewayid
   */
  public transitGatewayId: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnTransitGatewayVpcAttachmentProps) {
    super(scope, id, {
      "type": CfnTransitGatewayVpcAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "subnetIds", this);
    cdk.requireProperty(props, "transitGatewayId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.addSubnetIds = props.addSubnetIds;
    this.options = props.options;
    this.removeSubnetIds = props.removeSubnetIds;
    this.subnetIds = props.subnetIds;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::TransitGatewayVpcAttachment", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "addSubnetIds": this.addSubnetIds,
      "options": this.options,
      "removeSubnetIds": this.removeSubnetIds,
      "subnetIds": this.subnetIds,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnTransitGatewayVpcAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnTransitGatewayVpcAttachmentPropsToCloudFormation(props);
  }
}

export namespace CfnTransitGatewayVpcAttachment {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-tag.html
   */
  export interface TagProperty {
    /**
     * The IDs of one or more subnets to add.
     *
     * You can specify at most one subnet per Availability Zone.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-tag.html#cfn-ec2-transitgatewayvpcattachment-tag-addsubnetids
     */
    readonly addSubnetIds?: Array<string>;

    /**
     * The VPC attachment options, in JSON or YAML.
     *
     * - \`ApplianceModeSupport\` - Set to \`enable\` or \`disable\` . The default is \`disable\` .
     * - \`DnsSupport\` - Set to \`enable\` or \`disable\` . The default is \`enable\` .
     * - \`Ipv6Support\` - Set to \`enable\` or \`disable\` . The default is \`disable\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-tag.html#cfn-ec2-transitgatewayvpcattachment-tag-options
     */
    readonly options?: any | cdk.IResolvable;

    /**
     * The IDs of one or more subnets to remove.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-tag.html#cfn-ec2-transitgatewayvpcattachment-tag-removesubnetids
     */
    readonly removeSubnetIds?: Array<string>;

    /**
     * The IDs of the subnets.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-tag.html#cfn-ec2-transitgatewayvpcattachment-tag-subnetids
     */
    readonly subnetIds: Array<string>;

    /**
     * The tags for the VPC attachment.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-tag.html#cfn-ec2-transitgatewayvpcattachment-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnTransitGatewayVpcAttachment.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the transit gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-tag.html#cfn-ec2-transitgatewayvpcattachment-tag-transitgatewayid
     */
    readonly transitGatewayId: string;

    /**
     * The ID of the VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-tag.html#cfn-ec2-transitgatewayvpcattachment-tag-vpcid
     */
    readonly vpcId: string;
  }
}

/**
 * Properties for defining a \`CfnTransitGatewayVpcAttachment\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html
 */
export interface CfnTransitGatewayVpcAttachmentProps {
  /**
   * The IDs of one or more subnets to add.
   *
   * You can specify at most one subnet per Availability Zone.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-addsubnetids
   */
  readonly addSubnetIds?: Array<string>;

  /**
   * The VPC attachment options, in JSON or YAML.
   *
   * - \`ApplianceModeSupport\` - Set to \`enable\` or \`disable\` . The default is \`disable\` .
   * - \`DnsSupport\` - Set to \`enable\` or \`disable\` . The default is \`enable\` .
   * - \`Ipv6Support\` - Set to \`enable\` or \`disable\` . The default is \`disable\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-options
   */
  readonly options?: any | cdk.IResolvable;

  /**
   * The IDs of one or more subnets to remove.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-removesubnetids
   */
  readonly removeSubnetIds?: Array<string>;

  /**
   * The IDs of the subnets.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids
   */
  readonly subnetIds: Array<string>;

  /**
   * The tags for the VPC attachment.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-transitgatewayid
   */
  readonly transitGatewayId: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayVpcAttachmentTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addSubnetIds", cdk.listValidator(cdk.validateString))(properties.addSubnetIds));
  errors.collect(cdk.propertyValidator("options", cdk.validateObject)(properties.options));
  errors.collect(cdk.propertyValidator("removeSubnetIds", cdk.listValidator(cdk.validateString))(properties.removeSubnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.requiredValidator)(properties.subnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnTransitGatewayVpcAttachmentTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayVpcAttachmentTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayVpcAttachmentTagPropertyValidator(properties).assertSuccess();
  return {
    "AddSubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.addSubnetIds),
    "Options": cdk.objectToCloudFormation(properties.options),
    "RemoveSubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.removeSubnetIds),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds),
    "Tags": cdk.listMapper(convertCfnTransitGatewayVpcAttachmentTagPropertyToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayVpcAttachmentTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnTransitGatewayVpcAttachment.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayVpcAttachment.TagProperty>();
  ret.addPropertyResult("addSubnetIds", "AddSubnetIds", (properties.AddSubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AddSubnetIds) : undefined));
  ret.addPropertyResult("options", "Options", (properties.Options != null ? cfn_parse.FromCloudFormation.getAny(properties.Options) : undefined));
  ret.addPropertyResult("removeSubnetIds", "RemoveSubnetIds", (properties.RemoveSubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.RemoveSubnetIds) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnTransitGatewayVpcAttachmentTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnTransitGatewayVpcAttachmentProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnTransitGatewayVpcAttachmentProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnTransitGatewayVpcAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addSubnetIds", cdk.listValidator(cdk.validateString))(properties.addSubnetIds));
  errors.collect(cdk.propertyValidator("options", cdk.validateObject)(properties.options));
  errors.collect(cdk.propertyValidator("removeSubnetIds", cdk.listValidator(cdk.validateString))(properties.removeSubnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.requiredValidator)(properties.subnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.requiredValidator)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnTransitGatewayVpcAttachmentProps\\"");
}

// @ts-ignore TS6133
function convertCfnTransitGatewayVpcAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnTransitGatewayVpcAttachmentPropsValidator(properties).assertSuccess();
  return {
    "AddSubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.addSubnetIds),
    "Options": cdk.objectToCloudFormation(properties.options),
    "RemoveSubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.removeSubnetIds),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnTransitGatewayVpcAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnTransitGatewayVpcAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnTransitGatewayVpcAttachmentProps>();
  ret.addPropertyResult("addSubnetIds", "AddSubnetIds", (properties.AddSubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AddSubnetIds) : undefined));
  ret.addPropertyResult("options", "Options", (properties.Options != null ? cfn_parse.FromCloudFormation.getAny(properties.Options) : undefined));
  ret.addPropertyResult("removeSubnetIds", "RemoveSubnetIds", (properties.RemoveSubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.RemoveSubnetIds) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * An AWS Verified Access endpoint specifies the application that AWS Verified Access provides access to.
 *
 * It must be attached to an AWS Verified Access group. An AWS Verified Access endpoint must also have an attached access policy before you attached it to a group.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html
 */
export class CfnVerifiedAccessEndpoint extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VerifiedAccessEndpoint";

  /**
   * Build a CfnVerifiedAccessEndpoint from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVerifiedAccessEndpoint {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVerifiedAccessEndpointPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVerifiedAccessEndpoint(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * Use this to construct the redirect URI to add to your OIDC provider's allow list.
   *
   * @cloudformationAttribute DeviceValidationDomain
   */
  public readonly attrDeviceValidationDomain: string;

  /**
   * The DNS name generated for the endpoint.
   *
   * @cloudformationAttribute EndpointDomain
   */
  public readonly attrEndpointDomain: string;

  /**
   * The last updated time.
   *
   * @cloudformationAttribute LastUpdatedTime
   */
  public readonly attrLastUpdatedTime: string;

  /**
   * The endpoint status.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The ID of the Verified Access endpoint.
   *
   * @cloudformationAttribute VerifiedAccessEndpointId
   */
  public readonly attrVerifiedAccessEndpointId: string;

  /**
   * The instance identifier.
   *
   * @cloudformationAttribute VerifiedAccessInstanceId
   */
  public readonly attrVerifiedAccessInstanceId: string;

  /**
   * The DNS name for users to reach your application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-applicationdomain
   */
  public applicationDomain: string;

  /**
   * The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-attachmenttype
   */
  public attachmentType: string;

  /**
   * A description for the AWS Verified Access endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-description
   */
  public description?: string;

  /**
   * The ARN of a public TLS/SSL certificate imported into or created with ACM.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-domaincertificatearn
   */
  public domainCertificateArn: string;

  /**
   * A custom identifier that is prepended to the DNS name that is generated for the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-endpointdomainprefix
   */
  public endpointDomainPrefix: string;

  /**
   * The type of AWS Verified Access endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-endpointtype
   */
  public endpointType: string;

  /**
   * The load balancer details if creating the AWS Verified Access endpoint as \`load-balancer\` type.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions
   */
  public loadBalancerOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty;

  /**
   * The options for network-interface type endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions
   */
  public networkInterfaceOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty;

  /**
   * The Verified Access policy document.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-policydocument
   */
  public policyDocument?: string;

  /**
   * The status of the Verified Access policy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-policyenabled
   */
  public policyEnabled?: boolean | cdk.IResolvable;

  /**
   * The IDs of the security groups for the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-securitygroupids
   */
  public securityGroupIds?: Array<string>;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-tags
   */
  public tags?: Array<cdk.IResolvable | CfnVerifiedAccessEndpoint.TagProperty> | cdk.IResolvable;

  /**
   * The ID of the AWS Verified Access group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-verifiedaccessgroupid
   */
  public verifiedAccessGroupId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVerifiedAccessEndpointProps) {
    super(scope, id, {
      "type": CfnVerifiedAccessEndpoint.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "applicationDomain", this);
    cdk.requireProperty(props, "attachmentType", this);
    cdk.requireProperty(props, "domainCertificateArn", this);
    cdk.requireProperty(props, "endpointDomainPrefix", this);
    cdk.requireProperty(props, "endpointType", this);
    cdk.requireProperty(props, "verifiedAccessGroupId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrDeviceValidationDomain = cdk.Token.asString(this.getAtt("DeviceValidationDomain", cdk.ResolutionTypeHint.STRING));
    this.attrEndpointDomain = cdk.Token.asString(this.getAtt("EndpointDomain", cdk.ResolutionTypeHint.STRING));
    this.attrLastUpdatedTime = cdk.Token.asString(this.getAtt("LastUpdatedTime", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessEndpointId = cdk.Token.asString(this.getAtt("VerifiedAccessEndpointId", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessInstanceId = cdk.Token.asString(this.getAtt("VerifiedAccessInstanceId", cdk.ResolutionTypeHint.STRING));
    this.applicationDomain = props.applicationDomain;
    this.attachmentType = props.attachmentType;
    this.description = props.description;
    this.domainCertificateArn = props.domainCertificateArn;
    this.endpointDomainPrefix = props.endpointDomainPrefix;
    this.endpointType = props.endpointType;
    this.loadBalancerOptions = props.loadBalancerOptions;
    this.networkInterfaceOptions = props.networkInterfaceOptions;
    this.policyDocument = props.policyDocument;
    this.policyEnabled = props.policyEnabled;
    this.securityGroupIds = props.securityGroupIds;
    this.tags = props.tags;
    this.verifiedAccessGroupId = props.verifiedAccessGroupId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationDomain": this.applicationDomain,
      "attachmentType": this.attachmentType,
      "description": this.description,
      "domainCertificateArn": this.domainCertificateArn,
      "endpointDomainPrefix": this.endpointDomainPrefix,
      "endpointType": this.endpointType,
      "loadBalancerOptions": this.loadBalancerOptions,
      "networkInterfaceOptions": this.networkInterfaceOptions,
      "policyDocument": this.policyDocument,
      "policyEnabled": this.policyEnabled,
      "securityGroupIds": this.securityGroupIds,
      "tags": this.tags,
      "verifiedAccessGroupId": this.verifiedAccessGroupId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVerifiedAccessEndpoint.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVerifiedAccessEndpointPropsToCloudFormation(props);
  }
}

export namespace CfnVerifiedAccessEndpoint {
  /**
   * Describes the network interface options when creating an AWS Verified Access endpoint using the \`network-interface\` type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html
   */
  export interface NetworkInterfaceOptionsProperty {
    /**
     * The DNS name for users to reach your application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-applicationdomain
     */
    readonly applicationDomain: string;

    /**
     * The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-attachmenttype
     */
    readonly attachmentType: string;

    /**
     * A description for the AWS Verified Access endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-description
     */
    readonly description?: string;

    /**
     * The ARN of a public TLS/SSL certificate imported into or created with ACM.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-domaincertificatearn
     */
    readonly domainCertificateArn: string;

    /**
     * A custom identifier that is prepended to the DNS name that is generated for the endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-endpointdomainprefix
     */
    readonly endpointDomainPrefix: string;

    /**
     * The type of AWS Verified Access endpoint.
     *
     * Incoming application requests will be sent to an IP address, load balancer or a network interface depending on the endpoint type specified.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-endpointtype
     */
    readonly endpointType: string;

    /**
     * The load balancer details if creating the AWS Verified Access endpoint as \`load-balancer\` type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-loadbalanceroptions
     */
    readonly loadBalancerOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty;

    /**
     * The options for network-interface type endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-networkinterfaceoptions
     */
    readonly networkInterfaceOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty;

    /**
     * The Verified Access policy document.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-policydocument
     */
    readonly policyDocument?: string;

    /**
     * The status of the Verified Access policy.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-policyenabled
     */
    readonly policyEnabled?: boolean | cdk.IResolvable;

    /**
     * The IDs of the security groups for the endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessEndpoint.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the AWS Verified Access group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-verifiedaccessgroupid
     */
    readonly verifiedAccessGroupId: string;
  }

  /**
   * Describes the load balancer options when creating an AWS Verified Access endpoint using the \`load-balancer\` type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html
   */
  export interface LoadBalancerOptionsProperty {
    /**
     * The DNS name for users to reach your application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-applicationdomain
     */
    readonly applicationDomain: string;

    /**
     * The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-attachmenttype
     */
    readonly attachmentType: string;

    /**
     * A description for the AWS Verified Access endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-description
     */
    readonly description?: string;

    /**
     * The ARN of a public TLS/SSL certificate imported into or created with ACM.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-domaincertificatearn
     */
    readonly domainCertificateArn: string;

    /**
     * A custom identifier that is prepended to the DNS name that is generated for the endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-endpointdomainprefix
     */
    readonly endpointDomainPrefix: string;

    /**
     * The type of AWS Verified Access endpoint.
     *
     * Incoming application requests will be sent to an IP address, load balancer or a network interface depending on the endpoint type specified.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-endpointtype
     */
    readonly endpointType: string;

    /**
     * The load balancer details if creating the AWS Verified Access endpoint as \`load-balancer\` type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-loadbalanceroptions
     */
    readonly loadBalancerOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty;

    /**
     * The options for network-interface type endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-networkinterfaceoptions
     */
    readonly networkInterfaceOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty;

    /**
     * The Verified Access policy document.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-policydocument
     */
    readonly policyDocument?: string;

    /**
     * The status of the Verified Access policy.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-policyenabled
     */
    readonly policyEnabled?: boolean | cdk.IResolvable;

    /**
     * The IDs of the security groups for the endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessEndpoint.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the AWS Verified Access group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-verifiedaccessgroupid
     */
    readonly verifiedAccessGroupId: string;
  }

  /**
   * A key-value pair to associate with a resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html
   */
  export interface TagProperty {
    /**
     * The DNS name for users to reach your application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-applicationdomain
     */
    readonly applicationDomain: string;

    /**
     * The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-attachmenttype
     */
    readonly attachmentType: string;

    /**
     * A description for the AWS Verified Access endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-description
     */
    readonly description?: string;

    /**
     * The ARN of a public TLS/SSL certificate imported into or created with ACM.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-domaincertificatearn
     */
    readonly domainCertificateArn: string;

    /**
     * A custom identifier that is prepended to the DNS name that is generated for the endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-endpointdomainprefix
     */
    readonly endpointDomainPrefix: string;

    /**
     * The type of AWS Verified Access endpoint.
     *
     * Incoming application requests will be sent to an IP address, load balancer or a network interface depending on the endpoint type specified.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-endpointtype
     */
    readonly endpointType: string;

    /**
     * The load balancer details if creating the AWS Verified Access endpoint as \`load-balancer\` type.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-loadbalanceroptions
     */
    readonly loadBalancerOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty;

    /**
     * The options for network-interface type endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-networkinterfaceoptions
     */
    readonly networkInterfaceOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty;

    /**
     * The Verified Access policy document.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-policydocument
     */
    readonly policyDocument?: string;

    /**
     * The status of the Verified Access policy.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-policyenabled
     */
    readonly policyEnabled?: boolean | cdk.IResolvable;

    /**
     * The IDs of the security groups for the endpoint.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-securitygroupids
     */
    readonly securityGroupIds?: Array<string>;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessEndpoint.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the AWS Verified Access group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-tag.html#cfn-ec2-verifiedaccessendpoint-tag-verifiedaccessgroupid
     */
    readonly verifiedAccessGroupId: string;
  }
}

/**
 * Properties for defining a \`CfnVerifiedAccessEndpoint\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html
 */
export interface CfnVerifiedAccessEndpointProps {
  /**
   * The DNS name for users to reach your application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-applicationdomain
   */
  readonly applicationDomain: string;

  /**
   * The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-attachmenttype
   */
  readonly attachmentType: string;

  /**
   * A description for the AWS Verified Access endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-description
   */
  readonly description?: string;

  /**
   * The ARN of a public TLS/SSL certificate imported into or created with ACM.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-domaincertificatearn
   */
  readonly domainCertificateArn: string;

  /**
   * A custom identifier that is prepended to the DNS name that is generated for the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-endpointdomainprefix
   */
  readonly endpointDomainPrefix: string;

  /**
   * The type of AWS Verified Access endpoint.
   *
   * Incoming application requests will be sent to an IP address, load balancer or a network interface depending on the endpoint type specified.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-endpointtype
   */
  readonly endpointType: string;

  /**
   * The load balancer details if creating the AWS Verified Access endpoint as \`load-balancer\` type.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions
   */
  readonly loadBalancerOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty;

  /**
   * The options for network-interface type endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions
   */
  readonly networkInterfaceOptions?: cdk.IResolvable | CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty;

  /**
   * The Verified Access policy document.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-policydocument
   */
  readonly policyDocument?: string;

  /**
   * The status of the Verified Access policy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-policyenabled
   */
  readonly policyEnabled?: boolean | cdk.IResolvable;

  /**
   * The IDs of the security groups for the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-tags
   */
  readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessEndpoint.TagProperty> | cdk.IResolvable;

  /**
   * The ID of the AWS Verified Access group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-verifiedaccessgroupid
   */
  readonly verifiedAccessGroupId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessEndpointTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationDomain", cdk.requiredValidator)(properties.applicationDomain));
  errors.collect(cdk.propertyValidator("applicationDomain", cdk.validateString)(properties.applicationDomain));
  errors.collect(cdk.propertyValidator("attachmentType", cdk.requiredValidator)(properties.attachmentType));
  errors.collect(cdk.propertyValidator("attachmentType", cdk.validateString)(properties.attachmentType));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("domainCertificateArn", cdk.requiredValidator)(properties.domainCertificateArn));
  errors.collect(cdk.propertyValidator("domainCertificateArn", cdk.validateString)(properties.domainCertificateArn));
  errors.collect(cdk.propertyValidator("endpointDomainPrefix", cdk.requiredValidator)(properties.endpointDomainPrefix));
  errors.collect(cdk.propertyValidator("endpointDomainPrefix", cdk.validateString)(properties.endpointDomainPrefix));
  errors.collect(cdk.propertyValidator("endpointType", cdk.requiredValidator)(properties.endpointType));
  errors.collect(cdk.propertyValidator("endpointType", cdk.validateString)(properties.endpointType));
  errors.collect(cdk.propertyValidator("loadBalancerOptions", CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyValidator)(properties.loadBalancerOptions));
  errors.collect(cdk.propertyValidator("networkInterfaceOptions", CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyValidator)(properties.networkInterfaceOptions));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateString)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyEnabled", cdk.validateBoolean)(properties.policyEnabled));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessEndpointTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessGroupId", cdk.requiredValidator)(properties.verifiedAccessGroupId));
  errors.collect(cdk.propertyValidator("verifiedAccessGroupId", cdk.validateString)(properties.verifiedAccessGroupId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessEndpointTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessEndpointTagPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationDomain": cdk.stringToCloudFormation(properties.applicationDomain),
    "AttachmentType": cdk.stringToCloudFormation(properties.attachmentType),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DomainCertificateArn": cdk.stringToCloudFormation(properties.domainCertificateArn),
    "EndpointDomainPrefix": cdk.stringToCloudFormation(properties.endpointDomainPrefix),
    "EndpointType": cdk.stringToCloudFormation(properties.endpointType),
    "LoadBalancerOptions": convertCfnVerifiedAccessEndpointLoadBalancerOptionsPropertyToCloudFormation(properties.loadBalancerOptions),
    "NetworkInterfaceOptions": convertCfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyToCloudFormation(properties.networkInterfaceOptions),
    "PolicyDocument": cdk.stringToCloudFormation(properties.policyDocument),
    "PolicyEnabled": cdk.booleanToCloudFormation(properties.policyEnabled),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessEndpointTagPropertyToCloudFormation)(properties.tags),
    "VerifiedAccessGroupId": cdk.stringToCloudFormation(properties.verifiedAccessGroupId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessEndpointTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessEndpoint.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessEndpoint.TagProperty>();
  ret.addPropertyResult("applicationDomain", "ApplicationDomain", (properties.ApplicationDomain != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDomain) : undefined));
  ret.addPropertyResult("attachmentType", "AttachmentType", (properties.AttachmentType != null ? cfn_parse.FromCloudFormation.getString(properties.AttachmentType) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("domainCertificateArn", "DomainCertificateArn", (properties.DomainCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.DomainCertificateArn) : undefined));
  ret.addPropertyResult("endpointDomainPrefix", "EndpointDomainPrefix", (properties.EndpointDomainPrefix != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointDomainPrefix) : undefined));
  ret.addPropertyResult("endpointType", "EndpointType", (properties.EndpointType != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointType) : undefined));
  ret.addPropertyResult("loadBalancerOptions", "LoadBalancerOptions", (properties.LoadBalancerOptions != null ? CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyFromCloudFormation(properties.LoadBalancerOptions) : undefined));
  ret.addPropertyResult("networkInterfaceOptions", "NetworkInterfaceOptions", (properties.NetworkInterfaceOptions != null ? CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyFromCloudFormation(properties.NetworkInterfaceOptions) : undefined));
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("policyEnabled", "PolicyEnabled", (properties.PolicyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PolicyEnabled) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessEndpointTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessGroupId", "VerifiedAccessGroupId", (properties.VerifiedAccessGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.VerifiedAccessGroupId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LoadBalancerOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`LoadBalancerOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationDomain", cdk.requiredValidator)(properties.applicationDomain));
  errors.collect(cdk.propertyValidator("applicationDomain", cdk.validateString)(properties.applicationDomain));
  errors.collect(cdk.propertyValidator("attachmentType", cdk.requiredValidator)(properties.attachmentType));
  errors.collect(cdk.propertyValidator("attachmentType", cdk.validateString)(properties.attachmentType));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("domainCertificateArn", cdk.requiredValidator)(properties.domainCertificateArn));
  errors.collect(cdk.propertyValidator("domainCertificateArn", cdk.validateString)(properties.domainCertificateArn));
  errors.collect(cdk.propertyValidator("endpointDomainPrefix", cdk.requiredValidator)(properties.endpointDomainPrefix));
  errors.collect(cdk.propertyValidator("endpointDomainPrefix", cdk.validateString)(properties.endpointDomainPrefix));
  errors.collect(cdk.propertyValidator("endpointType", cdk.requiredValidator)(properties.endpointType));
  errors.collect(cdk.propertyValidator("endpointType", cdk.validateString)(properties.endpointType));
  errors.collect(cdk.propertyValidator("loadBalancerOptions", CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyValidator)(properties.loadBalancerOptions));
  errors.collect(cdk.propertyValidator("networkInterfaceOptions", CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyValidator)(properties.networkInterfaceOptions));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateString)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyEnabled", cdk.validateBoolean)(properties.policyEnabled));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessEndpointTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessGroupId", cdk.requiredValidator)(properties.verifiedAccessGroupId));
  errors.collect(cdk.propertyValidator("verifiedAccessGroupId", cdk.validateString)(properties.verifiedAccessGroupId));
  return errors.wrap("supplied properties not correct for \\"LoadBalancerOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessEndpointLoadBalancerOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationDomain": cdk.stringToCloudFormation(properties.applicationDomain),
    "AttachmentType": cdk.stringToCloudFormation(properties.attachmentType),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DomainCertificateArn": cdk.stringToCloudFormation(properties.domainCertificateArn),
    "EndpointDomainPrefix": cdk.stringToCloudFormation(properties.endpointDomainPrefix),
    "EndpointType": cdk.stringToCloudFormation(properties.endpointType),
    "LoadBalancerOptions": convertCfnVerifiedAccessEndpointLoadBalancerOptionsPropertyToCloudFormation(properties.loadBalancerOptions),
    "NetworkInterfaceOptions": convertCfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyToCloudFormation(properties.networkInterfaceOptions),
    "PolicyDocument": cdk.stringToCloudFormation(properties.policyDocument),
    "PolicyEnabled": cdk.booleanToCloudFormation(properties.policyEnabled),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessEndpointTagPropertyToCloudFormation)(properties.tags),
    "VerifiedAccessGroupId": cdk.stringToCloudFormation(properties.verifiedAccessGroupId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty>();
  ret.addPropertyResult("applicationDomain", "ApplicationDomain", (properties.ApplicationDomain != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDomain) : undefined));
  ret.addPropertyResult("attachmentType", "AttachmentType", (properties.AttachmentType != null ? cfn_parse.FromCloudFormation.getString(properties.AttachmentType) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("domainCertificateArn", "DomainCertificateArn", (properties.DomainCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.DomainCertificateArn) : undefined));
  ret.addPropertyResult("endpointDomainPrefix", "EndpointDomainPrefix", (properties.EndpointDomainPrefix != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointDomainPrefix) : undefined));
  ret.addPropertyResult("endpointType", "EndpointType", (properties.EndpointType != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointType) : undefined));
  ret.addPropertyResult("loadBalancerOptions", "LoadBalancerOptions", (properties.LoadBalancerOptions != null ? CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyFromCloudFormation(properties.LoadBalancerOptions) : undefined));
  ret.addPropertyResult("networkInterfaceOptions", "NetworkInterfaceOptions", (properties.NetworkInterfaceOptions != null ? CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyFromCloudFormation(properties.NetworkInterfaceOptions) : undefined));
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("policyEnabled", "PolicyEnabled", (properties.PolicyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PolicyEnabled) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessEndpointTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessGroupId", "VerifiedAccessGroupId", (properties.VerifiedAccessGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.VerifiedAccessGroupId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NetworkInterfaceOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkInterfaceOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationDomain", cdk.requiredValidator)(properties.applicationDomain));
  errors.collect(cdk.propertyValidator("applicationDomain", cdk.validateString)(properties.applicationDomain));
  errors.collect(cdk.propertyValidator("attachmentType", cdk.requiredValidator)(properties.attachmentType));
  errors.collect(cdk.propertyValidator("attachmentType", cdk.validateString)(properties.attachmentType));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("domainCertificateArn", cdk.requiredValidator)(properties.domainCertificateArn));
  errors.collect(cdk.propertyValidator("domainCertificateArn", cdk.validateString)(properties.domainCertificateArn));
  errors.collect(cdk.propertyValidator("endpointDomainPrefix", cdk.requiredValidator)(properties.endpointDomainPrefix));
  errors.collect(cdk.propertyValidator("endpointDomainPrefix", cdk.validateString)(properties.endpointDomainPrefix));
  errors.collect(cdk.propertyValidator("endpointType", cdk.requiredValidator)(properties.endpointType));
  errors.collect(cdk.propertyValidator("endpointType", cdk.validateString)(properties.endpointType));
  errors.collect(cdk.propertyValidator("loadBalancerOptions", CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyValidator)(properties.loadBalancerOptions));
  errors.collect(cdk.propertyValidator("networkInterfaceOptions", CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyValidator)(properties.networkInterfaceOptions));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateString)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyEnabled", cdk.validateBoolean)(properties.policyEnabled));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessEndpointTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessGroupId", cdk.requiredValidator)(properties.verifiedAccessGroupId));
  errors.collect(cdk.propertyValidator("verifiedAccessGroupId", cdk.validateString)(properties.verifiedAccessGroupId));
  return errors.wrap("supplied properties not correct for \\"NetworkInterfaceOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationDomain": cdk.stringToCloudFormation(properties.applicationDomain),
    "AttachmentType": cdk.stringToCloudFormation(properties.attachmentType),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DomainCertificateArn": cdk.stringToCloudFormation(properties.domainCertificateArn),
    "EndpointDomainPrefix": cdk.stringToCloudFormation(properties.endpointDomainPrefix),
    "EndpointType": cdk.stringToCloudFormation(properties.endpointType),
    "LoadBalancerOptions": convertCfnVerifiedAccessEndpointLoadBalancerOptionsPropertyToCloudFormation(properties.loadBalancerOptions),
    "NetworkInterfaceOptions": convertCfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyToCloudFormation(properties.networkInterfaceOptions),
    "PolicyDocument": cdk.stringToCloudFormation(properties.policyDocument),
    "PolicyEnabled": cdk.booleanToCloudFormation(properties.policyEnabled),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessEndpointTagPropertyToCloudFormation)(properties.tags),
    "VerifiedAccessGroupId": cdk.stringToCloudFormation(properties.verifiedAccessGroupId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty>();
  ret.addPropertyResult("applicationDomain", "ApplicationDomain", (properties.ApplicationDomain != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDomain) : undefined));
  ret.addPropertyResult("attachmentType", "AttachmentType", (properties.AttachmentType != null ? cfn_parse.FromCloudFormation.getString(properties.AttachmentType) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("domainCertificateArn", "DomainCertificateArn", (properties.DomainCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.DomainCertificateArn) : undefined));
  ret.addPropertyResult("endpointDomainPrefix", "EndpointDomainPrefix", (properties.EndpointDomainPrefix != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointDomainPrefix) : undefined));
  ret.addPropertyResult("endpointType", "EndpointType", (properties.EndpointType != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointType) : undefined));
  ret.addPropertyResult("loadBalancerOptions", "LoadBalancerOptions", (properties.LoadBalancerOptions != null ? CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyFromCloudFormation(properties.LoadBalancerOptions) : undefined));
  ret.addPropertyResult("networkInterfaceOptions", "NetworkInterfaceOptions", (properties.NetworkInterfaceOptions != null ? CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyFromCloudFormation(properties.NetworkInterfaceOptions) : undefined));
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("policyEnabled", "PolicyEnabled", (properties.PolicyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PolicyEnabled) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessEndpointTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessGroupId", "VerifiedAccessGroupId", (properties.VerifiedAccessGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.VerifiedAccessGroupId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVerifiedAccessEndpointProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVerifiedAccessEndpointProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessEndpointPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationDomain", cdk.requiredValidator)(properties.applicationDomain));
  errors.collect(cdk.propertyValidator("applicationDomain", cdk.validateString)(properties.applicationDomain));
  errors.collect(cdk.propertyValidator("attachmentType", cdk.requiredValidator)(properties.attachmentType));
  errors.collect(cdk.propertyValidator("attachmentType", cdk.validateString)(properties.attachmentType));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("domainCertificateArn", cdk.requiredValidator)(properties.domainCertificateArn));
  errors.collect(cdk.propertyValidator("domainCertificateArn", cdk.validateString)(properties.domainCertificateArn));
  errors.collect(cdk.propertyValidator("endpointDomainPrefix", cdk.requiredValidator)(properties.endpointDomainPrefix));
  errors.collect(cdk.propertyValidator("endpointDomainPrefix", cdk.validateString)(properties.endpointDomainPrefix));
  errors.collect(cdk.propertyValidator("endpointType", cdk.requiredValidator)(properties.endpointType));
  errors.collect(cdk.propertyValidator("endpointType", cdk.validateString)(properties.endpointType));
  errors.collect(cdk.propertyValidator("loadBalancerOptions", CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyValidator)(properties.loadBalancerOptions));
  errors.collect(cdk.propertyValidator("networkInterfaceOptions", CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyValidator)(properties.networkInterfaceOptions));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateString)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyEnabled", cdk.validateBoolean)(properties.policyEnabled));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessEndpointTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessGroupId", cdk.requiredValidator)(properties.verifiedAccessGroupId));
  errors.collect(cdk.propertyValidator("verifiedAccessGroupId", cdk.validateString)(properties.verifiedAccessGroupId));
  return errors.wrap("supplied properties not correct for \\"CfnVerifiedAccessEndpointProps\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessEndpointPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessEndpointPropsValidator(properties).assertSuccess();
  return {
    "ApplicationDomain": cdk.stringToCloudFormation(properties.applicationDomain),
    "AttachmentType": cdk.stringToCloudFormation(properties.attachmentType),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DomainCertificateArn": cdk.stringToCloudFormation(properties.domainCertificateArn),
    "EndpointDomainPrefix": cdk.stringToCloudFormation(properties.endpointDomainPrefix),
    "EndpointType": cdk.stringToCloudFormation(properties.endpointType),
    "LoadBalancerOptions": convertCfnVerifiedAccessEndpointLoadBalancerOptionsPropertyToCloudFormation(properties.loadBalancerOptions),
    "NetworkInterfaceOptions": convertCfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyToCloudFormation(properties.networkInterfaceOptions),
    "PolicyDocument": cdk.stringToCloudFormation(properties.policyDocument),
    "PolicyEnabled": cdk.booleanToCloudFormation(properties.policyEnabled),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessEndpointTagPropertyToCloudFormation)(properties.tags),
    "VerifiedAccessGroupId": cdk.stringToCloudFormation(properties.verifiedAccessGroupId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessEndpointPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessEndpointProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessEndpointProps>();
  ret.addPropertyResult("applicationDomain", "ApplicationDomain", (properties.ApplicationDomain != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDomain) : undefined));
  ret.addPropertyResult("attachmentType", "AttachmentType", (properties.AttachmentType != null ? cfn_parse.FromCloudFormation.getString(properties.AttachmentType) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("domainCertificateArn", "DomainCertificateArn", (properties.DomainCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.DomainCertificateArn) : undefined));
  ret.addPropertyResult("endpointDomainPrefix", "EndpointDomainPrefix", (properties.EndpointDomainPrefix != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointDomainPrefix) : undefined));
  ret.addPropertyResult("endpointType", "EndpointType", (properties.EndpointType != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointType) : undefined));
  ret.addPropertyResult("loadBalancerOptions", "LoadBalancerOptions", (properties.LoadBalancerOptions != null ? CfnVerifiedAccessEndpointLoadBalancerOptionsPropertyFromCloudFormation(properties.LoadBalancerOptions) : undefined));
  ret.addPropertyResult("networkInterfaceOptions", "NetworkInterfaceOptions", (properties.NetworkInterfaceOptions != null ? CfnVerifiedAccessEndpointNetworkInterfaceOptionsPropertyFromCloudFormation(properties.NetworkInterfaceOptions) : undefined));
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("policyEnabled", "PolicyEnabled", (properties.PolicyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PolicyEnabled) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessEndpointTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessGroupId", "VerifiedAccessGroupId", (properties.VerifiedAccessGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.VerifiedAccessGroupId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a Verified Access group.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html
 */
export class CfnVerifiedAccessGroup extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VerifiedAccessGroup";

  /**
   * Build a CfnVerifiedAccessGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVerifiedAccessGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVerifiedAccessGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVerifiedAccessGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The last updated time.
   *
   * @cloudformationAttribute LastUpdatedTime
   */
  public readonly attrLastUpdatedTime: string;

  /**
   * The ID of the AWS account that owns the group.
   *
   * @cloudformationAttribute Owner
   */
  public readonly attrOwner: string;

  /**
   * The ARN of the Verified Access group.
   *
   * @cloudformationAttribute VerifiedAccessGroupArn
   */
  public readonly attrVerifiedAccessGroupArn: string;

  /**
   * The ID of the Verified Access group.
   *
   * @cloudformationAttribute VerifiedAccessGroupId
   */
  public readonly attrVerifiedAccessGroupId: string;

  /**
   * A description for the AWS Verified Access group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-description
   */
  public description?: string;

  /**
   * The Verified Access policy document.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-policydocument
   */
  public policyDocument?: string;

  /**
   * The status of the Verified Access policy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-policyenabled
   */
  public policyEnabled?: boolean | cdk.IResolvable;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-tags
   */
  public tags?: Array<cdk.IResolvable | CfnVerifiedAccessGroup.TagProperty> | cdk.IResolvable;

  /**
   * The ID of the AWS Verified Access instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-verifiedaccessinstanceid
   */
  public verifiedAccessInstanceId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVerifiedAccessGroupProps) {
    super(scope, id, {
      "type": CfnVerifiedAccessGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "verifiedAccessInstanceId", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrLastUpdatedTime = cdk.Token.asString(this.getAtt("LastUpdatedTime", cdk.ResolutionTypeHint.STRING));
    this.attrOwner = cdk.Token.asString(this.getAtt("Owner", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessGroupArn = cdk.Token.asString(this.getAtt("VerifiedAccessGroupArn", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessGroupId = cdk.Token.asString(this.getAtt("VerifiedAccessGroupId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.policyDocument = props.policyDocument;
    this.policyEnabled = props.policyEnabled;
    this.tags = props.tags;
    this.verifiedAccessInstanceId = props.verifiedAccessInstanceId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "policyDocument": this.policyDocument,
      "policyEnabled": this.policyEnabled,
      "tags": this.tags,
      "verifiedAccessInstanceId": this.verifiedAccessInstanceId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVerifiedAccessGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVerifiedAccessGroupPropsToCloudFormation(props);
  }
}

export namespace CfnVerifiedAccessGroup {
  /**
   * A key-value pair to associate with a resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-tag.html
   */
  export interface TagProperty {
    /**
     * A description for the AWS Verified Access group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-tag.html#cfn-ec2-verifiedaccessgroup-tag-description
     */
    readonly description?: string;

    /**
     * The Verified Access policy document.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-tag.html#cfn-ec2-verifiedaccessgroup-tag-policydocument
     */
    readonly policyDocument?: string;

    /**
     * The status of the Verified Access policy.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-tag.html#cfn-ec2-verifiedaccessgroup-tag-policyenabled
     */
    readonly policyEnabled?: boolean | cdk.IResolvable;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-tag.html#cfn-ec2-verifiedaccessgroup-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessGroup.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the AWS Verified Access instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-tag.html#cfn-ec2-verifiedaccessgroup-tag-verifiedaccessinstanceid
     */
    readonly verifiedAccessInstanceId: string;
  }
}

/**
 * Properties for defining a \`CfnVerifiedAccessGroup\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html
 */
export interface CfnVerifiedAccessGroupProps {
  /**
   * A description for the AWS Verified Access group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-description
   */
  readonly description?: string;

  /**
   * The Verified Access policy document.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-policydocument
   */
  readonly policyDocument?: string;

  /**
   * The status of the Verified Access policy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-policyenabled
   */
  readonly policyEnabled?: boolean | cdk.IResolvable;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-tags
   */
  readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessGroup.TagProperty> | cdk.IResolvable;

  /**
   * The ID of the AWS Verified Access instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-verifiedaccessinstanceid
   */
  readonly verifiedAccessInstanceId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessGroupTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateString)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyEnabled", cdk.validateBoolean)(properties.policyEnabled));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessGroupTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessInstanceId", cdk.requiredValidator)(properties.verifiedAccessInstanceId));
  errors.collect(cdk.propertyValidator("verifiedAccessInstanceId", cdk.validateString)(properties.verifiedAccessInstanceId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessGroupTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessGroupTagPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "PolicyDocument": cdk.stringToCloudFormation(properties.policyDocument),
    "PolicyEnabled": cdk.booleanToCloudFormation(properties.policyEnabled),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessGroupTagPropertyToCloudFormation)(properties.tags),
    "VerifiedAccessInstanceId": cdk.stringToCloudFormation(properties.verifiedAccessInstanceId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessGroupTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessGroup.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessGroup.TagProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("policyEnabled", "PolicyEnabled", (properties.PolicyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PolicyEnabled) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessGroupTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessInstanceId", "VerifiedAccessInstanceId", (properties.VerifiedAccessInstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.VerifiedAccessInstanceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVerifiedAccessGroupProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVerifiedAccessGroupProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateString)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyEnabled", cdk.validateBoolean)(properties.policyEnabled));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessGroupTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessInstanceId", cdk.requiredValidator)(properties.verifiedAccessInstanceId));
  errors.collect(cdk.propertyValidator("verifiedAccessInstanceId", cdk.validateString)(properties.verifiedAccessInstanceId));
  return errors.wrap("supplied properties not correct for \\"CfnVerifiedAccessGroupProps\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessGroupPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "PolicyDocument": cdk.stringToCloudFormation(properties.policyDocument),
    "PolicyEnabled": cdk.booleanToCloudFormation(properties.policyEnabled),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessGroupTagPropertyToCloudFormation)(properties.tags),
    "VerifiedAccessInstanceId": cdk.stringToCloudFormation(properties.verifiedAccessInstanceId)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessGroupProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("policyEnabled", "PolicyEnabled", (properties.PolicyEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PolicyEnabled) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessGroupTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessInstanceId", "VerifiedAccessInstanceId", (properties.VerifiedAccessInstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.VerifiedAccessInstanceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a Verified Access instance.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html
 */
export class CfnVerifiedAccessInstance extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VerifiedAccessInstance";

  /**
   * Build a CfnVerifiedAccessInstance from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVerifiedAccessInstance {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVerifiedAccessInstancePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVerifiedAccessInstance(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The last updated time.
   *
   * @cloudformationAttribute LastUpdatedTime
   */
  public readonly attrLastUpdatedTime: string;

  /**
   * The ID of the Verified Access instance.
   *
   * @cloudformationAttribute VerifiedAccessInstanceId
   */
  public readonly attrVerifiedAccessInstanceId: string;

  /**
   * A description for the AWS Verified Access instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-description
   */
  public description?: string;

  /**
   * The current logging configuration for the Verified Access instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-loggingconfigurations
   */
  public loggingConfigurations?: cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessLogsProperty;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-tags
   */
  public tags?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.TagProperty> | cdk.IResolvable;

  /**
   * The IDs of the AWS Verified Access trust providers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustproviderids
   */
  public verifiedAccessTrustProviderIds?: Array<string>;

  /**
   * The IDs of the AWS Verified Access trust providers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustproviders
   */
  public verifiedAccessTrustProviders?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty> | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVerifiedAccessInstanceProps = {}) {
    super(scope, id, {
      "type": CfnVerifiedAccessInstance.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrLastUpdatedTime = cdk.Token.asString(this.getAtt("LastUpdatedTime", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessInstanceId = cdk.Token.asString(this.getAtt("VerifiedAccessInstanceId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.loggingConfigurations = props.loggingConfigurations;
    this.tags = props.tags;
    this.verifiedAccessTrustProviderIds = props.verifiedAccessTrustProviderIds;
    this.verifiedAccessTrustProviders = props.verifiedAccessTrustProviders;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "loggingConfigurations": this.loggingConfigurations,
      "tags": this.tags,
      "verifiedAccessTrustProviderIds": this.verifiedAccessTrustProviderIds,
      "verifiedAccessTrustProviders": this.verifiedAccessTrustProviders
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVerifiedAccessInstance.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVerifiedAccessInstancePropsToCloudFormation(props);
  }
}

export namespace CfnVerifiedAccessInstance {
  /**
   * Describes a Verified Access trust provider.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html
   */
  export interface VerifiedAccessTrustProviderProperty {
    /**
     * A description for the AWS Verified Access instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-description
     */
    readonly description?: string;

    /**
     * The current logging configuration for the Verified Access instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-loggingconfigurations
     */
    readonly loggingConfigurations?: cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessLogsProperty;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.TagProperty> | cdk.IResolvable;

    /**
     * The IDs of the AWS Verified Access trust providers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-verifiedaccesstrustproviderids
     */
    readonly verifiedAccessTrustProviderIds?: Array<string>;

    /**
     * The IDs of the AWS Verified Access trust providers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-verifiedaccesstrustproviders
     */
    readonly verifiedAccessTrustProviders?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty> | cdk.IResolvable;
  }

  /**
   * Describes the destinations for Verified Access logs.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html
   */
  export interface VerifiedAccessLogsProperty {
    /**
     * A description for the AWS Verified Access instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-description
     */
    readonly description?: string;

    /**
     * The current logging configuration for the Verified Access instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-loggingconfigurations
     */
    readonly loggingConfigurations?: cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessLogsProperty;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.TagProperty> | cdk.IResolvable;

    /**
     * The IDs of the AWS Verified Access trust providers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-verifiedaccesstrustproviderids
     */
    readonly verifiedAccessTrustProviderIds?: Array<string>;

    /**
     * The IDs of the AWS Verified Access trust providers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-verifiedaccesstrustproviders
     */
    readonly verifiedAccessTrustProviders?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty> | cdk.IResolvable;
  }

  /**
   * A key-value pair to associate with a resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-tag.html
   */
  export interface TagProperty {
    /**
     * A description for the AWS Verified Access instance.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-tag.html#cfn-ec2-verifiedaccessinstance-tag-description
     */
    readonly description?: string;

    /**
     * The current logging configuration for the Verified Access instances.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-tag.html#cfn-ec2-verifiedaccessinstance-tag-loggingconfigurations
     */
    readonly loggingConfigurations?: cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessLogsProperty;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-tag.html#cfn-ec2-verifiedaccessinstance-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.TagProperty> | cdk.IResolvable;

    /**
     * The IDs of the AWS Verified Access trust providers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-tag.html#cfn-ec2-verifiedaccessinstance-tag-verifiedaccesstrustproviderids
     */
    readonly verifiedAccessTrustProviderIds?: Array<string>;

    /**
     * The IDs of the AWS Verified Access trust providers.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-tag.html#cfn-ec2-verifiedaccessinstance-tag-verifiedaccesstrustproviders
     */
    readonly verifiedAccessTrustProviders?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnVerifiedAccessInstance\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html
 */
export interface CfnVerifiedAccessInstanceProps {
  /**
   * A description for the AWS Verified Access instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-description
   */
  readonly description?: string;

  /**
   * The current logging configuration for the Verified Access instances.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-loggingconfigurations
   */
  readonly loggingConfigurations?: cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessLogsProperty;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-tags
   */
  readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.TagProperty> | cdk.IResolvable;

  /**
   * The IDs of the AWS Verified Access trust providers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustproviderids
   */
  readonly verifiedAccessTrustProviderIds?: Array<string>;

  /**
   * The IDs of the AWS Verified Access trust providers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustproviders
   */
  readonly verifiedAccessTrustProviders?: Array<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty> | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("loggingConfigurations", CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyValidator)(properties.loggingConfigurations));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviderIds", cdk.listValidator(cdk.validateString))(properties.verifiedAccessTrustProviderIds));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviders", cdk.listValidator(CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyValidator))(properties.verifiedAccessTrustProviders));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceTagPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "LoggingConfigurations": convertCfnVerifiedAccessInstanceVerifiedAccessLogsPropertyToCloudFormation(properties.loggingConfigurations),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessInstanceTagPropertyToCloudFormation)(properties.tags),
    "VerifiedAccessTrustProviderIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.verifiedAccessTrustProviderIds),
    "VerifiedAccessTrustProviders": cdk.listMapper(convertCfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyToCloudFormation)(properties.verifiedAccessTrustProviders)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessInstance.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.TagProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("loggingConfigurations", "LoggingConfigurations", (properties.LoggingConfigurations != null ? CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyFromCloudFormation(properties.LoggingConfigurations) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviderIds", "VerifiedAccessTrustProviderIds", (properties.VerifiedAccessTrustProviderIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.VerifiedAccessTrustProviderIds) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviders", "VerifiedAccessTrustProviders", (properties.VerifiedAccessTrustProviders != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyFromCloudFormation)(properties.VerifiedAccessTrustProviders) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VerifiedAccessLogsProperty\`
 *
 * @param properties - the TypeScript properties of a \`VerifiedAccessLogsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("loggingConfigurations", CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyValidator)(properties.loggingConfigurations));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviderIds", cdk.listValidator(cdk.validateString))(properties.verifiedAccessTrustProviderIds));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviders", cdk.listValidator(CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyValidator))(properties.verifiedAccessTrustProviders));
  return errors.wrap("supplied properties not correct for \\"VerifiedAccessLogsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceVerifiedAccessLogsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "LoggingConfigurations": convertCfnVerifiedAccessInstanceVerifiedAccessLogsPropertyToCloudFormation(properties.loggingConfigurations),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessInstanceTagPropertyToCloudFormation)(properties.tags),
    "VerifiedAccessTrustProviderIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.verifiedAccessTrustProviderIds),
    "VerifiedAccessTrustProviders": cdk.listMapper(convertCfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyToCloudFormation)(properties.verifiedAccessTrustProviders)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessLogsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.VerifiedAccessLogsProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("loggingConfigurations", "LoggingConfigurations", (properties.LoggingConfigurations != null ? CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyFromCloudFormation(properties.LoggingConfigurations) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviderIds", "VerifiedAccessTrustProviderIds", (properties.VerifiedAccessTrustProviderIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.VerifiedAccessTrustProviderIds) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviders", "VerifiedAccessTrustProviders", (properties.VerifiedAccessTrustProviders != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyFromCloudFormation)(properties.VerifiedAccessTrustProviders) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VerifiedAccessTrustProviderProperty\`
 *
 * @param properties - the TypeScript properties of a \`VerifiedAccessTrustProviderProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("loggingConfigurations", CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyValidator)(properties.loggingConfigurations));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviderIds", cdk.listValidator(cdk.validateString))(properties.verifiedAccessTrustProviderIds));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviders", cdk.listValidator(CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyValidator))(properties.verifiedAccessTrustProviders));
  return errors.wrap("supplied properties not correct for \\"VerifiedAccessTrustProviderProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "LoggingConfigurations": convertCfnVerifiedAccessInstanceVerifiedAccessLogsPropertyToCloudFormation(properties.loggingConfigurations),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessInstanceTagPropertyToCloudFormation)(properties.tags),
    "VerifiedAccessTrustProviderIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.verifiedAccessTrustProviderIds),
    "VerifiedAccessTrustProviders": cdk.listMapper(convertCfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyToCloudFormation)(properties.verifiedAccessTrustProviders)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("loggingConfigurations", "LoggingConfigurations", (properties.LoggingConfigurations != null ? CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyFromCloudFormation(properties.LoggingConfigurations) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviderIds", "VerifiedAccessTrustProviderIds", (properties.VerifiedAccessTrustProviderIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.VerifiedAccessTrustProviderIds) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviders", "VerifiedAccessTrustProviders", (properties.VerifiedAccessTrustProviders != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyFromCloudFormation)(properties.VerifiedAccessTrustProviders) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVerifiedAccessInstanceProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVerifiedAccessInstanceProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessInstancePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("loggingConfigurations", CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyValidator)(properties.loggingConfigurations));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessInstanceTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviderIds", cdk.listValidator(cdk.validateString))(properties.verifiedAccessTrustProviderIds));
  errors.collect(cdk.propertyValidator("verifiedAccessTrustProviders", cdk.listValidator(CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyValidator))(properties.verifiedAccessTrustProviders));
  return errors.wrap("supplied properties not correct for \\"CfnVerifiedAccessInstanceProps\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessInstancePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessInstancePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "LoggingConfigurations": convertCfnVerifiedAccessInstanceVerifiedAccessLogsPropertyToCloudFormation(properties.loggingConfigurations),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessInstanceTagPropertyToCloudFormation)(properties.tags),
    "VerifiedAccessTrustProviderIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.verifiedAccessTrustProviderIds),
    "VerifiedAccessTrustProviders": cdk.listMapper(convertCfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyToCloudFormation)(properties.verifiedAccessTrustProviders)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessInstancePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessInstanceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessInstanceProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("loggingConfigurations", "LoggingConfigurations", (properties.LoggingConfigurations != null ? CfnVerifiedAccessInstanceVerifiedAccessLogsPropertyFromCloudFormation(properties.LoggingConfigurations) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessInstanceTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviderIds", "VerifiedAccessTrustProviderIds", (properties.VerifiedAccessTrustProviderIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.VerifiedAccessTrustProviderIds) : undefined));
  ret.addPropertyResult("verifiedAccessTrustProviders", "VerifiedAccessTrustProviders", (properties.VerifiedAccessTrustProviders != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessInstanceVerifiedAccessTrustProviderPropertyFromCloudFormation)(properties.VerifiedAccessTrustProviders) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Describes a Verified Access trust provider.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html
 */
export class CfnVerifiedAccessTrustProvider extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VerifiedAccessTrustProvider";

  /**
   * Build a CfnVerifiedAccessTrustProvider from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVerifiedAccessTrustProvider {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVerifiedAccessTrustProviderPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVerifiedAccessTrustProvider(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The creation time.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The last updated time.
   *
   * @cloudformationAttribute LastUpdatedTime
   */
  public readonly attrLastUpdatedTime: string;

  /**
   * The ID of the Verified Access trust provider.
   *
   * @cloudformationAttribute VerifiedAccessTrustProviderId
   */
  public readonly attrVerifiedAccessTrustProviderId: string;

  /**
   * A description for the AWS Verified Access trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-description
   */
  public description?: string;

  /**
   * The options for device-identity trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions
   */
  public deviceOptions?: CfnVerifiedAccessTrustProvider.DeviceOptionsProperty | cdk.IResolvable;

  /**
   * The type of device-based trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-devicetrustprovidertype
   */
  public deviceTrustProviderType?: string;

  /**
   * The options for an OpenID Connect-compatible user-identity trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions
   */
  public oidcOptions?: cdk.IResolvable | CfnVerifiedAccessTrustProvider.OidcOptionsProperty;

  /**
   * The identifier to be used when working with policy rules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-policyreferencename
   */
  public policyReferenceName: string;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-tags
   */
  public tags?: Array<cdk.IResolvable | CfnVerifiedAccessTrustProvider.TagProperty> | cdk.IResolvable;

  /**
   * The type of Verified Access trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-trustprovidertype
   */
  public trustProviderType: string;

  /**
   * The type of user-based trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-usertrustprovidertype
   */
  public userTrustProviderType?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVerifiedAccessTrustProviderProps) {
    super(scope, id, {
      "type": CfnVerifiedAccessTrustProvider.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "policyReferenceName", this);
    cdk.requireProperty(props, "trustProviderType", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrLastUpdatedTime = cdk.Token.asString(this.getAtt("LastUpdatedTime", cdk.ResolutionTypeHint.STRING));
    this.attrVerifiedAccessTrustProviderId = cdk.Token.asString(this.getAtt("VerifiedAccessTrustProviderId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.deviceOptions = props.deviceOptions;
    this.deviceTrustProviderType = props.deviceTrustProviderType;
    this.oidcOptions = props.oidcOptions;
    this.policyReferenceName = props.policyReferenceName;
    this.tags = props.tags;
    this.trustProviderType = props.trustProviderType;
    this.userTrustProviderType = props.userTrustProviderType;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "deviceOptions": this.deviceOptions,
      "deviceTrustProviderType": this.deviceTrustProviderType,
      "oidcOptions": this.oidcOptions,
      "policyReferenceName": this.policyReferenceName,
      "tags": this.tags,
      "trustProviderType": this.trustProviderType,
      "userTrustProviderType": this.userTrustProviderType
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVerifiedAccessTrustProvider.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVerifiedAccessTrustProviderPropsToCloudFormation(props);
  }
}

export namespace CfnVerifiedAccessTrustProvider {
  /**
   * Describes the options for an OpenID Connect-compatible user-identity trust provider.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html
   */
  export interface OidcOptionsProperty {
    /**
     * A description for the AWS Verified Access trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-description
     */
    readonly description?: string;

    /**
     * The options for device-identity trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-deviceoptions
     */
    readonly deviceOptions?: CfnVerifiedAccessTrustProvider.DeviceOptionsProperty | cdk.IResolvable;

    /**
     * The type of device-based trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-devicetrustprovidertype
     */
    readonly deviceTrustProviderType?: string;

    /**
     * The options for an OpenID Connect-compatible user-identity trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-oidcoptions
     */
    readonly oidcOptions?: cdk.IResolvable | CfnVerifiedAccessTrustProvider.OidcOptionsProperty;

    /**
     * The identifier to be used when working with policy rules.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-policyreferencename
     */
    readonly policyReferenceName: string;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessTrustProvider.TagProperty> | cdk.IResolvable;

    /**
     * The type of Verified Access trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-trustprovidertype
     */
    readonly trustProviderType: string;

    /**
     * The type of user-based trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-usertrustprovidertype
     */
    readonly userTrustProviderType?: string;
  }

  /**
   * Describes the options for an AWS Verified Access device-identity based trust provider.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html
   */
  export interface DeviceOptionsProperty {
    /**
     * A description for the AWS Verified Access trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-description
     */
    readonly description?: string;

    /**
     * The options for device-identity trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-deviceoptions
     */
    readonly deviceOptions?: CfnVerifiedAccessTrustProvider.DeviceOptionsProperty | cdk.IResolvable;

    /**
     * The type of device-based trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-devicetrustprovidertype
     */
    readonly deviceTrustProviderType?: string;

    /**
     * The options for an OpenID Connect-compatible user-identity trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-oidcoptions
     */
    readonly oidcOptions?: cdk.IResolvable | CfnVerifiedAccessTrustProvider.OidcOptionsProperty;

    /**
     * The identifier to be used when working with policy rules.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-policyreferencename
     */
    readonly policyReferenceName: string;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessTrustProvider.TagProperty> | cdk.IResolvable;

    /**
     * The type of Verified Access trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-trustprovidertype
     */
    readonly trustProviderType: string;

    /**
     * The type of user-based trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-usertrustprovidertype
     */
    readonly userTrustProviderType?: string;
  }

  /**
   * A key-value pair to associate with a resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-tag.html
   */
  export interface TagProperty {
    /**
     * A description for the AWS Verified Access trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-tag.html#cfn-ec2-verifiedaccesstrustprovider-tag-description
     */
    readonly description?: string;

    /**
     * The options for device-identity trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-tag.html#cfn-ec2-verifiedaccesstrustprovider-tag-deviceoptions
     */
    readonly deviceOptions?: CfnVerifiedAccessTrustProvider.DeviceOptionsProperty | cdk.IResolvable;

    /**
     * The type of device-based trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-tag.html#cfn-ec2-verifiedaccesstrustprovider-tag-devicetrustprovidertype
     */
    readonly deviceTrustProviderType?: string;

    /**
     * The options for an OpenID Connect-compatible user-identity trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-tag.html#cfn-ec2-verifiedaccesstrustprovider-tag-oidcoptions
     */
    readonly oidcOptions?: cdk.IResolvable | CfnVerifiedAccessTrustProvider.OidcOptionsProperty;

    /**
     * The identifier to be used when working with policy rules.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-tag.html#cfn-ec2-verifiedaccesstrustprovider-tag-policyreferencename
     */
    readonly policyReferenceName: string;

    /**
     * The tags.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-tag.html#cfn-ec2-verifiedaccesstrustprovider-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessTrustProvider.TagProperty> | cdk.IResolvable;

    /**
     * The type of Verified Access trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-tag.html#cfn-ec2-verifiedaccesstrustprovider-tag-trustprovidertype
     */
    readonly trustProviderType: string;

    /**
     * The type of user-based trust provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-tag.html#cfn-ec2-verifiedaccesstrustprovider-tag-usertrustprovidertype
     */
    readonly userTrustProviderType?: string;
  }
}

/**
 * Properties for defining a \`CfnVerifiedAccessTrustProvider\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html
 */
export interface CfnVerifiedAccessTrustProviderProps {
  /**
   * A description for the AWS Verified Access trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-description
   */
  readonly description?: string;

  /**
   * The options for device-identity trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions
   */
  readonly deviceOptions?: CfnVerifiedAccessTrustProvider.DeviceOptionsProperty | cdk.IResolvable;

  /**
   * The type of device-based trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-devicetrustprovidertype
   */
  readonly deviceTrustProviderType?: string;

  /**
   * The options for an OpenID Connect-compatible user-identity trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions
   */
  readonly oidcOptions?: cdk.IResolvable | CfnVerifiedAccessTrustProvider.OidcOptionsProperty;

  /**
   * The identifier to be used when working with policy rules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-policyreferencename
   */
  readonly policyReferenceName: string;

  /**
   * The tags.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-tags
   */
  readonly tags?: Array<cdk.IResolvable | CfnVerifiedAccessTrustProvider.TagProperty> | cdk.IResolvable;

  /**
   * The type of Verified Access trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-trustprovidertype
   */
  readonly trustProviderType: string;

  /**
   * The type of user-based trust provider.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-usertrustprovidertype
   */
  readonly userTrustProviderType?: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceOptions", CfnVerifiedAccessTrustProviderDeviceOptionsPropertyValidator)(properties.deviceOptions));
  errors.collect(cdk.propertyValidator("deviceTrustProviderType", cdk.validateString)(properties.deviceTrustProviderType));
  errors.collect(cdk.propertyValidator("oidcOptions", CfnVerifiedAccessTrustProviderOidcOptionsPropertyValidator)(properties.oidcOptions));
  errors.collect(cdk.propertyValidator("policyReferenceName", cdk.requiredValidator)(properties.policyReferenceName));
  errors.collect(cdk.propertyValidator("policyReferenceName", cdk.validateString)(properties.policyReferenceName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessTrustProviderTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.requiredValidator)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.validateString)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("userTrustProviderType", cdk.validateString)(properties.userTrustProviderType));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessTrustProviderTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessTrustProviderTagPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceOptions": convertCfnVerifiedAccessTrustProviderDeviceOptionsPropertyToCloudFormation(properties.deviceOptions),
    "DeviceTrustProviderType": cdk.stringToCloudFormation(properties.deviceTrustProviderType),
    "OidcOptions": convertCfnVerifiedAccessTrustProviderOidcOptionsPropertyToCloudFormation(properties.oidcOptions),
    "PolicyReferenceName": cdk.stringToCloudFormation(properties.policyReferenceName),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessTrustProviderTagPropertyToCloudFormation)(properties.tags),
    "TrustProviderType": cdk.stringToCloudFormation(properties.trustProviderType),
    "UserTrustProviderType": cdk.stringToCloudFormation(properties.userTrustProviderType)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessTrustProvider.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessTrustProvider.TagProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceOptions", "DeviceOptions", (properties.DeviceOptions != null ? CfnVerifiedAccessTrustProviderDeviceOptionsPropertyFromCloudFormation(properties.DeviceOptions) : undefined));
  ret.addPropertyResult("deviceTrustProviderType", "DeviceTrustProviderType", (properties.DeviceTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceTrustProviderType) : undefined));
  ret.addPropertyResult("oidcOptions", "OidcOptions", (properties.OidcOptions != null ? CfnVerifiedAccessTrustProviderOidcOptionsPropertyFromCloudFormation(properties.OidcOptions) : undefined));
  ret.addPropertyResult("policyReferenceName", "PolicyReferenceName", (properties.PolicyReferenceName != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyReferenceName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessTrustProviderTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("trustProviderType", "TrustProviderType", (properties.TrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.TrustProviderType) : undefined));
  ret.addPropertyResult("userTrustProviderType", "UserTrustProviderType", (properties.UserTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.UserTrustProviderType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeviceOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeviceOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderDeviceOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceOptions", CfnVerifiedAccessTrustProviderDeviceOptionsPropertyValidator)(properties.deviceOptions));
  errors.collect(cdk.propertyValidator("deviceTrustProviderType", cdk.validateString)(properties.deviceTrustProviderType));
  errors.collect(cdk.propertyValidator("oidcOptions", CfnVerifiedAccessTrustProviderOidcOptionsPropertyValidator)(properties.oidcOptions));
  errors.collect(cdk.propertyValidator("policyReferenceName", cdk.requiredValidator)(properties.policyReferenceName));
  errors.collect(cdk.propertyValidator("policyReferenceName", cdk.validateString)(properties.policyReferenceName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessTrustProviderTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.requiredValidator)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.validateString)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("userTrustProviderType", cdk.validateString)(properties.userTrustProviderType));
  return errors.wrap("supplied properties not correct for \\"DeviceOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessTrustProviderDeviceOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessTrustProviderDeviceOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceOptions": convertCfnVerifiedAccessTrustProviderDeviceOptionsPropertyToCloudFormation(properties.deviceOptions),
    "DeviceTrustProviderType": cdk.stringToCloudFormation(properties.deviceTrustProviderType),
    "OidcOptions": convertCfnVerifiedAccessTrustProviderOidcOptionsPropertyToCloudFormation(properties.oidcOptions),
    "PolicyReferenceName": cdk.stringToCloudFormation(properties.policyReferenceName),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessTrustProviderTagPropertyToCloudFormation)(properties.tags),
    "TrustProviderType": cdk.stringToCloudFormation(properties.trustProviderType),
    "UserTrustProviderType": cdk.stringToCloudFormation(properties.userTrustProviderType)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderDeviceOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessTrustProvider.DeviceOptionsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessTrustProvider.DeviceOptionsProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceOptions", "DeviceOptions", (properties.DeviceOptions != null ? CfnVerifiedAccessTrustProviderDeviceOptionsPropertyFromCloudFormation(properties.DeviceOptions) : undefined));
  ret.addPropertyResult("deviceTrustProviderType", "DeviceTrustProviderType", (properties.DeviceTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceTrustProviderType) : undefined));
  ret.addPropertyResult("oidcOptions", "OidcOptions", (properties.OidcOptions != null ? CfnVerifiedAccessTrustProviderOidcOptionsPropertyFromCloudFormation(properties.OidcOptions) : undefined));
  ret.addPropertyResult("policyReferenceName", "PolicyReferenceName", (properties.PolicyReferenceName != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyReferenceName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessTrustProviderTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("trustProviderType", "TrustProviderType", (properties.TrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.TrustProviderType) : undefined));
  ret.addPropertyResult("userTrustProviderType", "UserTrustProviderType", (properties.UserTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.UserTrustProviderType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`OidcOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`OidcOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderOidcOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceOptions", CfnVerifiedAccessTrustProviderDeviceOptionsPropertyValidator)(properties.deviceOptions));
  errors.collect(cdk.propertyValidator("deviceTrustProviderType", cdk.validateString)(properties.deviceTrustProviderType));
  errors.collect(cdk.propertyValidator("oidcOptions", CfnVerifiedAccessTrustProviderOidcOptionsPropertyValidator)(properties.oidcOptions));
  errors.collect(cdk.propertyValidator("policyReferenceName", cdk.requiredValidator)(properties.policyReferenceName));
  errors.collect(cdk.propertyValidator("policyReferenceName", cdk.validateString)(properties.policyReferenceName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessTrustProviderTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.requiredValidator)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.validateString)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("userTrustProviderType", cdk.validateString)(properties.userTrustProviderType));
  return errors.wrap("supplied properties not correct for \\"OidcOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessTrustProviderOidcOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessTrustProviderOidcOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceOptions": convertCfnVerifiedAccessTrustProviderDeviceOptionsPropertyToCloudFormation(properties.deviceOptions),
    "DeviceTrustProviderType": cdk.stringToCloudFormation(properties.deviceTrustProviderType),
    "OidcOptions": convertCfnVerifiedAccessTrustProviderOidcOptionsPropertyToCloudFormation(properties.oidcOptions),
    "PolicyReferenceName": cdk.stringToCloudFormation(properties.policyReferenceName),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessTrustProviderTagPropertyToCloudFormation)(properties.tags),
    "TrustProviderType": cdk.stringToCloudFormation(properties.trustProviderType),
    "UserTrustProviderType": cdk.stringToCloudFormation(properties.userTrustProviderType)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderOidcOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVerifiedAccessTrustProvider.OidcOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessTrustProvider.OidcOptionsProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceOptions", "DeviceOptions", (properties.DeviceOptions != null ? CfnVerifiedAccessTrustProviderDeviceOptionsPropertyFromCloudFormation(properties.DeviceOptions) : undefined));
  ret.addPropertyResult("deviceTrustProviderType", "DeviceTrustProviderType", (properties.DeviceTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceTrustProviderType) : undefined));
  ret.addPropertyResult("oidcOptions", "OidcOptions", (properties.OidcOptions != null ? CfnVerifiedAccessTrustProviderOidcOptionsPropertyFromCloudFormation(properties.OidcOptions) : undefined));
  ret.addPropertyResult("policyReferenceName", "PolicyReferenceName", (properties.PolicyReferenceName != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyReferenceName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessTrustProviderTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("trustProviderType", "TrustProviderType", (properties.TrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.TrustProviderType) : undefined));
  ret.addPropertyResult("userTrustProviderType", "UserTrustProviderType", (properties.UserTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.UserTrustProviderType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVerifiedAccessTrustProviderProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVerifiedAccessTrustProviderProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("deviceOptions", CfnVerifiedAccessTrustProviderDeviceOptionsPropertyValidator)(properties.deviceOptions));
  errors.collect(cdk.propertyValidator("deviceTrustProviderType", cdk.validateString)(properties.deviceTrustProviderType));
  errors.collect(cdk.propertyValidator("oidcOptions", CfnVerifiedAccessTrustProviderOidcOptionsPropertyValidator)(properties.oidcOptions));
  errors.collect(cdk.propertyValidator("policyReferenceName", cdk.requiredValidator)(properties.policyReferenceName));
  errors.collect(cdk.propertyValidator("policyReferenceName", cdk.validateString)(properties.policyReferenceName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVerifiedAccessTrustProviderTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.requiredValidator)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("trustProviderType", cdk.validateString)(properties.trustProviderType));
  errors.collect(cdk.propertyValidator("userTrustProviderType", cdk.validateString)(properties.userTrustProviderType));
  return errors.wrap("supplied properties not correct for \\"CfnVerifiedAccessTrustProviderProps\\"");
}

// @ts-ignore TS6133
function convertCfnVerifiedAccessTrustProviderPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVerifiedAccessTrustProviderPropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "DeviceOptions": convertCfnVerifiedAccessTrustProviderDeviceOptionsPropertyToCloudFormation(properties.deviceOptions),
    "DeviceTrustProviderType": cdk.stringToCloudFormation(properties.deviceTrustProviderType),
    "OidcOptions": convertCfnVerifiedAccessTrustProviderOidcOptionsPropertyToCloudFormation(properties.oidcOptions),
    "PolicyReferenceName": cdk.stringToCloudFormation(properties.policyReferenceName),
    "Tags": cdk.listMapper(convertCfnVerifiedAccessTrustProviderTagPropertyToCloudFormation)(properties.tags),
    "TrustProviderType": cdk.stringToCloudFormation(properties.trustProviderType),
    "UserTrustProviderType": cdk.stringToCloudFormation(properties.userTrustProviderType)
  };
}

// @ts-ignore TS6133
function CfnVerifiedAccessTrustProviderPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVerifiedAccessTrustProviderProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVerifiedAccessTrustProviderProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("deviceOptions", "DeviceOptions", (properties.DeviceOptions != null ? CfnVerifiedAccessTrustProviderDeviceOptionsPropertyFromCloudFormation(properties.DeviceOptions) : undefined));
  ret.addPropertyResult("deviceTrustProviderType", "DeviceTrustProviderType", (properties.DeviceTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.DeviceTrustProviderType) : undefined));
  ret.addPropertyResult("oidcOptions", "OidcOptions", (properties.OidcOptions != null ? CfnVerifiedAccessTrustProviderOidcOptionsPropertyFromCloudFormation(properties.OidcOptions) : undefined));
  ret.addPropertyResult("policyReferenceName", "PolicyReferenceName", (properties.PolicyReferenceName != null ? cfn_parse.FromCloudFormation.getString(properties.PolicyReferenceName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVerifiedAccessTrustProviderTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("trustProviderType", "TrustProviderType", (properties.TrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.TrustProviderType) : undefined));
  ret.addPropertyResult("userTrustProviderType", "UserTrustProviderType", (properties.UserTrustProviderType != null ? cfn_parse.FromCloudFormation.getString(properties.UserTrustProviderType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies an Amazon Elastic Block Store (Amazon EBS) volume.
 *
 * You can attach the volume to an instance in the same Availability Zone using [AWS::EC2::VolumeAttachment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volumeattachment.html) .
 *
 * When you use AWS CloudFormation to update an Amazon EBS volume that modifies \`Iops\` , \`Size\` , or \`VolumeType\` , there is a cooldown period before another operation can occur. This can cause your stack to report being in \`UPDATE_IN_PROGRESS\` or \`UPDATE_ROLLBACK_IN_PROGRESS\` for long periods of time.
 *
 * Amazon EBS does not support sizing down an Amazon EBS volume. AWS CloudFormation does not attempt to modify an Amazon EBS volume to a smaller size on rollback.
 *
 * Some common scenarios when you might encounter a cooldown period for Amazon EBS include:
 *
 * - You successfully update an Amazon EBS volume and the update succeeds. When you attempt another update within the cooldown window, that update will be subject to a cooldown period.
 * - You successfully update an Amazon EBS volume and the update succeeds but another change in your \`update-stack\` call fails. The rollback will be subject to a cooldown period.
 *
 * For more information on the cooldown period, see [Requirements when modifying volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/modify-volume-requirements.html) .
 *
 * *DeletionPolicy attribute*
 *
 * To control how AWS CloudFormation handles the volume when the stack is deleted, set a deletion policy for your volume. You can choose to retain the volume, to delete the volume, or to create a snapshot of the volume. For more information, see [DeletionPolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html) .
 *
 * > If you set a deletion policy that creates a snapshot, all tags on the volume are included in the snapshot.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html
 */
export class CfnVolume extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::Volume";

  /**
   * Build a CfnVolume from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVolume {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVolumePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVolume(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the volume.
   *
   * @cloudformationAttribute VolumeId
   */
  public readonly attrVolumeId: string;

  /**
   * Indicates whether the volume is auto-enabled for I/O operations.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-autoenableio
   */
  public autoEnableIo?: boolean | cdk.IResolvable;

  /**
   * The ID of the Availability Zone in which to create the volume.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-availabilityzone
   */
  public availabilityZone: string;

  /**
   * Indicates whether the volume should be encrypted.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-encrypted
   */
  public encrypted?: boolean | cdk.IResolvable;

  /**
   * The number of I/O operations per second (IOPS).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-iops
   */
  public iops?: number;

  /**
   * The identifier of the AWS KMS key to use for Amazon EBS encryption.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-kmskeyid
   */
  public kmsKeyId?: string;

  /**
   * Indicates whether Amazon EBS Multi-Attach is enabled.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-multiattachenabled
   */
  public multiAttachEnabled?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-outpostarn
   */
  public outpostArn?: string;

  /**
   * The size of the volume, in GiBs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-size
   */
  public size?: number;

  /**
   * The snapshot from which to create the volume.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-snapshotid
   */
  public snapshotId?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags to apply to the volume during creation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The throughput to provision for a volume, with a maximum of 1,000 MiB/s.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-throughput
   */
  public throughput?: number;

  /**
   * The volume type. This parameter can be one of the following values:.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-volumetype
   */
  public volumeType?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVolumeProps) {
    super(scope, id, {
      "type": CfnVolume.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "availabilityZone", this);

    this.attrVolumeId = cdk.Token.asString(this.getAtt("VolumeId", cdk.ResolutionTypeHint.STRING));
    this.autoEnableIo = props.autoEnableIo;
    this.availabilityZone = props.availabilityZone;
    this.encrypted = props.encrypted;
    this.iops = props.iops;
    this.kmsKeyId = props.kmsKeyId;
    this.multiAttachEnabled = props.multiAttachEnabled;
    this.outpostArn = props.outpostArn;
    this.size = props.size;
    this.snapshotId = props.snapshotId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::Volume", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.throughput = props.throughput;
    this.volumeType = props.volumeType;
    if ((this.node.scope != null && cdk.Resource.isResource(this.node.scope))) {
      this.node.addValidation({
        "validate": () => ((this.cfnOptions.deletionPolicy === undefined) ? ["'AWS::EC2::Volume' is a stateful resource type, and you must specify a Removal Policy for it. Call 'resource.applyRemovalPolicy()'."] : [])
      });
    }
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "autoEnableIo": this.autoEnableIo,
      "availabilityZone": this.availabilityZone,
      "encrypted": this.encrypted,
      "iops": this.iops,
      "kmsKeyId": this.kmsKeyId,
      "multiAttachEnabled": this.multiAttachEnabled,
      "outpostArn": this.outpostArn,
      "size": this.size,
      "snapshotId": this.snapshotId,
      "tags": this.tags.renderTags(),
      "throughput": this.throughput,
      "volumeType": this.volumeType
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVolume.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVolumePropsToCloudFormation(props);
  }
}

export namespace CfnVolume {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html
   */
  export interface TagProperty {
    /**
     * Indicates whether the volume is auto-enabled for I/O operations.
     *
     * By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html#cfn-ec2-volume-tag-autoenableio
     */
    readonly autoEnableIo?: boolean | cdk.IResolvable;

    /**
     * The ID of the Availability Zone in which to create the volume.
     *
     * For example, \`us-east-1a\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html#cfn-ec2-volume-tag-availabilityzone
     */
    readonly availabilityZone: string;

    /**
     * Indicates whether the volume should be encrypted.
     *
     * The effect of setting the encryption state to \`true\` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Encryption by default](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html#cfn-ec2-volume-tag-encrypted
     */
    readonly encrypted?: boolean | cdk.IResolvable;

    /**
     * The number of I/O operations per second (IOPS).
     *
     * For \`gp3\` , \`io1\` , and \`io2\` volumes, this represents the number of IOPS that are provisioned for the volume. For \`gp2\` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
     *
     * The following are the supported values for each volume type:
     *
     * - \`gp3\` : 3,000-16,000 IOPS
     * - \`io1\` : 100-64,000 IOPS
     * - \`io2\` : 100-64,000 IOPS
     *
     * \`io1\` and \`io2\` volumes support up to 64,000 IOPS only on [Instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . Other instance families support performance up to 32,000 IOPS.
     *
     * This parameter is required for \`io1\` and \`io2\` volumes. The default for \`gp3\` volumes is 3,000 IOPS. This parameter is not supported for \`gp2\` , \`st1\` , \`sc1\` , or \`standard\` volumes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html#cfn-ec2-volume-tag-iops
     */
    readonly iops?: number;

    /**
     * The identifier of the AWS KMS key to use for Amazon EBS encryption.
     *
     * If \`KmsKeyId\` is specified, the encrypted state must be \`true\` .
     *
     * If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to \`true\` , then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the AWS managed key .
     *
     * Alternatively, if you want to specify a different key, you can specify one of the following:
     *
     * - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
     * - Key alias. Specify the alias for the key, prefixed with \`alias/\` . For example, for a key with the alias \`my_cmk\` , use \`alias/my_cmk\` . Or to specify the AWS managed key , use \`alias/aws/ebs\` .
     * - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.
     * - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html#cfn-ec2-volume-tag-kmskeyid
     */
    readonly kmsKeyId?: string;

    /**
     * Indicates whether Amazon EBS Multi-Attach is enabled.
     *
     * AWS CloudFormation does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html#cfn-ec2-volume-tag-multiattachenabled
     */
    readonly multiAttachEnabled?: boolean | cdk.IResolvable;

    /**
     * The Amazon Resource Name (ARN) of the Outpost.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html#cfn-ec2-volume-tag-outpostarn
     */
    readonly outpostArn?: string;

    /**
     * The size of the volume, in GiBs.
     *
     * You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
     *
     * The following are the supported volumes sizes for each volume type:
     *
     * - \`gp2\` and \`gp3\` : 1-16,384
     * - \`io1\` and \`io2\` : 4-16,384
     * - \`st1\` and \`sc1\` : 125-16,384
     * - \`standard\` : 1-1,024
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html#cfn-ec2-volume-tag-size
     */
    readonly size?: number;

    /**
     * The snapshot from which to create the volume.
     *
     * You must specify either a snapshot ID or a volume size.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html#cfn-ec2-volume-tag-snapshotid
     */
    readonly snapshotId?: string;

    /**
     * The tags to apply to the volume during creation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html#cfn-ec2-volume-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVolume.TagProperty> | cdk.IResolvable;

    /**
     * The throughput to provision for a volume, with a maximum of 1,000 MiB/s.
     *
     * This parameter is valid only for \`gp3\` volumes. The default value is 125.
     *
     * Valid Range: Minimum value of 125. Maximum value of 1000.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html#cfn-ec2-volume-tag-throughput
     */
    readonly throughput?: number;

    /**
     * The volume type. This parameter can be one of the following values:.
     *
     * - General Purpose SSD: \`gp2\` | \`gp3\`
     * - Provisioned IOPS SSD: \`io1\` | \`io2\`
     * - Throughput Optimized HDD: \`st1\`
     * - Cold HDD: \`sc1\`
     * - Magnetic: \`standard\`
     *
     * For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the *Amazon Elastic Compute Cloud User Guide* .
     *
     * Default: \`gp2\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-volume-tag.html#cfn-ec2-volume-tag-volumetype
     */
    readonly volumeType?: string;
  }
}

/**
 * Properties for defining a \`CfnVolume\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html
 */
export interface CfnVolumeProps {
  /**
   * Indicates whether the volume is auto-enabled for I/O operations.
   *
   * By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-autoenableio
   */
  readonly autoEnableIo?: boolean | cdk.IResolvable;

  /**
   * The ID of the Availability Zone in which to create the volume.
   *
   * For example, \`us-east-1a\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-availabilityzone
   */
  readonly availabilityZone: string;

  /**
   * Indicates whether the volume should be encrypted.
   *
   * The effect of setting the encryption state to \`true\` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Encryption by default](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-encrypted
   */
  readonly encrypted?: boolean | cdk.IResolvable;

  /**
   * The number of I/O operations per second (IOPS).
   *
   * For \`gp3\` , \`io1\` , and \`io2\` volumes, this represents the number of IOPS that are provisioned for the volume. For \`gp2\` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
   *
   * The following are the supported values for each volume type:
   *
   * - \`gp3\` : 3,000-16,000 IOPS
   * - \`io1\` : 100-64,000 IOPS
   * - \`io2\` : 100-64,000 IOPS
   *
   * \`io1\` and \`io2\` volumes support up to 64,000 IOPS only on [Instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . Other instance families support performance up to 32,000 IOPS.
   *
   * This parameter is required for \`io1\` and \`io2\` volumes. The default for \`gp3\` volumes is 3,000 IOPS. This parameter is not supported for \`gp2\` , \`st1\` , \`sc1\` , or \`standard\` volumes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-iops
   */
  readonly iops?: number;

  /**
   * The identifier of the AWS KMS key to use for Amazon EBS encryption.
   *
   * If \`KmsKeyId\` is specified, the encrypted state must be \`true\` .
   *
   * If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to \`true\` , then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the AWS managed key .
   *
   * Alternatively, if you want to specify a different key, you can specify one of the following:
   *
   * - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
   * - Key alias. Specify the alias for the key, prefixed with \`alias/\` . For example, for a key with the alias \`my_cmk\` , use \`alias/my_cmk\` . Or to specify the AWS managed key , use \`alias/aws/ebs\` .
   * - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.
   * - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-kmskeyid
   */
  readonly kmsKeyId?: string;

  /**
   * Indicates whether Amazon EBS Multi-Attach is enabled.
   *
   * AWS CloudFormation does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-multiattachenabled
   */
  readonly multiAttachEnabled?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Name (ARN) of the Outpost.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-outpostarn
   */
  readonly outpostArn?: string;

  /**
   * The size of the volume, in GiBs.
   *
   * You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
   *
   * The following are the supported volumes sizes for each volume type:
   *
   * - \`gp2\` and \`gp3\` : 1-16,384
   * - \`io1\` and \`io2\` : 4-16,384
   * - \`st1\` and \`sc1\` : 125-16,384
   * - \`standard\` : 1-1,024
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-size
   */
  readonly size?: number;

  /**
   * The snapshot from which to create the volume.
   *
   * You must specify either a snapshot ID or a volume size.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-snapshotid
   */
  readonly snapshotId?: string;

  /**
   * The tags to apply to the volume during creation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The throughput to provision for a volume, with a maximum of 1,000 MiB/s.
   *
   * This parameter is valid only for \`gp3\` volumes. The default value is 125.
   *
   * Valid Range: Minimum value of 125. Maximum value of 1000.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-throughput
   */
  readonly throughput?: number;

  /**
   * The volume type. This parameter can be one of the following values:.
   *
   * - General Purpose SSD: \`gp2\` | \`gp3\`
   * - Provisioned IOPS SSD: \`io1\` | \`io2\`
   * - Throughput Optimized HDD: \`st1\`
   * - Cold HDD: \`sc1\`
   * - Magnetic: \`standard\`
   *
   * For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the *Amazon Elastic Compute Cloud User Guide* .
   *
   * Default: \`gp2\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-volumetype
   */
  readonly volumeType?: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVolumeTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoEnableIo", cdk.validateBoolean)(properties.autoEnableIo));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.requiredValidator)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("encrypted", cdk.validateBoolean)(properties.encrypted));
  errors.collect(cdk.propertyValidator("iops", cdk.validateNumber)(properties.iops));
  errors.collect(cdk.propertyValidator("kmsKeyId", cdk.validateString)(properties.kmsKeyId));
  errors.collect(cdk.propertyValidator("multiAttachEnabled", cdk.validateBoolean)(properties.multiAttachEnabled));
  errors.collect(cdk.propertyValidator("outpostArn", cdk.validateString)(properties.outpostArn));
  errors.collect(cdk.propertyValidator("size", cdk.validateNumber)(properties.size));
  errors.collect(cdk.propertyValidator("snapshotId", cdk.validateString)(properties.snapshotId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVolumeTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("throughput", cdk.validateNumber)(properties.throughput));
  errors.collect(cdk.propertyValidator("volumeType", cdk.validateString)(properties.volumeType));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVolumeTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVolumeTagPropertyValidator(properties).assertSuccess();
  return {
    "AutoEnableIO": cdk.booleanToCloudFormation(properties.autoEnableIo),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "Encrypted": cdk.booleanToCloudFormation(properties.encrypted),
    "Iops": cdk.numberToCloudFormation(properties.iops),
    "KmsKeyId": cdk.stringToCloudFormation(properties.kmsKeyId),
    "MultiAttachEnabled": cdk.booleanToCloudFormation(properties.multiAttachEnabled),
    "OutpostArn": cdk.stringToCloudFormation(properties.outpostArn),
    "Size": cdk.numberToCloudFormation(properties.size),
    "SnapshotId": cdk.stringToCloudFormation(properties.snapshotId),
    "Tags": cdk.listMapper(convertCfnVolumeTagPropertyToCloudFormation)(properties.tags),
    "Throughput": cdk.numberToCloudFormation(properties.throughput),
    "VolumeType": cdk.stringToCloudFormation(properties.volumeType)
  };
}

// @ts-ignore TS6133
function CfnVolumeTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVolume.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVolume.TagProperty>();
  ret.addPropertyResult("autoEnableIo", "AutoEnableIO", (properties.AutoEnableIO != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoEnableIO) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("encrypted", "Encrypted", (properties.Encrypted != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Encrypted) : undefined));
  ret.addPropertyResult("iops", "Iops", (properties.Iops != null ? cfn_parse.FromCloudFormation.getNumber(properties.Iops) : undefined));
  ret.addPropertyResult("kmsKeyId", "KmsKeyId", (properties.KmsKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyId) : undefined));
  ret.addPropertyResult("multiAttachEnabled", "MultiAttachEnabled", (properties.MultiAttachEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.MultiAttachEnabled) : undefined));
  ret.addPropertyResult("outpostArn", "OutpostArn", (properties.OutpostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutpostArn) : undefined));
  ret.addPropertyResult("size", "Size", (properties.Size != null ? cfn_parse.FromCloudFormation.getNumber(properties.Size) : undefined));
  ret.addPropertyResult("snapshotId", "SnapshotId", (properties.SnapshotId != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVolumeTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("throughput", "Throughput", (properties.Throughput != null ? cfn_parse.FromCloudFormation.getNumber(properties.Throughput) : undefined));
  ret.addPropertyResult("volumeType", "VolumeType", (properties.VolumeType != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVolumeProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVolumeProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVolumePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoEnableIo", cdk.validateBoolean)(properties.autoEnableIo));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.requiredValidator)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("availabilityZone", cdk.validateString)(properties.availabilityZone));
  errors.collect(cdk.propertyValidator("encrypted", cdk.validateBoolean)(properties.encrypted));
  errors.collect(cdk.propertyValidator("iops", cdk.validateNumber)(properties.iops));
  errors.collect(cdk.propertyValidator("kmsKeyId", cdk.validateString)(properties.kmsKeyId));
  errors.collect(cdk.propertyValidator("multiAttachEnabled", cdk.validateBoolean)(properties.multiAttachEnabled));
  errors.collect(cdk.propertyValidator("outpostArn", cdk.validateString)(properties.outpostArn));
  errors.collect(cdk.propertyValidator("size", cdk.validateNumber)(properties.size));
  errors.collect(cdk.propertyValidator("snapshotId", cdk.validateString)(properties.snapshotId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("throughput", cdk.validateNumber)(properties.throughput));
  errors.collect(cdk.propertyValidator("volumeType", cdk.validateString)(properties.volumeType));
  return errors.wrap("supplied properties not correct for \\"CfnVolumeProps\\"");
}

// @ts-ignore TS6133
function convertCfnVolumePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVolumePropsValidator(properties).assertSuccess();
  return {
    "AutoEnableIO": cdk.booleanToCloudFormation(properties.autoEnableIo),
    "AvailabilityZone": cdk.stringToCloudFormation(properties.availabilityZone),
    "Encrypted": cdk.booleanToCloudFormation(properties.encrypted),
    "Iops": cdk.numberToCloudFormation(properties.iops),
    "KmsKeyId": cdk.stringToCloudFormation(properties.kmsKeyId),
    "MultiAttachEnabled": cdk.booleanToCloudFormation(properties.multiAttachEnabled),
    "OutpostArn": cdk.stringToCloudFormation(properties.outpostArn),
    "Size": cdk.numberToCloudFormation(properties.size),
    "SnapshotId": cdk.stringToCloudFormation(properties.snapshotId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Throughput": cdk.numberToCloudFormation(properties.throughput),
    "VolumeType": cdk.stringToCloudFormation(properties.volumeType)
  };
}

// @ts-ignore TS6133
function CfnVolumePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVolumeProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVolumeProps>();
  ret.addPropertyResult("autoEnableIo", "AutoEnableIO", (properties.AutoEnableIO != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoEnableIO) : undefined));
  ret.addPropertyResult("availabilityZone", "AvailabilityZone", (properties.AvailabilityZone != null ? cfn_parse.FromCloudFormation.getString(properties.AvailabilityZone) : undefined));
  ret.addPropertyResult("encrypted", "Encrypted", (properties.Encrypted != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Encrypted) : undefined));
  ret.addPropertyResult("iops", "Iops", (properties.Iops != null ? cfn_parse.FromCloudFormation.getNumber(properties.Iops) : undefined));
  ret.addPropertyResult("kmsKeyId", "KmsKeyId", (properties.KmsKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyId) : undefined));
  ret.addPropertyResult("multiAttachEnabled", "MultiAttachEnabled", (properties.MultiAttachEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.MultiAttachEnabled) : undefined));
  ret.addPropertyResult("outpostArn", "OutpostArn", (properties.OutpostArn != null ? cfn_parse.FromCloudFormation.getString(properties.OutpostArn) : undefined));
  ret.addPropertyResult("size", "Size", (properties.Size != null ? cfn_parse.FromCloudFormation.getNumber(properties.Size) : undefined));
  ret.addPropertyResult("snapshotId", "SnapshotId", (properties.SnapshotId != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("throughput", "Throughput", (properties.Throughput != null ? cfn_parse.FromCloudFormation.getNumber(properties.Throughput) : undefined));
  ret.addPropertyResult("volumeType", "VolumeType", (properties.VolumeType != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Attaches an Amazon EBS volume to a running instance and exposes it to the instance with the specified device name.
 *
 * Before this resource can be deleted (and therefore the volume detached), you must first unmount the volume in the instance. Failure to do so results in the volume being stuck in the busy state while it is trying to detach, which could possibly damage the file system or the data it contains.
 *
 * If an Amazon EBS volume is the root device of an instance, it cannot be detached while the instance is in the "running" state. To detach the root volume, stop the instance first.
 *
 * If the root volume is detached from an instance with an AWS Marketplace product code, then the product codes from that volume are no longer associated with the instance.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html
 */
export class CfnVolumeAttachment extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VolumeAttachment";

  /**
   * Build a CfnVolumeAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVolumeAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVolumeAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVolumeAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The device name (for example, \`/dev/sdh\` or \`xvdh\` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-device
   */
  public device: string;

  /**
   * The ID of the instance to which the volume attaches.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-instanceid
   */
  public instanceId: string;

  /**
   * The ID of the Amazon EBS volume.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-volumeid
   */
  public volumeId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVolumeAttachmentProps) {
    super(scope, id, {
      "type": CfnVolumeAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "device", this);
    cdk.requireProperty(props, "instanceId", this);
    cdk.requireProperty(props, "volumeId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.device = props.device;
    this.instanceId = props.instanceId;
    this.volumeId = props.volumeId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "device": this.device,
      "instanceId": this.instanceId,
      "volumeId": this.volumeId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVolumeAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVolumeAttachmentPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVolumeAttachment\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html
 */
export interface CfnVolumeAttachmentProps {
  /**
   * The device name (for example, \`/dev/sdh\` or \`xvdh\` ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-device
   */
  readonly device: string;

  /**
   * The ID of the instance to which the volume attaches.
   *
   * This value can be a reference to an [\`AWS::EC2::Instance\`](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource, or it can be the physical ID of an existing EC2 instance.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-instanceid
   */
  readonly instanceId: string;

  /**
   * The ID of the Amazon EBS volume.
   *
   * The volume and instance must be within the same Availability Zone. This value can be a reference to an [\`AWS::EC2::Volume\`](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html) resource, or it can be the volume ID of an existing Amazon EBS volume.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-volumeid
   */
  readonly volumeId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVolumeAttachmentProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVolumeAttachmentProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVolumeAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("device", cdk.requiredValidator)(properties.device));
  errors.collect(cdk.propertyValidator("device", cdk.validateString)(properties.device));
  errors.collect(cdk.propertyValidator("instanceId", cdk.requiredValidator)(properties.instanceId));
  errors.collect(cdk.propertyValidator("instanceId", cdk.validateString)(properties.instanceId));
  errors.collect(cdk.propertyValidator("volumeId", cdk.requiredValidator)(properties.volumeId));
  errors.collect(cdk.propertyValidator("volumeId", cdk.validateString)(properties.volumeId));
  return errors.wrap("supplied properties not correct for \\"CfnVolumeAttachmentProps\\"");
}

// @ts-ignore TS6133
function convertCfnVolumeAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVolumeAttachmentPropsValidator(properties).assertSuccess();
  return {
    "Device": cdk.stringToCloudFormation(properties.device),
    "InstanceId": cdk.stringToCloudFormation(properties.instanceId),
    "VolumeId": cdk.stringToCloudFormation(properties.volumeId)
  };
}

// @ts-ignore TS6133
function CfnVolumeAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVolumeAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVolumeAttachmentProps>();
  ret.addPropertyResult("device", "Device", (properties.Device != null ? cfn_parse.FromCloudFormation.getString(properties.Device) : undefined));
  ret.addPropertyResult("instanceId", "InstanceId", (properties.InstanceId != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceId) : undefined));
  ret.addPropertyResult("volumeId", "VolumeId", (properties.VolumeId != null ? cfn_parse.FromCloudFormation.getString(properties.VolumeId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a virtual private cloud (VPC).
 *
 * You can optionally request an IPv6 CIDR block for the VPC. You can request an Amazon-provided IPv6 CIDR block from Amazon's pool of IPv6 addresses, or an IPv6 CIDR block from an IPv6 address pool that you provisioned through bring your own IP addresses (BYOIP).
 *
 * For more information, see [Virtual private clouds (VPC)](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/configure-your-vpc.html) in the *Amazon VPC User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
 */
export class CfnVPC extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPC";

  /**
   * Build a CfnVPC from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPC {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPC(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The primary IPv4 CIDR block for the VPC. For example, 10.0.0.0/16.
   *
   * @cloudformationAttribute CidrBlock
   */
  public readonly attrCidrBlock: string;

  /**
   * The association IDs of the IPv4 CIDR blocks for the VPC. For example, [ vpc-cidr-assoc-0280ab6b ].
   *
   * @cloudformationAttribute CidrBlockAssociations
   */
  public readonly attrCidrBlockAssociations: Array<string>;

  /**
   * The ID of the default network ACL for the VPC. For example, acl-814dafe3.
   *
   * @cloudformationAttribute DefaultNetworkAcl
   */
  public readonly attrDefaultNetworkAcl: string;

  /**
   * The ID of the default security group for the VPC. For example, sg-b178e0d3.
   *
   * @cloudformationAttribute DefaultSecurityGroup
   */
  public readonly attrDefaultSecurityGroup: string;

  /**
   * The IPv6 CIDR blocks for the VPC. For example, [ 2001:db8:1234:1a00::/56 ].
   *
   * @cloudformationAttribute Ipv6CidrBlocks
   */
  public readonly attrIpv6CidrBlocks: Array<string>;

  /**
   * The ID of the VPC.
   *
   * @cloudformationAttribute VpcId
   */
  public readonly attrVpcId: string;

  /**
   * The IPv4 network range for the VPC, in CIDR notation.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-cidrblock
   */
  public cidrBlock?: string;

  /**
   * Indicates whether the instances launched in the VPC get DNS hostnames.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-enablednshostnames
   */
  public enableDnsHostnames?: boolean | cdk.IResolvable;

  /**
   * Indicates whether the DNS resolution is supported for the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-enablednssupport
   */
  public enableDnsSupport?: boolean | cdk.IResolvable;

  /**
   * The allowed tenancy of instances launched into the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-instancetenancy
   */
  public instanceTenancy?: string;

  /**
   * The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4ipampoolid
   */
  public ipv4IpamPoolId?: string;

  /**
   * The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4netmasklength
   */
  public ipv4NetmaskLength?: number;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags for the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCProps = {}) {
    super(scope, id, {
      "type": CfnVPC.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrCidrBlock = cdk.Token.asString(this.getAtt("CidrBlock", cdk.ResolutionTypeHint.STRING));
    this.attrCidrBlockAssociations = cdk.Token.asList(this.getAtt("CidrBlockAssociations", cdk.ResolutionTypeHint.STRING_LIST));
    this.attrDefaultNetworkAcl = cdk.Token.asString(this.getAtt("DefaultNetworkAcl", cdk.ResolutionTypeHint.STRING));
    this.attrDefaultSecurityGroup = cdk.Token.asString(this.getAtt("DefaultSecurityGroup", cdk.ResolutionTypeHint.STRING));
    this.attrIpv6CidrBlocks = cdk.Token.asList(this.getAtt("Ipv6CidrBlocks", cdk.ResolutionTypeHint.STRING_LIST));
    this.attrVpcId = cdk.Token.asString(this.getAtt("VpcId", cdk.ResolutionTypeHint.STRING));
    this.cidrBlock = props.cidrBlock;
    this.enableDnsHostnames = props.enableDnsHostnames;
    this.enableDnsSupport = props.enableDnsSupport;
    this.instanceTenancy = props.instanceTenancy;
    this.ipv4IpamPoolId = props.ipv4IpamPoolId;
    this.ipv4NetmaskLength = props.ipv4NetmaskLength;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VPC", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "cidrBlock": this.cidrBlock,
      "enableDnsHostnames": this.enableDnsHostnames,
      "enableDnsSupport": this.enableDnsSupport,
      "instanceTenancy": this.instanceTenancy,
      "ipv4IpamPoolId": this.ipv4IpamPoolId,
      "ipv4NetmaskLength": this.ipv4NetmaskLength,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPC.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCPropsToCloudFormation(props);
  }
}

export namespace CfnVPC {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpc-tag.html
   */
  export interface TagProperty {
    /**
     * The IPv4 network range for the VPC, in CIDR notation.
     *
     * For example, \`10.0.0.0/16\` . We modify the specified CIDR block to its canonical form; for example, if you specify \`100.68.0.18/18\` , we modify it to \`100.68.0.0/18\` .
     *
     * You must specify either \`CidrBlock\` or \`Ipv4IpamPoolId\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpc-tag.html#cfn-ec2-vpc-tag-cidrblock
     */
    readonly cidrBlock?: string;

    /**
     * Indicates whether the instances launched in the VPC get DNS hostnames.
     *
     * If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see [DNS attributes in your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support) .
     *
     * You can only enable DNS hostnames if you've enabled DNS support.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpc-tag.html#cfn-ec2-vpc-tag-enablednshostnames
     */
    readonly enableDnsHostnames?: boolean | cdk.IResolvable;

    /**
     * Indicates whether the DNS resolution is supported for the VPC.
     *
     * If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see [DNS attributes in your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpc-tag.html#cfn-ec2-vpc-tag-enablednssupport
     */
    readonly enableDnsSupport?: boolean | cdk.IResolvable;

    /**
     * The allowed tenancy of instances launched into the VPC.
     *
     * - \`default\` : An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch.
     * - \`dedicated\` : An instance launched into the VPC runs on dedicated hardware by default, unless you explicitly specify a tenancy of \`host\` during instance launch. You cannot specify a tenancy of \`default\` during instance launch.
     *
     * Updating \`InstanceTenancy\` requires no replacement only if you are updating its value from \`dedicated\` to \`default\` . Updating \`InstanceTenancy\` from \`default\` to \`dedicated\` requires replacement.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpc-tag.html#cfn-ec2-vpc-tag-instancetenancy
     */
    readonly instanceTenancy?: string;

    /**
     * The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR.
     *
     * For more information, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
     *
     * You must specify either \`CidrBlock\` or \`Ipv4IpamPoolId\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpc-tag.html#cfn-ec2-vpc-tag-ipv4ipampoolid
     */
    readonly ipv4IpamPoolId?: string;

    /**
     * The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool.
     *
     * For more information about IPAM, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpc-tag.html#cfn-ec2-vpc-tag-ipv4netmasklength
     */
    readonly ipv4NetmaskLength?: number;

    /**
     * The tags for the VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpc-tag.html#cfn-ec2-vpc-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVPC.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnVPC\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
 */
export interface CfnVPCProps {
  /**
   * The IPv4 network range for the VPC, in CIDR notation.
   *
   * For example, \`10.0.0.0/16\` . We modify the specified CIDR block to its canonical form; for example, if you specify \`100.68.0.18/18\` , we modify it to \`100.68.0.0/18\` .
   *
   * You must specify either \`CidrBlock\` or \`Ipv4IpamPoolId\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-cidrblock
   */
  readonly cidrBlock?: string;

  /**
   * Indicates whether the instances launched in the VPC get DNS hostnames.
   *
   * If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see [DNS attributes in your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support) .
   *
   * You can only enable DNS hostnames if you've enabled DNS support.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-enablednshostnames
   */
  readonly enableDnsHostnames?: boolean | cdk.IResolvable;

  /**
   * Indicates whether the DNS resolution is supported for the VPC.
   *
   * If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see [DNS attributes in your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-enablednssupport
   */
  readonly enableDnsSupport?: boolean | cdk.IResolvable;

  /**
   * The allowed tenancy of instances launched into the VPC.
   *
   * - \`default\` : An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch.
   * - \`dedicated\` : An instance launched into the VPC runs on dedicated hardware by default, unless you explicitly specify a tenancy of \`host\` during instance launch. You cannot specify a tenancy of \`default\` during instance launch.
   *
   * Updating \`InstanceTenancy\` requires no replacement only if you are updating its value from \`dedicated\` to \`default\` . Updating \`InstanceTenancy\` from \`default\` to \`dedicated\` requires replacement.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-instancetenancy
   */
  readonly instanceTenancy?: string;

  /**
   * The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR.
   *
   * For more information, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * You must specify either \`CidrBlock\` or \`Ipv4IpamPoolId\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4ipampoolid
   */
  readonly ipv4IpamPoolId?: string;

  /**
   * The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool.
   *
   * For more information about IPAM, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4netmasklength
   */
  readonly ipv4NetmaskLength?: number;

  /**
   * The tags for the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("enableDnsHostnames", cdk.validateBoolean)(properties.enableDnsHostnames));
  errors.collect(cdk.propertyValidator("enableDnsSupport", cdk.validateBoolean)(properties.enableDnsSupport));
  errors.collect(cdk.propertyValidator("instanceTenancy", cdk.validateString)(properties.instanceTenancy));
  errors.collect(cdk.propertyValidator("ipv4IpamPoolId", cdk.validateString)(properties.ipv4IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv4NetmaskLength", cdk.validateNumber)(properties.ipv4NetmaskLength));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVPCTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVPCTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCTagPropertyValidator(properties).assertSuccess();
  return {
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "EnableDnsHostnames": cdk.booleanToCloudFormation(properties.enableDnsHostnames),
    "EnableDnsSupport": cdk.booleanToCloudFormation(properties.enableDnsSupport),
    "InstanceTenancy": cdk.stringToCloudFormation(properties.instanceTenancy),
    "Ipv4IpamPoolId": cdk.stringToCloudFormation(properties.ipv4IpamPoolId),
    "Ipv4NetmaskLength": cdk.numberToCloudFormation(properties.ipv4NetmaskLength),
    "Tags": cdk.listMapper(convertCfnVPCTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnVPCTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVPC.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPC.TagProperty>();
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("enableDnsHostnames", "EnableDnsHostnames", (properties.EnableDnsHostnames != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableDnsHostnames) : undefined));
  ret.addPropertyResult("enableDnsSupport", "EnableDnsSupport", (properties.EnableDnsSupport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableDnsSupport) : undefined));
  ret.addPropertyResult("instanceTenancy", "InstanceTenancy", (properties.InstanceTenancy != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceTenancy) : undefined));
  ret.addPropertyResult("ipv4IpamPoolId", "Ipv4IpamPoolId", (properties.Ipv4IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv4IpamPoolId) : undefined));
  ret.addPropertyResult("ipv4NetmaskLength", "Ipv4NetmaskLength", (properties.Ipv4NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv4NetmaskLength) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVPCTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("enableDnsHostnames", cdk.validateBoolean)(properties.enableDnsHostnames));
  errors.collect(cdk.propertyValidator("enableDnsSupport", cdk.validateBoolean)(properties.enableDnsSupport));
  errors.collect(cdk.propertyValidator("instanceTenancy", cdk.validateString)(properties.instanceTenancy));
  errors.collect(cdk.propertyValidator("ipv4IpamPoolId", cdk.validateString)(properties.ipv4IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv4NetmaskLength", cdk.validateNumber)(properties.ipv4NetmaskLength));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnVPCProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCPropsValidator(properties).assertSuccess();
  return {
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "EnableDnsHostnames": cdk.booleanToCloudFormation(properties.enableDnsHostnames),
    "EnableDnsSupport": cdk.booleanToCloudFormation(properties.enableDnsSupport),
    "InstanceTenancy": cdk.stringToCloudFormation(properties.instanceTenancy),
    "Ipv4IpamPoolId": cdk.stringToCloudFormation(properties.ipv4IpamPoolId),
    "Ipv4NetmaskLength": cdk.numberToCloudFormation(properties.ipv4NetmaskLength),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnVPCPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCProps>();
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("enableDnsHostnames", "EnableDnsHostnames", (properties.EnableDnsHostnames != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableDnsHostnames) : undefined));
  ret.addPropertyResult("enableDnsSupport", "EnableDnsSupport", (properties.EnableDnsSupport != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableDnsSupport) : undefined));
  ret.addPropertyResult("instanceTenancy", "InstanceTenancy", (properties.InstanceTenancy != null ? cfn_parse.FromCloudFormation.getString(properties.InstanceTenancy) : undefined));
  ret.addPropertyResult("ipv4IpamPoolId", "Ipv4IpamPoolId", (properties.Ipv4IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv4IpamPoolId) : undefined));
  ret.addPropertyResult("ipv4NetmaskLength", "Ipv4NetmaskLength", (properties.Ipv4NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv4NetmaskLength) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a CIDR block with your VPC.
 *
 * You can only associate a single IPv6 CIDR block with your VPC. The IPv6 CIDR block size is fixed at /56.
 *
 * For more information about associating CIDR blocks with your VPC and applicable restrictions, see [VPC and Subnet Sizing](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#VPC_Sizing) in the *Amazon VPC User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html
 */
export class CfnVPCCidrBlock extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCCidrBlock";

  /**
   * Build a CfnVPCCidrBlock from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCCidrBlock {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCCidrBlockPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCCidrBlock(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-amazonprovidedipv6cidrblock
   */
  public amazonProvidedIpv6CidrBlock?: boolean | cdk.IResolvable;

  /**
   * An IPv4 CIDR block to associate with the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-cidrblock
   */
  public cidrBlock?: string;

  /**
   * Associate a CIDR allocated from an IPv4 IPAM pool to a VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4ipampoolid
   */
  public ipv4IpamPoolId?: string;

  /**
   * The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4netmasklength
   */
  public ipv4NetmaskLength?: number;

  /**
   * An IPv6 CIDR block from the IPv6 address pool. You must also specify \`Ipv6Pool\` in the request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6cidrblock
   */
  public ipv6CidrBlock?: string;

  /**
   * Associates a CIDR allocated from an IPv6 IPAM pool to a VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6ipampoolid
   */
  public ipv6IpamPoolId?: string;

  /**
   * The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6netmasklength
   */
  public ipv6NetmaskLength?: number;

  /**
   * The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6pool
   */
  public ipv6Pool?: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-vpcid
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCCidrBlockProps) {
    super(scope, id, {
      "type": CfnVPCCidrBlock.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.amazonProvidedIpv6CidrBlock = props.amazonProvidedIpv6CidrBlock;
    this.cidrBlock = props.cidrBlock;
    this.ipv4IpamPoolId = props.ipv4IpamPoolId;
    this.ipv4NetmaskLength = props.ipv4NetmaskLength;
    this.ipv6CidrBlock = props.ipv6CidrBlock;
    this.ipv6IpamPoolId = props.ipv6IpamPoolId;
    this.ipv6NetmaskLength = props.ipv6NetmaskLength;
    this.ipv6Pool = props.ipv6Pool;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "amazonProvidedIpv6CidrBlock": this.amazonProvidedIpv6CidrBlock,
      "cidrBlock": this.cidrBlock,
      "ipv4IpamPoolId": this.ipv4IpamPoolId,
      "ipv4NetmaskLength": this.ipv4NetmaskLength,
      "ipv6CidrBlock": this.ipv6CidrBlock,
      "ipv6IpamPoolId": this.ipv6IpamPoolId,
      "ipv6NetmaskLength": this.ipv6NetmaskLength,
      "ipv6Pool": this.ipv6Pool,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCCidrBlock.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCCidrBlockPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCCidrBlock\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html
 */
export interface CfnVPCCidrBlockProps {
  /**
   * Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC.
   *
   * You cannot specify the range of IPv6 addresses, or the size of the CIDR block.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-amazonprovidedipv6cidrblock
   */
  readonly amazonProvidedIpv6CidrBlock?: boolean | cdk.IResolvable;

  /**
   * An IPv4 CIDR block to associate with the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-cidrblock
   */
  readonly cidrBlock?: string;

  /**
   * Associate a CIDR allocated from an IPv4 IPAM pool to a VPC.
   *
   * For more information about Amazon VPC IP Address Manager (IPAM), see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4ipampoolid
   */
  readonly ipv4IpamPoolId?: string;

  /**
   * The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.
   *
   * For more information about IPAM, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4netmasklength
   */
  readonly ipv4NetmaskLength?: number;

  /**
   * An IPv6 CIDR block from the IPv6 address pool. You must also specify \`Ipv6Pool\` in the request.
   *
   * To let Amazon choose the IPv6 CIDR block for you, omit this parameter.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6cidrblock
   */
  readonly ipv6CidrBlock?: string;

  /**
   * Associates a CIDR allocated from an IPv6 IPAM pool to a VPC.
   *
   * For more information about Amazon VPC IP Address Manager (IPAM), see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6ipampoolid
   */
  readonly ipv6IpamPoolId?: string;

  /**
   * The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.
   *
   * For more information about IPAM, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6netmasklength
   */
  readonly ipv6NetmaskLength?: number;

  /**
   * The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6pool
   */
  readonly ipv6Pool?: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCCidrBlockProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCCidrBlockProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCCidrBlockPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amazonProvidedIpv6CidrBlock", cdk.validateBoolean)(properties.amazonProvidedIpv6CidrBlock));
  errors.collect(cdk.propertyValidator("cidrBlock", cdk.validateString)(properties.cidrBlock));
  errors.collect(cdk.propertyValidator("ipv4IpamPoolId", cdk.validateString)(properties.ipv4IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv4NetmaskLength", cdk.validateNumber)(properties.ipv4NetmaskLength));
  errors.collect(cdk.propertyValidator("ipv6CidrBlock", cdk.validateString)(properties.ipv6CidrBlock));
  errors.collect(cdk.propertyValidator("ipv6IpamPoolId", cdk.validateString)(properties.ipv6IpamPoolId));
  errors.collect(cdk.propertyValidator("ipv6NetmaskLength", cdk.validateNumber)(properties.ipv6NetmaskLength));
  errors.collect(cdk.propertyValidator("ipv6Pool", cdk.validateString)(properties.ipv6Pool));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCCidrBlockProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCCidrBlockPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCCidrBlockPropsValidator(properties).assertSuccess();
  return {
    "AmazonProvidedIpv6CidrBlock": cdk.booleanToCloudFormation(properties.amazonProvidedIpv6CidrBlock),
    "CidrBlock": cdk.stringToCloudFormation(properties.cidrBlock),
    "Ipv4IpamPoolId": cdk.stringToCloudFormation(properties.ipv4IpamPoolId),
    "Ipv4NetmaskLength": cdk.numberToCloudFormation(properties.ipv4NetmaskLength),
    "Ipv6CidrBlock": cdk.stringToCloudFormation(properties.ipv6CidrBlock),
    "Ipv6IpamPoolId": cdk.stringToCloudFormation(properties.ipv6IpamPoolId),
    "Ipv6NetmaskLength": cdk.numberToCloudFormation(properties.ipv6NetmaskLength),
    "Ipv6Pool": cdk.stringToCloudFormation(properties.ipv6Pool),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCCidrBlockPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCCidrBlockProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCCidrBlockProps>();
  ret.addPropertyResult("amazonProvidedIpv6CidrBlock", "AmazonProvidedIpv6CidrBlock", (properties.AmazonProvidedIpv6CidrBlock != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AmazonProvidedIpv6CidrBlock) : undefined));
  ret.addPropertyResult("cidrBlock", "CidrBlock", (properties.CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.CidrBlock) : undefined));
  ret.addPropertyResult("ipv4IpamPoolId", "Ipv4IpamPoolId", (properties.Ipv4IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv4IpamPoolId) : undefined));
  ret.addPropertyResult("ipv4NetmaskLength", "Ipv4NetmaskLength", (properties.Ipv4NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv4NetmaskLength) : undefined));
  ret.addPropertyResult("ipv6CidrBlock", "Ipv6CidrBlock", (properties.Ipv6CidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6CidrBlock) : undefined));
  ret.addPropertyResult("ipv6IpamPoolId", "Ipv6IpamPoolId", (properties.Ipv6IpamPoolId != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6IpamPoolId) : undefined));
  ret.addPropertyResult("ipv6NetmaskLength", "Ipv6NetmaskLength", (properties.Ipv6NetmaskLength != null ? cfn_parse.FromCloudFormation.getNumber(properties.Ipv6NetmaskLength) : undefined));
  ret.addPropertyResult("ipv6Pool", "Ipv6Pool", (properties.Ipv6Pool != null ? cfn_parse.FromCloudFormation.getString(properties.Ipv6Pool) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Associates a set of DHCP options with a VPC, or associates no DHCP options with the VPC.
 *
 * After you associate the options with the VPC, any existing instances and all new instances that you launch in that VPC use the options. You don't need to restart or relaunch the instances. They automatically pick up the changes within a few hours, depending on how frequently the instance renews its DHCP lease. You can explicitly renew the lease using the operating system on the instance.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html
 */
export class CfnVPCDHCPOptionsAssociation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCDHCPOptionsAssociation";

  /**
   * Build a CfnVPCDHCPOptionsAssociation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCDHCPOptionsAssociation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCDHCPOptionsAssociationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCDHCPOptionsAssociation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the DHCP options set, or \`default\` to associate no DHCP options with the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-dhcpoptionsid
   */
  public dhcpOptionsId: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-vpcid
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCDHCPOptionsAssociationProps) {
    super(scope, id, {
      "type": CfnVPCDHCPOptionsAssociation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "dhcpOptionsId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.dhcpOptionsId = props.dhcpOptionsId;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "dhcpOptionsId": this.dhcpOptionsId,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCDHCPOptionsAssociation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCDHCPOptionsAssociationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCDHCPOptionsAssociation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html
 */
export interface CfnVPCDHCPOptionsAssociationProps {
  /**
   * The ID of the DHCP options set, or \`default\` to associate no DHCP options with the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-dhcpoptionsid
   */
  readonly dhcpOptionsId: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCDHCPOptionsAssociationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCDHCPOptionsAssociationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCDHCPOptionsAssociationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("dhcpOptionsId", cdk.requiredValidator)(properties.dhcpOptionsId));
  errors.collect(cdk.propertyValidator("dhcpOptionsId", cdk.validateString)(properties.dhcpOptionsId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCDHCPOptionsAssociationProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCDHCPOptionsAssociationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCDHCPOptionsAssociationPropsValidator(properties).assertSuccess();
  return {
    "DhcpOptionsId": cdk.stringToCloudFormation(properties.dhcpOptionsId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCDHCPOptionsAssociationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCDHCPOptionsAssociationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCDHCPOptionsAssociationProps>();
  ret.addPropertyResult("dhcpOptionsId", "DhcpOptionsId", (properties.DhcpOptionsId != null ? cfn_parse.FromCloudFormation.getString(properties.DhcpOptionsId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a VPC endpoint for a service.
 *
 * An endpoint enables you to create a private connection between your VPC and the service. The service may be provided by AWS , an AWS Marketplace Partner, or another AWS account. For more information, see the [AWS PrivateLink User Guide](https://docs.aws.amazon.com/vpc/latest/privatelink/) .
 *
 * An interface endpoint establishes connections between the subnets in your VPC and an AWS service, your own service, or a service hosted by another AWS account . You can specify the subnets in which to create the endpoint and the security groups to associate with the endpoint network interface.
 *
 * A gateway endpoint serves as a target for a route in your route table for traffic destined for Amazon S3 or Amazon DynamoDB. You can specify an endpoint policy for the endpoint, which controls access to the service from your VPC. You can also specify the VPC route tables that use the endpoint. For information about connectivity to Amazon S3, see [Why can’t I connect to an S3 bucket using a gateway VPC endpoint?](https://docs.aws.amazon.com/premiumsupport/knowledge-center/connect-s3-vpc-endpoint)
 *
 * A Gateway Load Balancer endpoint provides private connectivity between your VPC and virtual appliances from a service provider.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html
 */
export class CfnVPCEndpoint extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCEndpoint";

  /**
   * Build a CfnVPCEndpoint from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCEndpoint {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCEndpointPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCEndpoint(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The date and time the VPC endpoint was created. For example: \`Fri Sep 28 23:34:36 UTC 2018.\`
   *
   * @cloudformationAttribute CreationTimestamp
   */
  public readonly attrCreationTimestamp: string;

  /**
   * (Interface endpoints) The DNS entries for the endpoint. Each entry is a combination of the hosted zone ID and the DNS name. The entries are ordered as follows: regional public DNS, zonal public DNS, private DNS, and wildcard DNS. This order is not enforced for AWS Marketplace services.
   *
   * The following is an example. In the first entry, the hosted zone ID is Z1HUB23UULQXV and the DNS name is vpce-01abc23456de78f9g-12abccd3.ec2.us-east-1.vpce.amazonaws.com.
   *
   * ["Z1HUB23UULQXV:vpce-01abc23456de78f9g-12abccd3.ec2.us-east-1.vpce.amazonaws.com", "Z1HUB23UULQXV:vpce-01abc23456de78f9g-12abccd3-us-east-1a.ec2.us-east-1.vpce.amazonaws.com", "Z1C12344VYDITB0:ec2.us-east-1.amazonaws.com"]
   *
   * If you update the \`PrivateDnsEnabled\` or \`SubnetIds\` properties, the DNS entries in the list will change.
   *
   * @cloudformationAttribute DnsEntries
   */
  public readonly attrDnsEntries: Array<string>;

  /**
   * The ID of the VPC endpoint.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * (Interface endpoints) The network interface IDs. If you update the \`PrivateDnsEnabled\` or \`SubnetIds\` properties, the items in this list might change.
   *
   * @cloudformationAttribute NetworkInterfaceIds
   */
  public readonly attrNetworkInterfaceIds: Array<string>;

  /**
   * A policy that controls access to the service from the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-policydocument
   */
  public policyDocument?: any | cdk.IResolvable | string;

  /**
   * Indicate whether to associate a private hosted zone with the specified VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-privatednsenabled
   */
  public privateDnsEnabled?: boolean | cdk.IResolvable;

  /**
   * The IDs of the route tables.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-routetableids
   */
  public routeTableIds?: Array<string>;

  /**
   * The IDs of the security groups to associate with the endpoint network interfaces.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-securitygroupids
   */
  public securityGroupIds?: Array<string>;

  /**
   * The service name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-servicename
   */
  public serviceName: string;

  /**
   * The IDs of the subnets in which to create endpoint network interfaces.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-subnetids
   */
  public subnetIds?: Array<string>;

  /**
   * The type of endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcendpointtype
   */
  public vpcEndpointType?: string;

  /**
   * The ID of the VPC for the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcid
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCEndpointProps) {
    super(scope, id, {
      "type": CfnVPCEndpoint.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "serviceName", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrCreationTimestamp = cdk.Token.asString(this.getAtt("CreationTimestamp", cdk.ResolutionTypeHint.STRING));
    this.attrDnsEntries = cdk.Token.asList(this.getAtt("DnsEntries", cdk.ResolutionTypeHint.STRING_LIST));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrNetworkInterfaceIds = cdk.Token.asList(this.getAtt("NetworkInterfaceIds", cdk.ResolutionTypeHint.STRING_LIST));
    this.policyDocument = props.policyDocument;
    this.privateDnsEnabled = props.privateDnsEnabled;
    this.routeTableIds = props.routeTableIds;
    this.securityGroupIds = props.securityGroupIds;
    this.serviceName = props.serviceName;
    this.subnetIds = props.subnetIds;
    this.vpcEndpointType = props.vpcEndpointType;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "policyDocument": this.policyDocument,
      "privateDnsEnabled": this.privateDnsEnabled,
      "routeTableIds": this.routeTableIds,
      "securityGroupIds": this.securityGroupIds,
      "serviceName": this.serviceName,
      "subnetIds": this.subnetIds,
      "vpcEndpointType": this.vpcEndpointType,
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCEndpoint.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCEndpointPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCEndpoint\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html
 */
export interface CfnVPCEndpointProps {
  /**
   * A policy that controls access to the service from the VPC.
   *
   * If this parameter is not specified, the default policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints.
   *
   * For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation converts YAML policies to JSON format before calling the API to create or modify the VPC endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-policydocument
   */
  readonly policyDocument?: any | cdk.IResolvable | string;

  /**
   * Indicate whether to associate a private hosted zone with the specified VPC.
   *
   * The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, \`kinesis.us-east-1.amazonaws.com\` ), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service.
   *
   * To use a private hosted zone, you must set the following VPC attributes to \`true\` : \`enableDnsHostnames\` and \`enableDnsSupport\` .
   *
   * This property is supported only for interface endpoints.
   *
   * Default: \`false\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-privatednsenabled
   */
  readonly privateDnsEnabled?: boolean | cdk.IResolvable;

  /**
   * The IDs of the route tables.
   *
   * Routing is supported only for gateway endpoints.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-routetableids
   */
  readonly routeTableIds?: Array<string>;

  /**
   * The IDs of the security groups to associate with the endpoint network interfaces.
   *
   * If this parameter is not specified, we use the default security group for the VPC. Security groups are supported only for interface endpoints.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-securitygroupids
   */
  readonly securityGroupIds?: Array<string>;

  /**
   * The service name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-servicename
   */
  readonly serviceName: string;

  /**
   * The IDs of the subnets in which to create endpoint network interfaces.
   *
   * You must specify this property for an interface endpoint or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-subnetids
   */
  readonly subnetIds?: Array<string>;

  /**
   * The type of endpoint.
   *
   * Default: Gateway
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcendpointtype
   */
  readonly vpcEndpointType?: string;

  /**
   * The ID of the VPC for the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCEndpointProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCEndpointProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCEndpointPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("policyDocument", cdk.unionValidator(cdk.validateObject, cdk.validateString))(properties.policyDocument));
  errors.collect(cdk.propertyValidator("privateDnsEnabled", cdk.validateBoolean)(properties.privateDnsEnabled));
  errors.collect(cdk.propertyValidator("routeTableIds", cdk.listValidator(cdk.validateString))(properties.routeTableIds));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("serviceName", cdk.requiredValidator)(properties.serviceName));
  errors.collect(cdk.propertyValidator("serviceName", cdk.validateString)(properties.serviceName));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  errors.collect(cdk.propertyValidator("vpcEndpointType", cdk.validateString)(properties.vpcEndpointType));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCEndpointProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCEndpointPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCEndpointPropsValidator(properties).assertSuccess();
  return {
    "PolicyDocument": cdk.unionMapper([cdk.validateObject, cdk.validateString], [cdk.objectToCloudFormation, cdk.stringToCloudFormation])(properties.policyDocument),
    "PrivateDnsEnabled": cdk.booleanToCloudFormation(properties.privateDnsEnabled),
    "RouteTableIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.routeTableIds),
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "ServiceName": cdk.stringToCloudFormation(properties.serviceName),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds),
    "VpcEndpointType": cdk.stringToCloudFormation(properties.vpcEndpointType),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCEndpointPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCEndpointProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCEndpointProps>();
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateObject, cdk.validateString], [cfn_parse.FromCloudFormation.getAny, cfn_parse.FromCloudFormation.getString])(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("privateDnsEnabled", "PrivateDnsEnabled", (properties.PrivateDnsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.PrivateDnsEnabled) : undefined));
  ret.addPropertyResult("routeTableIds", "RouteTableIds", (properties.RouteTableIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.RouteTableIds) : undefined));
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("serviceName", "ServiceName", (properties.ServiceName != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceName) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addPropertyResult("vpcEndpointType", "VpcEndpointType", (properties.VpcEndpointType != null ? cfn_parse.FromCloudFormation.getString(properties.VpcEndpointType) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a connection notification for a VPC endpoint or VPC endpoint service.
 *
 * A connection notification notifies you of specific endpoint events. You must create an SNS topic to receive notifications. For more information, see [Create a Topic](https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html) in the *Amazon Simple Notification Service Developer Guide* .
 *
 * You can create a connection notification for interface endpoints only.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html
 */
export class CfnVPCEndpointConnectionNotification extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCEndpointConnectionNotification";

  /**
   * Build a CfnVPCEndpointConnectionNotification from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCEndpointConnectionNotification {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCEndpointConnectionNotificationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCEndpointConnectionNotification(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The endpoint events for which to receive notifications.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionevents
   */
  public connectionEvents: Array<string>;

  /**
   * The ARN of the SNS topic for the notifications.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionnotificationarn
   */
  public connectionNotificationArn: string;

  /**
   * The ID of the endpoint service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-serviceid
   */
  public serviceId?: string;

  /**
   * The ID of the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-vpcendpointid
   */
  public vpcEndpointId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCEndpointConnectionNotificationProps) {
    super(scope, id, {
      "type": CfnVPCEndpointConnectionNotification.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "connectionEvents", this);
    cdk.requireProperty(props, "connectionNotificationArn", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.connectionEvents = props.connectionEvents;
    this.connectionNotificationArn = props.connectionNotificationArn;
    this.serviceId = props.serviceId;
    this.vpcEndpointId = props.vpcEndpointId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "connectionEvents": this.connectionEvents,
      "connectionNotificationArn": this.connectionNotificationArn,
      "serviceId": this.serviceId,
      "vpcEndpointId": this.vpcEndpointId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCEndpointConnectionNotification.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCEndpointConnectionNotificationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCEndpointConnectionNotification\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html
 */
export interface CfnVPCEndpointConnectionNotificationProps {
  /**
   * The endpoint events for which to receive notifications.
   *
   * Valid values are \`Accept\` , \`Connect\` , \`Delete\` , and \`Reject\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionevents
   */
  readonly connectionEvents: Array<string>;

  /**
   * The ARN of the SNS topic for the notifications.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionnotificationarn
   */
  readonly connectionNotificationArn: string;

  /**
   * The ID of the endpoint service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-serviceid
   */
  readonly serviceId?: string;

  /**
   * The ID of the endpoint.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-vpcendpointid
   */
  readonly vpcEndpointId?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCEndpointConnectionNotificationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCEndpointConnectionNotificationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCEndpointConnectionNotificationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("connectionEvents", cdk.requiredValidator)(properties.connectionEvents));
  errors.collect(cdk.propertyValidator("connectionEvents", cdk.listValidator(cdk.validateString))(properties.connectionEvents));
  errors.collect(cdk.propertyValidator("connectionNotificationArn", cdk.requiredValidator)(properties.connectionNotificationArn));
  errors.collect(cdk.propertyValidator("connectionNotificationArn", cdk.validateString)(properties.connectionNotificationArn));
  errors.collect(cdk.propertyValidator("serviceId", cdk.validateString)(properties.serviceId));
  errors.collect(cdk.propertyValidator("vpcEndpointId", cdk.validateString)(properties.vpcEndpointId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCEndpointConnectionNotificationProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCEndpointConnectionNotificationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCEndpointConnectionNotificationPropsValidator(properties).assertSuccess();
  return {
    "ConnectionEvents": cdk.listMapper(cdk.stringToCloudFormation)(properties.connectionEvents),
    "ConnectionNotificationArn": cdk.stringToCloudFormation(properties.connectionNotificationArn),
    "ServiceId": cdk.stringToCloudFormation(properties.serviceId),
    "VPCEndpointId": cdk.stringToCloudFormation(properties.vpcEndpointId)
  };
}

// @ts-ignore TS6133
function CfnVPCEndpointConnectionNotificationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCEndpointConnectionNotificationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCEndpointConnectionNotificationProps>();
  ret.addPropertyResult("connectionEvents", "ConnectionEvents", (properties.ConnectionEvents != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ConnectionEvents) : undefined));
  ret.addPropertyResult("connectionNotificationArn", "ConnectionNotificationArn", (properties.ConnectionNotificationArn != null ? cfn_parse.FromCloudFormation.getString(properties.ConnectionNotificationArn) : undefined));
  ret.addPropertyResult("serviceId", "ServiceId", (properties.ServiceId != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceId) : undefined));
  ret.addPropertyResult("vpcEndpointId", "VPCEndpointId", (properties.VPCEndpointId != null ? cfn_parse.FromCloudFormation.getString(properties.VPCEndpointId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a VPC endpoint service configuration to which service consumers ( AWS accounts, users, and IAM roles) can connect.
 *
 * To create an endpoint service configuration, you must first create one of the following for your service:
 *
 * - A [Network Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/introduction.html) . Service consumers connect to your service using an interface endpoint.
 * - A [Gateway Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/gateway/introduction.html) . Service consumers connect to your service using a Gateway Load Balancer endpoint.
 *
 * For more information, see the [AWS PrivateLink User Guide](https://docs.aws.amazon.com/vpc/latest/privatelink/) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html
 */
export class CfnVPCEndpointService extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCEndpointService";

  /**
   * Build a CfnVPCEndpointService from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCEndpointService {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCEndpointServicePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCEndpointService(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the endpoint service.
   *
   * @cloudformationAttribute ServiceId
   */
  public readonly attrServiceId: string;

  /**
   * Indicates whether requests from service consumers to create an endpoint to your service must be accepted.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-acceptancerequired
   */
  public acceptanceRequired?: boolean | cdk.IResolvable;

  /**
   * Indicates whether to enable the built-in Contributor Insights rules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-contributorinsightsenabled
   */
  public contributorInsightsEnabled?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Names (ARNs) of the Gateway Load Balancers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-gatewayloadbalancerarns
   */
  public gatewayLoadBalancerArns?: Array<string>;

  /**
   * The Amazon Resource Names (ARNs) of the Network Load Balancers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-networkloadbalancerarns
   */
  public networkLoadBalancerArns?: Array<string>;

  /**
   * The entity that is responsible for the endpoint costs.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-payerresponsibility
   */
  public payerResponsibility?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCEndpointServiceProps = {}) {
    super(scope, id, {
      "type": CfnVPCEndpointService.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrServiceId = cdk.Token.asString(this.getAtt("ServiceId", cdk.ResolutionTypeHint.STRING));
    this.acceptanceRequired = props.acceptanceRequired;
    this.contributorInsightsEnabled = props.contributorInsightsEnabled;
    this.gatewayLoadBalancerArns = props.gatewayLoadBalancerArns;
    this.networkLoadBalancerArns = props.networkLoadBalancerArns;
    this.payerResponsibility = props.payerResponsibility;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "acceptanceRequired": this.acceptanceRequired,
      "contributorInsightsEnabled": this.contributorInsightsEnabled,
      "gatewayLoadBalancerArns": this.gatewayLoadBalancerArns,
      "networkLoadBalancerArns": this.networkLoadBalancerArns,
      "payerResponsibility": this.payerResponsibility
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCEndpointService.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCEndpointServicePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCEndpointService\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html
 */
export interface CfnVPCEndpointServiceProps {
  /**
   * Indicates whether requests from service consumers to create an endpoint to your service must be accepted.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-acceptancerequired
   */
  readonly acceptanceRequired?: boolean | cdk.IResolvable;

  /**
   * Indicates whether to enable the built-in Contributor Insights rules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-contributorinsightsenabled
   */
  readonly contributorInsightsEnabled?: boolean | cdk.IResolvable;

  /**
   * The Amazon Resource Names (ARNs) of the Gateway Load Balancers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-gatewayloadbalancerarns
   */
  readonly gatewayLoadBalancerArns?: Array<string>;

  /**
   * The Amazon Resource Names (ARNs) of the Network Load Balancers.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-networkloadbalancerarns
   */
  readonly networkLoadBalancerArns?: Array<string>;

  /**
   * The entity that is responsible for the endpoint costs.
   *
   * The default is the endpoint owner. If you set the payer responsibility to the service owner, you cannot set it back to the endpoint owner.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-payerresponsibility
   */
  readonly payerResponsibility?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCEndpointServiceProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCEndpointServiceProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCEndpointServicePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("acceptanceRequired", cdk.validateBoolean)(properties.acceptanceRequired));
  errors.collect(cdk.propertyValidator("contributorInsightsEnabled", cdk.validateBoolean)(properties.contributorInsightsEnabled));
  errors.collect(cdk.propertyValidator("gatewayLoadBalancerArns", cdk.listValidator(cdk.validateString))(properties.gatewayLoadBalancerArns));
  errors.collect(cdk.propertyValidator("networkLoadBalancerArns", cdk.listValidator(cdk.validateString))(properties.networkLoadBalancerArns));
  errors.collect(cdk.propertyValidator("payerResponsibility", cdk.validateString)(properties.payerResponsibility));
  return errors.wrap("supplied properties not correct for \\"CfnVPCEndpointServiceProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCEndpointServicePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCEndpointServicePropsValidator(properties).assertSuccess();
  return {
    "AcceptanceRequired": cdk.booleanToCloudFormation(properties.acceptanceRequired),
    "ContributorInsightsEnabled": cdk.booleanToCloudFormation(properties.contributorInsightsEnabled),
    "GatewayLoadBalancerArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.gatewayLoadBalancerArns),
    "NetworkLoadBalancerArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.networkLoadBalancerArns),
    "PayerResponsibility": cdk.stringToCloudFormation(properties.payerResponsibility)
  };
}

// @ts-ignore TS6133
function CfnVPCEndpointServicePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCEndpointServiceProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCEndpointServiceProps>();
  ret.addPropertyResult("acceptanceRequired", "AcceptanceRequired", (properties.AcceptanceRequired != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AcceptanceRequired) : undefined));
  ret.addPropertyResult("contributorInsightsEnabled", "ContributorInsightsEnabled", (properties.ContributorInsightsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ContributorInsightsEnabled) : undefined));
  ret.addPropertyResult("gatewayLoadBalancerArns", "GatewayLoadBalancerArns", (properties.GatewayLoadBalancerArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GatewayLoadBalancerArns) : undefined));
  ret.addPropertyResult("networkLoadBalancerArns", "NetworkLoadBalancerArns", (properties.NetworkLoadBalancerArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NetworkLoadBalancerArns) : undefined));
  ret.addPropertyResult("payerResponsibility", "PayerResponsibility", (properties.PayerResponsibility != null ? cfn_parse.FromCloudFormation.getString(properties.PayerResponsibility) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Grant or revoke permissions for service consumers (users, IAM roles, and AWS accounts) to connect to a VPC endpoint service.
 *
 * If you grant permissions to all principals, the service is public. Any users who know the name of a public service can send a request to attach an endpoint. If the service does not require manual approval, attachments are automatically approved.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html
 */
export class CfnVPCEndpointServicePermissions extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCEndpointServicePermissions";

  /**
   * Build a CfnVPCEndpointServicePermissions from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCEndpointServicePermissions {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCEndpointServicePermissionsPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCEndpointServicePermissions(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Names (ARN) of one or more principals (users, IAM roles, and AWS accounts).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-allowedprincipals
   */
  public allowedPrincipals?: Array<string>;

  /**
   * The ID of the service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-serviceid
   */
  public serviceId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCEndpointServicePermissionsProps) {
    super(scope, id, {
      "type": CfnVPCEndpointServicePermissions.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "serviceId", this);

    this.allowedPrincipals = props.allowedPrincipals;
    this.serviceId = props.serviceId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "allowedPrincipals": this.allowedPrincipals,
      "serviceId": this.serviceId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCEndpointServicePermissions.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCEndpointServicePermissionsPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCEndpointServicePermissions\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html
 */
export interface CfnVPCEndpointServicePermissionsProps {
  /**
   * The Amazon Resource Names (ARN) of one or more principals (users, IAM roles, and AWS accounts).
   *
   * Permissions are granted to the principals in this list. To grant permissions to all principals, specify an asterisk (*). Permissions are revoked for principals not in this list. If the list is empty, then all permissions are revoked.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-allowedprincipals
   */
  readonly allowedPrincipals?: Array<string>;

  /**
   * The ID of the service.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-serviceid
   */
  readonly serviceId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCEndpointServicePermissionsProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCEndpointServicePermissionsProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCEndpointServicePermissionsPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allowedPrincipals", cdk.listValidator(cdk.validateString))(properties.allowedPrincipals));
  errors.collect(cdk.propertyValidator("serviceId", cdk.requiredValidator)(properties.serviceId));
  errors.collect(cdk.propertyValidator("serviceId", cdk.validateString)(properties.serviceId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCEndpointServicePermissionsProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCEndpointServicePermissionsPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCEndpointServicePermissionsPropsValidator(properties).assertSuccess();
  return {
    "AllowedPrincipals": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowedPrincipals),
    "ServiceId": cdk.stringToCloudFormation(properties.serviceId)
  };
}

// @ts-ignore TS6133
function CfnVPCEndpointServicePermissionsPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCEndpointServicePermissionsProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCEndpointServicePermissionsProps>();
  ret.addPropertyResult("allowedPrincipals", "AllowedPrincipals", (properties.AllowedPrincipals != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowedPrincipals) : undefined));
  ret.addPropertyResult("serviceId", "ServiceId", (properties.ServiceId != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Attaches an internet gateway, or a virtual private gateway to a VPC, enabling connectivity between the internet and the VPC.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html
 */
export class CfnVPCGatewayAttachment extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCGatewayAttachment";

  /**
   * Build a CfnVPCGatewayAttachment from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCGatewayAttachment {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCGatewayAttachmentPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCGatewayAttachment(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the internet gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-internetgatewayid
   */
  public internetGatewayId?: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-vpcid
   */
  public vpcId: string;

  /**
   * The ID of the virtual private gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-vpngatewayid
   */
  public vpnGatewayId?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCGatewayAttachmentProps) {
    super(scope, id, {
      "type": CfnVPCGatewayAttachment.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.internetGatewayId = props.internetGatewayId;
    this.vpcId = props.vpcId;
    this.vpnGatewayId = props.vpnGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "internetGatewayId": this.internetGatewayId,
      "vpcId": this.vpcId,
      "vpnGatewayId": this.vpnGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCGatewayAttachment.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCGatewayAttachmentPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPCGatewayAttachment\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html
 */
export interface CfnVPCGatewayAttachmentProps {
  /**
   * The ID of the internet gateway.
   *
   * You must specify either \`InternetGatewayId\` or \`VpnGatewayId\` , but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-internetgatewayid
   */
  readonly internetGatewayId?: string;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-vpcid
   */
  readonly vpcId: string;

  /**
   * The ID of the virtual private gateway.
   *
   * You must specify either \`InternetGatewayId\` or \`VpnGatewayId\` , but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-vpngatewayid
   */
  readonly vpnGatewayId?: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCGatewayAttachmentProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCGatewayAttachmentProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCGatewayAttachmentPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("internetGatewayId", cdk.validateString)(properties.internetGatewayId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.validateString)(properties.vpnGatewayId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCGatewayAttachmentProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCGatewayAttachmentPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCGatewayAttachmentPropsValidator(properties).assertSuccess();
  return {
    "InternetGatewayId": cdk.stringToCloudFormation(properties.internetGatewayId),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId),
    "VpnGatewayId": cdk.stringToCloudFormation(properties.vpnGatewayId)
  };
}

// @ts-ignore TS6133
function CfnVPCGatewayAttachmentPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCGatewayAttachmentProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCGatewayAttachmentProps>();
  ret.addPropertyResult("internetGatewayId", "InternetGatewayId", (properties.InternetGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.InternetGatewayId) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addPropertyResult("vpnGatewayId", "VpnGatewayId", (properties.VpnGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Requests a VPC peering connection between two VPCs: a requester VPC that you own and an accepter VPC with which to create the connection.
 *
 * The accepter VPC can belong to a different AWS account and can be in a different Region than the requester VPC.
 *
 * The requester VPC and accepter VPC cannot have overlapping CIDR blocks. If you create a VPC peering connection request between VPCs with overlapping CIDR blocks, the VPC peering connection has a status of \`failed\` .
 *
 * If the VPCs belong to different accounts, the acceptor account must have a role that allows the requester account to accept the VPC peering connection. For more information, see [Walkthough: Peer with a VPC in another AWS account](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/peer-with-vpc-in-another-account.html) .
 *
 * If the requester and acceptor VPCs are in the same account, the peering request is accepted without a peering role.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html
 */
export class CfnVPCPeeringConnection extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPCPeeringConnection";

  /**
   * Build a CfnVPCPeeringConnection from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPCPeeringConnection {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPCPeeringConnectionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPCPeeringConnection(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the peering connection.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The AWS account ID of the owner of the accepter VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerownerid
   */
  public peerOwnerId?: string;

  /**
   * The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerregion
   */
  public peerRegion?: string;

  /**
   * The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerrolearn
   */
  public peerRoleArn?: string;

  /**
   * The ID of the VPC with which you are creating the VPC peering connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peervpcid
   */
  public peerVpcId: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-vpcid
   */
  public vpcId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPCPeeringConnectionProps) {
    super(scope, id, {
      "type": CfnVPCPeeringConnection.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "peerVpcId", this);
    cdk.requireProperty(props, "vpcId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.peerOwnerId = props.peerOwnerId;
    this.peerRegion = props.peerRegion;
    this.peerRoleArn = props.peerRoleArn;
    this.peerVpcId = props.peerVpcId;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VPCPeeringConnection", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.vpcId = props.vpcId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "peerOwnerId": this.peerOwnerId,
      "peerRegion": this.peerRegion,
      "peerRoleArn": this.peerRoleArn,
      "peerVpcId": this.peerVpcId,
      "tags": this.tags.renderTags(),
      "vpcId": this.vpcId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPCPeeringConnection.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPCPeeringConnectionPropsToCloudFormation(props);
  }
}

export namespace CfnVPCPeeringConnection {
  /**
   * A key-value pair to associate with a resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcpeeringconnection-tag.html
   */
  export interface TagProperty {
    /**
     * The AWS account ID of the owner of the accepter VPC.
     *
     * Default: Your AWS account ID
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcpeeringconnection-tag.html#cfn-ec2-vpcpeeringconnection-tag-peerownerid
     */
    readonly peerOwnerId?: string;

    /**
     * The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.
     *
     * Default: The Region in which you make the request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcpeeringconnection-tag.html#cfn-ec2-vpcpeeringconnection-tag-peerregion
     */
    readonly peerRegion?: string;

    /**
     * The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account.
     *
     * This is required when you are peering a VPC in a different AWS account.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcpeeringconnection-tag.html#cfn-ec2-vpcpeeringconnection-tag-peerrolearn
     */
    readonly peerRoleArn?: string;

    /**
     * The ID of the VPC with which you are creating the VPC peering connection.
     *
     * You must specify this parameter in the request.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcpeeringconnection-tag.html#cfn-ec2-vpcpeeringconnection-tag-peervpcid
     */
    readonly peerVpcId: string;

    /**
     * Any tags assigned to the resource.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcpeeringconnection-tag.html#cfn-ec2-vpcpeeringconnection-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVPCPeeringConnection.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the VPC.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcpeeringconnection-tag.html#cfn-ec2-vpcpeeringconnection-tag-vpcid
     */
    readonly vpcId: string;
  }
}

/**
 * Properties for defining a \`CfnVPCPeeringConnection\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html
 */
export interface CfnVPCPeeringConnectionProps {
  /**
   * The AWS account ID of the owner of the accepter VPC.
   *
   * Default: Your AWS account ID
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerownerid
   */
  readonly peerOwnerId?: string;

  /**
   * The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.
   *
   * Default: The Region in which you make the request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerregion
   */
  readonly peerRegion?: string;

  /**
   * The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account.
   *
   * This is required when you are peering a VPC in a different AWS account.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerrolearn
   */
  readonly peerRoleArn?: string;

  /**
   * The ID of the VPC with which you are creating the VPC peering connection.
   *
   * You must specify this parameter in the request.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peervpcid
   */
  readonly peerVpcId: string;

  /**
   * Any tags assigned to the resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-vpcid
   */
  readonly vpcId: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCPeeringConnectionTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("peerOwnerId", cdk.validateString)(properties.peerOwnerId));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.validateString)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerRoleArn", cdk.validateString)(properties.peerRoleArn));
  errors.collect(cdk.propertyValidator("peerVpcId", cdk.requiredValidator)(properties.peerVpcId));
  errors.collect(cdk.propertyValidator("peerVpcId", cdk.validateString)(properties.peerVpcId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVPCPeeringConnectionTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVPCPeeringConnectionTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCPeeringConnectionTagPropertyValidator(properties).assertSuccess();
  return {
    "PeerOwnerId": cdk.stringToCloudFormation(properties.peerOwnerId),
    "PeerRegion": cdk.stringToCloudFormation(properties.peerRegion),
    "PeerRoleArn": cdk.stringToCloudFormation(properties.peerRoleArn),
    "PeerVpcId": cdk.stringToCloudFormation(properties.peerVpcId),
    "Tags": cdk.listMapper(convertCfnVPCPeeringConnectionTagPropertyToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCPeeringConnectionTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVPCPeeringConnection.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCPeeringConnection.TagProperty>();
  ret.addPropertyResult("peerOwnerId", "PeerOwnerId", (properties.PeerOwnerId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerOwnerId) : undefined));
  ret.addPropertyResult("peerRegion", "PeerRegion", (properties.PeerRegion != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRegion) : undefined));
  ret.addPropertyResult("peerRoleArn", "PeerRoleArn", (properties.PeerRoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRoleArn) : undefined));
  ret.addPropertyResult("peerVpcId", "PeerVpcId", (properties.PeerVpcId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerVpcId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVPCPeeringConnectionTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVPCPeeringConnectionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPCPeeringConnectionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPCPeeringConnectionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("peerOwnerId", cdk.validateString)(properties.peerOwnerId));
  errors.collect(cdk.propertyValidator("peerRegion", cdk.validateString)(properties.peerRegion));
  errors.collect(cdk.propertyValidator("peerRoleArn", cdk.validateString)(properties.peerRoleArn));
  errors.collect(cdk.propertyValidator("peerVpcId", cdk.requiredValidator)(properties.peerVpcId));
  errors.collect(cdk.propertyValidator("peerVpcId", cdk.validateString)(properties.peerVpcId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("vpcId", cdk.requiredValidator)(properties.vpcId));
  errors.collect(cdk.propertyValidator("vpcId", cdk.validateString)(properties.vpcId));
  return errors.wrap("supplied properties not correct for \\"CfnVPCPeeringConnectionProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPCPeeringConnectionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPCPeeringConnectionPropsValidator(properties).assertSuccess();
  return {
    "PeerOwnerId": cdk.stringToCloudFormation(properties.peerOwnerId),
    "PeerRegion": cdk.stringToCloudFormation(properties.peerRegion),
    "PeerRoleArn": cdk.stringToCloudFormation(properties.peerRoleArn),
    "PeerVpcId": cdk.stringToCloudFormation(properties.peerVpcId),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VpcId": cdk.stringToCloudFormation(properties.vpcId)
  };
}

// @ts-ignore TS6133
function CfnVPCPeeringConnectionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPCPeeringConnectionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPCPeeringConnectionProps>();
  ret.addPropertyResult("peerOwnerId", "PeerOwnerId", (properties.PeerOwnerId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerOwnerId) : undefined));
  ret.addPropertyResult("peerRegion", "PeerRegion", (properties.PeerRegion != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRegion) : undefined));
  ret.addPropertyResult("peerRoleArn", "PeerRoleArn", (properties.PeerRoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.PeerRoleArn) : undefined));
  ret.addPropertyResult("peerVpcId", "PeerVpcId", (properties.PeerVpcId != null ? cfn_parse.FromCloudFormation.getString(properties.PeerVpcId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("vpcId", "VpcId", (properties.VpcId != null ? cfn_parse.FromCloudFormation.getString(properties.VpcId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a VPN connection between a virtual private gateway and a VPN customer gateway or a transit gateway and a VPN customer gateway.
 *
 * To specify a VPN connection between a transit gateway and customer gateway, use the \`TransitGatewayId\` and \`CustomerGatewayId\` properties.
 *
 * To specify a VPN connection between a virtual private gateway and customer gateway, use the \`VpnGatewayId\` and \`CustomerGatewayId\` properties.
 *
 * For more information, see [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the *AWS Site-to-Site VPN User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html
 */
export class CfnVPNConnection extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPNConnection";

  /**
   * Build a CfnVPNConnection from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPNConnection {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPNConnectionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPNConnection(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the VPN connection.
   *
   * @cloudformationAttribute VpnConnectionId
   */
  public readonly attrVpnConnectionId: string;

  /**
   * The ID of the customer gateway at your end of the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-customergatewayid
   */
  public customerGatewayId: string;

  /**
   * Indicates whether the VPN connection uses static routes only.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-staticroutesonly
   */
  public staticRoutesOnly?: boolean | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway associated with the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-transitgatewayid
   */
  public transitGatewayId?: string;

  /**
   * The type of VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-type
   */
  public type: string;

  /**
   * The ID of the virtual private gateway at the AWS side of the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpngatewayid
   */
  public vpnGatewayId?: string;

  /**
   * The tunnel options for the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpntunneloptionsspecifications
   */
  public vpnTunnelOptionsSpecifications?: Array<cdk.IResolvable | CfnVPNConnection.VpnTunnelOptionsSpecificationProperty> | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPNConnectionProps) {
    super(scope, id, {
      "type": CfnVPNConnection.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "customerGatewayId", this);
    cdk.requireProperty(props, "type", this);

    this.attrVpnConnectionId = cdk.Token.asString(this.getAtt("VpnConnectionId", cdk.ResolutionTypeHint.STRING));
    this.customerGatewayId = props.customerGatewayId;
    this.staticRoutesOnly = props.staticRoutesOnly;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VPNConnection", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.transitGatewayId = props.transitGatewayId;
    this.type = props.type;
    this.vpnGatewayId = props.vpnGatewayId;
    this.vpnTunnelOptionsSpecifications = props.vpnTunnelOptionsSpecifications;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "customerGatewayId": this.customerGatewayId,
      "staticRoutesOnly": this.staticRoutesOnly,
      "tags": this.tags.renderTags(),
      "transitGatewayId": this.transitGatewayId,
      "type": this.type,
      "vpnGatewayId": this.vpnGatewayId,
      "vpnTunnelOptionsSpecifications": this.vpnTunnelOptionsSpecifications
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPNConnection.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPNConnectionPropsToCloudFormation(props);
  }
}

export namespace CfnVPNConnection {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-tag.html
   */
  export interface TagProperty {
    /**
     * The ID of the customer gateway at your end of the VPN connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-tag.html#cfn-ec2-vpnconnection-tag-customergatewayid
     */
    readonly customerGatewayId: string;

    /**
     * Indicates whether the VPN connection uses static routes only.
     *
     * Static routes must be used for devices that don't support BGP.
     *
     * If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-tag.html#cfn-ec2-vpnconnection-tag-staticroutesonly
     */
    readonly staticRoutesOnly?: boolean | cdk.IResolvable;

    /**
     * Any tags assigned to the VPN connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-tag.html#cfn-ec2-vpnconnection-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVPNConnection.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the transit gateway associated with the VPN connection.
     *
     * You must specify either \`TransitGatewayId\` or \`VpnGatewayId\` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-tag.html#cfn-ec2-vpnconnection-tag-transitgatewayid
     */
    readonly transitGatewayId?: string;

    /**
     * The type of VPN connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-tag.html#cfn-ec2-vpnconnection-tag-type
     */
    readonly type: string;

    /**
     * The ID of the virtual private gateway at the AWS side of the VPN connection.
     *
     * You must specify either \`TransitGatewayId\` or \`VpnGatewayId\` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-tag.html#cfn-ec2-vpnconnection-tag-vpngatewayid
     */
    readonly vpnGatewayId?: string;

    /**
     * The tunnel options for the VPN connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-tag.html#cfn-ec2-vpnconnection-tag-vpntunneloptionsspecifications
     */
    readonly vpnTunnelOptionsSpecifications?: Array<cdk.IResolvable | CfnVPNConnection.VpnTunnelOptionsSpecificationProperty> | cdk.IResolvable;
  }

  /**
   * The tunnel options for a single VPN tunnel.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html
   */
  export interface VpnTunnelOptionsSpecificationProperty {
    /**
     * The ID of the customer gateway at your end of the VPN connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-customergatewayid
     */
    readonly customerGatewayId: string;

    /**
     * Indicates whether the VPN connection uses static routes only.
     *
     * Static routes must be used for devices that don't support BGP.
     *
     * If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-staticroutesonly
     */
    readonly staticRoutesOnly?: boolean | cdk.IResolvable;

    /**
     * Any tags assigned to the VPN connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVPNConnection.TagProperty> | cdk.IResolvable;

    /**
     * The ID of the transit gateway associated with the VPN connection.
     *
     * You must specify either \`TransitGatewayId\` or \`VpnGatewayId\` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-transitgatewayid
     */
    readonly transitGatewayId?: string;

    /**
     * The type of VPN connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-type
     */
    readonly type: string;

    /**
     * The ID of the virtual private gateway at the AWS side of the VPN connection.
     *
     * You must specify either \`TransitGatewayId\` or \`VpnGatewayId\` , but not both.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-vpngatewayid
     */
    readonly vpnGatewayId?: string;

    /**
     * The tunnel options for the VPN connection.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-vpntunneloptionsspecifications
     */
    readonly vpnTunnelOptionsSpecifications?: Array<cdk.IResolvable | CfnVPNConnection.VpnTunnelOptionsSpecificationProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnVPNConnection\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html
 */
export interface CfnVPNConnectionProps {
  /**
   * The ID of the customer gateway at your end of the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-customergatewayid
   */
  readonly customerGatewayId: string;

  /**
   * Indicates whether the VPN connection uses static routes only.
   *
   * Static routes must be used for devices that don't support BGP.
   *
   * If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify \`true\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-staticroutesonly
   */
  readonly staticRoutesOnly?: boolean | cdk.IResolvable;

  /**
   * Any tags assigned to the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The ID of the transit gateway associated with the VPN connection.
   *
   * You must specify either \`TransitGatewayId\` or \`VpnGatewayId\` , but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-transitgatewayid
   */
  readonly transitGatewayId?: string;

  /**
   * The type of VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-type
   */
  readonly type: string;

  /**
   * The ID of the virtual private gateway at the AWS side of the VPN connection.
   *
   * You must specify either \`TransitGatewayId\` or \`VpnGatewayId\` , but not both.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpngatewayid
   */
  readonly vpnGatewayId?: string;

  /**
   * The tunnel options for the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpntunneloptionsspecifications
   */
  readonly vpnTunnelOptionsSpecifications?: Array<cdk.IResolvable | CfnVPNConnection.VpnTunnelOptionsSpecificationProperty> | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`VpnTunnelOptionsSpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`VpnTunnelOptionsSpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("customerGatewayId", cdk.requiredValidator)(properties.customerGatewayId));
  errors.collect(cdk.propertyValidator("customerGatewayId", cdk.validateString)(properties.customerGatewayId));
  errors.collect(cdk.propertyValidator("staticRoutesOnly", cdk.validateBoolean)(properties.staticRoutesOnly));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVPNConnectionTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.validateString)(properties.vpnGatewayId));
  errors.collect(cdk.propertyValidator("vpnTunnelOptionsSpecifications", cdk.listValidator(CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyValidator))(properties.vpnTunnelOptionsSpecifications));
  return errors.wrap("supplied properties not correct for \\"VpnTunnelOptionsSpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVPNConnectionVpnTunnelOptionsSpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyValidator(properties).assertSuccess();
  return {
    "CustomerGatewayId": cdk.stringToCloudFormation(properties.customerGatewayId),
    "StaticRoutesOnly": cdk.booleanToCloudFormation(properties.staticRoutesOnly),
    "Tags": cdk.listMapper(convertCfnVPNConnectionTagPropertyToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "Type": cdk.stringToCloudFormation(properties.type),
    "VpnGatewayId": cdk.stringToCloudFormation(properties.vpnGatewayId),
    "VpnTunnelOptionsSpecifications": cdk.listMapper(convertCfnVPNConnectionVpnTunnelOptionsSpecificationPropertyToCloudFormation)(properties.vpnTunnelOptionsSpecifications)
  };
}

// @ts-ignore TS6133
function CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVPNConnection.VpnTunnelOptionsSpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNConnection.VpnTunnelOptionsSpecificationProperty>();
  ret.addPropertyResult("customerGatewayId", "CustomerGatewayId", (properties.CustomerGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.CustomerGatewayId) : undefined));
  ret.addPropertyResult("staticRoutesOnly", "StaticRoutesOnly", (properties.StaticRoutesOnly != null ? cfn_parse.FromCloudFormation.getBoolean(properties.StaticRoutesOnly) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVPNConnectionTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("vpnGatewayId", "VpnGatewayId", (properties.VpnGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnGatewayId) : undefined));
  ret.addPropertyResult("vpnTunnelOptionsSpecifications", "VpnTunnelOptionsSpecifications", (properties.VpnTunnelOptionsSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyFromCloudFormation)(properties.VpnTunnelOptionsSpecifications) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNConnectionTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("customerGatewayId", cdk.requiredValidator)(properties.customerGatewayId));
  errors.collect(cdk.propertyValidator("customerGatewayId", cdk.validateString)(properties.customerGatewayId));
  errors.collect(cdk.propertyValidator("staticRoutesOnly", cdk.validateBoolean)(properties.staticRoutesOnly));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVPNConnectionTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.validateString)(properties.vpnGatewayId));
  errors.collect(cdk.propertyValidator("vpnTunnelOptionsSpecifications", cdk.listValidator(CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyValidator))(properties.vpnTunnelOptionsSpecifications));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVPNConnectionTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNConnectionTagPropertyValidator(properties).assertSuccess();
  return {
    "CustomerGatewayId": cdk.stringToCloudFormation(properties.customerGatewayId),
    "StaticRoutesOnly": cdk.booleanToCloudFormation(properties.staticRoutesOnly),
    "Tags": cdk.listMapper(convertCfnVPNConnectionTagPropertyToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "Type": cdk.stringToCloudFormation(properties.type),
    "VpnGatewayId": cdk.stringToCloudFormation(properties.vpnGatewayId),
    "VpnTunnelOptionsSpecifications": cdk.listMapper(convertCfnVPNConnectionVpnTunnelOptionsSpecificationPropertyToCloudFormation)(properties.vpnTunnelOptionsSpecifications)
  };
}

// @ts-ignore TS6133
function CfnVPNConnectionTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVPNConnection.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNConnection.TagProperty>();
  ret.addPropertyResult("customerGatewayId", "CustomerGatewayId", (properties.CustomerGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.CustomerGatewayId) : undefined));
  ret.addPropertyResult("staticRoutesOnly", "StaticRoutesOnly", (properties.StaticRoutesOnly != null ? cfn_parse.FromCloudFormation.getBoolean(properties.StaticRoutesOnly) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVPNConnectionTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("vpnGatewayId", "VpnGatewayId", (properties.VpnGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnGatewayId) : undefined));
  ret.addPropertyResult("vpnTunnelOptionsSpecifications", "VpnTunnelOptionsSpecifications", (properties.VpnTunnelOptionsSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyFromCloudFormation)(properties.VpnTunnelOptionsSpecifications) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVPNConnectionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPNConnectionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNConnectionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("customerGatewayId", cdk.requiredValidator)(properties.customerGatewayId));
  errors.collect(cdk.propertyValidator("customerGatewayId", cdk.validateString)(properties.customerGatewayId));
  errors.collect(cdk.propertyValidator("staticRoutesOnly", cdk.validateBoolean)(properties.staticRoutesOnly));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("transitGatewayId", cdk.validateString)(properties.transitGatewayId));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.validateString)(properties.vpnGatewayId));
  errors.collect(cdk.propertyValidator("vpnTunnelOptionsSpecifications", cdk.listValidator(CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyValidator))(properties.vpnTunnelOptionsSpecifications));
  return errors.wrap("supplied properties not correct for \\"CfnVPNConnectionProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPNConnectionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNConnectionPropsValidator(properties).assertSuccess();
  return {
    "CustomerGatewayId": cdk.stringToCloudFormation(properties.customerGatewayId),
    "StaticRoutesOnly": cdk.booleanToCloudFormation(properties.staticRoutesOnly),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TransitGatewayId": cdk.stringToCloudFormation(properties.transitGatewayId),
    "Type": cdk.stringToCloudFormation(properties.type),
    "VpnGatewayId": cdk.stringToCloudFormation(properties.vpnGatewayId),
    "VpnTunnelOptionsSpecifications": cdk.listMapper(convertCfnVPNConnectionVpnTunnelOptionsSpecificationPropertyToCloudFormation)(properties.vpnTunnelOptionsSpecifications)
  };
}

// @ts-ignore TS6133
function CfnVPNConnectionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPNConnectionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNConnectionProps>();
  ret.addPropertyResult("customerGatewayId", "CustomerGatewayId", (properties.CustomerGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.CustomerGatewayId) : undefined));
  ret.addPropertyResult("staticRoutesOnly", "StaticRoutesOnly", (properties.StaticRoutesOnly != null ? cfn_parse.FromCloudFormation.getBoolean(properties.StaticRoutesOnly) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("transitGatewayId", "TransitGatewayId", (properties.TransitGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.TransitGatewayId) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("vpnGatewayId", "VpnGatewayId", (properties.VpnGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnGatewayId) : undefined));
  ret.addPropertyResult("vpnTunnelOptionsSpecifications", "VpnTunnelOptionsSpecifications", (properties.VpnTunnelOptionsSpecifications != null ? cfn_parse.FromCloudFormation.getArray(CfnVPNConnectionVpnTunnelOptionsSpecificationPropertyFromCloudFormation)(properties.VpnTunnelOptionsSpecifications) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a static route for a VPN connection between an existing virtual private gateway and a VPN customer gateway.
 *
 * The static route allows traffic to be routed from the virtual private gateway to the VPN customer gateway.
 *
 * For more information, see [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the *AWS Site-to-Site VPN User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html
 */
export class CfnVPNConnectionRoute extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPNConnectionRoute";

  /**
   * Build a CfnVPNConnectionRoute from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPNConnectionRoute {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPNConnectionRoutePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPNConnectionRoute(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The CIDR block associated with the local subnet of the customer network.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html#cfn-ec2-vpnconnectionroute-destinationcidrblock
   */
  public destinationCidrBlock: string;

  /**
   * The ID of the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html#cfn-ec2-vpnconnectionroute-vpnconnectionid
   */
  public vpnConnectionId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPNConnectionRouteProps) {
    super(scope, id, {
      "type": CfnVPNConnectionRoute.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "destinationCidrBlock", this);
    cdk.requireProperty(props, "vpnConnectionId", this);

    this.destinationCidrBlock = props.destinationCidrBlock;
    this.vpnConnectionId = props.vpnConnectionId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "destinationCidrBlock": this.destinationCidrBlock,
      "vpnConnectionId": this.vpnConnectionId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPNConnectionRoute.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPNConnectionRoutePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPNConnectionRoute\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html
 */
export interface CfnVPNConnectionRouteProps {
  /**
   * The CIDR block associated with the local subnet of the customer network.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html#cfn-ec2-vpnconnectionroute-destinationcidrblock
   */
  readonly destinationCidrBlock: string;

  /**
   * The ID of the VPN connection.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html#cfn-ec2-vpnconnectionroute-vpnconnectionid
   */
  readonly vpnConnectionId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPNConnectionRouteProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPNConnectionRouteProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNConnectionRoutePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.requiredValidator)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("destinationCidrBlock", cdk.validateString)(properties.destinationCidrBlock));
  errors.collect(cdk.propertyValidator("vpnConnectionId", cdk.requiredValidator)(properties.vpnConnectionId));
  errors.collect(cdk.propertyValidator("vpnConnectionId", cdk.validateString)(properties.vpnConnectionId));
  return errors.wrap("supplied properties not correct for \\"CfnVPNConnectionRouteProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPNConnectionRoutePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNConnectionRoutePropsValidator(properties).assertSuccess();
  return {
    "DestinationCidrBlock": cdk.stringToCloudFormation(properties.destinationCidrBlock),
    "VpnConnectionId": cdk.stringToCloudFormation(properties.vpnConnectionId)
  };
}

// @ts-ignore TS6133
function CfnVPNConnectionRoutePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPNConnectionRouteProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNConnectionRouteProps>();
  ret.addPropertyResult("destinationCidrBlock", "DestinationCidrBlock", (properties.DestinationCidrBlock != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationCidrBlock) : undefined));
  ret.addPropertyResult("vpnConnectionId", "VpnConnectionId", (properties.VpnConnectionId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnConnectionId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Specifies a virtual private gateway.
 *
 * A virtual private gateway is the endpoint on the VPC side of your VPN connection. You can create a virtual private gateway before creating the VPC itself.
 *
 * For more information, see [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html) in the *AWS Site-to-Site VPN User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html
 */
export class CfnVPNGateway extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPNGateway";

  /**
   * Build a CfnVPNGateway from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPNGateway {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPNGatewayPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPNGateway(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the VPN gateway.
   *
   * @cloudformationAttribute VPNGatewayId
   */
  public readonly attrVpnGatewayId: string;

  /**
   * The private Autonomous System Number (ASN) for the Amazon side of a BGP session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-amazonsideasn
   */
  public amazonSideAsn?: number;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Any tags assigned to the virtual private gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The type of VPN connection the virtual private gateway supports.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-type
   */
  public type: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPNGatewayProps) {
    super(scope, id, {
      "type": CfnVPNGateway.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "type", this);

    this.attrVpnGatewayId = cdk.Token.asString(this.getAtt("VPNGatewayId", cdk.ResolutionTypeHint.STRING));
    this.amazonSideAsn = props.amazonSideAsn;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::EC2::VPNGateway", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.type = props.type;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "amazonSideAsn": this.amazonSideAsn,
      "tags": this.tags.renderTags(),
      "type": this.type
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPNGateway.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPNGatewayPropsToCloudFormation(props);
  }
}

export namespace CfnVPNGateway {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpngateway-tag.html
   */
  export interface TagProperty {
    /**
     * The private Autonomous System Number (ASN) for the Amazon side of a BGP session.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpngateway-tag.html#cfn-ec2-vpngateway-tag-amazonsideasn
     */
    readonly amazonSideAsn?: number;

    /**
     * Any tags assigned to the virtual private gateway.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpngateway-tag.html#cfn-ec2-vpngateway-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnVPNGateway.TagProperty> | cdk.IResolvable;

    /**
     * The type of VPN connection the virtual private gateway supports.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpngateway-tag.html#cfn-ec2-vpngateway-tag-type
     */
    readonly type: string;
  }
}

/**
 * Properties for defining a \`CfnVPNGateway\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html
 */
export interface CfnVPNGatewayProps {
  /**
   * The private Autonomous System Number (ASN) for the Amazon side of a BGP session.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-amazonsideasn
   */
  readonly amazonSideAsn?: number;

  /**
   * Any tags assigned to the virtual private gateway.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The type of VPN connection the virtual private gateway supports.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-type
   */
  readonly type: string;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNGatewayTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amazonSideAsn", cdk.validateNumber)(properties.amazonSideAsn));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnVPNGatewayTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVPNGatewayTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNGatewayTagPropertyValidator(properties).assertSuccess();
  return {
    "AmazonSideAsn": cdk.numberToCloudFormation(properties.amazonSideAsn),
    "Tags": cdk.listMapper(convertCfnVPNGatewayTagPropertyToCloudFormation)(properties.tags),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnVPNGatewayTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVPNGateway.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNGateway.TagProperty>();
  ret.addPropertyResult("amazonSideAsn", "AmazonSideAsn", (properties.AmazonSideAsn != null ? cfn_parse.FromCloudFormation.getNumber(properties.AmazonSideAsn) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnVPNGatewayTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVPNGatewayProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPNGatewayProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNGatewayPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("amazonSideAsn", cdk.validateNumber)(properties.amazonSideAsn));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"CfnVPNGatewayProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPNGatewayPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNGatewayPropsValidator(properties).assertSuccess();
  return {
    "AmazonSideAsn": cdk.numberToCloudFormation(properties.amazonSideAsn),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnVPNGatewayPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPNGatewayProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNGatewayProps>();
  ret.addPropertyResult("amazonSideAsn", "AmazonSideAsn", (properties.AmazonSideAsn != null ? cfn_parse.FromCloudFormation.getNumber(properties.AmazonSideAsn) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Enables a virtual private gateway (VGW) to propagate routes to the specified route table of a VPC.
 *
 * If you reference a VPN gateway that is in the same template as your VPN gateway route propagation, you must explicitly declare a dependency on the VPN gateway attachment. The \`AWS::EC2::VPNGatewayRoutePropagation\` resource cannot use the VPN gateway until it has successfully attached to the VPC. Add a [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) in the \`AWS::EC2::VPNGatewayRoutePropagation\` resource to explicitly declare a dependency on the VPN gateway attachment.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html
 */
export class CfnVPNGatewayRoutePropagation extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::EC2::VPNGatewayRoutePropagation";

  /**
   * Build a CfnVPNGatewayRoutePropagation from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVPNGatewayRoutePropagation {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVPNGatewayRoutePropagationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVPNGatewayRoutePropagation(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ID of the VPN gateway.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The ID of the route table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-routetableids
   */
  public routeTableIds: Array<string>;

  /**
   * The ID of the virtual private gateway that is attached to a VPC.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-vpngatewayid
   */
  public vpnGatewayId: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVPNGatewayRoutePropagationProps) {
    super(scope, id, {
      "type": CfnVPNGatewayRoutePropagation.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "routeTableIds", this);
    cdk.requireProperty(props, "vpnGatewayId", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.routeTableIds = props.routeTableIds;
    this.vpnGatewayId = props.vpnGatewayId;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "routeTableIds": this.routeTableIds,
      "vpnGatewayId": this.vpnGatewayId
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVPNGatewayRoutePropagation.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVPNGatewayRoutePropagationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnVPNGatewayRoutePropagation\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html
 */
export interface CfnVPNGatewayRoutePropagationProps {
  /**
   * The ID of the route table.
   *
   * The routing table must be associated with the same VPC that the virtual private gateway is attached to.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-routetableids
   */
  readonly routeTableIds: Array<string>;

  /**
   * The ID of the virtual private gateway that is attached to a VPC.
   *
   * The virtual private gateway must be attached to the same VPC that the routing tables are associated with.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-vpngatewayid
   */
  readonly vpnGatewayId: string;
}

/**
 * Determine whether the given properties match those of a \`CfnVPNGatewayRoutePropagationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVPNGatewayRoutePropagationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVPNGatewayRoutePropagationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("routeTableIds", cdk.requiredValidator)(properties.routeTableIds));
  errors.collect(cdk.propertyValidator("routeTableIds", cdk.listValidator(cdk.validateString))(properties.routeTableIds));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.requiredValidator)(properties.vpnGatewayId));
  errors.collect(cdk.propertyValidator("vpnGatewayId", cdk.validateString)(properties.vpnGatewayId));
  return errors.wrap("supplied properties not correct for \\"CfnVPNGatewayRoutePropagationProps\\"");
}

// @ts-ignore TS6133
function convertCfnVPNGatewayRoutePropagationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVPNGatewayRoutePropagationPropsValidator(properties).assertSuccess();
  return {
    "RouteTableIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.routeTableIds),
    "VpnGatewayId": cdk.stringToCloudFormation(properties.vpnGatewayId)
  };
}

// @ts-ignore TS6133
function CfnVPNGatewayRoutePropagationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVPNGatewayRoutePropagationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVPNGatewayRoutePropagationProps>();
  ret.addPropertyResult("routeTableIds", "RouteTableIds", (properties.RouteTableIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.RouteTableIds) : undefined));
  ret.addPropertyResult("vpnGatewayId", "VpnGatewayId", (properties.VpnGatewayId != null ? cfn_parse.FromCloudFormation.getString(properties.VpnGatewayId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-omics 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * Creates an annotation store.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html
 */
export class CfnAnnotationStore extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Omics::AnnotationStore";

  /**
   * Build a CfnAnnotationStore from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnAnnotationStore {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnAnnotationStorePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnAnnotationStore(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * When the store was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The store's ID.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The store's status.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The store's status message.
   *
   * @cloudformationAttribute StatusMessage
   */
  public readonly attrStatusMessage: string;

  /**
   * The store's ARN.
   *
   * @cloudformationAttribute StoreArn
   */
  public readonly attrStoreArn: string;

  /**
   * The store's size in bytes.
   *
   * @cloudformationAttribute StoreSizeBytes
   */
  public readonly attrStoreSizeBytes: cdk.IResolvable;

  /**
   * When the store was updated.
   *
   * @cloudformationAttribute UpdateTime
   */
  public readonly attrUpdateTime: string;

  /**
   * A description for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-description
   */
  public description?: string;

  /**
   * The name of the Annotation Store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-name
   */
  public name: string;

  /**
   * The genome reference for the store's annotations.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-reference
   */
  public reference?: cdk.IResolvable | CfnAnnotationStore.ReferenceItemProperty;

  /**
   * The store's server-side encryption (SSE) settings.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-sseconfig
   */
  public sseConfig?: cdk.IResolvable | CfnAnnotationStore.SseConfigProperty;

  /**
   * The annotation file format of the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-storeformat
   */
  public storeFormat: string;

  /**
   * File parsing options for the annotation store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-storeoptions
   */
  public storeOptions?: cdk.IResolvable | CfnAnnotationStore.StoreOptionsProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Tags for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnAnnotationStoreProps) {
    super(scope, id, {
      "type": CfnAnnotationStore.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "name", this);
    cdk.requireProperty(props, "storeFormat", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("StatusMessage", cdk.ResolutionTypeHint.STRING));
    this.attrStoreArn = cdk.Token.asString(this.getAtt("StoreArn", cdk.ResolutionTypeHint.STRING));
    this.attrStoreSizeBytes = this.getAtt("StoreSizeBytes", cdk.ResolutionTypeHint.NUMBER);
    this.attrUpdateTime = cdk.Token.asString(this.getAtt("UpdateTime", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.name = props.name;
    this.reference = props.reference;
    this.sseConfig = props.sseConfig;
    this.storeFormat = props.storeFormat;
    this.storeOptions = props.storeOptions;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Omics::AnnotationStore", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "name": this.name,
      "reference": this.reference,
      "sseConfig": this.sseConfig,
      "storeFormat": this.storeFormat,
      "storeOptions": this.storeOptions,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnAnnotationStore.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnAnnotationStorePropsToCloudFormation(props);
  }
}

export namespace CfnAnnotationStore {
  /**
   * A genome reference.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-referenceitem.html
   */
  export interface ReferenceItemProperty {
    /**
     * A description for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-referenceitem.html#cfn-omics-annotationstore-referenceitem-description
     */
    readonly description?: string;

    /**
     * The name of the Annotation Store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-referenceitem.html#cfn-omics-annotationstore-referenceitem-name
     */
    readonly name: string;

    /**
     * The genome reference for the store's annotations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-referenceitem.html#cfn-omics-annotationstore-referenceitem-reference
     */
    readonly reference?: cdk.IResolvable | CfnAnnotationStore.ReferenceItemProperty;

    /**
     * The store's server-side encryption (SSE) settings.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-referenceitem.html#cfn-omics-annotationstore-referenceitem-sseconfig
     */
    readonly sseConfig?: cdk.IResolvable | CfnAnnotationStore.SseConfigProperty;

    /**
     * The annotation file format of the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-referenceitem.html#cfn-omics-annotationstore-referenceitem-storeformat
     */
    readonly storeFormat: string;

    /**
     * File parsing options for the annotation store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-referenceitem.html#cfn-omics-annotationstore-referenceitem-storeoptions
     */
    readonly storeOptions?: cdk.IResolvable | CfnAnnotationStore.StoreOptionsProperty;

    /**
     * Tags for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-referenceitem.html#cfn-omics-annotationstore-referenceitem-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, string>;
  }

  /**
   * Server-side encryption (SSE) settings for a store.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-sseconfig.html
   */
  export interface SseConfigProperty {
    /**
     * A description for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-sseconfig.html#cfn-omics-annotationstore-sseconfig-description
     */
    readonly description?: string;

    /**
     * The name of the Annotation Store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-sseconfig.html#cfn-omics-annotationstore-sseconfig-name
     */
    readonly name: string;

    /**
     * The genome reference for the store's annotations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-sseconfig.html#cfn-omics-annotationstore-sseconfig-reference
     */
    readonly reference?: cdk.IResolvable | CfnAnnotationStore.ReferenceItemProperty;

    /**
     * The store's server-side encryption (SSE) settings.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-sseconfig.html#cfn-omics-annotationstore-sseconfig-sseconfig
     */
    readonly sseConfig?: cdk.IResolvable | CfnAnnotationStore.SseConfigProperty;

    /**
     * The annotation file format of the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-sseconfig.html#cfn-omics-annotationstore-sseconfig-storeformat
     */
    readonly storeFormat: string;

    /**
     * File parsing options for the annotation store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-sseconfig.html#cfn-omics-annotationstore-sseconfig-storeoptions
     */
    readonly storeOptions?: cdk.IResolvable | CfnAnnotationStore.StoreOptionsProperty;

    /**
     * Tags for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-sseconfig.html#cfn-omics-annotationstore-sseconfig-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, string>;
  }

  /**
   * The store's file parsing options.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-storeoptions.html
   */
  export interface StoreOptionsProperty {
    /**
     * A description for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-storeoptions.html#cfn-omics-annotationstore-storeoptions-description
     */
    readonly description?: string;

    /**
     * The name of the Annotation Store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-storeoptions.html#cfn-omics-annotationstore-storeoptions-name
     */
    readonly name: string;

    /**
     * The genome reference for the store's annotations.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-storeoptions.html#cfn-omics-annotationstore-storeoptions-reference
     */
    readonly reference?: cdk.IResolvable | CfnAnnotationStore.ReferenceItemProperty;

    /**
     * The store's server-side encryption (SSE) settings.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-storeoptions.html#cfn-omics-annotationstore-storeoptions-sseconfig
     */
    readonly sseConfig?: cdk.IResolvable | CfnAnnotationStore.SseConfigProperty;

    /**
     * The annotation file format of the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-storeoptions.html#cfn-omics-annotationstore-storeoptions-storeformat
     */
    readonly storeFormat: string;

    /**
     * File parsing options for the annotation store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-storeoptions.html#cfn-omics-annotationstore-storeoptions-storeoptions
     */
    readonly storeOptions?: cdk.IResolvable | CfnAnnotationStore.StoreOptionsProperty;

    /**
     * Tags for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-annotationstore-storeoptions.html#cfn-omics-annotationstore-storeoptions-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, string>;
  }
}

/**
 * Properties for defining a \`CfnAnnotationStore\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html
 */
export interface CfnAnnotationStoreProps {
  /**
   * A description for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-description
   */
  readonly description?: string;

  /**
   * The name of the Annotation Store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-name
   */
  readonly name: string;

  /**
   * The genome reference for the store's annotations.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-reference
   */
  readonly reference?: cdk.IResolvable | CfnAnnotationStore.ReferenceItemProperty;

  /**
   * The store's server-side encryption (SSE) settings.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-sseconfig
   */
  readonly sseConfig?: cdk.IResolvable | CfnAnnotationStore.SseConfigProperty;

  /**
   * The annotation file format of the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-storeformat
   */
  readonly storeFormat: string;

  /**
   * File parsing options for the annotation store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-storeoptions
   */
  readonly storeOptions?: cdk.IResolvable | CfnAnnotationStore.StoreOptionsProperty;

  /**
   * Tags for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-annotationstore.html#cfn-omics-annotationstore-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`StoreOptionsProperty\`
 *
 * @param properties - the TypeScript properties of a \`StoreOptionsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnAnnotationStoreStoreOptionsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("reference", CfnAnnotationStoreReferenceItemPropertyValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("sseConfig", CfnAnnotationStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("storeFormat", cdk.requiredValidator)(properties.storeFormat));
  errors.collect(cdk.propertyValidator("storeFormat", cdk.validateString)(properties.storeFormat));
  errors.collect(cdk.propertyValidator("storeOptions", CfnAnnotationStoreStoreOptionsPropertyValidator)(properties.storeOptions));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"StoreOptionsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnAnnotationStoreStoreOptionsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnAnnotationStoreStoreOptionsPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Reference": convertCfnAnnotationStoreReferenceItemPropertyToCloudFormation(properties.reference),
    "SseConfig": convertCfnAnnotationStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "StoreFormat": cdk.stringToCloudFormation(properties.storeFormat),
    "StoreOptions": convertCfnAnnotationStoreStoreOptionsPropertyToCloudFormation(properties.storeOptions),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnAnnotationStoreStoreOptionsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnAnnotationStore.StoreOptionsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnAnnotationStore.StoreOptionsProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("reference", "Reference", (properties.Reference != null ? CfnAnnotationStoreReferenceItemPropertyFromCloudFormation(properties.Reference) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnAnnotationStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("storeFormat", "StoreFormat", (properties.StoreFormat != null ? cfn_parse.FromCloudFormation.getString(properties.StoreFormat) : undefined));
  ret.addPropertyResult("storeOptions", "StoreOptions", (properties.StoreOptions != null ? CfnAnnotationStoreStoreOptionsPropertyFromCloudFormation(properties.StoreOptions) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SseConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`SseConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnAnnotationStoreSseConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("reference", CfnAnnotationStoreReferenceItemPropertyValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("sseConfig", CfnAnnotationStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("storeFormat", cdk.requiredValidator)(properties.storeFormat));
  errors.collect(cdk.propertyValidator("storeFormat", cdk.validateString)(properties.storeFormat));
  errors.collect(cdk.propertyValidator("storeOptions", CfnAnnotationStoreStoreOptionsPropertyValidator)(properties.storeOptions));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"SseConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnAnnotationStoreSseConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnAnnotationStoreSseConfigPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Reference": convertCfnAnnotationStoreReferenceItemPropertyToCloudFormation(properties.reference),
    "SseConfig": convertCfnAnnotationStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "StoreFormat": cdk.stringToCloudFormation(properties.storeFormat),
    "StoreOptions": convertCfnAnnotationStoreStoreOptionsPropertyToCloudFormation(properties.storeOptions),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnAnnotationStoreSseConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnAnnotationStore.SseConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnAnnotationStore.SseConfigProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("reference", "Reference", (properties.Reference != null ? CfnAnnotationStoreReferenceItemPropertyFromCloudFormation(properties.Reference) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnAnnotationStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("storeFormat", "StoreFormat", (properties.StoreFormat != null ? cfn_parse.FromCloudFormation.getString(properties.StoreFormat) : undefined));
  ret.addPropertyResult("storeOptions", "StoreOptions", (properties.StoreOptions != null ? CfnAnnotationStoreStoreOptionsPropertyFromCloudFormation(properties.StoreOptions) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReferenceItemProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReferenceItemProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnAnnotationStoreReferenceItemPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("reference", CfnAnnotationStoreReferenceItemPropertyValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("sseConfig", CfnAnnotationStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("storeFormat", cdk.requiredValidator)(properties.storeFormat));
  errors.collect(cdk.propertyValidator("storeFormat", cdk.validateString)(properties.storeFormat));
  errors.collect(cdk.propertyValidator("storeOptions", CfnAnnotationStoreStoreOptionsPropertyValidator)(properties.storeOptions));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"ReferenceItemProperty\\"");
}

// @ts-ignore TS6133
function convertCfnAnnotationStoreReferenceItemPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnAnnotationStoreReferenceItemPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Reference": convertCfnAnnotationStoreReferenceItemPropertyToCloudFormation(properties.reference),
    "SseConfig": convertCfnAnnotationStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "StoreFormat": cdk.stringToCloudFormation(properties.storeFormat),
    "StoreOptions": convertCfnAnnotationStoreStoreOptionsPropertyToCloudFormation(properties.storeOptions),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnAnnotationStoreReferenceItemPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnAnnotationStore.ReferenceItemProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnAnnotationStore.ReferenceItemProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("reference", "Reference", (properties.Reference != null ? CfnAnnotationStoreReferenceItemPropertyFromCloudFormation(properties.Reference) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnAnnotationStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("storeFormat", "StoreFormat", (properties.StoreFormat != null ? cfn_parse.FromCloudFormation.getString(properties.StoreFormat) : undefined));
  ret.addPropertyResult("storeOptions", "StoreOptions", (properties.StoreOptions != null ? CfnAnnotationStoreStoreOptionsPropertyFromCloudFormation(properties.StoreOptions) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnAnnotationStoreProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnAnnotationStoreProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnAnnotationStorePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("reference", CfnAnnotationStoreReferenceItemPropertyValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("sseConfig", CfnAnnotationStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("storeFormat", cdk.requiredValidator)(properties.storeFormat));
  errors.collect(cdk.propertyValidator("storeFormat", cdk.validateString)(properties.storeFormat));
  errors.collect(cdk.propertyValidator("storeOptions", CfnAnnotationStoreStoreOptionsPropertyValidator)(properties.storeOptions));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnAnnotationStoreProps\\"");
}

// @ts-ignore TS6133
function convertCfnAnnotationStorePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnAnnotationStorePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Reference": convertCfnAnnotationStoreReferenceItemPropertyToCloudFormation(properties.reference),
    "SseConfig": convertCfnAnnotationStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "StoreFormat": cdk.stringToCloudFormation(properties.storeFormat),
    "StoreOptions": convertCfnAnnotationStoreStoreOptionsPropertyToCloudFormation(properties.storeOptions),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnAnnotationStorePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnAnnotationStoreProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnAnnotationStoreProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("reference", "Reference", (properties.Reference != null ? CfnAnnotationStoreReferenceItemPropertyFromCloudFormation(properties.Reference) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnAnnotationStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("storeFormat", "StoreFormat", (properties.StoreFormat != null ? cfn_parse.FromCloudFormation.getString(properties.StoreFormat) : undefined));
  ret.addPropertyResult("storeOptions", "StoreOptions", (properties.StoreOptions != null ? CfnAnnotationStoreStoreOptionsPropertyFromCloudFormation(properties.StoreOptions) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a reference store.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html
 */
export class CfnReferenceStore extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Omics::ReferenceStore";

  /**
   * Build a CfnReferenceStore from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnReferenceStore {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnReferenceStorePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnReferenceStore(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The store's ARN.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * When the store was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The store's ID.
   *
   * @cloudformationAttribute ReferenceStoreId
   */
  public readonly attrReferenceStoreId: string;

  /**
   * A description for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html#cfn-omics-referencestore-description
   */
  public description?: string;

  /**
   * A name for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html#cfn-omics-referencestore-name
   */
  public name: string;

  /**
   * Server-side encryption (SSE) settings for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html#cfn-omics-referencestore-sseconfig
   */
  public sseConfig?: cdk.IResolvable | CfnReferenceStore.SseConfigProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Tags for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html#cfn-omics-referencestore-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnReferenceStoreProps) {
    super(scope, id, {
      "type": CfnReferenceStore.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "name", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrReferenceStoreId = cdk.Token.asString(this.getAtt("ReferenceStoreId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.name = props.name;
    this.sseConfig = props.sseConfig;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Omics::ReferenceStore", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "name": this.name,
      "sseConfig": this.sseConfig,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnReferenceStore.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnReferenceStorePropsToCloudFormation(props);
  }
}

export namespace CfnReferenceStore {
  /**
   * Server-side encryption (SSE) settings for a store.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-referencestore-sseconfig.html
   */
  export interface SseConfigProperty {
    /**
     * A description for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-referencestore-sseconfig.html#cfn-omics-referencestore-sseconfig-description
     */
    readonly description?: string;

    /**
     * A name for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-referencestore-sseconfig.html#cfn-omics-referencestore-sseconfig-name
     */
    readonly name: string;

    /**
     * Server-side encryption (SSE) settings for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-referencestore-sseconfig.html#cfn-omics-referencestore-sseconfig-sseconfig
     */
    readonly sseConfig?: cdk.IResolvable | CfnReferenceStore.SseConfigProperty;

    /**
     * Tags for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-referencestore-sseconfig.html#cfn-omics-referencestore-sseconfig-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, string>;
  }
}

/**
 * Properties for defining a \`CfnReferenceStore\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html
 */
export interface CfnReferenceStoreProps {
  /**
   * A description for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html#cfn-omics-referencestore-description
   */
  readonly description?: string;

  /**
   * A name for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html#cfn-omics-referencestore-name
   */
  readonly name: string;

  /**
   * Server-side encryption (SSE) settings for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html#cfn-omics-referencestore-sseconfig
   */
  readonly sseConfig?: cdk.IResolvable | CfnReferenceStore.SseConfigProperty;

  /**
   * Tags for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-referencestore.html#cfn-omics-referencestore-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`SseConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`SseConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnReferenceStoreSseConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("sseConfig", CfnReferenceStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"SseConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnReferenceStoreSseConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnReferenceStoreSseConfigPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "SseConfig": convertCfnReferenceStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnReferenceStoreSseConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnReferenceStore.SseConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnReferenceStore.SseConfigProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnReferenceStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnReferenceStoreProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnReferenceStoreProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnReferenceStorePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("sseConfig", CfnReferenceStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnReferenceStoreProps\\"");
}

// @ts-ignore TS6133
function convertCfnReferenceStorePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnReferenceStorePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "SseConfig": convertCfnReferenceStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnReferenceStorePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnReferenceStoreProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnReferenceStoreProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnReferenceStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a run group.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html
 */
export class CfnRunGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Omics::RunGroup";

  /**
   * Build a CfnRunGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnRunGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnRunGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnRunGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The run group's ARN.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * When the run group was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The run group's ID.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The group's maximum CPU count setting.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-maxcpus
   */
  public maxCpus?: number;

  /**
   * The group's maximum duration setting in minutes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-maxduration
   */
  public maxDuration?: number;

  /**
   * The group's maximum concurrent run setting.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-maxruns
   */
  public maxRuns?: number;

  /**
   * The group's name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-name
   */
  public name?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Tags for the group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnRunGroupProps = {}) {
    super(scope, id, {
      "type": CfnRunGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.maxCpus = props.maxCpus;
    this.maxDuration = props.maxDuration;
    this.maxRuns = props.maxRuns;
    this.name = props.name;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Omics::RunGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "maxCpus": this.maxCpus,
      "maxDuration": this.maxDuration,
      "maxRuns": this.maxRuns,
      "name": this.name,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnRunGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnRunGroupPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnRunGroup\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html
 */
export interface CfnRunGroupProps {
  /**
   * The group's maximum CPU count setting.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-maxcpus
   */
  readonly maxCpus?: number;

  /**
   * The group's maximum duration setting in minutes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-maxduration
   */
  readonly maxDuration?: number;

  /**
   * The group's maximum concurrent run setting.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-maxruns
   */
  readonly maxRuns?: number;

  /**
   * The group's name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-name
   */
  readonly name?: string;

  /**
   * Tags for the group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-rungroup.html#cfn-omics-rungroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnRunGroupProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnRunGroupProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnRunGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("maxCpus", cdk.validateNumber)(properties.maxCpus));
  errors.collect(cdk.propertyValidator("maxDuration", cdk.validateNumber)(properties.maxDuration));
  errors.collect(cdk.propertyValidator("maxRuns", cdk.validateNumber)(properties.maxRuns));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnRunGroupProps\\"");
}

// @ts-ignore TS6133
function convertCfnRunGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnRunGroupPropsValidator(properties).assertSuccess();
  return {
    "MaxCpus": cdk.numberToCloudFormation(properties.maxCpus),
    "MaxDuration": cdk.numberToCloudFormation(properties.maxDuration),
    "MaxRuns": cdk.numberToCloudFormation(properties.maxRuns),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnRunGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnRunGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnRunGroupProps>();
  ret.addPropertyResult("maxCpus", "MaxCpus", (properties.MaxCpus != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxCpus) : undefined));
  ret.addPropertyResult("maxDuration", "MaxDuration", (properties.MaxDuration != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxDuration) : undefined));
  ret.addPropertyResult("maxRuns", "MaxRuns", (properties.MaxRuns != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxRuns) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a sequence store.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html
 */
export class CfnSequenceStore extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Omics::SequenceStore";

  /**
   * Build a CfnSequenceStore from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSequenceStore {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSequenceStorePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSequenceStore(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The store's ARN.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * When the store was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The store's ID.
   *
   * @cloudformationAttribute SequenceStoreId
   */
  public readonly attrSequenceStoreId: string;

  /**
   * A description for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-description
   */
  public description?: string;

  /**
   * A name for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-name
   */
  public name: string;

  /**
   * Server-side encryption (SSE) settings for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-sseconfig
   */
  public sseConfig?: cdk.IResolvable | CfnSequenceStore.SseConfigProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Tags for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSequenceStoreProps) {
    super(scope, id, {
      "type": CfnSequenceStore.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "name", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrSequenceStoreId = cdk.Token.asString(this.getAtt("SequenceStoreId", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.name = props.name;
    this.sseConfig = props.sseConfig;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Omics::SequenceStore", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "name": this.name,
      "sseConfig": this.sseConfig,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSequenceStore.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSequenceStorePropsToCloudFormation(props);
  }
}

export namespace CfnSequenceStore {
  /**
   * Server-side encryption (SSE) settings for a store.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-sequencestore-sseconfig.html
   */
  export interface SseConfigProperty {
    /**
     * A description for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-sequencestore-sseconfig.html#cfn-omics-sequencestore-sseconfig-description
     */
    readonly description?: string;

    /**
     * A name for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-sequencestore-sseconfig.html#cfn-omics-sequencestore-sseconfig-name
     */
    readonly name: string;

    /**
     * Server-side encryption (SSE) settings for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-sequencestore-sseconfig.html#cfn-omics-sequencestore-sseconfig-sseconfig
     */
    readonly sseConfig?: cdk.IResolvable | CfnSequenceStore.SseConfigProperty;

    /**
     * Tags for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-sequencestore-sseconfig.html#cfn-omics-sequencestore-sseconfig-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, string>;
  }
}

/**
 * Properties for defining a \`CfnSequenceStore\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html
 */
export interface CfnSequenceStoreProps {
  /**
   * A description for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-description
   */
  readonly description?: string;

  /**
   * A name for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-name
   */
  readonly name: string;

  /**
   * Server-side encryption (SSE) settings for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-sseconfig
   */
  readonly sseConfig?: cdk.IResolvable | CfnSequenceStore.SseConfigProperty;

  /**
   * Tags for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-sequencestore.html#cfn-omics-sequencestore-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`SseConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`SseConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSequenceStoreSseConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("sseConfig", CfnSequenceStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"SseConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSequenceStoreSseConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSequenceStoreSseConfigPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "SseConfig": convertCfnSequenceStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnSequenceStoreSseConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSequenceStore.SseConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSequenceStore.SseConfigProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnSequenceStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSequenceStoreProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSequenceStoreProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSequenceStorePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("sseConfig", CfnSequenceStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnSequenceStoreProps\\"");
}

// @ts-ignore TS6133
function convertCfnSequenceStorePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSequenceStorePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "SseConfig": convertCfnSequenceStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnSequenceStorePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSequenceStoreProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSequenceStoreProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnSequenceStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Create a store for variant data.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html
 */
export class CfnVariantStore extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Omics::VariantStore";

  /**
   * Build a CfnVariantStore from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnVariantStore {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnVariantStorePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnVariantStore(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * When the store was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The store's ID.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The store's status.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The store's status message.
   *
   * @cloudformationAttribute StatusMessage
   */
  public readonly attrStatusMessage: string;

  /**
   * The store's ARN.
   *
   * @cloudformationAttribute StoreArn
   */
  public readonly attrStoreArn: string;

  /**
   * The store's size in bytes.
   *
   * @cloudformationAttribute StoreSizeBytes
   */
  public readonly attrStoreSizeBytes: cdk.IResolvable;

  /**
   * When the store was updated.
   *
   * @cloudformationAttribute UpdateTime
   */
  public readonly attrUpdateTime: string;

  /**
   * A description for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-description
   */
  public description?: string;

  /**
   * A name for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-name
   */
  public name: string;

  /**
   * The genome reference for the store's variants.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-reference
   */
  public reference: cdk.IResolvable | CfnVariantStore.ReferenceItemProperty;

  /**
   * Server-side encryption (SSE) settings for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-sseconfig
   */
  public sseConfig?: cdk.IResolvable | CfnVariantStore.SseConfigProperty;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Tags for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnVariantStoreProps) {
    super(scope, id, {
      "type": CfnVariantStore.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "name", this);
    cdk.requireProperty(props, "reference", this);

    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrStatusMessage = cdk.Token.asString(this.getAtt("StatusMessage", cdk.ResolutionTypeHint.STRING));
    this.attrStoreArn = cdk.Token.asString(this.getAtt("StoreArn", cdk.ResolutionTypeHint.STRING));
    this.attrStoreSizeBytes = this.getAtt("StoreSizeBytes", cdk.ResolutionTypeHint.NUMBER);
    this.attrUpdateTime = cdk.Token.asString(this.getAtt("UpdateTime", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.name = props.name;
    this.reference = props.reference;
    this.sseConfig = props.sseConfig;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Omics::VariantStore", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "name": this.name,
      "reference": this.reference,
      "sseConfig": this.sseConfig,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnVariantStore.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnVariantStorePropsToCloudFormation(props);
  }
}

export namespace CfnVariantStore {
  /**
   * The read set's genome reference ARN.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-referenceitem.html
   */
  export interface ReferenceItemProperty {
    /**
     * A description for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-referenceitem.html#cfn-omics-variantstore-referenceitem-description
     */
    readonly description?: string;

    /**
     * A name for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-referenceitem.html#cfn-omics-variantstore-referenceitem-name
     */
    readonly name: string;

    /**
     * The genome reference for the store's variants.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-referenceitem.html#cfn-omics-variantstore-referenceitem-reference
     */
    readonly reference: cdk.IResolvable | CfnVariantStore.ReferenceItemProperty;

    /**
     * Server-side encryption (SSE) settings for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-referenceitem.html#cfn-omics-variantstore-referenceitem-sseconfig
     */
    readonly sseConfig?: cdk.IResolvable | CfnVariantStore.SseConfigProperty;

    /**
     * Tags for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-referenceitem.html#cfn-omics-variantstore-referenceitem-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, string>;
  }

  /**
   * Server-side encryption (SSE) settings for a store.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-sseconfig.html
   */
  export interface SseConfigProperty {
    /**
     * A description for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-sseconfig.html#cfn-omics-variantstore-sseconfig-description
     */
    readonly description?: string;

    /**
     * A name for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-sseconfig.html#cfn-omics-variantstore-sseconfig-name
     */
    readonly name: string;

    /**
     * The genome reference for the store's variants.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-sseconfig.html#cfn-omics-variantstore-sseconfig-reference
     */
    readonly reference: cdk.IResolvable | CfnVariantStore.ReferenceItemProperty;

    /**
     * Server-side encryption (SSE) settings for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-sseconfig.html#cfn-omics-variantstore-sseconfig-sseconfig
     */
    readonly sseConfig?: cdk.IResolvable | CfnVariantStore.SseConfigProperty;

    /**
     * Tags for the store.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-variantstore-sseconfig.html#cfn-omics-variantstore-sseconfig-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, string>;
  }
}

/**
 * Properties for defining a \`CfnVariantStore\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html
 */
export interface CfnVariantStoreProps {
  /**
   * A description for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-description
   */
  readonly description?: string;

  /**
   * A name for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-name
   */
  readonly name: string;

  /**
   * The genome reference for the store's variants.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-reference
   */
  readonly reference: cdk.IResolvable | CfnVariantStore.ReferenceItemProperty;

  /**
   * Server-side encryption (SSE) settings for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-sseconfig
   */
  readonly sseConfig?: cdk.IResolvable | CfnVariantStore.SseConfigProperty;

  /**
   * Tags for the store.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-variantstore.html#cfn-omics-variantstore-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`SseConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`SseConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVariantStoreSseConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("reference", cdk.requiredValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("reference", CfnVariantStoreReferenceItemPropertyValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("sseConfig", CfnVariantStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"SseConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVariantStoreSseConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVariantStoreSseConfigPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Reference": convertCfnVariantStoreReferenceItemPropertyToCloudFormation(properties.reference),
    "SseConfig": convertCfnVariantStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnVariantStoreSseConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVariantStore.SseConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVariantStore.SseConfigProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("reference", "Reference", (properties.Reference != null ? CfnVariantStoreReferenceItemPropertyFromCloudFormation(properties.Reference) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnVariantStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReferenceItemProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReferenceItemProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVariantStoreReferenceItemPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("reference", cdk.requiredValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("reference", CfnVariantStoreReferenceItemPropertyValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("sseConfig", CfnVariantStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"ReferenceItemProperty\\"");
}

// @ts-ignore TS6133
function convertCfnVariantStoreReferenceItemPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVariantStoreReferenceItemPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Reference": convertCfnVariantStoreReferenceItemPropertyToCloudFormation(properties.reference),
    "SseConfig": convertCfnVariantStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnVariantStoreReferenceItemPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnVariantStore.ReferenceItemProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVariantStore.ReferenceItemProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("reference", "Reference", (properties.Reference != null ? CfnVariantStoreReferenceItemPropertyFromCloudFormation(properties.Reference) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnVariantStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnVariantStoreProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnVariantStoreProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnVariantStorePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("reference", cdk.requiredValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("reference", CfnVariantStoreReferenceItemPropertyValidator)(properties.reference));
  errors.collect(cdk.propertyValidator("sseConfig", CfnVariantStoreSseConfigPropertyValidator)(properties.sseConfig));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnVariantStoreProps\\"");
}

// @ts-ignore TS6133
function convertCfnVariantStorePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnVariantStorePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "Name": cdk.stringToCloudFormation(properties.name),
    "Reference": convertCfnVariantStoreReferenceItemPropertyToCloudFormation(properties.reference),
    "SseConfig": convertCfnVariantStoreSseConfigPropertyToCloudFormation(properties.sseConfig),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnVariantStorePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnVariantStoreProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnVariantStoreProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("reference", "Reference", (properties.Reference != null ? CfnVariantStoreReferenceItemPropertyFromCloudFormation(properties.Reference) : undefined));
  ret.addPropertyResult("sseConfig", "SseConfig", (properties.SseConfig != null ? CfnVariantStoreSseConfigPropertyFromCloudFormation(properties.SseConfig) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Creates a workflow.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html
 */
export class CfnWorkflow extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Omics::Workflow";

  /**
   * Build a CfnWorkflow from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnWorkflow {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnWorkflowPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnWorkflow(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The ARN for the workflow.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * When the workflow was created.
   *
   * @cloudformationAttribute CreationTime
   */
  public readonly attrCreationTime: string;

  /**
   * The workflow's ID.
   *
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The workflow's status.
   *
   * @cloudformationAttribute Status
   */
  public readonly attrStatus: string;

  /**
   * The workflow's type.
   *
   * @cloudformationAttribute Type
   */
  public readonly attrType: string;

  /**
   * The URI of a definition for the workflow.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-definitionuri
   */
  public definitionUri?: string;

  /**
   * The parameter's description.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-description
   */
  public description?: string;

  /**
   * An engine for the workflow.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-engine
   */
  public engine?: string;

  /**
   * The path of the main definition file for the workflow.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-main
   */
  public main?: string;

  /**
   * The workflow's name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-name
   */
  public name?: string;

  /**
   * The workflow's parameter template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-parametertemplate
   */
  public parameterTemplate?: cdk.IResolvable | Record<string, cdk.IResolvable | CfnWorkflow.WorkflowParameterProperty>;

  /**
   * A storage capacity for the workflow in gigabytes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-storagecapacity
   */
  public storageCapacity?: number;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * Tags for the workflow.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnWorkflowProps = {}) {
    super(scope, id, {
      "type": CfnWorkflow.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrCreationTime = cdk.Token.asString(this.getAtt("CreationTime", cdk.ResolutionTypeHint.STRING));
    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.attrStatus = cdk.Token.asString(this.getAtt("Status", cdk.ResolutionTypeHint.STRING));
    this.attrType = cdk.Token.asString(this.getAtt("Type", cdk.ResolutionTypeHint.STRING));
    this.definitionUri = props.definitionUri;
    this.description = props.description;
    this.engine = props.engine;
    this.main = props.main;
    this.name = props.name;
    this.parameterTemplate = props.parameterTemplate;
    this.storageCapacity = props.storageCapacity;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Omics::Workflow", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "definitionUri": this.definitionUri,
      "description": this.description,
      "engine": this.engine,
      "main": this.main,
      "name": this.name,
      "parameterTemplate": this.parameterTemplate,
      "storageCapacity": this.storageCapacity,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnWorkflow.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnWorkflowPropsToCloudFormation(props);
  }
}

export namespace CfnWorkflow {
  /**
   * A workflow parameter.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-workflow-workflowparameter.html
   */
  export interface WorkflowParameterProperty {
    /**
     * The URI of a definition for the workflow.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-workflow-workflowparameter.html#cfn-omics-workflow-workflowparameter-definitionuri
     */
    readonly definitionUri?: string;

    /**
     * The parameter's description.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-workflow-workflowparameter.html#cfn-omics-workflow-workflowparameter-description
     */
    readonly description?: string;

    /**
     * An engine for the workflow.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-workflow-workflowparameter.html#cfn-omics-workflow-workflowparameter-engine
     */
    readonly engine?: string;

    /**
     * The path of the main definition file for the workflow.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-workflow-workflowparameter.html#cfn-omics-workflow-workflowparameter-main
     */
    readonly main?: string;

    /**
     * The workflow's name.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-workflow-workflowparameter.html#cfn-omics-workflow-workflowparameter-name
     */
    readonly name?: string;

    /**
     * The workflow's parameter template.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-workflow-workflowparameter.html#cfn-omics-workflow-workflowparameter-parametertemplate
     */
    readonly parameterTemplate?: cdk.IResolvable | Record<string, cdk.IResolvable | CfnWorkflow.WorkflowParameterProperty>;

    /**
     * A storage capacity for the workflow in gigabytes.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-workflow-workflowparameter.html#cfn-omics-workflow-workflowparameter-storagecapacity
     */
    readonly storageCapacity?: number;

    /**
     * Tags for the workflow.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-omics-workflow-workflowparameter.html#cfn-omics-workflow-workflowparameter-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, string>;
  }
}

/**
 * Properties for defining a \`CfnWorkflow\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html
 */
export interface CfnWorkflowProps {
  /**
   * The URI of a definition for the workflow.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-definitionuri
   */
  readonly definitionUri?: string;

  /**
   * The parameter's description.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-description
   */
  readonly description?: string;

  /**
   * An engine for the workflow.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-engine
   */
  readonly engine?: string;

  /**
   * The path of the main definition file for the workflow.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-main
   */
  readonly main?: string;

  /**
   * The workflow's name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-name
   */
  readonly name?: string;

  /**
   * The workflow's parameter template.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-parametertemplate
   */
  readonly parameterTemplate?: cdk.IResolvable | Record<string, cdk.IResolvable | CfnWorkflow.WorkflowParameterProperty>;

  /**
   * A storage capacity for the workflow in gigabytes.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-storagecapacity
   */
  readonly storageCapacity?: number;

  /**
   * Tags for the workflow.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-omics-workflow.html#cfn-omics-workflow-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`WorkflowParameterProperty\`
 *
 * @param properties - the TypeScript properties of a \`WorkflowParameterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnWorkflowWorkflowParameterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("definitionUri", cdk.validateString)(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("engine", cdk.validateString)(properties.engine));
  errors.collect(cdk.propertyValidator("main", cdk.validateString)(properties.main));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("parameterTemplate", cdk.hashValidator(CfnWorkflowWorkflowParameterPropertyValidator))(properties.parameterTemplate));
  errors.collect(cdk.propertyValidator("storageCapacity", cdk.validateNumber)(properties.storageCapacity));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateString))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"WorkflowParameterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnWorkflowWorkflowParameterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnWorkflowWorkflowParameterPropertyValidator(properties).assertSuccess();
  return {
    "DefinitionUri": cdk.stringToCloudFormation(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Engine": cdk.stringToCloudFormation(properties.engine),
    "Main": cdk.stringToCloudFormation(properties.main),
    "Name": cdk.stringToCloudFormation(properties.name),
    "ParameterTemplate": cdk.hashMapper(convertCfnWorkflowWorkflowParameterPropertyToCloudFormation)(properties.parameterTemplate),
    "StorageCapacity": cdk.numberToCloudFormation(properties.storageCapacity),
    "Tags": cdk.hashMapper(cdk.stringToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnWorkflowWorkflowParameterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnWorkflow.WorkflowParameterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnWorkflow.WorkflowParameterProperty>();
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getString(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("engine", "Engine", (properties.Engine != null ? cfn_parse.FromCloudFormation.getString(properties.Engine) : undefined));
  ret.addPropertyResult("main", "Main", (properties.Main != null ? cfn_parse.FromCloudFormation.getString(properties.Main) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("parameterTemplate", "ParameterTemplate", (properties.ParameterTemplate != null ? cfn_parse.FromCloudFormation.getMap(CfnWorkflowWorkflowParameterPropertyFromCloudFormation)(properties.ParameterTemplate) : undefined));
  ret.addPropertyResult("storageCapacity", "StorageCapacity", (properties.StorageCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.StorageCapacity) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnWorkflowProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnWorkflowProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnWorkflowPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("definitionUri", cdk.validateString)(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("engine", cdk.validateString)(properties.engine));
  errors.collect(cdk.propertyValidator("main", cdk.validateString)(properties.main));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("parameterTemplate", cdk.hashValidator(CfnWorkflowWorkflowParameterPropertyValidator))(properties.parameterTemplate));
  errors.collect(cdk.propertyValidator("storageCapacity", cdk.validateNumber)(properties.storageCapacity));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnWorkflowProps\\"");
}

// @ts-ignore TS6133
function convertCfnWorkflowPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnWorkflowPropsValidator(properties).assertSuccess();
  return {
    "DefinitionUri": cdk.stringToCloudFormation(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Engine": cdk.stringToCloudFormation(properties.engine),
    "Main": cdk.stringToCloudFormation(properties.main),
    "Name": cdk.stringToCloudFormation(properties.name),
    "ParameterTemplate": cdk.hashMapper(convertCfnWorkflowWorkflowParameterPropertyToCloudFormation)(properties.parameterTemplate),
    "StorageCapacity": cdk.numberToCloudFormation(properties.storageCapacity),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnWorkflowPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnWorkflowProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnWorkflowProps>();
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getString(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("engine", "Engine", (properties.Engine != null ? cfn_parse.FromCloudFormation.getString(properties.Engine) : undefined));
  ret.addPropertyResult("main", "Main", (properties.Main != null ? cfn_parse.FromCloudFormation.getString(properties.Main) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("parameterTemplate", "ParameterTemplate", (properties.ParameterTemplate != null ? cfn_parse.FromCloudFormation.getMap(CfnWorkflowWorkflowParameterPropertyFromCloudFormation)(properties.ParameterTemplate) : undefined));
  ret.addPropertyResult("storageCapacity", "StorageCapacity", (properties.StorageCapacity != null ? cfn_parse.FromCloudFormation.getNumber(properties.StorageCapacity) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-sam 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * Definition of AWS::Serverless::Api.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html
 */
export class CfnApi extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::Api";

  /**
   * Build a CfnApi from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApi {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApiPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApi(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-accesslogsetting
   */
  public accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-auth
   */
  public auth?: CfnApi.AuthProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-binarymediatypes
   */
  public binaryMediaTypes?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-cacheclusterenabled
   */
  public cacheClusterEnabled?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-cacheclustersize
   */
  public cacheClusterSize?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-canarysetting
   */
  public canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-cors
   */
  public cors?: CfnApi.CorsProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-definitionbody
   */
  public definitionBody?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-definitionuri
   */
  public definitionUri?: CfnApi.DefinitionUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-description
   */
  public description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-disableexecuteapiendpoint
   */
  public disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-domain
   */
  public domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-endpointconfiguration
   */
  public endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-gatewayresponses
   */
  public gatewayResponses?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-methodsettings
   */
  public methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-minimumcompressionsize
   */
  public minimumCompressionSize?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-models
   */
  public models?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-name
   */
  public name?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-openapiversion
   */
  public openApiVersion?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-stagename
   */
  public stageName?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-tracingenabled
   */
  public tracingEnabled?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-variables
   */
  public variables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApiProps = {}) {
    super(scope, id, {
      "type": CfnApi.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.accessLogSetting = props.accessLogSetting;
    this.auth = props.auth;
    this.binaryMediaTypes = props.binaryMediaTypes;
    this.cacheClusterEnabled = props.cacheClusterEnabled;
    this.cacheClusterSize = props.cacheClusterSize;
    this.canarySetting = props.canarySetting;
    this.cors = props.cors;
    this.definitionBody = props.definitionBody;
    this.definitionUri = props.definitionUri;
    this.description = props.description;
    this.disableExecuteApiEndpoint = props.disableExecuteApiEndpoint;
    this.domain = props.domain;
    this.endpointConfiguration = props.endpointConfiguration;
    this.gatewayResponses = props.gatewayResponses;
    this.methodSettings = props.methodSettings;
    this.minimumCompressionSize = props.minimumCompressionSize;
    this.models = props.models;
    this.name = props.name;
    this.openApiVersion = props.openApiVersion;
    this.stageName = props.stageName;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Serverless::Api", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.tracingEnabled = props.tracingEnabled;
    this.variables = props.variables;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "accessLogSetting": this.accessLogSetting,
      "auth": this.auth,
      "binaryMediaTypes": this.binaryMediaTypes,
      "cacheClusterEnabled": this.cacheClusterEnabled,
      "cacheClusterSize": this.cacheClusterSize,
      "canarySetting": this.canarySetting,
      "cors": this.cors,
      "definitionBody": this.definitionBody,
      "definitionUri": this.definitionUri,
      "description": this.description,
      "disableExecuteApiEndpoint": this.disableExecuteApiEndpoint,
      "domain": this.domain,
      "endpointConfiguration": this.endpointConfiguration,
      "gatewayResponses": this.gatewayResponses,
      "methodSettings": this.methodSettings,
      "minimumCompressionSize": this.minimumCompressionSize,
      "models": this.models,
      "name": this.name,
      "openApiVersion": this.openApiVersion,
      "stageName": this.stageName,
      "tags": this.tags.renderTags(),
      "tracingEnabled": this.tracingEnabled,
      "variables": this.variables
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApi.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApiPropsToCloudFormation(props);
  }
}

export namespace CfnApi {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html
   */
  export interface AccessLogSettingProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-accesslogsetting
     */
    readonly accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-auth
     */
    readonly auth?: CfnApi.AuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-binarymediatypes
     */
    readonly binaryMediaTypes?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-cacheclusterenabled
     */
    readonly cacheClusterEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-cacheclustersize
     */
    readonly cacheClusterSize?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-canarysetting
     */
    readonly canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-cors
     */
    readonly cors?: CfnApi.CorsProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-definitionuri
     */
    readonly definitionUri?: CfnApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-domain
     */
    readonly domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-endpointconfiguration
     */
    readonly endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-gatewayresponses
     */
    readonly gatewayResponses?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-methodsettings
     */
    readonly methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-minimumcompressionsize
     */
    readonly minimumCompressionSize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-models
     */
    readonly models?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-openapiversion
     */
    readonly openApiVersion?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-tracingenabled
     */
    readonly tracingEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-variables
     */
    readonly variables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html
   */
  export interface AuthProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-accesslogsetting
     */
    readonly accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-auth
     */
    readonly auth?: CfnApi.AuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-binarymediatypes
     */
    readonly binaryMediaTypes?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-cacheclusterenabled
     */
    readonly cacheClusterEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-cacheclustersize
     */
    readonly cacheClusterSize?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-canarysetting
     */
    readonly canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-cors
     */
    readonly cors?: CfnApi.CorsProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-definitionuri
     */
    readonly definitionUri?: CfnApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-domain
     */
    readonly domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-endpointconfiguration
     */
    readonly endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-gatewayresponses
     */
    readonly gatewayResponses?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-methodsettings
     */
    readonly methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-minimumcompressionsize
     */
    readonly minimumCompressionSize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-models
     */
    readonly models?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-openapiversion
     */
    readonly openApiVersion?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-tracingenabled
     */
    readonly tracingEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-variables
     */
    readonly variables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html
   */
  export interface CanarySettingProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-accesslogsetting
     */
    readonly accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-auth
     */
    readonly auth?: CfnApi.AuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-binarymediatypes
     */
    readonly binaryMediaTypes?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-cacheclusterenabled
     */
    readonly cacheClusterEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-cacheclustersize
     */
    readonly cacheClusterSize?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-canarysetting
     */
    readonly canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-cors
     */
    readonly cors?: CfnApi.CorsProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-definitionuri
     */
    readonly definitionUri?: CfnApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-domain
     */
    readonly domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-endpointconfiguration
     */
    readonly endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-gatewayresponses
     */
    readonly gatewayResponses?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-methodsettings
     */
    readonly methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-minimumcompressionsize
     */
    readonly minimumCompressionSize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-models
     */
    readonly models?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-openapiversion
     */
    readonly openApiVersion?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-tracingenabled
     */
    readonly tracingEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-variables
     */
    readonly variables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html
   */
  export interface CorsProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-accesslogsetting
     */
    readonly accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-auth
     */
    readonly auth?: CfnApi.AuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-binarymediatypes
     */
    readonly binaryMediaTypes?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-cacheclusterenabled
     */
    readonly cacheClusterEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-cacheclustersize
     */
    readonly cacheClusterSize?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-canarysetting
     */
    readonly canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-cors
     */
    readonly cors?: CfnApi.CorsProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-definitionuri
     */
    readonly definitionUri?: CfnApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-domain
     */
    readonly domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-endpointconfiguration
     */
    readonly endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-gatewayresponses
     */
    readonly gatewayResponses?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-methodsettings
     */
    readonly methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-minimumcompressionsize
     */
    readonly minimumCompressionSize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-models
     */
    readonly models?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-openapiversion
     */
    readonly openApiVersion?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-tracingenabled
     */
    readonly tracingEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-variables
     */
    readonly variables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html
   */
  export interface DefinitionUriProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-accesslogsetting
     */
    readonly accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-auth
     */
    readonly auth?: CfnApi.AuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-binarymediatypes
     */
    readonly binaryMediaTypes?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-cacheclusterenabled
     */
    readonly cacheClusterEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-cacheclustersize
     */
    readonly cacheClusterSize?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-canarysetting
     */
    readonly canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-cors
     */
    readonly cors?: CfnApi.CorsProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-definitionuri
     */
    readonly definitionUri?: CfnApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-domain
     */
    readonly domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-endpointconfiguration
     */
    readonly endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-gatewayresponses
     */
    readonly gatewayResponses?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-methodsettings
     */
    readonly methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-minimumcompressionsize
     */
    readonly minimumCompressionSize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-models
     */
    readonly models?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-openapiversion
     */
    readonly openApiVersion?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-tracingenabled
     */
    readonly tracingEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-variables
     */
    readonly variables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html
   */
  export interface DomainConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-accesslogsetting
     */
    readonly accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-auth
     */
    readonly auth?: CfnApi.AuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-binarymediatypes
     */
    readonly binaryMediaTypes?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-cacheclusterenabled
     */
    readonly cacheClusterEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-cacheclustersize
     */
    readonly cacheClusterSize?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-canarysetting
     */
    readonly canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-cors
     */
    readonly cors?: CfnApi.CorsProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-definitionuri
     */
    readonly definitionUri?: CfnApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-domain
     */
    readonly domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-endpointconfiguration
     */
    readonly endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-gatewayresponses
     */
    readonly gatewayResponses?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-methodsettings
     */
    readonly methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-minimumcompressionsize
     */
    readonly minimumCompressionSize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-models
     */
    readonly models?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-openapiversion
     */
    readonly openApiVersion?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-tracingenabled
     */
    readonly tracingEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-variables
     */
    readonly variables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html
   */
  export interface EndpointConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-accesslogsetting
     */
    readonly accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-auth
     */
    readonly auth?: CfnApi.AuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-binarymediatypes
     */
    readonly binaryMediaTypes?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-cacheclusterenabled
     */
    readonly cacheClusterEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-cacheclustersize
     */
    readonly cacheClusterSize?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-canarysetting
     */
    readonly canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-cors
     */
    readonly cors?: CfnApi.CorsProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-definitionuri
     */
    readonly definitionUri?: CfnApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-domain
     */
    readonly domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-endpointconfiguration
     */
    readonly endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-gatewayresponses
     */
    readonly gatewayResponses?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-methodsettings
     */
    readonly methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-minimumcompressionsize
     */
    readonly minimumCompressionSize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-models
     */
    readonly models?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-openapiversion
     */
    readonly openApiVersion?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-tracingenabled
     */
    readonly tracingEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-variables
     */
    readonly variables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }
}

/**
 * Properties for defining a \`CfnApi\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html
 */
export interface CfnApiProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-accesslogsetting
   */
  readonly accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-auth
   */
  readonly auth?: CfnApi.AuthProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-binarymediatypes
   */
  readonly binaryMediaTypes?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-cacheclusterenabled
   */
  readonly cacheClusterEnabled?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-cacheclustersize
   */
  readonly cacheClusterSize?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-canarysetting
   */
  readonly canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-cors
   */
  readonly cors?: CfnApi.CorsProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-definitionbody
   */
  readonly definitionBody?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-definitionuri
   */
  readonly definitionUri?: CfnApi.DefinitionUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-description
   */
  readonly description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-disableexecuteapiendpoint
   */
  readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-domain
   */
  readonly domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-endpointconfiguration
   */
  readonly endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-gatewayresponses
   */
  readonly gatewayResponses?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-methodsettings
   */
  readonly methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-minimumcompressionsize
   */
  readonly minimumCompressionSize?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-models
   */
  readonly models?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-name
   */
  readonly name?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-openapiversion
   */
  readonly openApiVersion?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-stagename
   */
  readonly stageName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-tracingenabled
   */
  readonly tracingEnabled?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-variables
   */
  readonly variables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
}

/**
 * Determine whether the given properties match those of a \`EndpointConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`EndpointConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiEndpointConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("binaryMediaTypes", cdk.listValidator(cdk.validateString))(properties.binaryMediaTypes));
  errors.collect(cdk.propertyValidator("cacheClusterEnabled", cdk.validateBoolean)(properties.cacheClusterEnabled));
  errors.collect(cdk.propertyValidator("cacheClusterSize", cdk.validateString)(properties.cacheClusterSize));
  errors.collect(cdk.propertyValidator("canarySetting", CfnApiCanarySettingPropertyValidator)(properties.canarySetting));
  errors.collect(cdk.propertyValidator("cors", cdk.unionValidator(CfnApiCorsPropertyValidator, cdk.validateString))(properties.cors));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("endpointConfiguration", CfnApiEndpointConfigurationPropertyValidator)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("gatewayResponses", cdk.hashValidator(cdk.validateObject))(properties.gatewayResponses));
  errors.collect(cdk.propertyValidator("methodSettings", cdk.listValidator(cdk.validateObject))(properties.methodSettings));
  errors.collect(cdk.propertyValidator("minimumCompressionSize", cdk.validateNumber)(properties.minimumCompressionSize));
  errors.collect(cdk.propertyValidator("models", cdk.hashValidator(cdk.validateObject))(properties.models));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("openApiVersion", cdk.validateString)(properties.openApiVersion));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("tracingEnabled", cdk.validateBoolean)(properties.tracingEnabled));
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateObject))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"EndpointConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiEndpointConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiEndpointConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnApiAuthPropertyToCloudFormation(properties.auth),
    "BinaryMediaTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.binaryMediaTypes),
    "CacheClusterEnabled": cdk.booleanToCloudFormation(properties.cacheClusterEnabled),
    "CacheClusterSize": cdk.stringToCloudFormation(properties.cacheClusterSize),
    "CanarySetting": convertCfnApiCanarySettingPropertyToCloudFormation(properties.canarySetting),
    "Cors": cdk.unionMapper([CfnApiCorsPropertyValidator, cdk.validateString], [convertCfnApiCorsPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.cors),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "EndpointConfiguration": convertCfnApiEndpointConfigurationPropertyToCloudFormation(properties.endpointConfiguration),
    "GatewayResponses": cdk.hashMapper(cdk.objectToCloudFormation)(properties.gatewayResponses),
    "MethodSettings": cdk.listMapper(cdk.objectToCloudFormation)(properties.methodSettings),
    "MinimumCompressionSize": cdk.numberToCloudFormation(properties.minimumCompressionSize),
    "Models": cdk.hashMapper(cdk.objectToCloudFormation)(properties.models),
    "Name": cdk.stringToCloudFormation(properties.name),
    "OpenApiVersion": cdk.stringToCloudFormation(properties.openApiVersion),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "TracingEnabled": cdk.booleanToCloudFormation(properties.tracingEnabled),
    "Variables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnApiEndpointConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.EndpointConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.EndpointConfigurationProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("binaryMediaTypes", "BinaryMediaTypes", (properties.BinaryMediaTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BinaryMediaTypes) : undefined));
  ret.addPropertyResult("cacheClusterEnabled", "CacheClusterEnabled", (properties.CacheClusterEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CacheClusterEnabled) : undefined));
  ret.addPropertyResult("cacheClusterSize", "CacheClusterSize", (properties.CacheClusterSize != null ? cfn_parse.FromCloudFormation.getString(properties.CacheClusterSize) : undefined));
  ret.addPropertyResult("canarySetting", "CanarySetting", (properties.CanarySetting != null ? CfnApiCanarySettingPropertyFromCloudFormation(properties.CanarySetting) : undefined));
  ret.addPropertyResult("cors", "Cors", (properties.Cors != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiCorsPropertyValidator, cdk.validateString], [CfnApiCorsPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Cors) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [CfnApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? CfnApiEndpointConfigurationPropertyFromCloudFormation(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("gatewayResponses", "GatewayResponses", (properties.GatewayResponses != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.GatewayResponses) : undefined));
  ret.addPropertyResult("methodSettings", "MethodSettings", (properties.MethodSettings != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.MethodSettings) : undefined));
  ret.addPropertyResult("minimumCompressionSize", "MinimumCompressionSize", (properties.MinimumCompressionSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinimumCompressionSize) : undefined));
  ret.addPropertyResult("models", "Models", (properties.Models != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Models) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("openApiVersion", "OpenApiVersion", (properties.OpenApiVersion != null ? cfn_parse.FromCloudFormation.getString(properties.OpenApiVersion) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("tracingEnabled", "TracingEnabled", (properties.TracingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TracingEnabled) : undefined));
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DomainConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`DomainConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiDomainConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("binaryMediaTypes", cdk.listValidator(cdk.validateString))(properties.binaryMediaTypes));
  errors.collect(cdk.propertyValidator("cacheClusterEnabled", cdk.validateBoolean)(properties.cacheClusterEnabled));
  errors.collect(cdk.propertyValidator("cacheClusterSize", cdk.validateString)(properties.cacheClusterSize));
  errors.collect(cdk.propertyValidator("canarySetting", CfnApiCanarySettingPropertyValidator)(properties.canarySetting));
  errors.collect(cdk.propertyValidator("cors", cdk.unionValidator(CfnApiCorsPropertyValidator, cdk.validateString))(properties.cors));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("endpointConfiguration", CfnApiEndpointConfigurationPropertyValidator)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("gatewayResponses", cdk.hashValidator(cdk.validateObject))(properties.gatewayResponses));
  errors.collect(cdk.propertyValidator("methodSettings", cdk.listValidator(cdk.validateObject))(properties.methodSettings));
  errors.collect(cdk.propertyValidator("minimumCompressionSize", cdk.validateNumber)(properties.minimumCompressionSize));
  errors.collect(cdk.propertyValidator("models", cdk.hashValidator(cdk.validateObject))(properties.models));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("openApiVersion", cdk.validateString)(properties.openApiVersion));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("tracingEnabled", cdk.validateBoolean)(properties.tracingEnabled));
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateObject))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"DomainConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiDomainConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiDomainConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnApiAuthPropertyToCloudFormation(properties.auth),
    "BinaryMediaTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.binaryMediaTypes),
    "CacheClusterEnabled": cdk.booleanToCloudFormation(properties.cacheClusterEnabled),
    "CacheClusterSize": cdk.stringToCloudFormation(properties.cacheClusterSize),
    "CanarySetting": convertCfnApiCanarySettingPropertyToCloudFormation(properties.canarySetting),
    "Cors": cdk.unionMapper([CfnApiCorsPropertyValidator, cdk.validateString], [convertCfnApiCorsPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.cors),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "EndpointConfiguration": convertCfnApiEndpointConfigurationPropertyToCloudFormation(properties.endpointConfiguration),
    "GatewayResponses": cdk.hashMapper(cdk.objectToCloudFormation)(properties.gatewayResponses),
    "MethodSettings": cdk.listMapper(cdk.objectToCloudFormation)(properties.methodSettings),
    "MinimumCompressionSize": cdk.numberToCloudFormation(properties.minimumCompressionSize),
    "Models": cdk.hashMapper(cdk.objectToCloudFormation)(properties.models),
    "Name": cdk.stringToCloudFormation(properties.name),
    "OpenApiVersion": cdk.stringToCloudFormation(properties.openApiVersion),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "TracingEnabled": cdk.booleanToCloudFormation(properties.tracingEnabled),
    "Variables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnApiDomainConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.DomainConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.DomainConfigurationProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("binaryMediaTypes", "BinaryMediaTypes", (properties.BinaryMediaTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BinaryMediaTypes) : undefined));
  ret.addPropertyResult("cacheClusterEnabled", "CacheClusterEnabled", (properties.CacheClusterEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CacheClusterEnabled) : undefined));
  ret.addPropertyResult("cacheClusterSize", "CacheClusterSize", (properties.CacheClusterSize != null ? cfn_parse.FromCloudFormation.getString(properties.CacheClusterSize) : undefined));
  ret.addPropertyResult("canarySetting", "CanarySetting", (properties.CanarySetting != null ? CfnApiCanarySettingPropertyFromCloudFormation(properties.CanarySetting) : undefined));
  ret.addPropertyResult("cors", "Cors", (properties.Cors != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiCorsPropertyValidator, cdk.validateString], [CfnApiCorsPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Cors) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [CfnApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? CfnApiEndpointConfigurationPropertyFromCloudFormation(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("gatewayResponses", "GatewayResponses", (properties.GatewayResponses != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.GatewayResponses) : undefined));
  ret.addPropertyResult("methodSettings", "MethodSettings", (properties.MethodSettings != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.MethodSettings) : undefined));
  ret.addPropertyResult("minimumCompressionSize", "MinimumCompressionSize", (properties.MinimumCompressionSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinimumCompressionSize) : undefined));
  ret.addPropertyResult("models", "Models", (properties.Models != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Models) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("openApiVersion", "OpenApiVersion", (properties.OpenApiVersion != null ? cfn_parse.FromCloudFormation.getString(properties.OpenApiVersion) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("tracingEnabled", "TracingEnabled", (properties.TracingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TracingEnabled) : undefined));
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DefinitionUriProperty\`
 *
 * @param properties - the TypeScript properties of a \`DefinitionUriProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiDefinitionUriPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("binaryMediaTypes", cdk.listValidator(cdk.validateString))(properties.binaryMediaTypes));
  errors.collect(cdk.propertyValidator("cacheClusterEnabled", cdk.validateBoolean)(properties.cacheClusterEnabled));
  errors.collect(cdk.propertyValidator("cacheClusterSize", cdk.validateString)(properties.cacheClusterSize));
  errors.collect(cdk.propertyValidator("canarySetting", CfnApiCanarySettingPropertyValidator)(properties.canarySetting));
  errors.collect(cdk.propertyValidator("cors", cdk.unionValidator(CfnApiCorsPropertyValidator, cdk.validateString))(properties.cors));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("endpointConfiguration", CfnApiEndpointConfigurationPropertyValidator)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("gatewayResponses", cdk.hashValidator(cdk.validateObject))(properties.gatewayResponses));
  errors.collect(cdk.propertyValidator("methodSettings", cdk.listValidator(cdk.validateObject))(properties.methodSettings));
  errors.collect(cdk.propertyValidator("minimumCompressionSize", cdk.validateNumber)(properties.minimumCompressionSize));
  errors.collect(cdk.propertyValidator("models", cdk.hashValidator(cdk.validateObject))(properties.models));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("openApiVersion", cdk.validateString)(properties.openApiVersion));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("tracingEnabled", cdk.validateBoolean)(properties.tracingEnabled));
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateObject))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"DefinitionUriProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiDefinitionUriPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiDefinitionUriPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnApiAuthPropertyToCloudFormation(properties.auth),
    "BinaryMediaTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.binaryMediaTypes),
    "CacheClusterEnabled": cdk.booleanToCloudFormation(properties.cacheClusterEnabled),
    "CacheClusterSize": cdk.stringToCloudFormation(properties.cacheClusterSize),
    "CanarySetting": convertCfnApiCanarySettingPropertyToCloudFormation(properties.canarySetting),
    "Cors": cdk.unionMapper([CfnApiCorsPropertyValidator, cdk.validateString], [convertCfnApiCorsPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.cors),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "EndpointConfiguration": convertCfnApiEndpointConfigurationPropertyToCloudFormation(properties.endpointConfiguration),
    "GatewayResponses": cdk.hashMapper(cdk.objectToCloudFormation)(properties.gatewayResponses),
    "MethodSettings": cdk.listMapper(cdk.objectToCloudFormation)(properties.methodSettings),
    "MinimumCompressionSize": cdk.numberToCloudFormation(properties.minimumCompressionSize),
    "Models": cdk.hashMapper(cdk.objectToCloudFormation)(properties.models),
    "Name": cdk.stringToCloudFormation(properties.name),
    "OpenApiVersion": cdk.stringToCloudFormation(properties.openApiVersion),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "TracingEnabled": cdk.booleanToCloudFormation(properties.tracingEnabled),
    "Variables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnApiDefinitionUriPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.DefinitionUriProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.DefinitionUriProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("binaryMediaTypes", "BinaryMediaTypes", (properties.BinaryMediaTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BinaryMediaTypes) : undefined));
  ret.addPropertyResult("cacheClusterEnabled", "CacheClusterEnabled", (properties.CacheClusterEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CacheClusterEnabled) : undefined));
  ret.addPropertyResult("cacheClusterSize", "CacheClusterSize", (properties.CacheClusterSize != null ? cfn_parse.FromCloudFormation.getString(properties.CacheClusterSize) : undefined));
  ret.addPropertyResult("canarySetting", "CanarySetting", (properties.CanarySetting != null ? CfnApiCanarySettingPropertyFromCloudFormation(properties.CanarySetting) : undefined));
  ret.addPropertyResult("cors", "Cors", (properties.Cors != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiCorsPropertyValidator, cdk.validateString], [CfnApiCorsPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Cors) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [CfnApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? CfnApiEndpointConfigurationPropertyFromCloudFormation(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("gatewayResponses", "GatewayResponses", (properties.GatewayResponses != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.GatewayResponses) : undefined));
  ret.addPropertyResult("methodSettings", "MethodSettings", (properties.MethodSettings != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.MethodSettings) : undefined));
  ret.addPropertyResult("minimumCompressionSize", "MinimumCompressionSize", (properties.MinimumCompressionSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinimumCompressionSize) : undefined));
  ret.addPropertyResult("models", "Models", (properties.Models != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Models) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("openApiVersion", "OpenApiVersion", (properties.OpenApiVersion != null ? cfn_parse.FromCloudFormation.getString(properties.OpenApiVersion) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("tracingEnabled", "TracingEnabled", (properties.TracingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TracingEnabled) : undefined));
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CorsProperty\`
 *
 * @param properties - the TypeScript properties of a \`CorsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiCorsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("binaryMediaTypes", cdk.listValidator(cdk.validateString))(properties.binaryMediaTypes));
  errors.collect(cdk.propertyValidator("cacheClusterEnabled", cdk.validateBoolean)(properties.cacheClusterEnabled));
  errors.collect(cdk.propertyValidator("cacheClusterSize", cdk.validateString)(properties.cacheClusterSize));
  errors.collect(cdk.propertyValidator("canarySetting", CfnApiCanarySettingPropertyValidator)(properties.canarySetting));
  errors.collect(cdk.propertyValidator("cors", cdk.unionValidator(CfnApiCorsPropertyValidator, cdk.validateString))(properties.cors));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("endpointConfiguration", CfnApiEndpointConfigurationPropertyValidator)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("gatewayResponses", cdk.hashValidator(cdk.validateObject))(properties.gatewayResponses));
  errors.collect(cdk.propertyValidator("methodSettings", cdk.listValidator(cdk.validateObject))(properties.methodSettings));
  errors.collect(cdk.propertyValidator("minimumCompressionSize", cdk.validateNumber)(properties.minimumCompressionSize));
  errors.collect(cdk.propertyValidator("models", cdk.hashValidator(cdk.validateObject))(properties.models));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("openApiVersion", cdk.validateString)(properties.openApiVersion));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("tracingEnabled", cdk.validateBoolean)(properties.tracingEnabled));
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateObject))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"CorsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiCorsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiCorsPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnApiAuthPropertyToCloudFormation(properties.auth),
    "BinaryMediaTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.binaryMediaTypes),
    "CacheClusterEnabled": cdk.booleanToCloudFormation(properties.cacheClusterEnabled),
    "CacheClusterSize": cdk.stringToCloudFormation(properties.cacheClusterSize),
    "CanarySetting": convertCfnApiCanarySettingPropertyToCloudFormation(properties.canarySetting),
    "Cors": cdk.unionMapper([CfnApiCorsPropertyValidator, cdk.validateString], [convertCfnApiCorsPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.cors),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "EndpointConfiguration": convertCfnApiEndpointConfigurationPropertyToCloudFormation(properties.endpointConfiguration),
    "GatewayResponses": cdk.hashMapper(cdk.objectToCloudFormation)(properties.gatewayResponses),
    "MethodSettings": cdk.listMapper(cdk.objectToCloudFormation)(properties.methodSettings),
    "MinimumCompressionSize": cdk.numberToCloudFormation(properties.minimumCompressionSize),
    "Models": cdk.hashMapper(cdk.objectToCloudFormation)(properties.models),
    "Name": cdk.stringToCloudFormation(properties.name),
    "OpenApiVersion": cdk.stringToCloudFormation(properties.openApiVersion),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "TracingEnabled": cdk.booleanToCloudFormation(properties.tracingEnabled),
    "Variables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnApiCorsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.CorsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.CorsProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("binaryMediaTypes", "BinaryMediaTypes", (properties.BinaryMediaTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BinaryMediaTypes) : undefined));
  ret.addPropertyResult("cacheClusterEnabled", "CacheClusterEnabled", (properties.CacheClusterEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CacheClusterEnabled) : undefined));
  ret.addPropertyResult("cacheClusterSize", "CacheClusterSize", (properties.CacheClusterSize != null ? cfn_parse.FromCloudFormation.getString(properties.CacheClusterSize) : undefined));
  ret.addPropertyResult("canarySetting", "CanarySetting", (properties.CanarySetting != null ? CfnApiCanarySettingPropertyFromCloudFormation(properties.CanarySetting) : undefined));
  ret.addPropertyResult("cors", "Cors", (properties.Cors != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiCorsPropertyValidator, cdk.validateString], [CfnApiCorsPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Cors) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [CfnApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? CfnApiEndpointConfigurationPropertyFromCloudFormation(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("gatewayResponses", "GatewayResponses", (properties.GatewayResponses != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.GatewayResponses) : undefined));
  ret.addPropertyResult("methodSettings", "MethodSettings", (properties.MethodSettings != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.MethodSettings) : undefined));
  ret.addPropertyResult("minimumCompressionSize", "MinimumCompressionSize", (properties.MinimumCompressionSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinimumCompressionSize) : undefined));
  ret.addPropertyResult("models", "Models", (properties.Models != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Models) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("openApiVersion", "OpenApiVersion", (properties.OpenApiVersion != null ? cfn_parse.FromCloudFormation.getString(properties.OpenApiVersion) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("tracingEnabled", "TracingEnabled", (properties.TracingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TracingEnabled) : undefined));
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CanarySettingProperty\`
 *
 * @param properties - the TypeScript properties of a \`CanarySettingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiCanarySettingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("binaryMediaTypes", cdk.listValidator(cdk.validateString))(properties.binaryMediaTypes));
  errors.collect(cdk.propertyValidator("cacheClusterEnabled", cdk.validateBoolean)(properties.cacheClusterEnabled));
  errors.collect(cdk.propertyValidator("cacheClusterSize", cdk.validateString)(properties.cacheClusterSize));
  errors.collect(cdk.propertyValidator("canarySetting", CfnApiCanarySettingPropertyValidator)(properties.canarySetting));
  errors.collect(cdk.propertyValidator("cors", cdk.unionValidator(CfnApiCorsPropertyValidator, cdk.validateString))(properties.cors));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("endpointConfiguration", CfnApiEndpointConfigurationPropertyValidator)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("gatewayResponses", cdk.hashValidator(cdk.validateObject))(properties.gatewayResponses));
  errors.collect(cdk.propertyValidator("methodSettings", cdk.listValidator(cdk.validateObject))(properties.methodSettings));
  errors.collect(cdk.propertyValidator("minimumCompressionSize", cdk.validateNumber)(properties.minimumCompressionSize));
  errors.collect(cdk.propertyValidator("models", cdk.hashValidator(cdk.validateObject))(properties.models));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("openApiVersion", cdk.validateString)(properties.openApiVersion));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("tracingEnabled", cdk.validateBoolean)(properties.tracingEnabled));
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateObject))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"CanarySettingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiCanarySettingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiCanarySettingPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnApiAuthPropertyToCloudFormation(properties.auth),
    "BinaryMediaTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.binaryMediaTypes),
    "CacheClusterEnabled": cdk.booleanToCloudFormation(properties.cacheClusterEnabled),
    "CacheClusterSize": cdk.stringToCloudFormation(properties.cacheClusterSize),
    "CanarySetting": convertCfnApiCanarySettingPropertyToCloudFormation(properties.canarySetting),
    "Cors": cdk.unionMapper([CfnApiCorsPropertyValidator, cdk.validateString], [convertCfnApiCorsPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.cors),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "EndpointConfiguration": convertCfnApiEndpointConfigurationPropertyToCloudFormation(properties.endpointConfiguration),
    "GatewayResponses": cdk.hashMapper(cdk.objectToCloudFormation)(properties.gatewayResponses),
    "MethodSettings": cdk.listMapper(cdk.objectToCloudFormation)(properties.methodSettings),
    "MinimumCompressionSize": cdk.numberToCloudFormation(properties.minimumCompressionSize),
    "Models": cdk.hashMapper(cdk.objectToCloudFormation)(properties.models),
    "Name": cdk.stringToCloudFormation(properties.name),
    "OpenApiVersion": cdk.stringToCloudFormation(properties.openApiVersion),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "TracingEnabled": cdk.booleanToCloudFormation(properties.tracingEnabled),
    "Variables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnApiCanarySettingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.CanarySettingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.CanarySettingProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("binaryMediaTypes", "BinaryMediaTypes", (properties.BinaryMediaTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BinaryMediaTypes) : undefined));
  ret.addPropertyResult("cacheClusterEnabled", "CacheClusterEnabled", (properties.CacheClusterEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CacheClusterEnabled) : undefined));
  ret.addPropertyResult("cacheClusterSize", "CacheClusterSize", (properties.CacheClusterSize != null ? cfn_parse.FromCloudFormation.getString(properties.CacheClusterSize) : undefined));
  ret.addPropertyResult("canarySetting", "CanarySetting", (properties.CanarySetting != null ? CfnApiCanarySettingPropertyFromCloudFormation(properties.CanarySetting) : undefined));
  ret.addPropertyResult("cors", "Cors", (properties.Cors != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiCorsPropertyValidator, cdk.validateString], [CfnApiCorsPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Cors) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [CfnApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? CfnApiEndpointConfigurationPropertyFromCloudFormation(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("gatewayResponses", "GatewayResponses", (properties.GatewayResponses != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.GatewayResponses) : undefined));
  ret.addPropertyResult("methodSettings", "MethodSettings", (properties.MethodSettings != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.MethodSettings) : undefined));
  ret.addPropertyResult("minimumCompressionSize", "MinimumCompressionSize", (properties.MinimumCompressionSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinimumCompressionSize) : undefined));
  ret.addPropertyResult("models", "Models", (properties.Models != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Models) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("openApiVersion", "OpenApiVersion", (properties.OpenApiVersion != null ? cfn_parse.FromCloudFormation.getString(properties.OpenApiVersion) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("tracingEnabled", "TracingEnabled", (properties.TracingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TracingEnabled) : undefined));
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AuthProperty\`
 *
 * @param properties - the TypeScript properties of a \`AuthProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiAuthPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("binaryMediaTypes", cdk.listValidator(cdk.validateString))(properties.binaryMediaTypes));
  errors.collect(cdk.propertyValidator("cacheClusterEnabled", cdk.validateBoolean)(properties.cacheClusterEnabled));
  errors.collect(cdk.propertyValidator("cacheClusterSize", cdk.validateString)(properties.cacheClusterSize));
  errors.collect(cdk.propertyValidator("canarySetting", CfnApiCanarySettingPropertyValidator)(properties.canarySetting));
  errors.collect(cdk.propertyValidator("cors", cdk.unionValidator(CfnApiCorsPropertyValidator, cdk.validateString))(properties.cors));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("endpointConfiguration", CfnApiEndpointConfigurationPropertyValidator)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("gatewayResponses", cdk.hashValidator(cdk.validateObject))(properties.gatewayResponses));
  errors.collect(cdk.propertyValidator("methodSettings", cdk.listValidator(cdk.validateObject))(properties.methodSettings));
  errors.collect(cdk.propertyValidator("minimumCompressionSize", cdk.validateNumber)(properties.minimumCompressionSize));
  errors.collect(cdk.propertyValidator("models", cdk.hashValidator(cdk.validateObject))(properties.models));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("openApiVersion", cdk.validateString)(properties.openApiVersion));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("tracingEnabled", cdk.validateBoolean)(properties.tracingEnabled));
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateObject))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"AuthProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiAuthPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiAuthPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnApiAuthPropertyToCloudFormation(properties.auth),
    "BinaryMediaTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.binaryMediaTypes),
    "CacheClusterEnabled": cdk.booleanToCloudFormation(properties.cacheClusterEnabled),
    "CacheClusterSize": cdk.stringToCloudFormation(properties.cacheClusterSize),
    "CanarySetting": convertCfnApiCanarySettingPropertyToCloudFormation(properties.canarySetting),
    "Cors": cdk.unionMapper([CfnApiCorsPropertyValidator, cdk.validateString], [convertCfnApiCorsPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.cors),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "EndpointConfiguration": convertCfnApiEndpointConfigurationPropertyToCloudFormation(properties.endpointConfiguration),
    "GatewayResponses": cdk.hashMapper(cdk.objectToCloudFormation)(properties.gatewayResponses),
    "MethodSettings": cdk.listMapper(cdk.objectToCloudFormation)(properties.methodSettings),
    "MinimumCompressionSize": cdk.numberToCloudFormation(properties.minimumCompressionSize),
    "Models": cdk.hashMapper(cdk.objectToCloudFormation)(properties.models),
    "Name": cdk.stringToCloudFormation(properties.name),
    "OpenApiVersion": cdk.stringToCloudFormation(properties.openApiVersion),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "TracingEnabled": cdk.booleanToCloudFormation(properties.tracingEnabled),
    "Variables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnApiAuthPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.AuthProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.AuthProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("binaryMediaTypes", "BinaryMediaTypes", (properties.BinaryMediaTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BinaryMediaTypes) : undefined));
  ret.addPropertyResult("cacheClusterEnabled", "CacheClusterEnabled", (properties.CacheClusterEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CacheClusterEnabled) : undefined));
  ret.addPropertyResult("cacheClusterSize", "CacheClusterSize", (properties.CacheClusterSize != null ? cfn_parse.FromCloudFormation.getString(properties.CacheClusterSize) : undefined));
  ret.addPropertyResult("canarySetting", "CanarySetting", (properties.CanarySetting != null ? CfnApiCanarySettingPropertyFromCloudFormation(properties.CanarySetting) : undefined));
  ret.addPropertyResult("cors", "Cors", (properties.Cors != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiCorsPropertyValidator, cdk.validateString], [CfnApiCorsPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Cors) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [CfnApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? CfnApiEndpointConfigurationPropertyFromCloudFormation(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("gatewayResponses", "GatewayResponses", (properties.GatewayResponses != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.GatewayResponses) : undefined));
  ret.addPropertyResult("methodSettings", "MethodSettings", (properties.MethodSettings != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.MethodSettings) : undefined));
  ret.addPropertyResult("minimumCompressionSize", "MinimumCompressionSize", (properties.MinimumCompressionSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinimumCompressionSize) : undefined));
  ret.addPropertyResult("models", "Models", (properties.Models != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Models) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("openApiVersion", "OpenApiVersion", (properties.OpenApiVersion != null ? cfn_parse.FromCloudFormation.getString(properties.OpenApiVersion) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("tracingEnabled", "TracingEnabled", (properties.TracingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TracingEnabled) : undefined));
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AccessLogSettingProperty\`
 *
 * @param properties - the TypeScript properties of a \`AccessLogSettingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiAccessLogSettingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("binaryMediaTypes", cdk.listValidator(cdk.validateString))(properties.binaryMediaTypes));
  errors.collect(cdk.propertyValidator("cacheClusterEnabled", cdk.validateBoolean)(properties.cacheClusterEnabled));
  errors.collect(cdk.propertyValidator("cacheClusterSize", cdk.validateString)(properties.cacheClusterSize));
  errors.collect(cdk.propertyValidator("canarySetting", CfnApiCanarySettingPropertyValidator)(properties.canarySetting));
  errors.collect(cdk.propertyValidator("cors", cdk.unionValidator(CfnApiCorsPropertyValidator, cdk.validateString))(properties.cors));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("endpointConfiguration", CfnApiEndpointConfigurationPropertyValidator)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("gatewayResponses", cdk.hashValidator(cdk.validateObject))(properties.gatewayResponses));
  errors.collect(cdk.propertyValidator("methodSettings", cdk.listValidator(cdk.validateObject))(properties.methodSettings));
  errors.collect(cdk.propertyValidator("minimumCompressionSize", cdk.validateNumber)(properties.minimumCompressionSize));
  errors.collect(cdk.propertyValidator("models", cdk.hashValidator(cdk.validateObject))(properties.models));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("openApiVersion", cdk.validateString)(properties.openApiVersion));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("tracingEnabled", cdk.validateBoolean)(properties.tracingEnabled));
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateObject))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"AccessLogSettingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiAccessLogSettingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiAccessLogSettingPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnApiAuthPropertyToCloudFormation(properties.auth),
    "BinaryMediaTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.binaryMediaTypes),
    "CacheClusterEnabled": cdk.booleanToCloudFormation(properties.cacheClusterEnabled),
    "CacheClusterSize": cdk.stringToCloudFormation(properties.cacheClusterSize),
    "CanarySetting": convertCfnApiCanarySettingPropertyToCloudFormation(properties.canarySetting),
    "Cors": cdk.unionMapper([CfnApiCorsPropertyValidator, cdk.validateString], [convertCfnApiCorsPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.cors),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "EndpointConfiguration": convertCfnApiEndpointConfigurationPropertyToCloudFormation(properties.endpointConfiguration),
    "GatewayResponses": cdk.hashMapper(cdk.objectToCloudFormation)(properties.gatewayResponses),
    "MethodSettings": cdk.listMapper(cdk.objectToCloudFormation)(properties.methodSettings),
    "MinimumCompressionSize": cdk.numberToCloudFormation(properties.minimumCompressionSize),
    "Models": cdk.hashMapper(cdk.objectToCloudFormation)(properties.models),
    "Name": cdk.stringToCloudFormation(properties.name),
    "OpenApiVersion": cdk.stringToCloudFormation(properties.openApiVersion),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "TracingEnabled": cdk.booleanToCloudFormation(properties.tracingEnabled),
    "Variables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnApiAccessLogSettingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.AccessLogSettingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.AccessLogSettingProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("binaryMediaTypes", "BinaryMediaTypes", (properties.BinaryMediaTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BinaryMediaTypes) : undefined));
  ret.addPropertyResult("cacheClusterEnabled", "CacheClusterEnabled", (properties.CacheClusterEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CacheClusterEnabled) : undefined));
  ret.addPropertyResult("cacheClusterSize", "CacheClusterSize", (properties.CacheClusterSize != null ? cfn_parse.FromCloudFormation.getString(properties.CacheClusterSize) : undefined));
  ret.addPropertyResult("canarySetting", "CanarySetting", (properties.CanarySetting != null ? CfnApiCanarySettingPropertyFromCloudFormation(properties.CanarySetting) : undefined));
  ret.addPropertyResult("cors", "Cors", (properties.Cors != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiCorsPropertyValidator, cdk.validateString], [CfnApiCorsPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Cors) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [CfnApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? CfnApiEndpointConfigurationPropertyFromCloudFormation(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("gatewayResponses", "GatewayResponses", (properties.GatewayResponses != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.GatewayResponses) : undefined));
  ret.addPropertyResult("methodSettings", "MethodSettings", (properties.MethodSettings != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.MethodSettings) : undefined));
  ret.addPropertyResult("minimumCompressionSize", "MinimumCompressionSize", (properties.MinimumCompressionSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinimumCompressionSize) : undefined));
  ret.addPropertyResult("models", "Models", (properties.Models != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Models) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("openApiVersion", "OpenApiVersion", (properties.OpenApiVersion != null ? cfn_parse.FromCloudFormation.getString(properties.OpenApiVersion) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("tracingEnabled", "TracingEnabled", (properties.TracingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TracingEnabled) : undefined));
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApiProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnApiProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("binaryMediaTypes", cdk.listValidator(cdk.validateString))(properties.binaryMediaTypes));
  errors.collect(cdk.propertyValidator("cacheClusterEnabled", cdk.validateBoolean)(properties.cacheClusterEnabled));
  errors.collect(cdk.propertyValidator("cacheClusterSize", cdk.validateString)(properties.cacheClusterSize));
  errors.collect(cdk.propertyValidator("canarySetting", CfnApiCanarySettingPropertyValidator)(properties.canarySetting));
  errors.collect(cdk.propertyValidator("cors", cdk.unionValidator(CfnApiCorsPropertyValidator, cdk.validateString))(properties.cors));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("endpointConfiguration", CfnApiEndpointConfigurationPropertyValidator)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("gatewayResponses", cdk.hashValidator(cdk.validateObject))(properties.gatewayResponses));
  errors.collect(cdk.propertyValidator("methodSettings", cdk.listValidator(cdk.validateObject))(properties.methodSettings));
  errors.collect(cdk.propertyValidator("minimumCompressionSize", cdk.validateNumber)(properties.minimumCompressionSize));
  errors.collect(cdk.propertyValidator("models", cdk.hashValidator(cdk.validateObject))(properties.models));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("openApiVersion", cdk.validateString)(properties.openApiVersion));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("tracingEnabled", cdk.validateBoolean)(properties.tracingEnabled));
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateObject))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"CfnApiProps\\"");
}

// @ts-ignore TS6133
function convertCfnApiPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiPropsValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnApiAuthPropertyToCloudFormation(properties.auth),
    "BinaryMediaTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.binaryMediaTypes),
    "CacheClusterEnabled": cdk.booleanToCloudFormation(properties.cacheClusterEnabled),
    "CacheClusterSize": cdk.stringToCloudFormation(properties.cacheClusterSize),
    "CanarySetting": convertCfnApiCanarySettingPropertyToCloudFormation(properties.canarySetting),
    "Cors": cdk.unionMapper([CfnApiCorsPropertyValidator, cdk.validateString], [convertCfnApiCorsPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.cors),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "EndpointConfiguration": convertCfnApiEndpointConfigurationPropertyToCloudFormation(properties.endpointConfiguration),
    "GatewayResponses": cdk.hashMapper(cdk.objectToCloudFormation)(properties.gatewayResponses),
    "MethodSettings": cdk.listMapper(cdk.objectToCloudFormation)(properties.methodSettings),
    "MinimumCompressionSize": cdk.numberToCloudFormation(properties.minimumCompressionSize),
    "Models": cdk.hashMapper(cdk.objectToCloudFormation)(properties.models),
    "Name": cdk.stringToCloudFormation(properties.name),
    "OpenApiVersion": cdk.stringToCloudFormation(properties.openApiVersion),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TracingEnabled": cdk.booleanToCloudFormation(properties.tracingEnabled),
    "Variables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnApiPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApiProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApiProps>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("binaryMediaTypes", "BinaryMediaTypes", (properties.BinaryMediaTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BinaryMediaTypes) : undefined));
  ret.addPropertyResult("cacheClusterEnabled", "CacheClusterEnabled", (properties.CacheClusterEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CacheClusterEnabled) : undefined));
  ret.addPropertyResult("cacheClusterSize", "CacheClusterSize", (properties.CacheClusterSize != null ? cfn_parse.FromCloudFormation.getString(properties.CacheClusterSize) : undefined));
  ret.addPropertyResult("canarySetting", "CanarySetting", (properties.CanarySetting != null ? CfnApiCanarySettingPropertyFromCloudFormation(properties.CanarySetting) : undefined));
  ret.addPropertyResult("cors", "Cors", (properties.Cors != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiCorsPropertyValidator, cdk.validateString], [CfnApiCorsPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Cors) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [CfnApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? CfnApiEndpointConfigurationPropertyFromCloudFormation(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("gatewayResponses", "GatewayResponses", (properties.GatewayResponses != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.GatewayResponses) : undefined));
  ret.addPropertyResult("methodSettings", "MethodSettings", (properties.MethodSettings != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.MethodSettings) : undefined));
  ret.addPropertyResult("minimumCompressionSize", "MinimumCompressionSize", (properties.MinimumCompressionSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinimumCompressionSize) : undefined));
  ret.addPropertyResult("models", "Models", (properties.Models != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Models) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("openApiVersion", "OpenApiVersion", (properties.OpenApiVersion != null ? cfn_parse.FromCloudFormation.getString(properties.OpenApiVersion) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("tracingEnabled", "TracingEnabled", (properties.TracingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TracingEnabled) : undefined));
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::Application.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html
 */
export class CfnApplication extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::Application";

  /**
   * Build a CfnApplication from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplication {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplication(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-location
   */
  public location?: cdk.IResolvable | CfnApplication.LocationProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-notificationarns
   */
  public notificationArns?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-parameters
   */
  public parameters?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-timeoutinminutes
   */
  public timeoutInMinutes?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationProps = {}) {
    super(scope, id, {
      "type": CfnApplication.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.location = props.location;
    this.notificationArns = props.notificationArns;
    this.parameters = props.parameters;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Serverless::Application", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.timeoutInMinutes = props.timeoutInMinutes;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "location": this.location,
      "notificationArns": this.notificationArns,
      "parameters": this.parameters,
      "tags": this.tags.renderTags(),
      "timeoutInMinutes": this.timeoutInMinutes
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplication.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationPropsToCloudFormation(props);
  }
}

export namespace CfnApplication {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-application-location.html
   */
  export interface LocationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-application-location.html#cfn-serverless-application-location-location
     */
    readonly location?: cdk.IResolvable | CfnApplication.LocationProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-application-location.html#cfn-serverless-application-location-notificationarns
     */
    readonly notificationArns?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-application-location.html#cfn-serverless-application-location-parameters
     */
    readonly parameters?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-application-location.html#cfn-serverless-application-location-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-application-location.html#cfn-serverless-application-location-timeoutinminutes
     */
    readonly timeoutInMinutes?: number;
  }
}

/**
 * Properties for defining a \`CfnApplication\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html
 */
export interface CfnApplicationProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-location
   */
  readonly location?: cdk.IResolvable | CfnApplication.LocationProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-notificationarns
   */
  readonly notificationArns?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-parameters
   */
  readonly parameters?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-timeoutinminutes
   */
  readonly timeoutInMinutes?: number;
}

/**
 * Determine whether the given properties match those of a \`LocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationLocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("location", cdk.unionValidator(CfnApplicationLocationPropertyValidator, cdk.validateString))(properties.location));
  errors.collect(cdk.propertyValidator("notificationArns", cdk.listValidator(cdk.validateString))(properties.notificationArns));
  errors.collect(cdk.propertyValidator("parameters", cdk.hashValidator(cdk.validateObject))(properties.parameters));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("timeoutInMinutes", cdk.validateNumber)(properties.timeoutInMinutes));
  return errors.wrap("supplied properties not correct for \\"LocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationLocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationLocationPropertyValidator(properties).assertSuccess();
  return {
    "Location": cdk.unionMapper([CfnApplicationLocationPropertyValidator, cdk.validateString], [convertCfnApplicationLocationPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.location),
    "NotificationArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.notificationArns),
    "Parameters": cdk.hashMapper(cdk.objectToCloudFormation)(properties.parameters),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "TimeoutInMinutes": cdk.numberToCloudFormation(properties.timeoutInMinutes)
  };
}

// @ts-ignore TS6133
function CfnApplicationLocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplication.LocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplication.LocationProperty>();
  ret.addPropertyResult("location", "Location", (properties.Location != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApplicationLocationPropertyValidator, cdk.validateString], [CfnApplicationLocationPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Location) : undefined));
  ret.addPropertyResult("notificationArns", "NotificationArns", (properties.NotificationArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NotificationArns) : undefined));
  ret.addPropertyResult("parameters", "Parameters", (properties.Parameters != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Parameters) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("timeoutInMinutes", "TimeoutInMinutes", (properties.TimeoutInMinutes != null ? cfn_parse.FromCloudFormation.getNumber(properties.TimeoutInMinutes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("location", cdk.unionValidator(CfnApplicationLocationPropertyValidator, cdk.validateString))(properties.location));
  errors.collect(cdk.propertyValidator("notificationArns", cdk.listValidator(cdk.validateString))(properties.notificationArns));
  errors.collect(cdk.propertyValidator("parameters", cdk.hashValidator(cdk.validateObject))(properties.parameters));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("timeoutInMinutes", cdk.validateNumber)(properties.timeoutInMinutes));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationProps\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationPropsValidator(properties).assertSuccess();
  return {
    "Location": cdk.unionMapper([CfnApplicationLocationPropertyValidator, cdk.validateString], [convertCfnApplicationLocationPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.location),
    "NotificationArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.notificationArns),
    "Parameters": cdk.hashMapper(cdk.objectToCloudFormation)(properties.parameters),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "TimeoutInMinutes": cdk.numberToCloudFormation(properties.timeoutInMinutes)
  };
}

// @ts-ignore TS6133
function CfnApplicationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationProps>();
  ret.addPropertyResult("location", "Location", (properties.Location != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApplicationLocationPropertyValidator, cdk.validateString], [CfnApplicationLocationPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Location) : undefined));
  ret.addPropertyResult("notificationArns", "NotificationArns", (properties.NotificationArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NotificationArns) : undefined));
  ret.addPropertyResult("parameters", "Parameters", (properties.Parameters != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Parameters) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("timeoutInMinutes", "TimeoutInMinutes", (properties.TimeoutInMinutes != null ? cfn_parse.FromCloudFormation.getNumber(properties.TimeoutInMinutes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::Function.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html
 */
export class CfnFunction extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::Function";

  /**
   * Build a CfnFunction from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnFunction {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnFunctionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnFunction(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-architectures
   */
  public architectures?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-assumerolepolicydocument
   */
  public assumeRolePolicyDocument?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-autopublishalias
   */
  public autoPublishAlias?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-autopublishcodesha256
   */
  public autoPublishCodeSha256?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-codesigningconfigarn
   */
  public codeSigningConfigArn?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-codeuri
   */
  public codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-deadletterqueue
   */
  public deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-deploymentpreference
   */
  public deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-description
   */
  public description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-environment
   */
  public environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-eventinvokeconfig
   */
  public eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-events
   */
  public events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-filesystemconfigs
   */
  public fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-functionname
   */
  public functionName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-handler
   */
  public handler?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-imageconfig
   */
  public imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-imageuri
   */
  public imageUri?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-inlinecode
   */
  public inlineCode?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-kmskeyarn
   */
  public kmsKeyArn?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-layers
   */
  public layers?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-memorysize
   */
  public memorySize?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-packagetype
   */
  public packageType?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-permissionsboundary
   */
  public permissionsBoundary?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-policies
   */
  public policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-provisionedconcurrencyconfig
   */
  public provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-reservedconcurrentexecutions
   */
  public reservedConcurrentExecutions?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-role
   */
  public role?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-runtime
   */
  public runtime?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-timeout
   */
  public timeout?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-tracing
   */
  public tracing?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-versiondescription
   */
  public versionDescription?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-vpcconfig
   */
  public vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnFunctionProps = {}) {
    super(scope, id, {
      "type": CfnFunction.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.architectures = props.architectures;
    this.assumeRolePolicyDocument = props.assumeRolePolicyDocument;
    this.autoPublishAlias = props.autoPublishAlias;
    this.autoPublishCodeSha256 = props.autoPublishCodeSha256;
    this.codeSigningConfigArn = props.codeSigningConfigArn;
    this.codeUri = props.codeUri;
    this.deadLetterQueue = props.deadLetterQueue;
    this.deploymentPreference = props.deploymentPreference;
    this.description = props.description;
    this.environment = props.environment;
    this.eventInvokeConfig = props.eventInvokeConfig;
    this.events = props.events;
    this.fileSystemConfigs = props.fileSystemConfigs;
    this.functionName = props.functionName;
    this.handler = props.handler;
    this.imageConfig = props.imageConfig;
    this.imageUri = props.imageUri;
    this.inlineCode = props.inlineCode;
    this.kmsKeyArn = props.kmsKeyArn;
    this.layers = props.layers;
    this.memorySize = props.memorySize;
    this.packageType = props.packageType;
    this.permissionsBoundary = props.permissionsBoundary;
    this.policies = props.policies;
    this.provisionedConcurrencyConfig = props.provisionedConcurrencyConfig;
    this.reservedConcurrentExecutions = props.reservedConcurrentExecutions;
    this.role = props.role;
    this.runtime = props.runtime;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Serverless::Function", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.timeout = props.timeout;
    this.tracing = props.tracing;
    this.versionDescription = props.versionDescription;
    this.vpcConfig = props.vpcConfig;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "architectures": this.architectures,
      "assumeRolePolicyDocument": this.assumeRolePolicyDocument,
      "autoPublishAlias": this.autoPublishAlias,
      "autoPublishCodeSha256": this.autoPublishCodeSha256,
      "codeSigningConfigArn": this.codeSigningConfigArn,
      "codeUri": this.codeUri,
      "deadLetterQueue": this.deadLetterQueue,
      "deploymentPreference": this.deploymentPreference,
      "description": this.description,
      "environment": this.environment,
      "eventInvokeConfig": this.eventInvokeConfig,
      "events": this.events,
      "fileSystemConfigs": this.fileSystemConfigs,
      "functionName": this.functionName,
      "handler": this.handler,
      "imageConfig": this.imageConfig,
      "imageUri": this.imageUri,
      "inlineCode": this.inlineCode,
      "kmsKeyArn": this.kmsKeyArn,
      "layers": this.layers,
      "memorySize": this.memorySize,
      "packageType": this.packageType,
      "permissionsBoundary": this.permissionsBoundary,
      "policies": this.policies,
      "provisionedConcurrencyConfig": this.provisionedConcurrencyConfig,
      "reservedConcurrentExecutions": this.reservedConcurrentExecutions,
      "role": this.role,
      "runtime": this.runtime,
      "tags": this.tags.renderTags(),
      "timeout": this.timeout,
      "tracing": this.tracing,
      "versionDescription": this.versionDescription,
      "vpcConfig": this.vpcConfig
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnFunction.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnFunctionPropsToCloudFormation(props);
  }
}

export namespace CfnFunction {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html
   */
  export interface CodeUriProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-architectures
     */
    readonly architectures?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-assumerolepolicydocument
     */
    readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-autopublishalias
     */
    readonly autoPublishAlias?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-autopublishcodesha256
     */
    readonly autoPublishCodeSha256?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-codesigningconfigarn
     */
    readonly codeSigningConfigArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-codeuri
     */
    readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-deadletterqueue
     */
    readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-deploymentpreference
     */
    readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-environment
     */
    readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-eventinvokeconfig
     */
    readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-filesystemconfigs
     */
    readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-functionname
     */
    readonly functionName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-handler
     */
    readonly handler?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-imageconfig
     */
    readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-imageuri
     */
    readonly imageUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-inlinecode
     */
    readonly inlineCode?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-layers
     */
    readonly layers?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-memorysize
     */
    readonly memorySize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-packagetype
     */
    readonly packageType?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-permissionsboundary
     */
    readonly permissionsBoundary?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-policies
     */
    readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-provisionedconcurrencyconfig
     */
    readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-reservedconcurrentexecutions
     */
    readonly reservedConcurrentExecutions?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-runtime
     */
    readonly runtime?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-timeout
     */
    readonly timeout?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-tracing
     */
    readonly tracing?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-versiondescription
     */
    readonly versionDescription?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-vpcconfig
     */
    readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html
   */
  export interface DeadLetterQueueProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-architectures
     */
    readonly architectures?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-assumerolepolicydocument
     */
    readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-autopublishalias
     */
    readonly autoPublishAlias?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-autopublishcodesha256
     */
    readonly autoPublishCodeSha256?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-codesigningconfigarn
     */
    readonly codeSigningConfigArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-codeuri
     */
    readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-deadletterqueue
     */
    readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-deploymentpreference
     */
    readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-environment
     */
    readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-eventinvokeconfig
     */
    readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-filesystemconfigs
     */
    readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-functionname
     */
    readonly functionName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-handler
     */
    readonly handler?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-imageconfig
     */
    readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-imageuri
     */
    readonly imageUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-inlinecode
     */
    readonly inlineCode?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-layers
     */
    readonly layers?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-memorysize
     */
    readonly memorySize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-packagetype
     */
    readonly packageType?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-permissionsboundary
     */
    readonly permissionsBoundary?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-policies
     */
    readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-provisionedconcurrencyconfig
     */
    readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-reservedconcurrentexecutions
     */
    readonly reservedConcurrentExecutions?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-runtime
     */
    readonly runtime?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-timeout
     */
    readonly timeout?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-tracing
     */
    readonly tracing?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-versiondescription
     */
    readonly versionDescription?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-vpcconfig
     */
    readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html
   */
  export interface DeploymentPreferenceProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-architectures
     */
    readonly architectures?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-assumerolepolicydocument
     */
    readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-autopublishalias
     */
    readonly autoPublishAlias?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-autopublishcodesha256
     */
    readonly autoPublishCodeSha256?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-codesigningconfigarn
     */
    readonly codeSigningConfigArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-codeuri
     */
    readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-deadletterqueue
     */
    readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-deploymentpreference
     */
    readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-environment
     */
    readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-eventinvokeconfig
     */
    readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-filesystemconfigs
     */
    readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-functionname
     */
    readonly functionName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-handler
     */
    readonly handler?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-imageconfig
     */
    readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-imageuri
     */
    readonly imageUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-inlinecode
     */
    readonly inlineCode?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-layers
     */
    readonly layers?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-memorysize
     */
    readonly memorySize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-packagetype
     */
    readonly packageType?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-permissionsboundary
     */
    readonly permissionsBoundary?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-policies
     */
    readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-provisionedconcurrencyconfig
     */
    readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-reservedconcurrentexecutions
     */
    readonly reservedConcurrentExecutions?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-runtime
     */
    readonly runtime?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-timeout
     */
    readonly timeout?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-tracing
     */
    readonly tracing?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-versiondescription
     */
    readonly versionDescription?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-vpcconfig
     */
    readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html
   */
  export interface FunctionEnvironmentProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-architectures
     */
    readonly architectures?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-assumerolepolicydocument
     */
    readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-autopublishalias
     */
    readonly autoPublishAlias?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-autopublishcodesha256
     */
    readonly autoPublishCodeSha256?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-codesigningconfigarn
     */
    readonly codeSigningConfigArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-codeuri
     */
    readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-deadletterqueue
     */
    readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-deploymentpreference
     */
    readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-environment
     */
    readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-eventinvokeconfig
     */
    readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-filesystemconfigs
     */
    readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-functionname
     */
    readonly functionName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-handler
     */
    readonly handler?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-imageconfig
     */
    readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-imageuri
     */
    readonly imageUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-inlinecode
     */
    readonly inlineCode?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-layers
     */
    readonly layers?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-memorysize
     */
    readonly memorySize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-packagetype
     */
    readonly packageType?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-permissionsboundary
     */
    readonly permissionsBoundary?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-policies
     */
    readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-provisionedconcurrencyconfig
     */
    readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-reservedconcurrentexecutions
     */
    readonly reservedConcurrentExecutions?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-runtime
     */
    readonly runtime?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-timeout
     */
    readonly timeout?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-tracing
     */
    readonly tracing?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-versiondescription
     */
    readonly versionDescription?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-vpcconfig
     */
    readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html
   */
  export interface EventInvokeConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-architectures
     */
    readonly architectures?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-assumerolepolicydocument
     */
    readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-autopublishalias
     */
    readonly autoPublishAlias?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-autopublishcodesha256
     */
    readonly autoPublishCodeSha256?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-codesigningconfigarn
     */
    readonly codeSigningConfigArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-codeuri
     */
    readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-deadletterqueue
     */
    readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-deploymentpreference
     */
    readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-environment
     */
    readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-eventinvokeconfig
     */
    readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-filesystemconfigs
     */
    readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-functionname
     */
    readonly functionName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-handler
     */
    readonly handler?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-imageconfig
     */
    readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-imageuri
     */
    readonly imageUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-inlinecode
     */
    readonly inlineCode?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-layers
     */
    readonly layers?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-memorysize
     */
    readonly memorySize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-packagetype
     */
    readonly packageType?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-permissionsboundary
     */
    readonly permissionsBoundary?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-policies
     */
    readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-provisionedconcurrencyconfig
     */
    readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-reservedconcurrentexecutions
     */
    readonly reservedConcurrentExecutions?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-runtime
     */
    readonly runtime?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-timeout
     */
    readonly timeout?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-tracing
     */
    readonly tracing?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-versiondescription
     */
    readonly versionDescription?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-vpcconfig
     */
    readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html
   */
  export interface EventSourceProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-architectures
     */
    readonly architectures?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-assumerolepolicydocument
     */
    readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-autopublishalias
     */
    readonly autoPublishAlias?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-autopublishcodesha256
     */
    readonly autoPublishCodeSha256?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-codesigningconfigarn
     */
    readonly codeSigningConfigArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-codeuri
     */
    readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-deadletterqueue
     */
    readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-deploymentpreference
     */
    readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-environment
     */
    readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-eventinvokeconfig
     */
    readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-filesystemconfigs
     */
    readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-functionname
     */
    readonly functionName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-handler
     */
    readonly handler?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-imageconfig
     */
    readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-imageuri
     */
    readonly imageUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-inlinecode
     */
    readonly inlineCode?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-layers
     */
    readonly layers?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-memorysize
     */
    readonly memorySize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-packagetype
     */
    readonly packageType?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-permissionsboundary
     */
    readonly permissionsBoundary?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-policies
     */
    readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-provisionedconcurrencyconfig
     */
    readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-reservedconcurrentexecutions
     */
    readonly reservedConcurrentExecutions?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-runtime
     */
    readonly runtime?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-timeout
     */
    readonly timeout?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-tracing
     */
    readonly tracing?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-versiondescription
     */
    readonly versionDescription?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-vpcconfig
     */
    readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html
   */
  export interface FileSystemConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-architectures
     */
    readonly architectures?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-assumerolepolicydocument
     */
    readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-autopublishalias
     */
    readonly autoPublishAlias?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-autopublishcodesha256
     */
    readonly autoPublishCodeSha256?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-codesigningconfigarn
     */
    readonly codeSigningConfigArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-codeuri
     */
    readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-deadletterqueue
     */
    readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-deploymentpreference
     */
    readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-environment
     */
    readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-eventinvokeconfig
     */
    readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-filesystemconfigs
     */
    readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-functionname
     */
    readonly functionName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-handler
     */
    readonly handler?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-imageconfig
     */
    readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-imageuri
     */
    readonly imageUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-inlinecode
     */
    readonly inlineCode?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-layers
     */
    readonly layers?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-memorysize
     */
    readonly memorySize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-packagetype
     */
    readonly packageType?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-permissionsboundary
     */
    readonly permissionsBoundary?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-policies
     */
    readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-provisionedconcurrencyconfig
     */
    readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-reservedconcurrentexecutions
     */
    readonly reservedConcurrentExecutions?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-runtime
     */
    readonly runtime?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-timeout
     */
    readonly timeout?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-tracing
     */
    readonly tracing?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-versiondescription
     */
    readonly versionDescription?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-vpcconfig
     */
    readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html
   */
  export interface ImageConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-architectures
     */
    readonly architectures?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-assumerolepolicydocument
     */
    readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-autopublishalias
     */
    readonly autoPublishAlias?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-autopublishcodesha256
     */
    readonly autoPublishCodeSha256?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-codesigningconfigarn
     */
    readonly codeSigningConfigArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-codeuri
     */
    readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-deadletterqueue
     */
    readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-deploymentpreference
     */
    readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-environment
     */
    readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-eventinvokeconfig
     */
    readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-filesystemconfigs
     */
    readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-functionname
     */
    readonly functionName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-handler
     */
    readonly handler?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-imageconfig
     */
    readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-imageuri
     */
    readonly imageUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-inlinecode
     */
    readonly inlineCode?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-layers
     */
    readonly layers?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-memorysize
     */
    readonly memorySize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-packagetype
     */
    readonly packageType?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-permissionsboundary
     */
    readonly permissionsBoundary?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-policies
     */
    readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-provisionedconcurrencyconfig
     */
    readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-reservedconcurrentexecutions
     */
    readonly reservedConcurrentExecutions?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-runtime
     */
    readonly runtime?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-timeout
     */
    readonly timeout?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-tracing
     */
    readonly tracing?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-versiondescription
     */
    readonly versionDescription?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-vpcconfig
     */
    readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html
   */
  export interface PoliciesProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-architectures
     */
    readonly architectures?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-assumerolepolicydocument
     */
    readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-autopublishalias
     */
    readonly autoPublishAlias?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-autopublishcodesha256
     */
    readonly autoPublishCodeSha256?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-codesigningconfigarn
     */
    readonly codeSigningConfigArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-codeuri
     */
    readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-deadletterqueue
     */
    readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-deploymentpreference
     */
    readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-environment
     */
    readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-eventinvokeconfig
     */
    readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-filesystemconfigs
     */
    readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-functionname
     */
    readonly functionName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-handler
     */
    readonly handler?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-imageconfig
     */
    readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-imageuri
     */
    readonly imageUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-inlinecode
     */
    readonly inlineCode?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-layers
     */
    readonly layers?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-memorysize
     */
    readonly memorySize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-packagetype
     */
    readonly packageType?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-permissionsboundary
     */
    readonly permissionsBoundary?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-policies
     */
    readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-provisionedconcurrencyconfig
     */
    readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-reservedconcurrentexecutions
     */
    readonly reservedConcurrentExecutions?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-runtime
     */
    readonly runtime?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-timeout
     */
    readonly timeout?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-tracing
     */
    readonly tracing?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-versiondescription
     */
    readonly versionDescription?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-vpcconfig
     */
    readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html
   */
  export interface ProvisionedConcurrencyConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-architectures
     */
    readonly architectures?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-assumerolepolicydocument
     */
    readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-autopublishalias
     */
    readonly autoPublishAlias?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-autopublishcodesha256
     */
    readonly autoPublishCodeSha256?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-codesigningconfigarn
     */
    readonly codeSigningConfigArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-codeuri
     */
    readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-deadletterqueue
     */
    readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-deploymentpreference
     */
    readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-environment
     */
    readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-eventinvokeconfig
     */
    readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-filesystemconfigs
     */
    readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-functionname
     */
    readonly functionName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-handler
     */
    readonly handler?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-imageconfig
     */
    readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-imageuri
     */
    readonly imageUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-inlinecode
     */
    readonly inlineCode?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-layers
     */
    readonly layers?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-memorysize
     */
    readonly memorySize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-packagetype
     */
    readonly packageType?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-permissionsboundary
     */
    readonly permissionsBoundary?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-policies
     */
    readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-provisionedconcurrencyconfig
     */
    readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-reservedconcurrentexecutions
     */
    readonly reservedConcurrentExecutions?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-runtime
     */
    readonly runtime?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-timeout
     */
    readonly timeout?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-tracing
     */
    readonly tracing?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-versiondescription
     */
    readonly versionDescription?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-vpcconfig
     */
    readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html
   */
  export interface VpcConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-architectures
     */
    readonly architectures?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-assumerolepolicydocument
     */
    readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-autopublishalias
     */
    readonly autoPublishAlias?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-autopublishcodesha256
     */
    readonly autoPublishCodeSha256?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-codesigningconfigarn
     */
    readonly codeSigningConfigArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-codeuri
     */
    readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-deadletterqueue
     */
    readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-deploymentpreference
     */
    readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-environment
     */
    readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-eventinvokeconfig
     */
    readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-filesystemconfigs
     */
    readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-functionname
     */
    readonly functionName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-handler
     */
    readonly handler?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-imageconfig
     */
    readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-imageuri
     */
    readonly imageUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-inlinecode
     */
    readonly inlineCode?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-layers
     */
    readonly layers?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-memorysize
     */
    readonly memorySize?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-packagetype
     */
    readonly packageType?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-permissionsboundary
     */
    readonly permissionsBoundary?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-policies
     */
    readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-provisionedconcurrencyconfig
     */
    readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-reservedconcurrentexecutions
     */
    readonly reservedConcurrentExecutions?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-runtime
     */
    readonly runtime?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-timeout
     */
    readonly timeout?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-tracing
     */
    readonly tracing?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-versiondescription
     */
    readonly versionDescription?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-vpcconfig
     */
    readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
  }
}

/**
 * Properties for defining a \`CfnFunction\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html
 */
export interface CfnFunctionProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-architectures
   */
  readonly architectures?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-assumerolepolicydocument
   */
  readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-autopublishalias
   */
  readonly autoPublishAlias?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-autopublishcodesha256
   */
  readonly autoPublishCodeSha256?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-codesigningconfigarn
   */
  readonly codeSigningConfigArn?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-codeuri
   */
  readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-deadletterqueue
   */
  readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-deploymentpreference
   */
  readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-description
   */
  readonly description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-environment
   */
  readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-eventinvokeconfig
   */
  readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-events
   */
  readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-filesystemconfigs
   */
  readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-functionname
   */
  readonly functionName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-handler
   */
  readonly handler?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-imageconfig
   */
  readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-imageuri
   */
  readonly imageUri?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-inlinecode
   */
  readonly inlineCode?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-kmskeyarn
   */
  readonly kmsKeyArn?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-layers
   */
  readonly layers?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-memorysize
   */
  readonly memorySize?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-packagetype
   */
  readonly packageType?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-permissionsboundary
   */
  readonly permissionsBoundary?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-policies
   */
  readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-provisionedconcurrencyconfig
   */
  readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-reservedconcurrentexecutions
   */
  readonly reservedConcurrentExecutions?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-role
   */
  readonly role?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-runtime
   */
  readonly runtime?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-timeout
   */
  readonly timeout?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-tracing
   */
  readonly tracing?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-versiondescription
   */
  readonly versionDescription?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-vpcconfig
   */
  readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
}

/**
 * Determine whether the given properties match those of a \`VpcConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`VpcConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionVpcConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"VpcConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionVpcConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionVpcConfigPropertyValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionVpcConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.VpcConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.VpcConfigProperty>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ProvisionedConcurrencyConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`ProvisionedConcurrencyConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionProvisionedConcurrencyConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"ProvisionedConcurrencyConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionProvisionedConcurrencyConfigPropertyValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.ProvisionedConcurrencyConfigProperty>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PoliciesProperty\`
 *
 * @param properties - the TypeScript properties of a \`PoliciesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionPoliciesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"PoliciesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionPoliciesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionPoliciesPropertyValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionPoliciesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.PoliciesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.PoliciesProperty>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ImageConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`ImageConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionImageConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"ImageConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionImageConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionImageConfigPropertyValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionImageConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.ImageConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.ImageConfigProperty>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FileSystemConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`FileSystemConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionFileSystemConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"FileSystemConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionFileSystemConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionFileSystemConfigPropertyValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionFileSystemConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.FileSystemConfigProperty>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventSourceProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventSourceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionEventSourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"EventSourceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionEventSourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionEventSourcePropertyValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionEventSourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.EventSourceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.EventSourceProperty>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventInvokeConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventInvokeConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionEventInvokeConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"EventInvokeConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionEventInvokeConfigPropertyValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.EventInvokeConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.EventInvokeConfigProperty>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FunctionEnvironmentProperty\`
 *
 * @param properties - the TypeScript properties of a \`FunctionEnvironmentProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionFunctionEnvironmentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"FunctionEnvironmentProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionFunctionEnvironmentPropertyValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.FunctionEnvironmentProperty>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeploymentPreferenceProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeploymentPreferenceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionDeploymentPreferencePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"DeploymentPreferenceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionDeploymentPreferencePropertyValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.DeploymentPreferenceProperty>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeadLetterQueueProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeadLetterQueueProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionDeadLetterQueuePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"DeadLetterQueueProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionDeadLetterQueuePropertyValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.DeadLetterQueueProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.DeadLetterQueueProperty>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CodeUriProperty\`
 *
 * @param properties - the TypeScript properties of a \`CodeUriProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionCodeUriPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"CodeUriProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionCodeUriPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionCodeUriPropertyValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionCodeUriPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.CodeUriProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.CodeUriProperty>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnFunctionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnFunctionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"CfnFunctionProps\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionPropsValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunctionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunctionProps>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::HttpApi.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html
 */
export class CfnHttpApi extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::HttpApi";

  /**
   * Build a CfnHttpApi from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnHttpApi {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnHttpApiPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnHttpApi(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-accesslogsetting
   */
  public accessLogSetting?: CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-auth
   */
  public auth?: CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-corsconfiguration
   */
  public corsConfiguration?: boolean | CfnHttpApi.CorsConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-defaultroutesettings
   */
  public defaultRouteSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-definitionbody
   */
  public definitionBody?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-definitionuri
   */
  public definitionUri?: CfnHttpApi.DefinitionUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-description
   */
  public description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-disableexecuteapiendpoint
   */
  public disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-domain
   */
  public domain?: CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-failonwarnings
   */
  public failOnWarnings?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-routesettings
   */
  public routeSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-stagename
   */
  public stageName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-stagevariables
   */
  public stageVariables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnHttpApiProps = {}) {
    super(scope, id, {
      "type": CfnHttpApi.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.accessLogSetting = props.accessLogSetting;
    this.auth = props.auth;
    this.corsConfiguration = props.corsConfiguration;
    this.defaultRouteSettings = props.defaultRouteSettings;
    this.definitionBody = props.definitionBody;
    this.definitionUri = props.definitionUri;
    this.description = props.description;
    this.disableExecuteApiEndpoint = props.disableExecuteApiEndpoint;
    this.domain = props.domain;
    this.failOnWarnings = props.failOnWarnings;
    this.routeSettings = props.routeSettings;
    this.stageName = props.stageName;
    this.stageVariables = props.stageVariables;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Serverless::HttpApi", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "accessLogSetting": this.accessLogSetting,
      "auth": this.auth,
      "corsConfiguration": this.corsConfiguration,
      "defaultRouteSettings": this.defaultRouteSettings,
      "definitionBody": this.definitionBody,
      "definitionUri": this.definitionUri,
      "description": this.description,
      "disableExecuteApiEndpoint": this.disableExecuteApiEndpoint,
      "domain": this.domain,
      "failOnWarnings": this.failOnWarnings,
      "routeSettings": this.routeSettings,
      "stageName": this.stageName,
      "stageVariables": this.stageVariables,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnHttpApi.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnHttpApiPropsToCloudFormation(props);
  }
}

export namespace CfnHttpApi {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html
   */
  export interface AccessLogSettingProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-accesslogsetting
     */
    readonly accessLogSetting?: CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-auth
     */
    readonly auth?: CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-corsconfiguration
     */
    readonly corsConfiguration?: boolean | CfnHttpApi.CorsConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-defaultroutesettings
     */
    readonly defaultRouteSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-definitionuri
     */
    readonly definitionUri?: CfnHttpApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-domain
     */
    readonly domain?: CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-failonwarnings
     */
    readonly failOnWarnings?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-routesettings
     */
    readonly routeSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-stagevariables
     */
    readonly stageVariables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html
   */
  export interface HttpApiAuthProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-accesslogsetting
     */
    readonly accessLogSetting?: CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-auth
     */
    readonly auth?: CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-corsconfiguration
     */
    readonly corsConfiguration?: boolean | CfnHttpApi.CorsConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-defaultroutesettings
     */
    readonly defaultRouteSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-definitionuri
     */
    readonly definitionUri?: CfnHttpApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-domain
     */
    readonly domain?: CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-failonwarnings
     */
    readonly failOnWarnings?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-routesettings
     */
    readonly routeSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-stagevariables
     */
    readonly stageVariables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html
   */
  export interface CorsConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-accesslogsetting
     */
    readonly accessLogSetting?: CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-auth
     */
    readonly auth?: CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-corsconfiguration
     */
    readonly corsConfiguration?: boolean | CfnHttpApi.CorsConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-defaultroutesettings
     */
    readonly defaultRouteSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-definitionuri
     */
    readonly definitionUri?: CfnHttpApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-domain
     */
    readonly domain?: CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-failonwarnings
     */
    readonly failOnWarnings?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-routesettings
     */
    readonly routeSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-stagevariables
     */
    readonly stageVariables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html
   */
  export interface RouteSettingsProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-accesslogsetting
     */
    readonly accessLogSetting?: CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-auth
     */
    readonly auth?: CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-corsconfiguration
     */
    readonly corsConfiguration?: boolean | CfnHttpApi.CorsConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-defaultroutesettings
     */
    readonly defaultRouteSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-definitionuri
     */
    readonly definitionUri?: CfnHttpApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-domain
     */
    readonly domain?: CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-failonwarnings
     */
    readonly failOnWarnings?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-routesettings
     */
    readonly routeSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-stagevariables
     */
    readonly stageVariables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html
   */
  export interface DefinitionUriProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-accesslogsetting
     */
    readonly accessLogSetting?: CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-auth
     */
    readonly auth?: CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-corsconfiguration
     */
    readonly corsConfiguration?: boolean | CfnHttpApi.CorsConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-defaultroutesettings
     */
    readonly defaultRouteSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-definitionuri
     */
    readonly definitionUri?: CfnHttpApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-domain
     */
    readonly domain?: CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-failonwarnings
     */
    readonly failOnWarnings?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-routesettings
     */
    readonly routeSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-stagevariables
     */
    readonly stageVariables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html
   */
  export interface HttpApiDomainConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-accesslogsetting
     */
    readonly accessLogSetting?: CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-auth
     */
    readonly auth?: CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-corsconfiguration
     */
    readonly corsConfiguration?: boolean | CfnHttpApi.CorsConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-defaultroutesettings
     */
    readonly defaultRouteSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-definitionbody
     */
    readonly definitionBody?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-definitionuri
     */
    readonly definitionUri?: CfnHttpApi.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-disableexecuteapiendpoint
     */
    readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-domain
     */
    readonly domain?: CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-failonwarnings
     */
    readonly failOnWarnings?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-routesettings
     */
    readonly routeSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-stagename
     */
    readonly stageName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-stagevariables
     */
    readonly stageVariables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }
}

/**
 * Properties for defining a \`CfnHttpApi\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html
 */
export interface CfnHttpApiProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-accesslogsetting
   */
  readonly accessLogSetting?: CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-auth
   */
  readonly auth?: CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-corsconfiguration
   */
  readonly corsConfiguration?: boolean | CfnHttpApi.CorsConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-defaultroutesettings
   */
  readonly defaultRouteSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-definitionbody
   */
  readonly definitionBody?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-definitionuri
   */
  readonly definitionUri?: CfnHttpApi.DefinitionUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-description
   */
  readonly description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-disableexecuteapiendpoint
   */
  readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-domain
   */
  readonly domain?: CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-failonwarnings
   */
  readonly failOnWarnings?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-routesettings
   */
  readonly routeSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-stagename
   */
  readonly stageName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-stagevariables
   */
  readonly stageVariables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`HttpApiDomainConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`HttpApiDomainConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiHttpApiDomainConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnHttpApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnHttpApiHttpApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("corsConfiguration", cdk.unionValidator(cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator))(properties.corsConfiguration));
  errors.collect(cdk.propertyValidator("defaultRouteSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.defaultRouteSettings));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnHttpApiHttpApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("failOnWarnings", cdk.validateBoolean)(properties.failOnWarnings));
  errors.collect(cdk.propertyValidator("routeSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.routeSettings));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("stageVariables", cdk.hashValidator(cdk.validateObject))(properties.stageVariables));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"HttpApiDomainConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiHttpApiDomainConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiHttpApiDomainConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnHttpApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnHttpApiHttpApiAuthPropertyToCloudFormation(properties.auth),
    "CorsConfiguration": cdk.unionMapper([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cdk.booleanToCloudFormation, convertCfnHttpApiCorsConfigurationPropertyToCloudFormation])(properties.corsConfiguration),
    "DefaultRouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.defaultRouteSettings),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnHttpApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnHttpApiHttpApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "FailOnWarnings": cdk.booleanToCloudFormation(properties.failOnWarnings),
    "RouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.routeSettings),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "StageVariables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.stageVariables),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnHttpApiHttpApiDomainConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.HttpApiDomainConfigurationProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnHttpApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnHttpApiHttpApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("corsConfiguration", "CorsConfiguration", (properties.CorsConfiguration != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cfn_parse.FromCloudFormation.getBoolean, CfnHttpApiCorsConfigurationPropertyFromCloudFormation])(properties.CorsConfiguration) : undefined));
  ret.addPropertyResult("defaultRouteSettings", "DefaultRouteSettings", (properties.DefaultRouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.DefaultRouteSettings) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [CfnHttpApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnHttpApiHttpApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("failOnWarnings", "FailOnWarnings", (properties.FailOnWarnings != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FailOnWarnings) : undefined));
  ret.addPropertyResult("routeSettings", "RouteSettings", (properties.RouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.RouteSettings) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("stageVariables", "StageVariables", (properties.StageVariables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.StageVariables) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DefinitionUriProperty\`
 *
 * @param properties - the TypeScript properties of a \`DefinitionUriProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiDefinitionUriPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnHttpApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnHttpApiHttpApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("corsConfiguration", cdk.unionValidator(cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator))(properties.corsConfiguration));
  errors.collect(cdk.propertyValidator("defaultRouteSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.defaultRouteSettings));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnHttpApiHttpApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("failOnWarnings", cdk.validateBoolean)(properties.failOnWarnings));
  errors.collect(cdk.propertyValidator("routeSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.routeSettings));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("stageVariables", cdk.hashValidator(cdk.validateObject))(properties.stageVariables));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"DefinitionUriProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiDefinitionUriPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiDefinitionUriPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnHttpApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnHttpApiHttpApiAuthPropertyToCloudFormation(properties.auth),
    "CorsConfiguration": cdk.unionMapper([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cdk.booleanToCloudFormation, convertCfnHttpApiCorsConfigurationPropertyToCloudFormation])(properties.corsConfiguration),
    "DefaultRouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.defaultRouteSettings),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnHttpApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnHttpApiHttpApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "FailOnWarnings": cdk.booleanToCloudFormation(properties.failOnWarnings),
    "RouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.routeSettings),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "StageVariables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.stageVariables),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnHttpApiDefinitionUriPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.DefinitionUriProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.DefinitionUriProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnHttpApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnHttpApiHttpApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("corsConfiguration", "CorsConfiguration", (properties.CorsConfiguration != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cfn_parse.FromCloudFormation.getBoolean, CfnHttpApiCorsConfigurationPropertyFromCloudFormation])(properties.CorsConfiguration) : undefined));
  ret.addPropertyResult("defaultRouteSettings", "DefaultRouteSettings", (properties.DefaultRouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.DefaultRouteSettings) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [CfnHttpApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnHttpApiHttpApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("failOnWarnings", "FailOnWarnings", (properties.FailOnWarnings != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FailOnWarnings) : undefined));
  ret.addPropertyResult("routeSettings", "RouteSettings", (properties.RouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.RouteSettings) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("stageVariables", "StageVariables", (properties.StageVariables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.StageVariables) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RouteSettingsProperty\`
 *
 * @param properties - the TypeScript properties of a \`RouteSettingsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiRouteSettingsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnHttpApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnHttpApiHttpApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("corsConfiguration", cdk.unionValidator(cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator))(properties.corsConfiguration));
  errors.collect(cdk.propertyValidator("defaultRouteSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.defaultRouteSettings));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnHttpApiHttpApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("failOnWarnings", cdk.validateBoolean)(properties.failOnWarnings));
  errors.collect(cdk.propertyValidator("routeSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.routeSettings));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("stageVariables", cdk.hashValidator(cdk.validateObject))(properties.stageVariables));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"RouteSettingsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiRouteSettingsPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnHttpApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnHttpApiHttpApiAuthPropertyToCloudFormation(properties.auth),
    "CorsConfiguration": cdk.unionMapper([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cdk.booleanToCloudFormation, convertCfnHttpApiCorsConfigurationPropertyToCloudFormation])(properties.corsConfiguration),
    "DefaultRouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.defaultRouteSettings),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnHttpApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnHttpApiHttpApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "FailOnWarnings": cdk.booleanToCloudFormation(properties.failOnWarnings),
    "RouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.routeSettings),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "StageVariables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.stageVariables),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnHttpApi.RouteSettingsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.RouteSettingsProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnHttpApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnHttpApiHttpApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("corsConfiguration", "CorsConfiguration", (properties.CorsConfiguration != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cfn_parse.FromCloudFormation.getBoolean, CfnHttpApiCorsConfigurationPropertyFromCloudFormation])(properties.CorsConfiguration) : undefined));
  ret.addPropertyResult("defaultRouteSettings", "DefaultRouteSettings", (properties.DefaultRouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.DefaultRouteSettings) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [CfnHttpApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnHttpApiHttpApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("failOnWarnings", "FailOnWarnings", (properties.FailOnWarnings != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FailOnWarnings) : undefined));
  ret.addPropertyResult("routeSettings", "RouteSettings", (properties.RouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.RouteSettings) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("stageVariables", "StageVariables", (properties.StageVariables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.StageVariables) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CorsConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CorsConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiCorsConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnHttpApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnHttpApiHttpApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("corsConfiguration", cdk.unionValidator(cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator))(properties.corsConfiguration));
  errors.collect(cdk.propertyValidator("defaultRouteSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.defaultRouteSettings));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnHttpApiHttpApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("failOnWarnings", cdk.validateBoolean)(properties.failOnWarnings));
  errors.collect(cdk.propertyValidator("routeSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.routeSettings));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("stageVariables", cdk.hashValidator(cdk.validateObject))(properties.stageVariables));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CorsConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiCorsConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiCorsConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnHttpApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnHttpApiHttpApiAuthPropertyToCloudFormation(properties.auth),
    "CorsConfiguration": cdk.unionMapper([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cdk.booleanToCloudFormation, convertCfnHttpApiCorsConfigurationPropertyToCloudFormation])(properties.corsConfiguration),
    "DefaultRouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.defaultRouteSettings),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnHttpApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnHttpApiHttpApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "FailOnWarnings": cdk.booleanToCloudFormation(properties.failOnWarnings),
    "RouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.routeSettings),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "StageVariables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.stageVariables),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnHttpApiCorsConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.CorsConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.CorsConfigurationProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnHttpApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnHttpApiHttpApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("corsConfiguration", "CorsConfiguration", (properties.CorsConfiguration != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cfn_parse.FromCloudFormation.getBoolean, CfnHttpApiCorsConfigurationPropertyFromCloudFormation])(properties.CorsConfiguration) : undefined));
  ret.addPropertyResult("defaultRouteSettings", "DefaultRouteSettings", (properties.DefaultRouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.DefaultRouteSettings) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [CfnHttpApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnHttpApiHttpApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("failOnWarnings", "FailOnWarnings", (properties.FailOnWarnings != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FailOnWarnings) : undefined));
  ret.addPropertyResult("routeSettings", "RouteSettings", (properties.RouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.RouteSettings) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("stageVariables", "StageVariables", (properties.StageVariables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.StageVariables) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`HttpApiAuthProperty\`
 *
 * @param properties - the TypeScript properties of a \`HttpApiAuthProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiHttpApiAuthPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnHttpApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnHttpApiHttpApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("corsConfiguration", cdk.unionValidator(cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator))(properties.corsConfiguration));
  errors.collect(cdk.propertyValidator("defaultRouteSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.defaultRouteSettings));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnHttpApiHttpApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("failOnWarnings", cdk.validateBoolean)(properties.failOnWarnings));
  errors.collect(cdk.propertyValidator("routeSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.routeSettings));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("stageVariables", cdk.hashValidator(cdk.validateObject))(properties.stageVariables));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"HttpApiAuthProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiHttpApiAuthPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiHttpApiAuthPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnHttpApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnHttpApiHttpApiAuthPropertyToCloudFormation(properties.auth),
    "CorsConfiguration": cdk.unionMapper([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cdk.booleanToCloudFormation, convertCfnHttpApiCorsConfigurationPropertyToCloudFormation])(properties.corsConfiguration),
    "DefaultRouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.defaultRouteSettings),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnHttpApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnHttpApiHttpApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "FailOnWarnings": cdk.booleanToCloudFormation(properties.failOnWarnings),
    "RouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.routeSettings),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "StageVariables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.stageVariables),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnHttpApiHttpApiAuthPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.HttpApiAuthProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnHttpApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnHttpApiHttpApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("corsConfiguration", "CorsConfiguration", (properties.CorsConfiguration != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cfn_parse.FromCloudFormation.getBoolean, CfnHttpApiCorsConfigurationPropertyFromCloudFormation])(properties.CorsConfiguration) : undefined));
  ret.addPropertyResult("defaultRouteSettings", "DefaultRouteSettings", (properties.DefaultRouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.DefaultRouteSettings) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [CfnHttpApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnHttpApiHttpApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("failOnWarnings", "FailOnWarnings", (properties.FailOnWarnings != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FailOnWarnings) : undefined));
  ret.addPropertyResult("routeSettings", "RouteSettings", (properties.RouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.RouteSettings) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("stageVariables", "StageVariables", (properties.StageVariables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.StageVariables) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AccessLogSettingProperty\`
 *
 * @param properties - the TypeScript properties of a \`AccessLogSettingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiAccessLogSettingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnHttpApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnHttpApiHttpApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("corsConfiguration", cdk.unionValidator(cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator))(properties.corsConfiguration));
  errors.collect(cdk.propertyValidator("defaultRouteSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.defaultRouteSettings));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnHttpApiHttpApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("failOnWarnings", cdk.validateBoolean)(properties.failOnWarnings));
  errors.collect(cdk.propertyValidator("routeSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.routeSettings));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("stageVariables", cdk.hashValidator(cdk.validateObject))(properties.stageVariables));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"AccessLogSettingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiAccessLogSettingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiAccessLogSettingPropertyValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnHttpApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnHttpApiHttpApiAuthPropertyToCloudFormation(properties.auth),
    "CorsConfiguration": cdk.unionMapper([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cdk.booleanToCloudFormation, convertCfnHttpApiCorsConfigurationPropertyToCloudFormation])(properties.corsConfiguration),
    "DefaultRouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.defaultRouteSettings),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnHttpApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnHttpApiHttpApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "FailOnWarnings": cdk.booleanToCloudFormation(properties.failOnWarnings),
    "RouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.routeSettings),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "StageVariables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.stageVariables),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnHttpApiAccessLogSettingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.AccessLogSettingProperty>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnHttpApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnHttpApiHttpApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("corsConfiguration", "CorsConfiguration", (properties.CorsConfiguration != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cfn_parse.FromCloudFormation.getBoolean, CfnHttpApiCorsConfigurationPropertyFromCloudFormation])(properties.CorsConfiguration) : undefined));
  ret.addPropertyResult("defaultRouteSettings", "DefaultRouteSettings", (properties.DefaultRouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.DefaultRouteSettings) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [CfnHttpApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnHttpApiHttpApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("failOnWarnings", "FailOnWarnings", (properties.FailOnWarnings != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FailOnWarnings) : undefined));
  ret.addPropertyResult("routeSettings", "RouteSettings", (properties.RouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.RouteSettings) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("stageVariables", "StageVariables", (properties.StageVariables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.StageVariables) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnHttpApiProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnHttpApiProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnHttpApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnHttpApiHttpApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("corsConfiguration", cdk.unionValidator(cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator))(properties.corsConfiguration));
  errors.collect(cdk.propertyValidator("defaultRouteSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.defaultRouteSettings));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnHttpApiHttpApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("failOnWarnings", cdk.validateBoolean)(properties.failOnWarnings));
  errors.collect(cdk.propertyValidator("routeSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.routeSettings));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("stageVariables", cdk.hashValidator(cdk.validateObject))(properties.stageVariables));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnHttpApiProps\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiPropsValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnHttpApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnHttpApiHttpApiAuthPropertyToCloudFormation(properties.auth),
    "CorsConfiguration": cdk.unionMapper([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cdk.booleanToCloudFormation, convertCfnHttpApiCorsConfigurationPropertyToCloudFormation])(properties.corsConfiguration),
    "DefaultRouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.defaultRouteSettings),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnHttpApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnHttpApiHttpApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "FailOnWarnings": cdk.booleanToCloudFormation(properties.failOnWarnings),
    "RouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.routeSettings),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "StageVariables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.stageVariables),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnHttpApiPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApiProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApiProps>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnHttpApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnHttpApiHttpApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("corsConfiguration", "CorsConfiguration", (properties.CorsConfiguration != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cfn_parse.FromCloudFormation.getBoolean, CfnHttpApiCorsConfigurationPropertyFromCloudFormation])(properties.CorsConfiguration) : undefined));
  ret.addPropertyResult("defaultRouteSettings", "DefaultRouteSettings", (properties.DefaultRouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.DefaultRouteSettings) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [CfnHttpApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnHttpApiHttpApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("failOnWarnings", "FailOnWarnings", (properties.FailOnWarnings != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FailOnWarnings) : undefined));
  ret.addPropertyResult("routeSettings", "RouteSettings", (properties.RouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.RouteSettings) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("stageVariables", "StageVariables", (properties.StageVariables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.StageVariables) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::LayerVersion.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html
 */
export class CfnLayerVersion extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::LayerVersion";

  /**
   * Build a CfnLayerVersion from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLayerVersion {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLayerVersionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLayerVersion(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-compatibleruntimes
   */
  public compatibleRuntimes?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-contenturi
   */
  public contentUri?: CfnLayerVersion.ContentUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-description
   */
  public description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-layername
   */
  public layerName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-licenseinfo
   */
  public licenseInfo?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-retentionpolicy
   */
  public retentionPolicy?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLayerVersionProps = {}) {
    super(scope, id, {
      "type": CfnLayerVersion.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.compatibleRuntimes = props.compatibleRuntimes;
    this.contentUri = props.contentUri;
    this.description = props.description;
    this.layerName = props.layerName;
    this.licenseInfo = props.licenseInfo;
    this.retentionPolicy = props.retentionPolicy;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "compatibleRuntimes": this.compatibleRuntimes,
      "contentUri": this.contentUri,
      "description": this.description,
      "layerName": this.layerName,
      "licenseInfo": this.licenseInfo,
      "retentionPolicy": this.retentionPolicy
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLayerVersion.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLayerVersionPropsToCloudFormation(props);
  }
}

export namespace CfnLayerVersion {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-contenturi.html
   */
  export interface ContentUriProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-contenturi.html#cfn-serverless-layerversion-contenturi-compatibleruntimes
     */
    readonly compatibleRuntimes?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-contenturi.html#cfn-serverless-layerversion-contenturi-contenturi
     */
    readonly contentUri?: CfnLayerVersion.ContentUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-contenturi.html#cfn-serverless-layerversion-contenturi-description
     */
    readonly description?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-contenturi.html#cfn-serverless-layerversion-contenturi-layername
     */
    readonly layerName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-contenturi.html#cfn-serverless-layerversion-contenturi-licenseinfo
     */
    readonly licenseInfo?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-contenturi.html#cfn-serverless-layerversion-contenturi-retentionpolicy
     */
    readonly retentionPolicy?: string;
  }
}

/**
 * Properties for defining a \`CfnLayerVersion\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html
 */
export interface CfnLayerVersionProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-compatibleruntimes
   */
  readonly compatibleRuntimes?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-contenturi
   */
  readonly contentUri?: CfnLayerVersion.ContentUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-description
   */
  readonly description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-layername
   */
  readonly layerName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-licenseinfo
   */
  readonly licenseInfo?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-retentionpolicy
   */
  readonly retentionPolicy?: string;
}

/**
 * Determine whether the given properties match those of a \`ContentUriProperty\`
 *
 * @param properties - the TypeScript properties of a \`ContentUriProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLayerVersionContentUriPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("compatibleRuntimes", cdk.listValidator(cdk.validateString))(properties.compatibleRuntimes));
  errors.collect(cdk.propertyValidator("contentUri", cdk.unionValidator(CfnLayerVersionContentUriPropertyValidator, cdk.validateString))(properties.contentUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("layerName", cdk.validateString)(properties.layerName));
  errors.collect(cdk.propertyValidator("licenseInfo", cdk.validateString)(properties.licenseInfo));
  errors.collect(cdk.propertyValidator("retentionPolicy", cdk.validateString)(properties.retentionPolicy));
  return errors.wrap("supplied properties not correct for \\"ContentUriProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLayerVersionContentUriPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLayerVersionContentUriPropertyValidator(properties).assertSuccess();
  return {
    "CompatibleRuntimes": cdk.listMapper(cdk.stringToCloudFormation)(properties.compatibleRuntimes),
    "ContentUri": cdk.unionMapper([CfnLayerVersionContentUriPropertyValidator, cdk.validateString], [convertCfnLayerVersionContentUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.contentUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "LayerName": cdk.stringToCloudFormation(properties.layerName),
    "LicenseInfo": cdk.stringToCloudFormation(properties.licenseInfo),
    "RetentionPolicy": cdk.stringToCloudFormation(properties.retentionPolicy)
  };
}

// @ts-ignore TS6133
function CfnLayerVersionContentUriPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLayerVersion.ContentUriProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLayerVersion.ContentUriProperty>();
  ret.addPropertyResult("compatibleRuntimes", "CompatibleRuntimes", (properties.CompatibleRuntimes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.CompatibleRuntimes) : undefined));
  ret.addPropertyResult("contentUri", "ContentUri", (properties.ContentUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnLayerVersionContentUriPropertyValidator, cdk.validateString], [CfnLayerVersionContentUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.ContentUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("layerName", "LayerName", (properties.LayerName != null ? cfn_parse.FromCloudFormation.getString(properties.LayerName) : undefined));
  ret.addPropertyResult("licenseInfo", "LicenseInfo", (properties.LicenseInfo != null ? cfn_parse.FromCloudFormation.getString(properties.LicenseInfo) : undefined));
  ret.addPropertyResult("retentionPolicy", "RetentionPolicy", (properties.RetentionPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.RetentionPolicy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnLayerVersionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLayerVersionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLayerVersionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("compatibleRuntimes", cdk.listValidator(cdk.validateString))(properties.compatibleRuntimes));
  errors.collect(cdk.propertyValidator("contentUri", cdk.unionValidator(CfnLayerVersionContentUriPropertyValidator, cdk.validateString))(properties.contentUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("layerName", cdk.validateString)(properties.layerName));
  errors.collect(cdk.propertyValidator("licenseInfo", cdk.validateString)(properties.licenseInfo));
  errors.collect(cdk.propertyValidator("retentionPolicy", cdk.validateString)(properties.retentionPolicy));
  return errors.wrap("supplied properties not correct for \\"CfnLayerVersionProps\\"");
}

// @ts-ignore TS6133
function convertCfnLayerVersionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLayerVersionPropsValidator(properties).assertSuccess();
  return {
    "CompatibleRuntimes": cdk.listMapper(cdk.stringToCloudFormation)(properties.compatibleRuntimes),
    "ContentUri": cdk.unionMapper([CfnLayerVersionContentUriPropertyValidator, cdk.validateString], [convertCfnLayerVersionContentUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.contentUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "LayerName": cdk.stringToCloudFormation(properties.layerName),
    "LicenseInfo": cdk.stringToCloudFormation(properties.licenseInfo),
    "RetentionPolicy": cdk.stringToCloudFormation(properties.retentionPolicy)
  };
}

// @ts-ignore TS6133
function CfnLayerVersionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLayerVersionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLayerVersionProps>();
  ret.addPropertyResult("compatibleRuntimes", "CompatibleRuntimes", (properties.CompatibleRuntimes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.CompatibleRuntimes) : undefined));
  ret.addPropertyResult("contentUri", "ContentUri", (properties.ContentUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnLayerVersionContentUriPropertyValidator, cdk.validateString], [CfnLayerVersionContentUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.ContentUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("layerName", "LayerName", (properties.LayerName != null ? cfn_parse.FromCloudFormation.getString(properties.LayerName) : undefined));
  ret.addPropertyResult("licenseInfo", "LicenseInfo", (properties.LicenseInfo != null ? cfn_parse.FromCloudFormation.getString(properties.LicenseInfo) : undefined));
  ret.addPropertyResult("retentionPolicy", "RetentionPolicy", (properties.RetentionPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.RetentionPolicy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::SimpleTable.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html
 */
export class CfnSimpleTable extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::SimpleTable";

  /**
   * Build a CfnSimpleTable from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSimpleTable {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSimpleTablePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSimpleTable(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-primarykey
   */
  public primaryKey?: cdk.IResolvable | CfnSimpleTable.PrimaryKeyProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-provisionedthroughput
   */
  public provisionedThroughput?: cdk.IResolvable | CfnSimpleTable.ProvisionedThroughputProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-ssespecification
   */
  public sseSpecification?: cdk.IResolvable | CfnSimpleTable.SSESpecificationProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-tablename
   */
  public tableName?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSimpleTableProps = {}) {
    super(scope, id, {
      "type": CfnSimpleTable.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.primaryKey = props.primaryKey;
    this.provisionedThroughput = props.provisionedThroughput;
    this.sseSpecification = props.sseSpecification;
    this.tableName = props.tableName;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Serverless::SimpleTable", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "primaryKey": this.primaryKey,
      "provisionedThroughput": this.provisionedThroughput,
      "sseSpecification": this.sseSpecification,
      "tableName": this.tableName,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSimpleTable.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSimpleTablePropsToCloudFormation(props);
  }
}

export namespace CfnSimpleTable {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-primarykey.html
   */
  export interface PrimaryKeyProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-primarykey.html#cfn-serverless-simpletable-primarykey-primarykey
     */
    readonly primaryKey?: cdk.IResolvable | CfnSimpleTable.PrimaryKeyProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-primarykey.html#cfn-serverless-simpletable-primarykey-provisionedthroughput
     */
    readonly provisionedThroughput?: cdk.IResolvable | CfnSimpleTable.ProvisionedThroughputProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-primarykey.html#cfn-serverless-simpletable-primarykey-ssespecification
     */
    readonly sseSpecification?: cdk.IResolvable | CfnSimpleTable.SSESpecificationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-primarykey.html#cfn-serverless-simpletable-primarykey-tablename
     */
    readonly tableName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-primarykey.html#cfn-serverless-simpletable-primarykey-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-provisionedthroughput.html
   */
  export interface ProvisionedThroughputProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-provisionedthroughput.html#cfn-serverless-simpletable-provisionedthroughput-primarykey
     */
    readonly primaryKey?: cdk.IResolvable | CfnSimpleTable.PrimaryKeyProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-provisionedthroughput.html#cfn-serverless-simpletable-provisionedthroughput-provisionedthroughput
     */
    readonly provisionedThroughput?: cdk.IResolvable | CfnSimpleTable.ProvisionedThroughputProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-provisionedthroughput.html#cfn-serverless-simpletable-provisionedthroughput-ssespecification
     */
    readonly sseSpecification?: cdk.IResolvable | CfnSimpleTable.SSESpecificationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-provisionedthroughput.html#cfn-serverless-simpletable-provisionedthroughput-tablename
     */
    readonly tableName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-provisionedthroughput.html#cfn-serverless-simpletable-provisionedthroughput-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-ssespecification.html
   */
  export interface SSESpecificationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-ssespecification.html#cfn-serverless-simpletable-ssespecification-primarykey
     */
    readonly primaryKey?: cdk.IResolvable | CfnSimpleTable.PrimaryKeyProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-ssespecification.html#cfn-serverless-simpletable-ssespecification-provisionedthroughput
     */
    readonly provisionedThroughput?: cdk.IResolvable | CfnSimpleTable.ProvisionedThroughputProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-ssespecification.html#cfn-serverless-simpletable-ssespecification-ssespecification
     */
    readonly sseSpecification?: cdk.IResolvable | CfnSimpleTable.SSESpecificationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-ssespecification.html#cfn-serverless-simpletable-ssespecification-tablename
     */
    readonly tableName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-ssespecification.html#cfn-serverless-simpletable-ssespecification-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }
}

/**
 * Properties for defining a \`CfnSimpleTable\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html
 */
export interface CfnSimpleTableProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-primarykey
   */
  readonly primaryKey?: cdk.IResolvable | CfnSimpleTable.PrimaryKeyProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-provisionedthroughput
   */
  readonly provisionedThroughput?: cdk.IResolvable | CfnSimpleTable.ProvisionedThroughputProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-ssespecification
   */
  readonly sseSpecification?: cdk.IResolvable | CfnSimpleTable.SSESpecificationProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-tablename
   */
  readonly tableName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`SSESpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`SSESpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSimpleTableSSESpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primaryKey", CfnSimpleTablePrimaryKeyPropertyValidator)(properties.primaryKey));
  errors.collect(cdk.propertyValidator("provisionedThroughput", CfnSimpleTableProvisionedThroughputPropertyValidator)(properties.provisionedThroughput));
  errors.collect(cdk.propertyValidator("sseSpecification", CfnSimpleTableSSESpecificationPropertyValidator)(properties.sseSpecification));
  errors.collect(cdk.propertyValidator("tableName", cdk.validateString)(properties.tableName));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"SSESpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSimpleTableSSESpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSimpleTableSSESpecificationPropertyValidator(properties).assertSuccess();
  return {
    "PrimaryKey": convertCfnSimpleTablePrimaryKeyPropertyToCloudFormation(properties.primaryKey),
    "ProvisionedThroughput": convertCfnSimpleTableProvisionedThroughputPropertyToCloudFormation(properties.provisionedThroughput),
    "SSESpecification": convertCfnSimpleTableSSESpecificationPropertyToCloudFormation(properties.sseSpecification),
    "TableName": cdk.stringToCloudFormation(properties.tableName),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnSimpleTableSSESpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSimpleTable.SSESpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSimpleTable.SSESpecificationProperty>();
  ret.addPropertyResult("primaryKey", "PrimaryKey", (properties.PrimaryKey != null ? CfnSimpleTablePrimaryKeyPropertyFromCloudFormation(properties.PrimaryKey) : undefined));
  ret.addPropertyResult("provisionedThroughput", "ProvisionedThroughput", (properties.ProvisionedThroughput != null ? CfnSimpleTableProvisionedThroughputPropertyFromCloudFormation(properties.ProvisionedThroughput) : undefined));
  ret.addPropertyResult("sseSpecification", "SSESpecification", (properties.SSESpecification != null ? CfnSimpleTableSSESpecificationPropertyFromCloudFormation(properties.SSESpecification) : undefined));
  ret.addPropertyResult("tableName", "TableName", (properties.TableName != null ? cfn_parse.FromCloudFormation.getString(properties.TableName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ProvisionedThroughputProperty\`
 *
 * @param properties - the TypeScript properties of a \`ProvisionedThroughputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSimpleTableProvisionedThroughputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primaryKey", CfnSimpleTablePrimaryKeyPropertyValidator)(properties.primaryKey));
  errors.collect(cdk.propertyValidator("provisionedThroughput", CfnSimpleTableProvisionedThroughputPropertyValidator)(properties.provisionedThroughput));
  errors.collect(cdk.propertyValidator("sseSpecification", CfnSimpleTableSSESpecificationPropertyValidator)(properties.sseSpecification));
  errors.collect(cdk.propertyValidator("tableName", cdk.validateString)(properties.tableName));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"ProvisionedThroughputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSimpleTableProvisionedThroughputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSimpleTableProvisionedThroughputPropertyValidator(properties).assertSuccess();
  return {
    "PrimaryKey": convertCfnSimpleTablePrimaryKeyPropertyToCloudFormation(properties.primaryKey),
    "ProvisionedThroughput": convertCfnSimpleTableProvisionedThroughputPropertyToCloudFormation(properties.provisionedThroughput),
    "SSESpecification": convertCfnSimpleTableSSESpecificationPropertyToCloudFormation(properties.sseSpecification),
    "TableName": cdk.stringToCloudFormation(properties.tableName),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnSimpleTableProvisionedThroughputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSimpleTable.ProvisionedThroughputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSimpleTable.ProvisionedThroughputProperty>();
  ret.addPropertyResult("primaryKey", "PrimaryKey", (properties.PrimaryKey != null ? CfnSimpleTablePrimaryKeyPropertyFromCloudFormation(properties.PrimaryKey) : undefined));
  ret.addPropertyResult("provisionedThroughput", "ProvisionedThroughput", (properties.ProvisionedThroughput != null ? CfnSimpleTableProvisionedThroughputPropertyFromCloudFormation(properties.ProvisionedThroughput) : undefined));
  ret.addPropertyResult("sseSpecification", "SSESpecification", (properties.SSESpecification != null ? CfnSimpleTableSSESpecificationPropertyFromCloudFormation(properties.SSESpecification) : undefined));
  ret.addPropertyResult("tableName", "TableName", (properties.TableName != null ? cfn_parse.FromCloudFormation.getString(properties.TableName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PrimaryKeyProperty\`
 *
 * @param properties - the TypeScript properties of a \`PrimaryKeyProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSimpleTablePrimaryKeyPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primaryKey", CfnSimpleTablePrimaryKeyPropertyValidator)(properties.primaryKey));
  errors.collect(cdk.propertyValidator("provisionedThroughput", CfnSimpleTableProvisionedThroughputPropertyValidator)(properties.provisionedThroughput));
  errors.collect(cdk.propertyValidator("sseSpecification", CfnSimpleTableSSESpecificationPropertyValidator)(properties.sseSpecification));
  errors.collect(cdk.propertyValidator("tableName", cdk.validateString)(properties.tableName));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"PrimaryKeyProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSimpleTablePrimaryKeyPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSimpleTablePrimaryKeyPropertyValidator(properties).assertSuccess();
  return {
    "PrimaryKey": convertCfnSimpleTablePrimaryKeyPropertyToCloudFormation(properties.primaryKey),
    "ProvisionedThroughput": convertCfnSimpleTableProvisionedThroughputPropertyToCloudFormation(properties.provisionedThroughput),
    "SSESpecification": convertCfnSimpleTableSSESpecificationPropertyToCloudFormation(properties.sseSpecification),
    "TableName": cdk.stringToCloudFormation(properties.tableName),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnSimpleTablePrimaryKeyPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSimpleTable.PrimaryKeyProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSimpleTable.PrimaryKeyProperty>();
  ret.addPropertyResult("primaryKey", "PrimaryKey", (properties.PrimaryKey != null ? CfnSimpleTablePrimaryKeyPropertyFromCloudFormation(properties.PrimaryKey) : undefined));
  ret.addPropertyResult("provisionedThroughput", "ProvisionedThroughput", (properties.ProvisionedThroughput != null ? CfnSimpleTableProvisionedThroughputPropertyFromCloudFormation(properties.ProvisionedThroughput) : undefined));
  ret.addPropertyResult("sseSpecification", "SSESpecification", (properties.SSESpecification != null ? CfnSimpleTableSSESpecificationPropertyFromCloudFormation(properties.SSESpecification) : undefined));
  ret.addPropertyResult("tableName", "TableName", (properties.TableName != null ? cfn_parse.FromCloudFormation.getString(properties.TableName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSimpleTableProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSimpleTableProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSimpleTablePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primaryKey", CfnSimpleTablePrimaryKeyPropertyValidator)(properties.primaryKey));
  errors.collect(cdk.propertyValidator("provisionedThroughput", CfnSimpleTableProvisionedThroughputPropertyValidator)(properties.provisionedThroughput));
  errors.collect(cdk.propertyValidator("sseSpecification", CfnSimpleTableSSESpecificationPropertyValidator)(properties.sseSpecification));
  errors.collect(cdk.propertyValidator("tableName", cdk.validateString)(properties.tableName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnSimpleTableProps\\"");
}

// @ts-ignore TS6133
function convertCfnSimpleTablePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSimpleTablePropsValidator(properties).assertSuccess();
  return {
    "PrimaryKey": convertCfnSimpleTablePrimaryKeyPropertyToCloudFormation(properties.primaryKey),
    "ProvisionedThroughput": convertCfnSimpleTableProvisionedThroughputPropertyToCloudFormation(properties.provisionedThroughput),
    "SSESpecification": convertCfnSimpleTableSSESpecificationPropertyToCloudFormation(properties.sseSpecification),
    "TableName": cdk.stringToCloudFormation(properties.tableName),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnSimpleTablePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSimpleTableProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSimpleTableProps>();
  ret.addPropertyResult("primaryKey", "PrimaryKey", (properties.PrimaryKey != null ? CfnSimpleTablePrimaryKeyPropertyFromCloudFormation(properties.PrimaryKey) : undefined));
  ret.addPropertyResult("provisionedThroughput", "ProvisionedThroughput", (properties.ProvisionedThroughput != null ? CfnSimpleTableProvisionedThroughputPropertyFromCloudFormation(properties.ProvisionedThroughput) : undefined));
  ret.addPropertyResult("sseSpecification", "SSESpecification", (properties.SSESpecification != null ? CfnSimpleTableSSESpecificationPropertyFromCloudFormation(properties.SSESpecification) : undefined));
  ret.addPropertyResult("tableName", "TableName", (properties.TableName != null ? cfn_parse.FromCloudFormation.getString(properties.TableName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::StateMachine.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html
 */
export class CfnStateMachine extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::StateMachine";

  /**
   * Build a CfnStateMachine from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnStateMachine {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnStateMachinePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnStateMachine(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-definition
   */
  public definition?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-definitionsubstitutions
   */
  public definitionSubstitutions?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-definitionuri
   */
  public definitionUri?: CfnStateMachine.DefinitionUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-events
   */
  public events?: cdk.IResolvable | Record<string, CfnStateMachine.EventSourceProperty | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-logging
   */
  public logging?: cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-name
   */
  public name?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-permissionsboundaries
   */
  public permissionsBoundaries?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-policies
   */
  public policies?: Array<CfnStateMachine.PoliciesProperty | CfnStateMachine.PoliciesProperty | string> | cdk.IResolvable | CfnStateMachine.PoliciesProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-role
   */
  public role?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-tracing
   */
  public tracing?: cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-type
   */
  public type?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnStateMachineProps = {}) {
    super(scope, id, {
      "type": CfnStateMachine.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.definition = props.definition;
    this.definitionSubstitutions = props.definitionSubstitutions;
    this.definitionUri = props.definitionUri;
    this.events = props.events;
    this.logging = props.logging;
    this.name = props.name;
    this.permissionsBoundaries = props.permissionsBoundaries;
    this.policies = props.policies;
    this.role = props.role;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Serverless::StateMachine", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.tracing = props.tracing;
    this.type = props.type;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "definition": this.definition,
      "definitionSubstitutions": this.definitionSubstitutions,
      "definitionUri": this.definitionUri,
      "events": this.events,
      "logging": this.logging,
      "name": this.name,
      "permissionsBoundaries": this.permissionsBoundaries,
      "policies": this.policies,
      "role": this.role,
      "tags": this.tags.renderTags(),
      "tracing": this.tracing,
      "type": this.type
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnStateMachine.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnStateMachinePropsToCloudFormation(props);
  }
}

export namespace CfnStateMachine {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html
   */
  export interface DefinitionUriProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-definition
     */
    readonly definition?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-definitionsubstitutions
     */
    readonly definitionSubstitutions?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-definitionuri
     */
    readonly definitionUri?: CfnStateMachine.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnStateMachine.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-logging
     */
    readonly logging?: cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-permissionsboundaries
     */
    readonly permissionsBoundaries?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-policies
     */
    readonly policies?: Array<CfnStateMachine.PoliciesProperty | CfnStateMachine.PoliciesProperty | string> | cdk.IResolvable | CfnStateMachine.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-tracing
     */
    readonly tracing?: cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-type
     */
    readonly type?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html
   */
  export interface EventSourceProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-definition
     */
    readonly definition?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-definitionsubstitutions
     */
    readonly definitionSubstitutions?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-definitionuri
     */
    readonly definitionUri?: CfnStateMachine.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnStateMachine.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-logging
     */
    readonly logging?: cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-permissionsboundaries
     */
    readonly permissionsBoundaries?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-policies
     */
    readonly policies?: Array<CfnStateMachine.PoliciesProperty | CfnStateMachine.PoliciesProperty | string> | cdk.IResolvable | CfnStateMachine.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-tracing
     */
    readonly tracing?: cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-type
     */
    readonly type?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html
   */
  export interface LoggingConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-definition
     */
    readonly definition?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-definitionsubstitutions
     */
    readonly definitionSubstitutions?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-definitionuri
     */
    readonly definitionUri?: CfnStateMachine.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnStateMachine.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-logging
     */
    readonly logging?: cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-permissionsboundaries
     */
    readonly permissionsBoundaries?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-policies
     */
    readonly policies?: Array<CfnStateMachine.PoliciesProperty | CfnStateMachine.PoliciesProperty | string> | cdk.IResolvable | CfnStateMachine.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-tracing
     */
    readonly tracing?: cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-type
     */
    readonly type?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html
   */
  export interface PoliciesProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-definition
     */
    readonly definition?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-definitionsubstitutions
     */
    readonly definitionSubstitutions?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-definitionuri
     */
    readonly definitionUri?: CfnStateMachine.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnStateMachine.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-logging
     */
    readonly logging?: cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-permissionsboundaries
     */
    readonly permissionsBoundaries?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-policies
     */
    readonly policies?: Array<CfnStateMachine.PoliciesProperty | CfnStateMachine.PoliciesProperty | string> | cdk.IResolvable | CfnStateMachine.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-tracing
     */
    readonly tracing?: cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-type
     */
    readonly type?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html
   */
  export interface TracingConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-definition
     */
    readonly definition?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-definitionsubstitutions
     */
    readonly definitionSubstitutions?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-definitionuri
     */
    readonly definitionUri?: CfnStateMachine.DefinitionUriProperty | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-events
     */
    readonly events?: cdk.IResolvable | Record<string, CfnStateMachine.EventSourceProperty | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-logging
     */
    readonly logging?: cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-permissionsboundaries
     */
    readonly permissionsBoundaries?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-policies
     */
    readonly policies?: Array<CfnStateMachine.PoliciesProperty | CfnStateMachine.PoliciesProperty | string> | cdk.IResolvable | CfnStateMachine.PoliciesProperty | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-tags
     */
    readonly tags?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-tracing
     */
    readonly tracing?: cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-type
     */
    readonly type?: string;
  }
}

/**
 * Properties for defining a \`CfnStateMachine\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html
 */
export interface CfnStateMachineProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-definition
   */
  readonly definition?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-definitionsubstitutions
   */
  readonly definitionSubstitutions?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-definitionuri
   */
  readonly definitionUri?: CfnStateMachine.DefinitionUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-events
   */
  readonly events?: cdk.IResolvable | Record<string, CfnStateMachine.EventSourceProperty | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-logging
   */
  readonly logging?: cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-name
   */
  readonly name?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-permissionsboundaries
   */
  readonly permissionsBoundaries?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-policies
   */
  readonly policies?: Array<CfnStateMachine.PoliciesProperty | CfnStateMachine.PoliciesProperty | string> | cdk.IResolvable | CfnStateMachine.PoliciesProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-role
   */
  readonly role?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-tracing
   */
  readonly tracing?: cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-type
   */
  readonly type?: string;
}

/**
 * Determine whether the given properties match those of a \`TracingConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TracingConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineTracingConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("definition", cdk.validateObject)(properties.definition));
  errors.collect(cdk.propertyValidator("definitionSubstitutions", cdk.hashValidator(cdk.validateObject))(properties.definitionSubstitutions));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnStateMachineEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("logging", CfnStateMachineLoggingConfigurationPropertyValidator)(properties.logging));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("permissionsBoundaries", cdk.validateString)(properties.permissionsBoundaries));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("tracing", CfnStateMachineTracingConfigurationPropertyValidator)(properties.tracing));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"TracingConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineTracingConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineTracingConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Definition": cdk.objectToCloudFormation(properties.definition),
    "DefinitionSubstitutions": cdk.hashMapper(cdk.objectToCloudFormation)(properties.definitionSubstitutions),
    "DefinitionUri": cdk.unionMapper([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [convertCfnStateMachineDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Events": cdk.hashMapper(convertCfnStateMachineEventSourcePropertyToCloudFormation)(properties.events),
    "Logging": convertCfnStateMachineLoggingConfigurationPropertyToCloudFormation(properties.logging),
    "Name": cdk.stringToCloudFormation(properties.name),
    "PermissionsBoundaries": cdk.stringToCloudFormation(properties.permissionsBoundaries),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [convertCfnStateMachinePoliciesPropertyToCloudFormation, convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Tracing": convertCfnStateMachineTracingConfigurationPropertyToCloudFormation(properties.tracing),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnStateMachineTracingConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.TracingConfigurationProperty>();
  ret.addPropertyResult("definition", "Definition", (properties.Definition != null ? cfn_parse.FromCloudFormation.getAny(properties.Definition) : undefined));
  ret.addPropertyResult("definitionSubstitutions", "DefinitionSubstitutions", (properties.DefinitionSubstitutions != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.DefinitionSubstitutions) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [CfnStateMachineDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnStateMachineEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("logging", "Logging", (properties.Logging != null ? CfnStateMachineLoggingConfigurationPropertyFromCloudFormation(properties.Logging) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("permissionsBoundaries", "PermissionsBoundaries", (properties.PermissionsBoundaries != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundaries) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [CfnStateMachinePoliciesPropertyFromCloudFormation, CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? CfnStateMachineTracingConfigurationPropertyFromCloudFormation(properties.Tracing) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PoliciesProperty\`
 *
 * @param properties - the TypeScript properties of a \`PoliciesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachinePoliciesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("definition", cdk.validateObject)(properties.definition));
  errors.collect(cdk.propertyValidator("definitionSubstitutions", cdk.hashValidator(cdk.validateObject))(properties.definitionSubstitutions));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnStateMachineEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("logging", CfnStateMachineLoggingConfigurationPropertyValidator)(properties.logging));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("permissionsBoundaries", cdk.validateString)(properties.permissionsBoundaries));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("tracing", CfnStateMachineTracingConfigurationPropertyValidator)(properties.tracing));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"PoliciesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachinePoliciesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachinePoliciesPropertyValidator(properties).assertSuccess();
  return {
    "Definition": cdk.objectToCloudFormation(properties.definition),
    "DefinitionSubstitutions": cdk.hashMapper(cdk.objectToCloudFormation)(properties.definitionSubstitutions),
    "DefinitionUri": cdk.unionMapper([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [convertCfnStateMachineDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Events": cdk.hashMapper(convertCfnStateMachineEventSourcePropertyToCloudFormation)(properties.events),
    "Logging": convertCfnStateMachineLoggingConfigurationPropertyToCloudFormation(properties.logging),
    "Name": cdk.stringToCloudFormation(properties.name),
    "PermissionsBoundaries": cdk.stringToCloudFormation(properties.permissionsBoundaries),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [convertCfnStateMachinePoliciesPropertyToCloudFormation, convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Tracing": convertCfnStateMachineTracingConfigurationPropertyToCloudFormation(properties.tracing),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnStateMachinePoliciesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.PoliciesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.PoliciesProperty>();
  ret.addPropertyResult("definition", "Definition", (properties.Definition != null ? cfn_parse.FromCloudFormation.getAny(properties.Definition) : undefined));
  ret.addPropertyResult("definitionSubstitutions", "DefinitionSubstitutions", (properties.DefinitionSubstitutions != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.DefinitionSubstitutions) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [CfnStateMachineDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnStateMachineEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("logging", "Logging", (properties.Logging != null ? CfnStateMachineLoggingConfigurationPropertyFromCloudFormation(properties.Logging) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("permissionsBoundaries", "PermissionsBoundaries", (properties.PermissionsBoundaries != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundaries) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [CfnStateMachinePoliciesPropertyFromCloudFormation, CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? CfnStateMachineTracingConfigurationPropertyFromCloudFormation(properties.Tracing) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LoggingConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LoggingConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineLoggingConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("definition", cdk.validateObject)(properties.definition));
  errors.collect(cdk.propertyValidator("definitionSubstitutions", cdk.hashValidator(cdk.validateObject))(properties.definitionSubstitutions));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnStateMachineEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("logging", CfnStateMachineLoggingConfigurationPropertyValidator)(properties.logging));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("permissionsBoundaries", cdk.validateString)(properties.permissionsBoundaries));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("tracing", CfnStateMachineTracingConfigurationPropertyValidator)(properties.tracing));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"LoggingConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineLoggingConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineLoggingConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Definition": cdk.objectToCloudFormation(properties.definition),
    "DefinitionSubstitutions": cdk.hashMapper(cdk.objectToCloudFormation)(properties.definitionSubstitutions),
    "DefinitionUri": cdk.unionMapper([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [convertCfnStateMachineDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Events": cdk.hashMapper(convertCfnStateMachineEventSourcePropertyToCloudFormation)(properties.events),
    "Logging": convertCfnStateMachineLoggingConfigurationPropertyToCloudFormation(properties.logging),
    "Name": cdk.stringToCloudFormation(properties.name),
    "PermissionsBoundaries": cdk.stringToCloudFormation(properties.permissionsBoundaries),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [convertCfnStateMachinePoliciesPropertyToCloudFormation, convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Tracing": convertCfnStateMachineTracingConfigurationPropertyToCloudFormation(properties.tracing),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnStateMachineLoggingConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.LoggingConfigurationProperty>();
  ret.addPropertyResult("definition", "Definition", (properties.Definition != null ? cfn_parse.FromCloudFormation.getAny(properties.Definition) : undefined));
  ret.addPropertyResult("definitionSubstitutions", "DefinitionSubstitutions", (properties.DefinitionSubstitutions != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.DefinitionSubstitutions) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [CfnStateMachineDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnStateMachineEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("logging", "Logging", (properties.Logging != null ? CfnStateMachineLoggingConfigurationPropertyFromCloudFormation(properties.Logging) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("permissionsBoundaries", "PermissionsBoundaries", (properties.PermissionsBoundaries != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundaries) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [CfnStateMachinePoliciesPropertyFromCloudFormation, CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? CfnStateMachineTracingConfigurationPropertyFromCloudFormation(properties.Tracing) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventSourceProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventSourceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineEventSourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("definition", cdk.validateObject)(properties.definition));
  errors.collect(cdk.propertyValidator("definitionSubstitutions", cdk.hashValidator(cdk.validateObject))(properties.definitionSubstitutions));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnStateMachineEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("logging", CfnStateMachineLoggingConfigurationPropertyValidator)(properties.logging));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("permissionsBoundaries", cdk.validateString)(properties.permissionsBoundaries));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("tracing", CfnStateMachineTracingConfigurationPropertyValidator)(properties.tracing));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"EventSourceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineEventSourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineEventSourcePropertyValidator(properties).assertSuccess();
  return {
    "Definition": cdk.objectToCloudFormation(properties.definition),
    "DefinitionSubstitutions": cdk.hashMapper(cdk.objectToCloudFormation)(properties.definitionSubstitutions),
    "DefinitionUri": cdk.unionMapper([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [convertCfnStateMachineDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Events": cdk.hashMapper(convertCfnStateMachineEventSourcePropertyToCloudFormation)(properties.events),
    "Logging": convertCfnStateMachineLoggingConfigurationPropertyToCloudFormation(properties.logging),
    "Name": cdk.stringToCloudFormation(properties.name),
    "PermissionsBoundaries": cdk.stringToCloudFormation(properties.permissionsBoundaries),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [convertCfnStateMachinePoliciesPropertyToCloudFormation, convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Tracing": convertCfnStateMachineTracingConfigurationPropertyToCloudFormation(properties.tracing),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnStateMachineEventSourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachine.EventSourceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.EventSourceProperty>();
  ret.addPropertyResult("definition", "Definition", (properties.Definition != null ? cfn_parse.FromCloudFormation.getAny(properties.Definition) : undefined));
  ret.addPropertyResult("definitionSubstitutions", "DefinitionSubstitutions", (properties.DefinitionSubstitutions != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.DefinitionSubstitutions) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [CfnStateMachineDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnStateMachineEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("logging", "Logging", (properties.Logging != null ? CfnStateMachineLoggingConfigurationPropertyFromCloudFormation(properties.Logging) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("permissionsBoundaries", "PermissionsBoundaries", (properties.PermissionsBoundaries != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundaries) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [CfnStateMachinePoliciesPropertyFromCloudFormation, CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? CfnStateMachineTracingConfigurationPropertyFromCloudFormation(properties.Tracing) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DefinitionUriProperty\`
 *
 * @param properties - the TypeScript properties of a \`DefinitionUriProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineDefinitionUriPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("definition", cdk.validateObject)(properties.definition));
  errors.collect(cdk.propertyValidator("definitionSubstitutions", cdk.hashValidator(cdk.validateObject))(properties.definitionSubstitutions));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnStateMachineEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("logging", CfnStateMachineLoggingConfigurationPropertyValidator)(properties.logging));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("permissionsBoundaries", cdk.validateString)(properties.permissionsBoundaries));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("tags", cdk.hashValidator(cdk.validateObject))(properties.tags));
  errors.collect(cdk.propertyValidator("tracing", CfnStateMachineTracingConfigurationPropertyValidator)(properties.tracing));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"DefinitionUriProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineDefinitionUriPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineDefinitionUriPropertyValidator(properties).assertSuccess();
  return {
    "Definition": cdk.objectToCloudFormation(properties.definition),
    "DefinitionSubstitutions": cdk.hashMapper(cdk.objectToCloudFormation)(properties.definitionSubstitutions),
    "DefinitionUri": cdk.unionMapper([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [convertCfnStateMachineDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Events": cdk.hashMapper(convertCfnStateMachineEventSourcePropertyToCloudFormation)(properties.events),
    "Logging": convertCfnStateMachineLoggingConfigurationPropertyToCloudFormation(properties.logging),
    "Name": cdk.stringToCloudFormation(properties.name),
    "PermissionsBoundaries": cdk.stringToCloudFormation(properties.permissionsBoundaries),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [convertCfnStateMachinePoliciesPropertyToCloudFormation, convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Tags": cdk.hashMapper(cdk.objectToCloudFormation)(properties.tags),
    "Tracing": convertCfnStateMachineTracingConfigurationPropertyToCloudFormation(properties.tracing),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnStateMachineDefinitionUriPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachine.DefinitionUriProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.DefinitionUriProperty>();
  ret.addPropertyResult("definition", "Definition", (properties.Definition != null ? cfn_parse.FromCloudFormation.getAny(properties.Definition) : undefined));
  ret.addPropertyResult("definitionSubstitutions", "DefinitionSubstitutions", (properties.DefinitionSubstitutions != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.DefinitionSubstitutions) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [CfnStateMachineDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnStateMachineEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("logging", "Logging", (properties.Logging != null ? CfnStateMachineLoggingConfigurationPropertyFromCloudFormation(properties.Logging) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("permissionsBoundaries", "PermissionsBoundaries", (properties.PermissionsBoundaries != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundaries) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [CfnStateMachinePoliciesPropertyFromCloudFormation, CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Tags) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? CfnStateMachineTracingConfigurationPropertyFromCloudFormation(properties.Tracing) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnStateMachineProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnStateMachineProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachinePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("definition", cdk.validateObject)(properties.definition));
  errors.collect(cdk.propertyValidator("definitionSubstitutions", cdk.hashValidator(cdk.validateObject))(properties.definitionSubstitutions));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnStateMachineEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("logging", CfnStateMachineLoggingConfigurationPropertyValidator)(properties.logging));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("permissionsBoundaries", cdk.validateString)(properties.permissionsBoundaries));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("tracing", CfnStateMachineTracingConfigurationPropertyValidator)(properties.tracing));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"CfnStateMachineProps\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachinePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachinePropsValidator(properties).assertSuccess();
  return {
    "Definition": cdk.objectToCloudFormation(properties.definition),
    "DefinitionSubstitutions": cdk.hashMapper(cdk.objectToCloudFormation)(properties.definitionSubstitutions),
    "DefinitionUri": cdk.unionMapper([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [convertCfnStateMachineDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Events": cdk.hashMapper(convertCfnStateMachineEventSourcePropertyToCloudFormation)(properties.events),
    "Logging": convertCfnStateMachineLoggingConfigurationPropertyToCloudFormation(properties.logging),
    "Name": cdk.stringToCloudFormation(properties.name),
    "PermissionsBoundaries": cdk.stringToCloudFormation(properties.permissionsBoundaries),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [convertCfnStateMachinePoliciesPropertyToCloudFormation, convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "Tracing": convertCfnStateMachineTracingConfigurationPropertyToCloudFormation(properties.tracing),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnStateMachinePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachineProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachineProps>();
  ret.addPropertyResult("definition", "Definition", (properties.Definition != null ? cfn_parse.FromCloudFormation.getAny(properties.Definition) : undefined));
  ret.addPropertyResult("definitionSubstitutions", "DefinitionSubstitutions", (properties.DefinitionSubstitutions != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.DefinitionSubstitutions) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [CfnStateMachineDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnStateMachineEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("logging", "Logging", (properties.Logging != null ? CfnStateMachineLoggingConfigurationPropertyFromCloudFormation(properties.Logging) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("permissionsBoundaries", "PermissionsBoundaries", (properties.PermissionsBoundaries != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundaries) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [CfnStateMachinePoliciesPropertyFromCloudFormation, CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? CfnStateMachineTracingConfigurationPropertyFromCloudFormation(properties.Tracing) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-scheduler 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * A *schedule* is the main resource you create, configure, and manage using Amazon EventBridge Scheduler.
 *
 * Every schedule has a *schedule expression* that determines when, and with what frequency, the schedule runs. EventBridge Scheduler supports three types of schedules: rate, cron, and one-time schedules. For more information about different schedule types, see [Schedule types](https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html) in the *EventBridge Scheduler User Guide* .
 *
 * When you create a schedule, you configure a target for the schedule to invoke. A target is an API operation that EventBridge Scheduler calls on your behalf every time your schedule runs. EventBridge Scheduler supports two types of targets: *templated* targets invoke common API operations across a core groups of services, and customizeable *universal* targets that you can use to call more than 6,000 operations across over 270 services. For more information about configuring targets, see [Managing targets](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-targets.html) in the *EventBridge Scheduler User Guide* .
 *
 * For more information about managing schedules, changing the schedule state, setting up flexible time windows, and configuring a dead-letter queue for a schedule, see [Managing a schedule](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-schedule.html) in the *EventBridge Scheduler User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html
 */
export class CfnSchedule extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Scheduler::Schedule";

  /**
   * Build a CfnSchedule from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSchedule {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSchedulePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSchedule(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Name (ARN) for the Amazon EventBridge Scheduler schedule.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The description you specify for the schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-description
   */
  public description?: string;

  /**
   * The date, in UTC, before which the schedule can invoke its target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-enddate
   */
  public endDate?: string;

  /**
   * Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-flexibletimewindow
   */
  public flexibleTimeWindow: CfnSchedule.FlexibleTimeWindowProperty | cdk.IResolvable;

  /**
   * The name of the schedule group associated with this schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-groupname
   */
  public groupName?: string;

  /**
   * The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-kmskeyarn
   */
  public kmsKeyArn?: string;

  /**
   * The name of the schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-name
   */
  public name?: string;

  /**
   * The expression that defines when the schedule runs. The following formats are supported.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-scheduleexpression
   */
  public scheduleExpression: string;

  /**
   * The timezone in which the scheduling expression is evaluated.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-scheduleexpressiontimezone
   */
  public scheduleExpressionTimezone?: string;

  /**
   * The date, in UTC, after which the schedule can begin invoking its target.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-startdate
   */
  public startDate?: string;

  /**
   * Specifies whether the schedule is enabled or disabled.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-state
   */
  public state?: string;

  /**
   * The schedule's target details.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-target
   */
  public target: cdk.IResolvable | CfnSchedule.TargetProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnScheduleProps) {
    super(scope, id, {
      "type": CfnSchedule.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "flexibleTimeWindow", this);
    cdk.requireProperty(props, "scheduleExpression", this);
    cdk.requireProperty(props, "target", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.endDate = props.endDate;
    this.flexibleTimeWindow = props.flexibleTimeWindow;
    this.groupName = props.groupName;
    this.kmsKeyArn = props.kmsKeyArn;
    this.name = props.name;
    this.scheduleExpression = props.scheduleExpression;
    this.scheduleExpressionTimezone = props.scheduleExpressionTimezone;
    this.startDate = props.startDate;
    this.state = props.state;
    this.target = props.target;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "endDate": this.endDate,
      "flexibleTimeWindow": this.flexibleTimeWindow,
      "groupName": this.groupName,
      "kmsKeyArn": this.kmsKeyArn,
      "name": this.name,
      "scheduleExpression": this.scheduleExpression,
      "scheduleExpressionTimezone": this.scheduleExpressionTimezone,
      "startDate": this.startDate,
      "state": this.state,
      "target": this.target
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSchedule.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSchedulePropsToCloudFormation(props);
  }
}

export namespace CfnSchedule {
  /**
   * Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html
   */
  export interface FlexibleTimeWindowProperty {
    /**
     * The description you specify for the schedule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-description
     */
    readonly description?: string;

    /**
     * The date, in UTC, before which the schedule can invoke its target.
     *
     * Depending on the schedule's recurrence expression, invocations might stop on, or before, the \`EndDate\` you specify.
     * EventBridge Scheduler ignores \`EndDate\` for one-time schedules.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-enddate
     */
    readonly endDate?: string;

    /**
     * Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-flexibletimewindow
     */
    readonly flexibleTimeWindow: CfnSchedule.FlexibleTimeWindowProperty | cdk.IResolvable;

    /**
     * The name of the schedule group associated with this schedule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-groupname
     */
    readonly groupName?: string;

    /**
     * The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * The name of the schedule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-name
     */
    readonly name?: string;

    /**
     * The expression that defines when the schedule runs. The following formats are supported.
     *
     * - \`at\` expression - \`at(yyyy-mm-ddThh:mm:ss)\`
     * - \`rate\` expression - \`rate(unit value)\`
     * - \`cron\` expression - \`cron(fields)\`
     *
     * You can use \`at\` expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use \`rate\` and \`cron\` expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month.
     *
     * A \`cron\` expression consists of six fields separated by white spaces: \`(minutes hours day_of_month month day_of_week year)\` .
     *
     * A \`rate\` expression consists of a *value* as a positive integer, and a *unit* with the following options: \`minute\` | \`minutes\` | \`hour\` | \`hours\` | \`day\` | \`days\`
     *
     * For more information and examples, see [Schedule types on EventBridge Scheduler](https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html) in the *EventBridge Scheduler User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-scheduleexpression
     */
    readonly scheduleExpression: string;

    /**
     * The timezone in which the scheduling expression is evaluated.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-scheduleexpressiontimezone
     */
    readonly scheduleExpressionTimezone?: string;

    /**
     * The date, in UTC, after which the schedule can begin invoking its target.
     *
     * Depending on the schedule's recurrence expression, invocations might occur on, or after, the \`StartDate\` you specify.
     * EventBridge Scheduler ignores \`StartDate\` for one-time schedules.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-startdate
     */
    readonly startDate?: string;

    /**
     * Specifies whether the schedule is enabled or disabled.
     *
     * *Allowed Values* : \`ENABLED\` | \`DISABLED\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-state
     */
    readonly state?: string;

    /**
     * The schedule's target details.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-target
     */
    readonly target: cdk.IResolvable | CfnSchedule.TargetProperty;
  }

  /**
   * The schedule's target.
   *
   * EventBridge Scheduler supports templated target that invoke common API operations, as well as universal targets that you can customize to invoke over 6,000 API operations across more than 270 services. You can only specify one templated or universal target for a schedule.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html
   */
  export interface TargetProperty {
    /**
     * The description you specify for the schedule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-description
     */
    readonly description?: string;

    /**
     * The date, in UTC, before which the schedule can invoke its target.
     *
     * Depending on the schedule's recurrence expression, invocations might stop on, or before, the \`EndDate\` you specify.
     * EventBridge Scheduler ignores \`EndDate\` for one-time schedules.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-enddate
     */
    readonly endDate?: string;

    /**
     * Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-flexibletimewindow
     */
    readonly flexibleTimeWindow: CfnSchedule.FlexibleTimeWindowProperty | cdk.IResolvable;

    /**
     * The name of the schedule group associated with this schedule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-groupname
     */
    readonly groupName?: string;

    /**
     * The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-kmskeyarn
     */
    readonly kmsKeyArn?: string;

    /**
     * The name of the schedule.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-name
     */
    readonly name?: string;

    /**
     * The expression that defines when the schedule runs. The following formats are supported.
     *
     * - \`at\` expression - \`at(yyyy-mm-ddThh:mm:ss)\`
     * - \`rate\` expression - \`rate(unit value)\`
     * - \`cron\` expression - \`cron(fields)\`
     *
     * You can use \`at\` expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use \`rate\` and \`cron\` expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month.
     *
     * A \`cron\` expression consists of six fields separated by white spaces: \`(minutes hours day_of_month month day_of_week year)\` .
     *
     * A \`rate\` expression consists of a *value* as a positive integer, and a *unit* with the following options: \`minute\` | \`minutes\` | \`hour\` | \`hours\` | \`day\` | \`days\`
     *
     * For more information and examples, see [Schedule types on EventBridge Scheduler](https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html) in the *EventBridge Scheduler User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-scheduleexpression
     */
    readonly scheduleExpression: string;

    /**
     * The timezone in which the scheduling expression is evaluated.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-scheduleexpressiontimezone
     */
    readonly scheduleExpressionTimezone?: string;

    /**
     * The date, in UTC, after which the schedule can begin invoking its target.
     *
     * Depending on the schedule's recurrence expression, invocations might occur on, or after, the \`StartDate\` you specify.
     * EventBridge Scheduler ignores \`StartDate\` for one-time schedules.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-startdate
     */
    readonly startDate?: string;

    /**
     * Specifies whether the schedule is enabled or disabled.
     *
     * *Allowed Values* : \`ENABLED\` | \`DISABLED\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-state
     */
    readonly state?: string;

    /**
     * The schedule's target details.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-target
     */
    readonly target: cdk.IResolvable | CfnSchedule.TargetProperty;
  }
}

/**
 * Properties for defining a \`CfnSchedule\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html
 */
export interface CfnScheduleProps {
  /**
   * The description you specify for the schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-description
   */
  readonly description?: string;

  /**
   * The date, in UTC, before which the schedule can invoke its target.
   *
   * Depending on the schedule's recurrence expression, invocations might stop on, or before, the \`EndDate\` you specify.
   * EventBridge Scheduler ignores \`EndDate\` for one-time schedules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-enddate
   */
  readonly endDate?: string;

  /**
   * Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-flexibletimewindow
   */
  readonly flexibleTimeWindow: CfnSchedule.FlexibleTimeWindowProperty | cdk.IResolvable;

  /**
   * The name of the schedule group associated with this schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-groupname
   */
  readonly groupName?: string;

  /**
   * The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-kmskeyarn
   */
  readonly kmsKeyArn?: string;

  /**
   * The name of the schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-name
   */
  readonly name?: string;

  /**
   * The expression that defines when the schedule runs. The following formats are supported.
   *
   * - \`at\` expression - \`at(yyyy-mm-ddThh:mm:ss)\`
   * - \`rate\` expression - \`rate(unit value)\`
   * - \`cron\` expression - \`cron(fields)\`
   *
   * You can use \`at\` expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use \`rate\` and \`cron\` expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month.
   *
   * A \`cron\` expression consists of six fields separated by white spaces: \`(minutes hours day_of_month month day_of_week year)\` .
   *
   * A \`rate\` expression consists of a *value* as a positive integer, and a *unit* with the following options: \`minute\` | \`minutes\` | \`hour\` | \`hours\` | \`day\` | \`days\`
   *
   * For more information and examples, see [Schedule types on EventBridge Scheduler](https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html) in the *EventBridge Scheduler User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-scheduleexpression
   */
  readonly scheduleExpression: string;

  /**
   * The timezone in which the scheduling expression is evaluated.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-scheduleexpressiontimezone
   */
  readonly scheduleExpressionTimezone?: string;

  /**
   * The date, in UTC, after which the schedule can begin invoking its target.
   *
   * Depending on the schedule's recurrence expression, invocations might occur on, or after, the \`StartDate\` you specify.
   * EventBridge Scheduler ignores \`StartDate\` for one-time schedules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-startdate
   */
  readonly startDate?: string;

  /**
   * Specifies whether the schedule is enabled or disabled.
   *
   * *Allowed Values* : \`ENABLED\` | \`DISABLED\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-state
   */
  readonly state?: string;

  /**
   * The schedule's target details.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-target
   */
  readonly target: cdk.IResolvable | CfnSchedule.TargetProperty;
}

/**
 * Determine whether the given properties match those of a \`TargetProperty\`
 *
 * @param properties - the TypeScript properties of a \`TargetProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleTargetPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("flexibleTimeWindow", cdk.requiredValidator)(properties.flexibleTimeWindow));
  errors.collect(cdk.propertyValidator("flexibleTimeWindow", CfnScheduleFlexibleTimeWindowPropertyValidator)(properties.flexibleTimeWindow));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("scheduleExpression", cdk.requiredValidator)(properties.scheduleExpression));
  errors.collect(cdk.propertyValidator("scheduleExpression", cdk.validateString)(properties.scheduleExpression));
  errors.collect(cdk.propertyValidator("scheduleExpressionTimezone", cdk.validateString)(properties.scheduleExpressionTimezone));
  errors.collect(cdk.propertyValidator("startDate", cdk.validateString)(properties.startDate));
  errors.collect(cdk.propertyValidator("state", cdk.validateString)(properties.state));
  errors.collect(cdk.propertyValidator("target", cdk.requiredValidator)(properties.target));
  errors.collect(cdk.propertyValidator("target", CfnScheduleTargetPropertyValidator)(properties.target));
  return errors.wrap("supplied properties not correct for \\"TargetProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleTargetPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleTargetPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "FlexibleTimeWindow": convertCfnScheduleFlexibleTimeWindowPropertyToCloudFormation(properties.flexibleTimeWindow),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Name": cdk.stringToCloudFormation(properties.name),
    "ScheduleExpression": cdk.stringToCloudFormation(properties.scheduleExpression),
    "ScheduleExpressionTimezone": cdk.stringToCloudFormation(properties.scheduleExpressionTimezone),
    "StartDate": cdk.stringToCloudFormation(properties.startDate),
    "State": cdk.stringToCloudFormation(properties.state),
    "Target": convertCfnScheduleTargetPropertyToCloudFormation(properties.target)
  };
}

// @ts-ignore TS6133
function CfnScheduleTargetPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.TargetProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.TargetProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("flexibleTimeWindow", "FlexibleTimeWindow", (properties.FlexibleTimeWindow != null ? CfnScheduleFlexibleTimeWindowPropertyFromCloudFormation(properties.FlexibleTimeWindow) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("scheduleExpression", "ScheduleExpression", (properties.ScheduleExpression != null ? cfn_parse.FromCloudFormation.getString(properties.ScheduleExpression) : undefined));
  ret.addPropertyResult("scheduleExpressionTimezone", "ScheduleExpressionTimezone", (properties.ScheduleExpressionTimezone != null ? cfn_parse.FromCloudFormation.getString(properties.ScheduleExpressionTimezone) : undefined));
  ret.addPropertyResult("startDate", "StartDate", (properties.StartDate != null ? cfn_parse.FromCloudFormation.getString(properties.StartDate) : undefined));
  ret.addPropertyResult("state", "State", (properties.State != null ? cfn_parse.FromCloudFormation.getString(properties.State) : undefined));
  ret.addPropertyResult("target", "Target", (properties.Target != null ? CfnScheduleTargetPropertyFromCloudFormation(properties.Target) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FlexibleTimeWindowProperty\`
 *
 * @param properties - the TypeScript properties of a \`FlexibleTimeWindowProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleFlexibleTimeWindowPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("flexibleTimeWindow", cdk.requiredValidator)(properties.flexibleTimeWindow));
  errors.collect(cdk.propertyValidator("flexibleTimeWindow", CfnScheduleFlexibleTimeWindowPropertyValidator)(properties.flexibleTimeWindow));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("scheduleExpression", cdk.requiredValidator)(properties.scheduleExpression));
  errors.collect(cdk.propertyValidator("scheduleExpression", cdk.validateString)(properties.scheduleExpression));
  errors.collect(cdk.propertyValidator("scheduleExpressionTimezone", cdk.validateString)(properties.scheduleExpressionTimezone));
  errors.collect(cdk.propertyValidator("startDate", cdk.validateString)(properties.startDate));
  errors.collect(cdk.propertyValidator("state", cdk.validateString)(properties.state));
  errors.collect(cdk.propertyValidator("target", cdk.requiredValidator)(properties.target));
  errors.collect(cdk.propertyValidator("target", CfnScheduleTargetPropertyValidator)(properties.target));
  return errors.wrap("supplied properties not correct for \\"FlexibleTimeWindowProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleFlexibleTimeWindowPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleFlexibleTimeWindowPropertyValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "FlexibleTimeWindow": convertCfnScheduleFlexibleTimeWindowPropertyToCloudFormation(properties.flexibleTimeWindow),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Name": cdk.stringToCloudFormation(properties.name),
    "ScheduleExpression": cdk.stringToCloudFormation(properties.scheduleExpression),
    "ScheduleExpressionTimezone": cdk.stringToCloudFormation(properties.scheduleExpressionTimezone),
    "StartDate": cdk.stringToCloudFormation(properties.startDate),
    "State": cdk.stringToCloudFormation(properties.state),
    "Target": convertCfnScheduleTargetPropertyToCloudFormation(properties.target)
  };
}

// @ts-ignore TS6133
function CfnScheduleFlexibleTimeWindowPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.FlexibleTimeWindowProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.FlexibleTimeWindowProperty>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("flexibleTimeWindow", "FlexibleTimeWindow", (properties.FlexibleTimeWindow != null ? CfnScheduleFlexibleTimeWindowPropertyFromCloudFormation(properties.FlexibleTimeWindow) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("scheduleExpression", "ScheduleExpression", (properties.ScheduleExpression != null ? cfn_parse.FromCloudFormation.getString(properties.ScheduleExpression) : undefined));
  ret.addPropertyResult("scheduleExpressionTimezone", "ScheduleExpressionTimezone", (properties.ScheduleExpressionTimezone != null ? cfn_parse.FromCloudFormation.getString(properties.ScheduleExpressionTimezone) : undefined));
  ret.addPropertyResult("startDate", "StartDate", (properties.StartDate != null ? cfn_parse.FromCloudFormation.getString(properties.StartDate) : undefined));
  ret.addPropertyResult("state", "State", (properties.State != null ? cfn_parse.FromCloudFormation.getString(properties.State) : undefined));
  ret.addPropertyResult("target", "Target", (properties.Target != null ? CfnScheduleTargetPropertyFromCloudFormation(properties.Target) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnScheduleProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnScheduleProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSchedulePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("flexibleTimeWindow", cdk.requiredValidator)(properties.flexibleTimeWindow));
  errors.collect(cdk.propertyValidator("flexibleTimeWindow", CfnScheduleFlexibleTimeWindowPropertyValidator)(properties.flexibleTimeWindow));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("scheduleExpression", cdk.requiredValidator)(properties.scheduleExpression));
  errors.collect(cdk.propertyValidator("scheduleExpression", cdk.validateString)(properties.scheduleExpression));
  errors.collect(cdk.propertyValidator("scheduleExpressionTimezone", cdk.validateString)(properties.scheduleExpressionTimezone));
  errors.collect(cdk.propertyValidator("startDate", cdk.validateString)(properties.startDate));
  errors.collect(cdk.propertyValidator("state", cdk.validateString)(properties.state));
  errors.collect(cdk.propertyValidator("target", cdk.requiredValidator)(properties.target));
  errors.collect(cdk.propertyValidator("target", CfnScheduleTargetPropertyValidator)(properties.target));
  return errors.wrap("supplied properties not correct for \\"CfnScheduleProps\\"");
}

// @ts-ignore TS6133
function convertCfnSchedulePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSchedulePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "FlexibleTimeWindow": convertCfnScheduleFlexibleTimeWindowPropertyToCloudFormation(properties.flexibleTimeWindow),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Name": cdk.stringToCloudFormation(properties.name),
    "ScheduleExpression": cdk.stringToCloudFormation(properties.scheduleExpression),
    "ScheduleExpressionTimezone": cdk.stringToCloudFormation(properties.scheduleExpressionTimezone),
    "StartDate": cdk.stringToCloudFormation(properties.startDate),
    "State": cdk.stringToCloudFormation(properties.state),
    "Target": convertCfnScheduleTargetPropertyToCloudFormation(properties.target)
  };
}

// @ts-ignore TS6133
function CfnSchedulePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnScheduleProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnScheduleProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("flexibleTimeWindow", "FlexibleTimeWindow", (properties.FlexibleTimeWindow != null ? CfnScheduleFlexibleTimeWindowPropertyFromCloudFormation(properties.FlexibleTimeWindow) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("scheduleExpression", "ScheduleExpression", (properties.ScheduleExpression != null ? cfn_parse.FromCloudFormation.getString(properties.ScheduleExpression) : undefined));
  ret.addPropertyResult("scheduleExpressionTimezone", "ScheduleExpressionTimezone", (properties.ScheduleExpressionTimezone != null ? cfn_parse.FromCloudFormation.getString(properties.ScheduleExpressionTimezone) : undefined));
  ret.addPropertyResult("startDate", "StartDate", (properties.StartDate != null ? cfn_parse.FromCloudFormation.getString(properties.StartDate) : undefined));
  ret.addPropertyResult("state", "State", (properties.State != null ? cfn_parse.FromCloudFormation.getString(properties.State) : undefined));
  ret.addPropertyResult("target", "Target", (properties.Target != null ? CfnScheduleTargetPropertyFromCloudFormation(properties.Target) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * A *schedule group* is an Amazon EventBridge Scheduler resource you use to organize your schedules.
 *
 * Your AWS account comes with a \`default\` scheduler group. You associate a new schedule with the \`default\` group or with schedule groups that you create and manage. You can create up to [500 schedule groups](https://docs.aws.amazon.com/scheduler/latest/UserGuide/scheduler-quotas.html) in your AWS account. With EventBridge Scheduler, you apply [tags](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) to schedule groups, not to individual schedules to organize your resources.
 *
 * For more information about managing schedule groups, see [Managing a schedule group](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-schedule-group.html) in the *EventBridge Scheduler User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html
 */
export class CfnScheduleGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Scheduler::ScheduleGroup";

  /**
   * Build a CfnScheduleGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnScheduleGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnScheduleGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnScheduleGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Name (ARN) of the schedule group.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The date and time at which the schedule group was created.
   *
   * @cloudformationAttribute CreationDate
   */
  public readonly attrCreationDate: string;

  /**
   * The time at which the schedule group was last modified.
   *
   * @cloudformationAttribute LastModificationDate
   */
  public readonly attrLastModificationDate: string;

  /**
   * Specifies the state of the schedule group.
   *
   * *Allowed Values* : \`ACTIVE\` | \`DELETING\`
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The name of the schedule group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html#cfn-scheduler-schedulegroup-name
   */
  public name?: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * An array of key-value pairs to apply to this resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html#cfn-scheduler-schedulegroup-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnScheduleGroupProps = {}) {
    super(scope, id, {
      "type": CfnScheduleGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrCreationDate = cdk.Token.asString(this.getAtt("CreationDate", cdk.ResolutionTypeHint.STRING));
    this.attrLastModificationDate = cdk.Token.asString(this.getAtt("LastModificationDate", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.name = props.name;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Scheduler::ScheduleGroup", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "name": this.name,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnScheduleGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnScheduleGroupPropsToCloudFormation(props);
  }
}

export namespace CfnScheduleGroup {
  /**
   * Tag to associate with the resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedulegroup-tag.html
   */
  export interface TagProperty {
    /**
     * The name of the schedule group.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedulegroup-tag.html#cfn-scheduler-schedulegroup-tag-name
     */
    readonly name?: string;

    /**
     * An array of key-value pairs to apply to this resource.
     *
     * For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedulegroup-tag.html#cfn-scheduler-schedulegroup-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnScheduleGroup.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnScheduleGroup\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html
 */
export interface CfnScheduleGroupProps {
  /**
   * The name of the schedule group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html#cfn-scheduler-schedulegroup-name
   */
  readonly name?: string;

  /**
   * An array of key-value pairs to apply to this resource.
   *
   * For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html#cfn-scheduler-schedulegroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleGroupTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnScheduleGroupTagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleGroupTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleGroupTagPropertyValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name),
    "Tags": cdk.listMapper(convertCfnScheduleGroupTagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnScheduleGroupTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnScheduleGroup.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnScheduleGroup.TagProperty>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnScheduleGroupTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnScheduleGroupProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnScheduleGroupProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnScheduleGroupProps\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleGroupPropsValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnScheduleGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnScheduleGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnScheduleGroupProps>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-sqs 1`] = `
{
  "augmentations": "// Copyright 2012-2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
/* eslint-disable prettier/prettier,max-len */
import * as cw from "aws-cdk-lib/aws-cloudwatch";
import { QueueBase } from "./queue-base";

declare module "./queue-base" {
  interface IQueue {
    /**
     * Return the given named metric for this Queue
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The approximate age of the oldest non-deleted message in the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateAgeOfOldestMessage(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages in the queue that are delayed and not available for reading immediately.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesDelayed(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages that are in flight.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesNotVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages available for retrieval from the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of ReceiveMessage API calls that did not return a message.
     *
     * Sum over 5 minutes
     */
    metricNumberOfEmptyReceives(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages deleted from the queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesDeleted(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages returned by calls to the ReceiveMessage action.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesReceived(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages added to a queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesSent(props?: cw.MetricOptions): cw.Metric;

    /**
     * The size of messages added to a queue.
     *
     * Average over 5 minutes
     */
    metricSentMessageSize(props?: cw.MetricOptions): cw.Metric;
  }
}



declare module "./queue-base" {
  interface QueueBase {
    /**
     * Return the given named metric for this Queue
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The approximate age of the oldest non-deleted message in the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateAgeOfOldestMessage(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages in the queue that are delayed and not available for reading immediately.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesDelayed(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages that are in flight.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesNotVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages available for retrieval from the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of ReceiveMessage API calls that did not return a message.
     *
     * Sum over 5 minutes
     */
    metricNumberOfEmptyReceives(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages deleted from the queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesDeleted(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages returned by calls to the ReceiveMessage action.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesReceived(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages added to a queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesSent(props?: cw.MetricOptions): cw.Metric;

    /**
     * The size of messages added to a queue.
     *
     * Average over 5 minutes
     */
    metricSentMessageSize(props?: cw.MetricOptions): cw.Metric;
  }
}

QueueBase.prototype.metric = function(metricName: string, props?: cw.MetricOptions) {
  return new cw.Metric({
    "namespace": "AWS/SQS",
    "metricName": metricName,
    "dimensionsMap": {
      "QueueName": this.queueName
    },
    ...props
  }).attachTo(this);
};
QueueBase.prototype.metricApproximateAgeOfOldestMessage = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateAgeOfOldestMessage", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricApproximateNumberOfMessagesDelayed = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateNumberOfMessagesDelayed", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricApproximateNumberOfMessagesNotVisible = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateNumberOfMessagesNotVisible", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricApproximateNumberOfMessagesVisible = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateNumberOfMessagesVisible", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfEmptyReceives = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfEmptyReceives", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfMessagesDeleted = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfMessagesDeleted", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfMessagesReceived = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfMessagesReceived", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfMessagesSent = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfMessagesSent", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricSentMessageSize = function(props?: cw.MetricOptions) {
  return this.metric("SentMessageSize", {
    "statistic": "Average",
    ...props
  });
};",
  "metrics": "/* eslint-disable prettier/prettier,max-len */
export interface MetricWithDims<D> {
  readonly namespace: string;

  readonly metricName: string;

  readonly statistic: string;

  readonly dimensionsMap: D;
}

export class SQSMetrics {
  public static numberOfMessagesSentAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfMessagesSent",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateNumberOfMessagesDelayedAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateNumberOfMessagesDelayed",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfMessagesReceivedAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfMessagesReceived",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfMessagesDeletedAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfMessagesDeleted",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateNumberOfMessagesNotVisibleAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateNumberOfMessagesNotVisible",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateNumberOfMessagesVisibleAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateNumberOfMessagesVisible",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateAgeOfOldestMessageAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateAgeOfOldestMessage",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfEmptyReceivesAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfEmptyReceives",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static sentMessageSizeAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "SentMessageSize",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}",
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`AWS::SQS::Queue\` resource creates an Amazon SQS standard or FIFO queue.
 *
 * Keep the following caveats in mind:
 *
 * - If you don't specify the \`FifoQueue\` property, Amazon SQS creates a standard queue.
 *
 * > You can't change the queue type after you create it and you can't convert an existing standard queue into a FIFO queue. You must either create a new FIFO queue for your application or delete your existing standard queue and recreate it as a FIFO queue. For more information, see [Moving from a standard queue to a FIFO queue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues-moving.html) in the *Amazon SQS Developer Guide* .
 * - If you don't provide a value for a property, the queue is created with the default value for the property.
 * - If you delete a queue, you must wait at least 60 seconds before creating a queue with the same name.
 * - To successfully create a new queue, you must provide a queue name that adheres to the [limits related to queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/limits-queues.html) and is unique within the scope of your queues.
 *
 * For more information about creating FIFO (first-in-first-out) queues, see [Creating an Amazon SQS queue ( AWS CloudFormation )](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/screate-queue-cloudformation.html) in the *Amazon SQS Developer Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html
 */
export class CfnQueue extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::SQS::Queue";

  /**
   * Build a CfnQueue from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnQueue {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnQueuePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnQueue(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Returns the Amazon Resource Name (ARN) of the queue. For example: \`arn:aws:sqs:us-east-2:123456789012:mystack-myqueue-15PG5C2FC1CW8\` .
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * Returns the queue name. For example: \`mystack-myqueue-1VF9BKQH5BJVI\` .
   *
   * @cloudformationAttribute QueueName
   */
  public readonly attrQueueName: string;

  /**
   * Returns the URLs of the queues from the policy.
   *
   * @cloudformationAttribute QueueUrl
   */
  public readonly attrQueueUrl: string;

  /**
   * For first-in-first-out (FIFO) queues, specifies whether to enable content-based deduplication.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-contentbaseddeduplication
   */
  public contentBasedDeduplication?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether message deduplication occurs at the message group or queue level.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-deduplicationscope
   */
  public deduplicationScope?: string;

  /**
   * The time in seconds for which the delivery of all messages in the queue is delayed.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-delayseconds
   */
  public delaySeconds?: number;

  /**
   * If set to true, creates a FIFO queue.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-fifoqueue
   */
  public fifoQueue?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether the FIFO queue throughput quota applies to the entire queue or per message group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-fifothroughputlimit
   */
  public fifoThroughputLimit?: string;

  /**
   * The length of time in seconds for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-kmsdatakeyreuseperiodseconds
   */
  public kmsDataKeyReusePeriodSeconds?: number;

  /**
   * The ID of an AWS Key Management Service (KMS) for Amazon SQS , or a custom KMS.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-kmsmasterkeyid
   */
  public kmsMasterKeyId?: string;

  /**
   * The limit of how many bytes that a message can contain before Amazon SQS rejects it.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-maximummessagesize
   */
  public maximumMessageSize?: number;

  /**
   * The number of seconds that Amazon SQS retains a message.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-messageretentionperiod
   */
  public messageRetentionPeriod?: number;

  /**
   * A name for the queue.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-queuename
   */
  public queueName?: string;

  /**
   * Specifies the duration, in seconds, that the ReceiveMessage action call waits until a message is in the queue in order to include it in the response, rather than returning an empty response if a message isn't yet available.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-receivemessagewaittimeseconds
   */
  public receiveMessageWaitTimeSeconds?: number;

  /**
   * The string that includes the parameters for the permissions for the dead-letter queue redrive permission and which source queues can specify dead-letter queues as a JSON object.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-redriveallowpolicy
   */
  public redriveAllowPolicy?: any | cdk.IResolvable | string;

  /**
   * The string that includes the parameters for the dead-letter queue functionality of the source queue as a JSON object.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-redrivepolicy
   */
  public redrivePolicy?: any | cdk.IResolvable | string;

  /**
   * Enables server-side queue encryption using SQS owned encryption keys.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-sqsmanagedsseenabled
   */
  public sqsManagedSseEnabled?: boolean | cdk.IResolvable;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * The tags that you attach to this queue.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * The length of time during which a message will be unavailable after a message is delivered from the queue.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-visibilitytimeout
   */
  public visibilityTimeout?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnQueueProps = {}) {
    super(scope, id, {
      "type": CfnQueue.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrQueueName = cdk.Token.asString(this.getAtt("QueueName", cdk.ResolutionTypeHint.STRING));
    this.attrQueueUrl = cdk.Token.asString(this.getAtt("QueueUrl", cdk.ResolutionTypeHint.STRING));
    this.contentBasedDeduplication = props.contentBasedDeduplication;
    this.deduplicationScope = props.deduplicationScope;
    this.delaySeconds = props.delaySeconds;
    this.fifoQueue = props.fifoQueue;
    this.fifoThroughputLimit = props.fifoThroughputLimit;
    this.kmsDataKeyReusePeriodSeconds = props.kmsDataKeyReusePeriodSeconds;
    this.kmsMasterKeyId = props.kmsMasterKeyId;
    this.maximumMessageSize = props.maximumMessageSize;
    this.messageRetentionPeriod = props.messageRetentionPeriod;
    this.queueName = props.queueName;
    this.receiveMessageWaitTimeSeconds = props.receiveMessageWaitTimeSeconds;
    this.redriveAllowPolicy = props.redriveAllowPolicy;
    this.redrivePolicy = props.redrivePolicy;
    this.sqsManagedSseEnabled = props.sqsManagedSseEnabled;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::SQS::Queue", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
    this.visibilityTimeout = props.visibilityTimeout;
    if ((this.node.scope != null && cdk.Resource.isResource(this.node.scope))) {
      this.node.addValidation({
        "validate": () => ((this.cfnOptions.deletionPolicy === undefined) ? ["'AWS::SQS::Queue' is a stateful resource type, and you must specify a Removal Policy for it. Call 'resource.applyRemovalPolicy()'."] : [])
      });
    }
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "contentBasedDeduplication": this.contentBasedDeduplication,
      "deduplicationScope": this.deduplicationScope,
      "delaySeconds": this.delaySeconds,
      "fifoQueue": this.fifoQueue,
      "fifoThroughputLimit": this.fifoThroughputLimit,
      "kmsDataKeyReusePeriodSeconds": this.kmsDataKeyReusePeriodSeconds,
      "kmsMasterKeyId": this.kmsMasterKeyId,
      "maximumMessageSize": this.maximumMessageSize,
      "messageRetentionPeriod": this.messageRetentionPeriod,
      "queueName": this.queueName,
      "receiveMessageWaitTimeSeconds": this.receiveMessageWaitTimeSeconds,
      "redriveAllowPolicy": this.redriveAllowPolicy,
      "redrivePolicy": this.redrivePolicy,
      "sqsManagedSseEnabled": this.sqsManagedSseEnabled,
      "tags": this.tags.renderTags(),
      "visibilityTimeout": this.visibilityTimeout
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnQueue.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnQueuePropsToCloudFormation(props);
  }
}

export namespace CfnQueue {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html
   */
  export interface TagProperty {
    /**
     * For first-in-first-out (FIFO) queues, specifies whether to enable content-based deduplication.
     *
     * During the deduplication interval, Amazon SQS treats messages that are sent with identical content as duplicates and delivers only one copy of the message. For more information, see the \`ContentBasedDeduplication\` attribute for the \`[CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html)\` action in the *Amazon SQS API Reference* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-contentbaseddeduplication
     */
    readonly contentBasedDeduplication?: boolean | cdk.IResolvable;

    /**
     * For high throughput for FIFO queues, specifies whether message deduplication occurs at the message group or queue level.
     *
     * Valid values are \`messageGroup\` and \`queue\` .
     *
     * To enable high throughput for a FIFO queue, set this attribute to \`messageGroup\` *and* set the \`FifoThroughputLimit\` attribute to \`perMessageGroupId\` . If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Amazon SQS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-deduplicationscope
     */
    readonly deduplicationScope?: string;

    /**
     * The time in seconds for which the delivery of all messages in the queue is delayed.
     *
     * You can specify an integer value of \`0\` to \`900\` (15 minutes). The default value is \`0\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-delayseconds
     */
    readonly delaySeconds?: number;

    /**
     * If set to true, creates a FIFO queue.
     *
     * If you don't specify this property, Amazon SQS creates a standard queue. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Amazon SQS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-fifoqueue
     */
    readonly fifoQueue?: boolean | cdk.IResolvable;

    /**
     * For high throughput for FIFO queues, specifies whether the FIFO queue throughput quota applies to the entire queue or per message group.
     *
     * Valid values are \`perQueue\` and \`perMessageGroupId\` .
     *
     * To enable high throughput for a FIFO queue, set this attribute to \`perMessageGroupId\` *and* set the \`DeduplicationScope\` attribute to \`messageGroup\` . If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Amazon SQS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-fifothroughputlimit
     */
    readonly fifoThroughputLimit?: string;

    /**
     * The length of time in seconds for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again.
     *
     * The value must be an integer between 60 (1 minute) and 86,400 (24 hours). The default is 300 (5 minutes).
     *
     * > A shorter time period provides better security, but results in more calls to AWS KMS , which might incur charges after Free Tier. For more information, see [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html#sqs-how-does-the-data-key-reuse-period-work) in the *Amazon SQS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-kmsdatakeyreuseperiodseconds
     */
    readonly kmsDataKeyReusePeriodSeconds?: number;

    /**
     * The ID of an AWS Key Management Service (KMS) for Amazon SQS , or a custom KMS.
     *
     * To use the AWS managed KMS for Amazon SQS , specify a (default) alias ARN, alias name (e.g. \`alias/aws/sqs\` ), key ARN, or key ID. For more information, see the following:
     *
     * - [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html) in the *Amazon SQS Developer Guide*
     * - [CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html) in the *Amazon SQS API Reference*
     * - [Request Parameters](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the *AWS Key Management Service API Reference*
     * - The Key Management Service (KMS) section of the [AWS Key Management Service Best Practices](https://docs.aws.amazon.com/https://d0.awsstatic.com/whitepapers/aws-kms-best-practices.pdf) whitepaper
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-kmsmasterkeyid
     */
    readonly kmsMasterKeyId?: string;

    /**
     * The limit of how many bytes that a message can contain before Amazon SQS rejects it.
     *
     * You can specify an integer value from \`1,024\` bytes (1 KiB) to \`262,144\` bytes (256 KiB). The default value is \`262,144\` (256 KiB).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-maximummessagesize
     */
    readonly maximumMessageSize?: number;

    /**
     * The number of seconds that Amazon SQS retains a message.
     *
     * You can specify an integer value from \`60\` seconds (1 minute) to \`1,209,600\` seconds (14 days). The default value is \`345,600\` seconds (4 days).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-messageretentionperiod
     */
    readonly messageRetentionPeriod?: number;

    /**
     * A name for the queue.
     *
     * To create a FIFO queue, the name of your FIFO queue must end with the \`.fifo\` suffix. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Amazon SQS Developer Guide* .
     *
     * If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the queue name. For more information, see [Name type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html) in the *AWS CloudFormation User Guide* .
     *
     * > If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-queuename
     */
    readonly queueName?: string;

    /**
     * Specifies the duration, in seconds, that the ReceiveMessage action call waits until a message is in the queue in order to include it in the response, rather than returning an empty response if a message isn't yet available.
     *
     * You can specify an integer from 1 to 20. Short polling is used as the default or when you specify 0 for this property. For more information, see [Consuming messages using long polling](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html#sqs-long-polling) in the *Amazon SQS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-receivemessagewaittimeseconds
     */
    readonly receiveMessageWaitTimeSeconds?: number;

    /**
     * The string that includes the parameters for the permissions for the dead-letter queue redrive permission and which source queues can specify dead-letter queues as a JSON object.
     *
     * The parameters are as follows:
     *
     * - \`redrivePermission\` : The permission type that defines which source queues can specify the current queue as the dead-letter queue. Valid values are:
     *
     * - \`allowAll\` : (Default) Any source queues in this AWS account in the same Region can specify this queue as the dead-letter queue.
     * - \`denyAll\` : No source queues can specify this queue as the dead-letter queue.
     * - \`byQueue\` : Only queues specified by the \`sourceQueueArns\` parameter can specify this queue as the dead-letter queue.
     * - \`sourceQueueArns\` : The Amazon Resource Names (ARN)s of the source queues that can specify this queue as the dead-letter queue and redrive messages. You can specify this parameter only when the \`redrivePermission\` parameter is set to \`byQueue\` . You can specify up to 10 source queue ARNs. To allow more than 10 source queues to specify dead-letter queues, set the \`redrivePermission\` parameter to \`allowAll\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-redriveallowpolicy
     */
    readonly redriveAllowPolicy?: any | cdk.IResolvable | string;

    /**
     * The string that includes the parameters for the dead-letter queue functionality of the source queue as a JSON object.
     *
     * The parameters are as follows:
     *
     * - \`deadLetterTargetArn\` : The Amazon Resource Name (ARN) of the dead-letter queue to which Amazon SQS moves messages after the value of \`maxReceiveCount\` is exceeded.
     * - \`maxReceiveCount\` : The number of times a message is delivered to the source queue before being moved to the dead-letter queue. When the \`ReceiveCount\` for a message exceeds the \`maxReceiveCount\` for a queue, Amazon SQS moves the message to the dead-letter-queue.
     *
     * > The dead-letter queue of a FIFO queue must also be a FIFO queue. Similarly, the dead-letter queue of a standard queue must also be a standard queue.
     *
     * *JSON*
     *
     * \`{ "deadLetterTargetArn" : *String* , "maxReceiveCount" : *Integer* }\`
     *
     * *YAML*
     *
     * \`deadLetterTargetArn : *String*\`
     *
     * \`maxReceiveCount : *Integer*\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-redrivepolicy
     */
    readonly redrivePolicy?: any | cdk.IResolvable | string;

    /**
     * Enables server-side queue encryption using SQS owned encryption keys.
     *
     * Only one server-side encryption option is supported per queue (for example, [SSE-KMS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sse-existing-queue.html) or [SSE-SQS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sqs-sse-queue.html) ).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-sqsmanagedsseenabled
     */
    readonly sqsManagedSseEnabled?: boolean | cdk.IResolvable;

    /**
     * The tags that you attach to this queue.
     *
     * For more information, see [Resource tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) in the *AWS CloudFormation User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnQueue.TagProperty> | cdk.IResolvable;

    /**
     * The length of time during which a message will be unavailable after a message is delivered from the queue.
     *
     * This blocks other components from receiving the same message and gives the initial component time to process and delete the message from the queue.
     *
     * Values must be from 0 to 43,200 seconds (12 hours). If you don't specify a value, AWS CloudFormation uses the default value of 30 seconds.
     *
     * For more information about Amazon SQS queue visibility timeouts, see [Visibility timeout](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html) in the *Amazon SQS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queue-tag.html#cfn-sqs-queue-tag-visibilitytimeout
     */
    readonly visibilityTimeout?: number;
  }
}

/**
 * Properties for defining a \`CfnQueue\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html
 */
export interface CfnQueueProps {
  /**
   * For first-in-first-out (FIFO) queues, specifies whether to enable content-based deduplication.
   *
   * During the deduplication interval, Amazon SQS treats messages that are sent with identical content as duplicates and delivers only one copy of the message. For more information, see the \`ContentBasedDeduplication\` attribute for the \`[CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html)\` action in the *Amazon SQS API Reference* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-contentbaseddeduplication
   */
  readonly contentBasedDeduplication?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether message deduplication occurs at the message group or queue level.
   *
   * Valid values are \`messageGroup\` and \`queue\` .
   *
   * To enable high throughput for a FIFO queue, set this attribute to \`messageGroup\` *and* set the \`FifoThroughputLimit\` attribute to \`perMessageGroupId\` . If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-deduplicationscope
   */
  readonly deduplicationScope?: string;

  /**
   * The time in seconds for which the delivery of all messages in the queue is delayed.
   *
   * You can specify an integer value of \`0\` to \`900\` (15 minutes). The default value is \`0\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-delayseconds
   */
  readonly delaySeconds?: number;

  /**
   * If set to true, creates a FIFO queue.
   *
   * If you don't specify this property, Amazon SQS creates a standard queue. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-fifoqueue
   */
  readonly fifoQueue?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether the FIFO queue throughput quota applies to the entire queue or per message group.
   *
   * Valid values are \`perQueue\` and \`perMessageGroupId\` .
   *
   * To enable high throughput for a FIFO queue, set this attribute to \`perMessageGroupId\` *and* set the \`DeduplicationScope\` attribute to \`messageGroup\` . If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-fifothroughputlimit
   */
  readonly fifoThroughputLimit?: string;

  /**
   * The length of time in seconds for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again.
   *
   * The value must be an integer between 60 (1 minute) and 86,400 (24 hours). The default is 300 (5 minutes).
   *
   * > A shorter time period provides better security, but results in more calls to AWS KMS , which might incur charges after Free Tier. For more information, see [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html#sqs-how-does-the-data-key-reuse-period-work) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-kmsdatakeyreuseperiodseconds
   */
  readonly kmsDataKeyReusePeriodSeconds?: number;

  /**
   * The ID of an AWS Key Management Service (KMS) for Amazon SQS , or a custom KMS.
   *
   * To use the AWS managed KMS for Amazon SQS , specify a (default) alias ARN, alias name (e.g. \`alias/aws/sqs\` ), key ARN, or key ID. For more information, see the following:
   *
   * - [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html) in the *Amazon SQS Developer Guide*
   * - [CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html) in the *Amazon SQS API Reference*
   * - [Request Parameters](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the *AWS Key Management Service API Reference*
   * - The Key Management Service (KMS) section of the [AWS Key Management Service Best Practices](https://docs.aws.amazon.com/https://d0.awsstatic.com/whitepapers/aws-kms-best-practices.pdf) whitepaper
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-kmsmasterkeyid
   */
  readonly kmsMasterKeyId?: string;

  /**
   * The limit of how many bytes that a message can contain before Amazon SQS rejects it.
   *
   * You can specify an integer value from \`1,024\` bytes (1 KiB) to \`262,144\` bytes (256 KiB). The default value is \`262,144\` (256 KiB).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-maximummessagesize
   */
  readonly maximumMessageSize?: number;

  /**
   * The number of seconds that Amazon SQS retains a message.
   *
   * You can specify an integer value from \`60\` seconds (1 minute) to \`1,209,600\` seconds (14 days). The default value is \`345,600\` seconds (4 days).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-messageretentionperiod
   */
  readonly messageRetentionPeriod?: number;

  /**
   * A name for the queue.
   *
   * To create a FIFO queue, the name of your FIFO queue must end with the \`.fifo\` suffix. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Amazon SQS Developer Guide* .
   *
   * If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the queue name. For more information, see [Name type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html) in the *AWS CloudFormation User Guide* .
   *
   * > If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-queuename
   */
  readonly queueName?: string;

  /**
   * Specifies the duration, in seconds, that the ReceiveMessage action call waits until a message is in the queue in order to include it in the response, rather than returning an empty response if a message isn't yet available.
   *
   * You can specify an integer from 1 to 20. Short polling is used as the default or when you specify 0 for this property. For more information, see [Consuming messages using long polling](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html#sqs-long-polling) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-receivemessagewaittimeseconds
   */
  readonly receiveMessageWaitTimeSeconds?: number;

  /**
   * The string that includes the parameters for the permissions for the dead-letter queue redrive permission and which source queues can specify dead-letter queues as a JSON object.
   *
   * The parameters are as follows:
   *
   * - \`redrivePermission\` : The permission type that defines which source queues can specify the current queue as the dead-letter queue. Valid values are:
   *
   * - \`allowAll\` : (Default) Any source queues in this AWS account in the same Region can specify this queue as the dead-letter queue.
   * - \`denyAll\` : No source queues can specify this queue as the dead-letter queue.
   * - \`byQueue\` : Only queues specified by the \`sourceQueueArns\` parameter can specify this queue as the dead-letter queue.
   * - \`sourceQueueArns\` : The Amazon Resource Names (ARN)s of the source queues that can specify this queue as the dead-letter queue and redrive messages. You can specify this parameter only when the \`redrivePermission\` parameter is set to \`byQueue\` . You can specify up to 10 source queue ARNs. To allow more than 10 source queues to specify dead-letter queues, set the \`redrivePermission\` parameter to \`allowAll\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-redriveallowpolicy
   */
  readonly redriveAllowPolicy?: any | cdk.IResolvable | string;

  /**
   * The string that includes the parameters for the dead-letter queue functionality of the source queue as a JSON object.
   *
   * The parameters are as follows:
   *
   * - \`deadLetterTargetArn\` : The Amazon Resource Name (ARN) of the dead-letter queue to which Amazon SQS moves messages after the value of \`maxReceiveCount\` is exceeded.
   * - \`maxReceiveCount\` : The number of times a message is delivered to the source queue before being moved to the dead-letter queue. When the \`ReceiveCount\` for a message exceeds the \`maxReceiveCount\` for a queue, Amazon SQS moves the message to the dead-letter-queue.
   *
   * > The dead-letter queue of a FIFO queue must also be a FIFO queue. Similarly, the dead-letter queue of a standard queue must also be a standard queue.
   *
   * *JSON*
   *
   * \`{ "deadLetterTargetArn" : *String* , "maxReceiveCount" : *Integer* }\`
   *
   * *YAML*
   *
   * \`deadLetterTargetArn : *String*\`
   *
   * \`maxReceiveCount : *Integer*\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-redrivepolicy
   */
  readonly redrivePolicy?: any | cdk.IResolvable | string;

  /**
   * Enables server-side queue encryption using SQS owned encryption keys.
   *
   * Only one server-side encryption option is supported per queue (for example, [SSE-KMS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sse-existing-queue.html) or [SSE-SQS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sqs-sse-queue.html) ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-sqsmanagedsseenabled
   */
  readonly sqsManagedSseEnabled?: boolean | cdk.IResolvable;

  /**
   * The tags that you attach to this queue.
   *
   * For more information, see [Resource tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) in the *AWS CloudFormation User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The length of time during which a message will be unavailable after a message is delivered from the queue.
   *
   * This blocks other components from receiving the same message and gives the initial component time to process and delete the message from the queue.
   *
   * Values must be from 0 to 43,200 seconds (12 hours). If you don't specify a value, AWS CloudFormation uses the default value of 30 seconds.
   *
   * For more information about Amazon SQS queue visibility timeouts, see [Visibility timeout](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-visibilitytimeout
   */
  readonly visibilityTimeout?: number;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnQueueTagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("contentBasedDeduplication", cdk.validateBoolean)(properties.contentBasedDeduplication));
  errors.collect(cdk.propertyValidator("deduplicationScope", cdk.validateString)(properties.deduplicationScope));
  errors.collect(cdk.propertyValidator("delaySeconds", cdk.validateNumber)(properties.delaySeconds));
  errors.collect(cdk.propertyValidator("fifoQueue", cdk.validateBoolean)(properties.fifoQueue));
  errors.collect(cdk.propertyValidator("fifoThroughputLimit", cdk.validateString)(properties.fifoThroughputLimit));
  errors.collect(cdk.propertyValidator("kmsDataKeyReusePeriodSeconds", cdk.validateNumber)(properties.kmsDataKeyReusePeriodSeconds));
  errors.collect(cdk.propertyValidator("kmsMasterKeyId", cdk.validateString)(properties.kmsMasterKeyId));
  errors.collect(cdk.propertyValidator("maximumMessageSize", cdk.validateNumber)(properties.maximumMessageSize));
  errors.collect(cdk.propertyValidator("messageRetentionPeriod", cdk.validateNumber)(properties.messageRetentionPeriod));
  errors.collect(cdk.propertyValidator("queueName", cdk.validateString)(properties.queueName));
  errors.collect(cdk.propertyValidator("receiveMessageWaitTimeSeconds", cdk.validateNumber)(properties.receiveMessageWaitTimeSeconds));
  errors.collect(cdk.propertyValidator("redriveAllowPolicy", cdk.unionValidator(cdk.validateObject, cdk.validateString))(properties.redriveAllowPolicy));
  errors.collect(cdk.propertyValidator("redrivePolicy", cdk.unionValidator(cdk.validateObject, cdk.validateString))(properties.redrivePolicy));
  errors.collect(cdk.propertyValidator("sqsManagedSseEnabled", cdk.validateBoolean)(properties.sqsManagedSseEnabled));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnQueueTagPropertyValidator))(properties.tags));
  errors.collect(cdk.propertyValidator("visibilityTimeout", cdk.validateNumber)(properties.visibilityTimeout));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnQueueTagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnQueueTagPropertyValidator(properties).assertSuccess();
  return {
    "ContentBasedDeduplication": cdk.booleanToCloudFormation(properties.contentBasedDeduplication),
    "DeduplicationScope": cdk.stringToCloudFormation(properties.deduplicationScope),
    "DelaySeconds": cdk.numberToCloudFormation(properties.delaySeconds),
    "FifoQueue": cdk.booleanToCloudFormation(properties.fifoQueue),
    "FifoThroughputLimit": cdk.stringToCloudFormation(properties.fifoThroughputLimit),
    "KmsDataKeyReusePeriodSeconds": cdk.numberToCloudFormation(properties.kmsDataKeyReusePeriodSeconds),
    "KmsMasterKeyId": cdk.stringToCloudFormation(properties.kmsMasterKeyId),
    "MaximumMessageSize": cdk.numberToCloudFormation(properties.maximumMessageSize),
    "MessageRetentionPeriod": cdk.numberToCloudFormation(properties.messageRetentionPeriod),
    "QueueName": cdk.stringToCloudFormation(properties.queueName),
    "ReceiveMessageWaitTimeSeconds": cdk.numberToCloudFormation(properties.receiveMessageWaitTimeSeconds),
    "RedriveAllowPolicy": cdk.unionMapper([cdk.validateObject, cdk.validateString], [cdk.objectToCloudFormation, cdk.stringToCloudFormation])(properties.redriveAllowPolicy),
    "RedrivePolicy": cdk.unionMapper([cdk.validateObject, cdk.validateString], [cdk.objectToCloudFormation, cdk.stringToCloudFormation])(properties.redrivePolicy),
    "SqsManagedSseEnabled": cdk.booleanToCloudFormation(properties.sqsManagedSseEnabled),
    "Tags": cdk.listMapper(convertCfnQueueTagPropertyToCloudFormation)(properties.tags),
    "VisibilityTimeout": cdk.numberToCloudFormation(properties.visibilityTimeout)
  };
}

// @ts-ignore TS6133
function CfnQueueTagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnQueue.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnQueue.TagProperty>();
  ret.addPropertyResult("contentBasedDeduplication", "ContentBasedDeduplication", (properties.ContentBasedDeduplication != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ContentBasedDeduplication) : undefined));
  ret.addPropertyResult("deduplicationScope", "DeduplicationScope", (properties.DeduplicationScope != null ? cfn_parse.FromCloudFormation.getString(properties.DeduplicationScope) : undefined));
  ret.addPropertyResult("delaySeconds", "DelaySeconds", (properties.DelaySeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.DelaySeconds) : undefined));
  ret.addPropertyResult("fifoQueue", "FifoQueue", (properties.FifoQueue != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FifoQueue) : undefined));
  ret.addPropertyResult("fifoThroughputLimit", "FifoThroughputLimit", (properties.FifoThroughputLimit != null ? cfn_parse.FromCloudFormation.getString(properties.FifoThroughputLimit) : undefined));
  ret.addPropertyResult("kmsDataKeyReusePeriodSeconds", "KmsDataKeyReusePeriodSeconds", (properties.KmsDataKeyReusePeriodSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.KmsDataKeyReusePeriodSeconds) : undefined));
  ret.addPropertyResult("kmsMasterKeyId", "KmsMasterKeyId", (properties.KmsMasterKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsMasterKeyId) : undefined));
  ret.addPropertyResult("maximumMessageSize", "MaximumMessageSize", (properties.MaximumMessageSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumMessageSize) : undefined));
  ret.addPropertyResult("messageRetentionPeriod", "MessageRetentionPeriod", (properties.MessageRetentionPeriod != null ? cfn_parse.FromCloudFormation.getNumber(properties.MessageRetentionPeriod) : undefined));
  ret.addPropertyResult("queueName", "QueueName", (properties.QueueName != null ? cfn_parse.FromCloudFormation.getString(properties.QueueName) : undefined));
  ret.addPropertyResult("receiveMessageWaitTimeSeconds", "ReceiveMessageWaitTimeSeconds", (properties.ReceiveMessageWaitTimeSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReceiveMessageWaitTimeSeconds) : undefined));
  ret.addPropertyResult("redriveAllowPolicy", "RedriveAllowPolicy", (properties.RedriveAllowPolicy != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateObject, cdk.validateString], [cfn_parse.FromCloudFormation.getAny, cfn_parse.FromCloudFormation.getString])(properties.RedriveAllowPolicy) : undefined));
  ret.addPropertyResult("redrivePolicy", "RedrivePolicy", (properties.RedrivePolicy != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateObject, cdk.validateString], [cfn_parse.FromCloudFormation.getAny, cfn_parse.FromCloudFormation.getString])(properties.RedrivePolicy) : undefined));
  ret.addPropertyResult("sqsManagedSseEnabled", "SqsManagedSseEnabled", (properties.SqsManagedSseEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SqsManagedSseEnabled) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnQueueTagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addPropertyResult("visibilityTimeout", "VisibilityTimeout", (properties.VisibilityTimeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.VisibilityTimeout) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnQueueProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnQueueProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnQueuePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("contentBasedDeduplication", cdk.validateBoolean)(properties.contentBasedDeduplication));
  errors.collect(cdk.propertyValidator("deduplicationScope", cdk.validateString)(properties.deduplicationScope));
  errors.collect(cdk.propertyValidator("delaySeconds", cdk.validateNumber)(properties.delaySeconds));
  errors.collect(cdk.propertyValidator("fifoQueue", cdk.validateBoolean)(properties.fifoQueue));
  errors.collect(cdk.propertyValidator("fifoThroughputLimit", cdk.validateString)(properties.fifoThroughputLimit));
  errors.collect(cdk.propertyValidator("kmsDataKeyReusePeriodSeconds", cdk.validateNumber)(properties.kmsDataKeyReusePeriodSeconds));
  errors.collect(cdk.propertyValidator("kmsMasterKeyId", cdk.validateString)(properties.kmsMasterKeyId));
  errors.collect(cdk.propertyValidator("maximumMessageSize", cdk.validateNumber)(properties.maximumMessageSize));
  errors.collect(cdk.propertyValidator("messageRetentionPeriod", cdk.validateNumber)(properties.messageRetentionPeriod));
  errors.collect(cdk.propertyValidator("queueName", cdk.validateString)(properties.queueName));
  errors.collect(cdk.propertyValidator("receiveMessageWaitTimeSeconds", cdk.validateNumber)(properties.receiveMessageWaitTimeSeconds));
  errors.collect(cdk.propertyValidator("redriveAllowPolicy", cdk.unionValidator(cdk.validateObject, cdk.validateString))(properties.redriveAllowPolicy));
  errors.collect(cdk.propertyValidator("redrivePolicy", cdk.unionValidator(cdk.validateObject, cdk.validateString))(properties.redrivePolicy));
  errors.collect(cdk.propertyValidator("sqsManagedSseEnabled", cdk.validateBoolean)(properties.sqsManagedSseEnabled));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("visibilityTimeout", cdk.validateNumber)(properties.visibilityTimeout));
  return errors.wrap("supplied properties not correct for \\"CfnQueueProps\\"");
}

// @ts-ignore TS6133
function convertCfnQueuePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnQueuePropsValidator(properties).assertSuccess();
  return {
    "ContentBasedDeduplication": cdk.booleanToCloudFormation(properties.contentBasedDeduplication),
    "DeduplicationScope": cdk.stringToCloudFormation(properties.deduplicationScope),
    "DelaySeconds": cdk.numberToCloudFormation(properties.delaySeconds),
    "FifoQueue": cdk.booleanToCloudFormation(properties.fifoQueue),
    "FifoThroughputLimit": cdk.stringToCloudFormation(properties.fifoThroughputLimit),
    "KmsDataKeyReusePeriodSeconds": cdk.numberToCloudFormation(properties.kmsDataKeyReusePeriodSeconds),
    "KmsMasterKeyId": cdk.stringToCloudFormation(properties.kmsMasterKeyId),
    "MaximumMessageSize": cdk.numberToCloudFormation(properties.maximumMessageSize),
    "MessageRetentionPeriod": cdk.numberToCloudFormation(properties.messageRetentionPeriod),
    "QueueName": cdk.stringToCloudFormation(properties.queueName),
    "ReceiveMessageWaitTimeSeconds": cdk.numberToCloudFormation(properties.receiveMessageWaitTimeSeconds),
    "RedriveAllowPolicy": cdk.unionMapper([cdk.validateObject, cdk.validateString], [cdk.objectToCloudFormation, cdk.stringToCloudFormation])(properties.redriveAllowPolicy),
    "RedrivePolicy": cdk.unionMapper([cdk.validateObject, cdk.validateString], [cdk.objectToCloudFormation, cdk.stringToCloudFormation])(properties.redrivePolicy),
    "SqsManagedSseEnabled": cdk.booleanToCloudFormation(properties.sqsManagedSseEnabled),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VisibilityTimeout": cdk.numberToCloudFormation(properties.visibilityTimeout)
  };
}

// @ts-ignore TS6133
function CfnQueuePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnQueueProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnQueueProps>();
  ret.addPropertyResult("contentBasedDeduplication", "ContentBasedDeduplication", (properties.ContentBasedDeduplication != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ContentBasedDeduplication) : undefined));
  ret.addPropertyResult("deduplicationScope", "DeduplicationScope", (properties.DeduplicationScope != null ? cfn_parse.FromCloudFormation.getString(properties.DeduplicationScope) : undefined));
  ret.addPropertyResult("delaySeconds", "DelaySeconds", (properties.DelaySeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.DelaySeconds) : undefined));
  ret.addPropertyResult("fifoQueue", "FifoQueue", (properties.FifoQueue != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FifoQueue) : undefined));
  ret.addPropertyResult("fifoThroughputLimit", "FifoThroughputLimit", (properties.FifoThroughputLimit != null ? cfn_parse.FromCloudFormation.getString(properties.FifoThroughputLimit) : undefined));
  ret.addPropertyResult("kmsDataKeyReusePeriodSeconds", "KmsDataKeyReusePeriodSeconds", (properties.KmsDataKeyReusePeriodSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.KmsDataKeyReusePeriodSeconds) : undefined));
  ret.addPropertyResult("kmsMasterKeyId", "KmsMasterKeyId", (properties.KmsMasterKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsMasterKeyId) : undefined));
  ret.addPropertyResult("maximumMessageSize", "MaximumMessageSize", (properties.MaximumMessageSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumMessageSize) : undefined));
  ret.addPropertyResult("messageRetentionPeriod", "MessageRetentionPeriod", (properties.MessageRetentionPeriod != null ? cfn_parse.FromCloudFormation.getNumber(properties.MessageRetentionPeriod) : undefined));
  ret.addPropertyResult("queueName", "QueueName", (properties.QueueName != null ? cfn_parse.FromCloudFormation.getString(properties.QueueName) : undefined));
  ret.addPropertyResult("receiveMessageWaitTimeSeconds", "ReceiveMessageWaitTimeSeconds", (properties.ReceiveMessageWaitTimeSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReceiveMessageWaitTimeSeconds) : undefined));
  ret.addPropertyResult("redriveAllowPolicy", "RedriveAllowPolicy", (properties.RedriveAllowPolicy != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateObject, cdk.validateString], [cfn_parse.FromCloudFormation.getAny, cfn_parse.FromCloudFormation.getString])(properties.RedriveAllowPolicy) : undefined));
  ret.addPropertyResult("redrivePolicy", "RedrivePolicy", (properties.RedrivePolicy != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateObject, cdk.validateString], [cfn_parse.FromCloudFormation.getAny, cfn_parse.FromCloudFormation.getString])(properties.RedrivePolicy) : undefined));
  ret.addPropertyResult("sqsManagedSseEnabled", "SqsManagedSseEnabled", (properties.SqsManagedSseEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SqsManagedSseEnabled) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("visibilityTimeout", "VisibilityTimeout", (properties.VisibilityTimeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.VisibilityTimeout) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * The \`AWS::SQS::QueuePolicy\` type applies a policy to Amazon SQS queues.
 *
 * For an example snippet, see [Declaring an Amazon SQS policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-iam.html#scenario-sqs-policy) in the *AWS CloudFormation User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html
 */
export class CfnQueuePolicy extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::SQS::QueuePolicy";

  /**
   * Build a CfnQueuePolicy from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnQueuePolicy {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnQueuePolicyPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnQueuePolicy(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * A policy document that contains the permissions for the specified Amazon SQS queues.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html#cfn-sqs-queuepolicy-policydocument
   */
  public policyDocument: any | cdk.IResolvable;

  /**
   * The URLs of the queues to which you want to add the policy.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html#cfn-sqs-queuepolicy-queues
   */
  public queues: Array<string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnQueuePolicyProps) {
    super(scope, id, {
      "type": CfnQueuePolicy.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "policyDocument", this);
    cdk.requireProperty(props, "queues", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.policyDocument = props.policyDocument;
    this.queues = props.queues;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "policyDocument": this.policyDocument,
      "queues": this.queues
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnQueuePolicy.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnQueuePolicyPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnQueuePolicy\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html
 */
export interface CfnQueuePolicyProps {
  /**
   * A policy document that contains the permissions for the specified Amazon SQS queues.
   *
   * For more information about Amazon SQS policies, see [Using custom policies with the Amazon SQS access policy language](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-creating-custom-policies.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html#cfn-sqs-queuepolicy-policydocument
   */
  readonly policyDocument: any | cdk.IResolvable;

  /**
   * The URLs of the queues to which you want to add the policy.
   *
   * You can use the \`[Ref](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-ref.html)\` function to specify an \`[AWS::SQS::Queue](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queues.html)\` resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html#cfn-sqs-queuepolicy-queues
   */
  readonly queues: Array<string>;
}

/**
 * Determine whether the given properties match those of a \`CfnQueuePolicyProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnQueuePolicyProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnQueuePolicyPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("policyDocument", cdk.requiredValidator)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateObject)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("queues", cdk.requiredValidator)(properties.queues));
  errors.collect(cdk.propertyValidator("queues", cdk.listValidator(cdk.validateString))(properties.queues));
  return errors.wrap("supplied properties not correct for \\"CfnQueuePolicyProps\\"");
}

// @ts-ignore TS6133
function convertCfnQueuePolicyPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnQueuePolicyPropsValidator(properties).assertSuccess();
  return {
    "PolicyDocument": cdk.objectToCloudFormation(properties.policyDocument),
    "Queues": cdk.listMapper(cdk.stringToCloudFormation)(properties.queues)
  };
}

// @ts-ignore TS6133
function CfnQueuePolicyPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnQueuePolicyProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnQueuePolicyProps>();
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("queues", "Queues", (properties.Queues != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Queues) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`can codegen service with arbitrary suffix 1`] = `
"/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * Creates an Amazon Kinesis Data Analytics application.
 *
 * For information about creating a Kinesis Data Analytics application, see [Creating an Application](https://docs.aws.amazon.com/kinesisanalytics/latest/java/getting-started.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html
 */
export class CfnApplicationV2 extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::KinesisAnalyticsV2::Application";

  /**
   * Build a CfnApplicationV2 from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplicationV2 {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationV2PropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplicationV2(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Use this parameter to configure the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationconfiguration
   */
  public applicationConfiguration?: CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable;

  /**
   * The description of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationdescription
   */
  public applicationDescription?: string;

  /**
   * Describes the maintenance configuration for the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration
   */
  public applicationMaintenanceConfiguration?: CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable;

  /**
   * To create a Kinesis Data Analytics Studio notebook, you must set the mode to \`INTERACTIVE\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationmode
   */
  public applicationMode?: string;

  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationname
   */
  public applicationName?: string;

  /**
   * Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-runconfiguration
   */
  public runConfiguration?: cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty;

  /**
   * The runtime environment for the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-runtimeenvironment
   */
  public runtimeEnvironment: string;

  /**
   * Specifies the IAM role that the application uses to access external resources.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-serviceexecutionrole
   */
  public serviceExecutionRole: string;

  /**
   * Tag Manager which manages the tags for this resource
   */
  public readonly tags: cdk.TagManager;

  /**
   * A list of one or more tags to assign to the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-tags
   */
  public tagsRaw?: Array<cdk.CfnTag>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationV2Props) {
    super(scope, id, {
      "type": CfnApplicationV2.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "runtimeEnvironment", this);
    cdk.requireProperty(props, "serviceExecutionRole", this);

    this.applicationConfiguration = props.applicationConfiguration;
    this.applicationDescription = props.applicationDescription;
    this.applicationMaintenanceConfiguration = props.applicationMaintenanceConfiguration;
    this.applicationMode = props.applicationMode;
    this.applicationName = props.applicationName;
    this.runConfiguration = props.runConfiguration;
    this.runtimeEnvironment = props.runtimeEnvironment;
    this.serviceExecutionRole = props.serviceExecutionRole;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::KinesisAnalyticsV2::Application", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tagsRaw = props.tags;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationConfiguration": this.applicationConfiguration,
      "applicationDescription": this.applicationDescription,
      "applicationMaintenanceConfiguration": this.applicationMaintenanceConfiguration,
      "applicationMode": this.applicationMode,
      "applicationName": this.applicationName,
      "runConfiguration": this.runConfiguration,
      "runtimeEnvironment": this.runtimeEnvironment,
      "serviceExecutionRole": this.serviceExecutionRole,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplicationV2.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationV2PropsToCloudFormation(props);
  }
}

export namespace CfnApplicationV2 {
  /**
   * Specifies the creation parameters for a Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html
   */
  export interface ApplicationConfigurationProperty {
    /**
     * Use this parameter to configure the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-applicationconfiguration
     */
    readonly applicationConfiguration?: CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable;

    /**
     * The description of the application.
     *
     * @default - ""
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-applicationdescription
     */
    readonly applicationDescription?: string;

    /**
     * Describes the maintenance configuration for the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-applicationmaintenanceconfiguration
     */
    readonly applicationMaintenanceConfiguration?: CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable;

    /**
     * To create a Kinesis Data Analytics Studio notebook, you must set the mode to \`INTERACTIVE\` .
     *
     * However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-applicationmode
     */
    readonly applicationMode?: string;

    /**
     * The name of the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-applicationname
     */
    readonly applicationName?: string;

    /**
     * Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.
     *
     * This section is evaluated only on stack updates for applications in running RUNNING state and has no effect during manual application start.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-runconfiguration
     */
    readonly runConfiguration?: cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty;

    /**
     * The runtime environment for the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-runtimeenvironment
     */
    readonly runtimeEnvironment: string;

    /**
     * Specifies the IAM role that the application uses to access external resources.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-serviceexecutionrole
     */
    readonly serviceExecutionRole: string;

    /**
     * A list of one or more tags to assign to the application.
     *
     * A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnApplicationV2.TagProperty> | cdk.IResolvable;
  }

  /**
   * Describes the starting parameters for an Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html
   */
  export interface RunConfigurationProperty {
    /**
     * Use this parameter to configure the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-applicationconfiguration
     */
    readonly applicationConfiguration?: CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable;

    /**
     * The description of the application.
     *
     * @default - ""
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-applicationdescription
     */
    readonly applicationDescription?: string;

    /**
     * Describes the maintenance configuration for the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-applicationmaintenanceconfiguration
     */
    readonly applicationMaintenanceConfiguration?: CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable;

    /**
     * To create a Kinesis Data Analytics Studio notebook, you must set the mode to \`INTERACTIVE\` .
     *
     * However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-applicationmode
     */
    readonly applicationMode?: string;

    /**
     * The name of the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-applicationname
     */
    readonly applicationName?: string;

    /**
     * Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.
     *
     * This section is evaluated only on stack updates for applications in running RUNNING state and has no effect during manual application start.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-runconfiguration
     */
    readonly runConfiguration?: cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty;

    /**
     * The runtime environment for the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-runtimeenvironment
     */
    readonly runtimeEnvironment: string;

    /**
     * Specifies the IAM role that the application uses to access external resources.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-serviceexecutionrole
     */
    readonly serviceExecutionRole: string;

    /**
     * A list of one or more tags to assign to the application.
     *
     * A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnApplicationV2.TagProperty> | cdk.IResolvable;
  }

  /**
   * Specifies the maintence window parameters for a Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html
   */
  export interface ApplicationMaintenanceConfigurationProperty {
    /**
     * Use this parameter to configure the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration-applicationconfiguration
     */
    readonly applicationConfiguration?: CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable;

    /**
     * The description of the application.
     *
     * @default - ""
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration-applicationdescription
     */
    readonly applicationDescription?: string;

    /**
     * Describes the maintenance configuration for the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration-applicationmaintenanceconfiguration
     */
    readonly applicationMaintenanceConfiguration?: CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable;

    /**
     * To create a Kinesis Data Analytics Studio notebook, you must set the mode to \`INTERACTIVE\` .
     *
     * However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration-applicationmode
     */
    readonly applicationMode?: string;

    /**
     * The name of the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration-applicationname
     */
    readonly applicationName?: string;

    /**
     * Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.
     *
     * This section is evaluated only on stack updates for applications in running RUNNING state and has no effect during manual application start.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration-runconfiguration
     */
    readonly runConfiguration?: cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty;

    /**
     * The runtime environment for the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration-runtimeenvironment
     */
    readonly runtimeEnvironment: string;

    /**
     * Specifies the IAM role that the application uses to access external resources.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration-serviceexecutionrole
     */
    readonly serviceExecutionRole: string;

    /**
     * A list of one or more tags to assign to the application.
     *
     * A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnApplicationV2.TagProperty> | cdk.IResolvable;
  }

  /**
   * A key-value pair that identifies an application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-tag.html
   */
  export interface TagProperty {
    /**
     * Use this parameter to configure the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-tag.html#cfn-kinesisanalyticsv2-application-tag-applicationconfiguration
     */
    readonly applicationConfiguration?: CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable;

    /**
     * The description of the application.
     *
     * @default - ""
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-tag.html#cfn-kinesisanalyticsv2-application-tag-applicationdescription
     */
    readonly applicationDescription?: string;

    /**
     * Describes the maintenance configuration for the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-tag.html#cfn-kinesisanalyticsv2-application-tag-applicationmaintenanceconfiguration
     */
    readonly applicationMaintenanceConfiguration?: CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable;

    /**
     * To create a Kinesis Data Analytics Studio notebook, you must set the mode to \`INTERACTIVE\` .
     *
     * However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-tag.html#cfn-kinesisanalyticsv2-application-tag-applicationmode
     */
    readonly applicationMode?: string;

    /**
     * The name of the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-tag.html#cfn-kinesisanalyticsv2-application-tag-applicationname
     */
    readonly applicationName?: string;

    /**
     * Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.
     *
     * This section is evaluated only on stack updates for applications in running RUNNING state and has no effect during manual application start.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-tag.html#cfn-kinesisanalyticsv2-application-tag-runconfiguration
     */
    readonly runConfiguration?: cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty;

    /**
     * The runtime environment for the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-tag.html#cfn-kinesisanalyticsv2-application-tag-runtimeenvironment
     */
    readonly runtimeEnvironment: string;

    /**
     * Specifies the IAM role that the application uses to access external resources.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-tag.html#cfn-kinesisanalyticsv2-application-tag-serviceexecutionrole
     */
    readonly serviceExecutionRole: string;

    /**
     * A list of one or more tags to assign to the application.
     *
     * A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-tag.html#cfn-kinesisanalyticsv2-application-tag-tags
     */
    readonly tags?: Array<cdk.IResolvable | CfnApplicationV2.TagProperty> | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnApplication\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html
 */
export interface CfnApplicationV2Props {
  /**
   * Use this parameter to configure the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationconfiguration
   */
  readonly applicationConfiguration?: CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable;

  /**
   * The description of the application.
   *
   * @default - ""
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationdescription
   */
  readonly applicationDescription?: string;

  /**
   * Describes the maintenance configuration for the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration
   */
  readonly applicationMaintenanceConfiguration?: CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable;

  /**
   * To create a Kinesis Data Analytics Studio notebook, you must set the mode to \`INTERACTIVE\` .
   *
   * However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationmode
   */
  readonly applicationMode?: string;

  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationname
   */
  readonly applicationName?: string;

  /**
   * Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.
   *
   * This section is evaluated only on stack updates for applications in running RUNNING state and has no effect during manual application start.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-runconfiguration
   */
  readonly runConfiguration?: cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty;

  /**
   * The runtime environment for the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-runtimeenvironment
   */
  readonly runtimeEnvironment: string;

  /**
   * Specifies the IAM role that the application uses to access external resources.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-serviceexecutionrole
   */
  readonly serviceExecutionRole: string;

  /**
   * A list of one or more tags to assign to the application.
   *
   * A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`TagProperty\`
 *
 * @param properties - the TypeScript properties of a \`TagProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2TagPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationConfiguration", CfnApplicationV2ApplicationConfigurationPropertyValidator)(properties.applicationConfiguration));
  errors.collect(cdk.propertyValidator("applicationDescription", cdk.validateString)(properties.applicationDescription));
  errors.collect(cdk.propertyValidator("applicationMaintenanceConfiguration", CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator)(properties.applicationMaintenanceConfiguration));
  errors.collect(cdk.propertyValidator("applicationMode", cdk.validateString)(properties.applicationMode));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("runConfiguration", CfnApplicationV2RunConfigurationPropertyValidator)(properties.runConfiguration));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.requiredValidator)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.validateString)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.requiredValidator)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.validateString)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnApplicationV2TagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"TagProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2TagPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2TagPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationConfiguration": convertCfnApplicationV2ApplicationConfigurationPropertyToCloudFormation(properties.applicationConfiguration),
    "ApplicationDescription": cdk.stringToCloudFormation(properties.applicationDescription),
    "ApplicationMaintenanceConfiguration": convertCfnApplicationV2ApplicationMaintenanceConfigurationPropertyToCloudFormation(properties.applicationMaintenanceConfiguration),
    "ApplicationMode": cdk.stringToCloudFormation(properties.applicationMode),
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "RunConfiguration": convertCfnApplicationV2RunConfigurationPropertyToCloudFormation(properties.runConfiguration),
    "RuntimeEnvironment": cdk.stringToCloudFormation(properties.runtimeEnvironment),
    "ServiceExecutionRole": cdk.stringToCloudFormation(properties.serviceExecutionRole),
    "Tags": cdk.listMapper(convertCfnApplicationV2TagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2TagPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.TagProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.TagProperty>();
  ret.addPropertyResult("applicationConfiguration", "ApplicationConfiguration", (properties.ApplicationConfiguration != null ? CfnApplicationV2ApplicationConfigurationPropertyFromCloudFormation(properties.ApplicationConfiguration) : undefined));
  ret.addPropertyResult("applicationDescription", "ApplicationDescription", (properties.ApplicationDescription != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDescription) : undefined));
  ret.addPropertyResult("applicationMaintenanceConfiguration", "ApplicationMaintenanceConfiguration", (properties.ApplicationMaintenanceConfiguration != null ? CfnApplicationV2ApplicationMaintenanceConfigurationPropertyFromCloudFormation(properties.ApplicationMaintenanceConfiguration) : undefined));
  ret.addPropertyResult("applicationMode", "ApplicationMode", (properties.ApplicationMode != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationMode) : undefined));
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("runConfiguration", "RunConfiguration", (properties.RunConfiguration != null ? CfnApplicationV2RunConfigurationPropertyFromCloudFormation(properties.RunConfiguration) : undefined));
  ret.addPropertyResult("runtimeEnvironment", "RuntimeEnvironment", (properties.RuntimeEnvironment != null ? cfn_parse.FromCloudFormation.getString(properties.RuntimeEnvironment) : undefined));
  ret.addPropertyResult("serviceExecutionRole", "ServiceExecutionRole", (properties.ServiceExecutionRole != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceExecutionRole) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2TagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApplicationMaintenanceConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationMaintenanceConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationConfiguration", CfnApplicationV2ApplicationConfigurationPropertyValidator)(properties.applicationConfiguration));
  errors.collect(cdk.propertyValidator("applicationDescription", cdk.validateString)(properties.applicationDescription));
  errors.collect(cdk.propertyValidator("applicationMaintenanceConfiguration", CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator)(properties.applicationMaintenanceConfiguration));
  errors.collect(cdk.propertyValidator("applicationMode", cdk.validateString)(properties.applicationMode));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("runConfiguration", CfnApplicationV2RunConfigurationPropertyValidator)(properties.runConfiguration));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.requiredValidator)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.validateString)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.requiredValidator)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.validateString)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnApplicationV2TagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"ApplicationMaintenanceConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ApplicationMaintenanceConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationConfiguration": convertCfnApplicationV2ApplicationConfigurationPropertyToCloudFormation(properties.applicationConfiguration),
    "ApplicationDescription": cdk.stringToCloudFormation(properties.applicationDescription),
    "ApplicationMaintenanceConfiguration": convertCfnApplicationV2ApplicationMaintenanceConfigurationPropertyToCloudFormation(properties.applicationMaintenanceConfiguration),
    "ApplicationMode": cdk.stringToCloudFormation(properties.applicationMode),
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "RunConfiguration": convertCfnApplicationV2RunConfigurationPropertyToCloudFormation(properties.runConfiguration),
    "RuntimeEnvironment": cdk.stringToCloudFormation(properties.runtimeEnvironment),
    "ServiceExecutionRole": cdk.stringToCloudFormation(properties.serviceExecutionRole),
    "Tags": cdk.listMapper(convertCfnApplicationV2TagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ApplicationMaintenanceConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ApplicationMaintenanceConfigurationProperty>();
  ret.addPropertyResult("applicationConfiguration", "ApplicationConfiguration", (properties.ApplicationConfiguration != null ? CfnApplicationV2ApplicationConfigurationPropertyFromCloudFormation(properties.ApplicationConfiguration) : undefined));
  ret.addPropertyResult("applicationDescription", "ApplicationDescription", (properties.ApplicationDescription != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDescription) : undefined));
  ret.addPropertyResult("applicationMaintenanceConfiguration", "ApplicationMaintenanceConfiguration", (properties.ApplicationMaintenanceConfiguration != null ? CfnApplicationV2ApplicationMaintenanceConfigurationPropertyFromCloudFormation(properties.ApplicationMaintenanceConfiguration) : undefined));
  ret.addPropertyResult("applicationMode", "ApplicationMode", (properties.ApplicationMode != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationMode) : undefined));
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("runConfiguration", "RunConfiguration", (properties.RunConfiguration != null ? CfnApplicationV2RunConfigurationPropertyFromCloudFormation(properties.RunConfiguration) : undefined));
  ret.addPropertyResult("runtimeEnvironment", "RuntimeEnvironment", (properties.RuntimeEnvironment != null ? cfn_parse.FromCloudFormation.getString(properties.RuntimeEnvironment) : undefined));
  ret.addPropertyResult("serviceExecutionRole", "ServiceExecutionRole", (properties.ServiceExecutionRole != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceExecutionRole) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2TagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RunConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`RunConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2RunConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationConfiguration", CfnApplicationV2ApplicationConfigurationPropertyValidator)(properties.applicationConfiguration));
  errors.collect(cdk.propertyValidator("applicationDescription", cdk.validateString)(properties.applicationDescription));
  errors.collect(cdk.propertyValidator("applicationMaintenanceConfiguration", CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator)(properties.applicationMaintenanceConfiguration));
  errors.collect(cdk.propertyValidator("applicationMode", cdk.validateString)(properties.applicationMode));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("runConfiguration", CfnApplicationV2RunConfigurationPropertyValidator)(properties.runConfiguration));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.requiredValidator)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.validateString)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.requiredValidator)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.validateString)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnApplicationV2TagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"RunConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2RunConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2RunConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationConfiguration": convertCfnApplicationV2ApplicationConfigurationPropertyToCloudFormation(properties.applicationConfiguration),
    "ApplicationDescription": cdk.stringToCloudFormation(properties.applicationDescription),
    "ApplicationMaintenanceConfiguration": convertCfnApplicationV2ApplicationMaintenanceConfigurationPropertyToCloudFormation(properties.applicationMaintenanceConfiguration),
    "ApplicationMode": cdk.stringToCloudFormation(properties.applicationMode),
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "RunConfiguration": convertCfnApplicationV2RunConfigurationPropertyToCloudFormation(properties.runConfiguration),
    "RuntimeEnvironment": cdk.stringToCloudFormation(properties.runtimeEnvironment),
    "ServiceExecutionRole": cdk.stringToCloudFormation(properties.serviceExecutionRole),
    "Tags": cdk.listMapper(convertCfnApplicationV2TagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2RunConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.RunConfigurationProperty>();
  ret.addPropertyResult("applicationConfiguration", "ApplicationConfiguration", (properties.ApplicationConfiguration != null ? CfnApplicationV2ApplicationConfigurationPropertyFromCloudFormation(properties.ApplicationConfiguration) : undefined));
  ret.addPropertyResult("applicationDescription", "ApplicationDescription", (properties.ApplicationDescription != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDescription) : undefined));
  ret.addPropertyResult("applicationMaintenanceConfiguration", "ApplicationMaintenanceConfiguration", (properties.ApplicationMaintenanceConfiguration != null ? CfnApplicationV2ApplicationMaintenanceConfigurationPropertyFromCloudFormation(properties.ApplicationMaintenanceConfiguration) : undefined));
  ret.addPropertyResult("applicationMode", "ApplicationMode", (properties.ApplicationMode != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationMode) : undefined));
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("runConfiguration", "RunConfiguration", (properties.RunConfiguration != null ? CfnApplicationV2RunConfigurationPropertyFromCloudFormation(properties.RunConfiguration) : undefined));
  ret.addPropertyResult("runtimeEnvironment", "RuntimeEnvironment", (properties.RuntimeEnvironment != null ? cfn_parse.FromCloudFormation.getString(properties.RuntimeEnvironment) : undefined));
  ret.addPropertyResult("serviceExecutionRole", "ServiceExecutionRole", (properties.ServiceExecutionRole != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceExecutionRole) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2TagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApplicationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ApplicationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationConfiguration", CfnApplicationV2ApplicationConfigurationPropertyValidator)(properties.applicationConfiguration));
  errors.collect(cdk.propertyValidator("applicationDescription", cdk.validateString)(properties.applicationDescription));
  errors.collect(cdk.propertyValidator("applicationMaintenanceConfiguration", CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator)(properties.applicationMaintenanceConfiguration));
  errors.collect(cdk.propertyValidator("applicationMode", cdk.validateString)(properties.applicationMode));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("runConfiguration", CfnApplicationV2RunConfigurationPropertyValidator)(properties.runConfiguration));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.requiredValidator)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.validateString)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.requiredValidator)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.validateString)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(CfnApplicationV2TagPropertyValidator))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"ApplicationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ApplicationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ApplicationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationConfiguration": convertCfnApplicationV2ApplicationConfigurationPropertyToCloudFormation(properties.applicationConfiguration),
    "ApplicationDescription": cdk.stringToCloudFormation(properties.applicationDescription),
    "ApplicationMaintenanceConfiguration": convertCfnApplicationV2ApplicationMaintenanceConfigurationPropertyToCloudFormation(properties.applicationMaintenanceConfiguration),
    "ApplicationMode": cdk.stringToCloudFormation(properties.applicationMode),
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "RunConfiguration": convertCfnApplicationV2RunConfigurationPropertyToCloudFormation(properties.runConfiguration),
    "RuntimeEnvironment": cdk.stringToCloudFormation(properties.runtimeEnvironment),
    "ServiceExecutionRole": cdk.stringToCloudFormation(properties.serviceExecutionRole),
    "Tags": cdk.listMapper(convertCfnApplicationV2TagPropertyToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ApplicationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ApplicationConfigurationProperty>();
  ret.addPropertyResult("applicationConfiguration", "ApplicationConfiguration", (properties.ApplicationConfiguration != null ? CfnApplicationV2ApplicationConfigurationPropertyFromCloudFormation(properties.ApplicationConfiguration) : undefined));
  ret.addPropertyResult("applicationDescription", "ApplicationDescription", (properties.ApplicationDescription != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDescription) : undefined));
  ret.addPropertyResult("applicationMaintenanceConfiguration", "ApplicationMaintenanceConfiguration", (properties.ApplicationMaintenanceConfiguration != null ? CfnApplicationV2ApplicationMaintenanceConfigurationPropertyFromCloudFormation(properties.ApplicationMaintenanceConfiguration) : undefined));
  ret.addPropertyResult("applicationMode", "ApplicationMode", (properties.ApplicationMode != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationMode) : undefined));
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("runConfiguration", "RunConfiguration", (properties.RunConfiguration != null ? CfnApplicationV2RunConfigurationPropertyFromCloudFormation(properties.RunConfiguration) : undefined));
  ret.addPropertyResult("runtimeEnvironment", "RuntimeEnvironment", (properties.RuntimeEnvironment != null ? cfn_parse.FromCloudFormation.getString(properties.RuntimeEnvironment) : undefined));
  ret.addPropertyResult("serviceExecutionRole", "ServiceExecutionRole", (properties.ServiceExecutionRole != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceExecutionRole) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2TagPropertyFromCloudFormation)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationV2Props\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationV2Props\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2PropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationConfiguration", CfnApplicationV2ApplicationConfigurationPropertyValidator)(properties.applicationConfiguration));
  errors.collect(cdk.propertyValidator("applicationDescription", cdk.validateString)(properties.applicationDescription));
  errors.collect(cdk.propertyValidator("applicationMaintenanceConfiguration", CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator)(properties.applicationMaintenanceConfiguration));
  errors.collect(cdk.propertyValidator("applicationMode", cdk.validateString)(properties.applicationMode));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("runConfiguration", CfnApplicationV2RunConfigurationPropertyValidator)(properties.runConfiguration));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.requiredValidator)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.validateString)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.requiredValidator)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.validateString)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationV2Props\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2PropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2PropsValidator(properties).assertSuccess();
  return {
    "ApplicationConfiguration": convertCfnApplicationV2ApplicationConfigurationPropertyToCloudFormation(properties.applicationConfiguration),
    "ApplicationDescription": cdk.stringToCloudFormation(properties.applicationDescription),
    "ApplicationMaintenanceConfiguration": convertCfnApplicationV2ApplicationMaintenanceConfigurationPropertyToCloudFormation(properties.applicationMaintenanceConfiguration),
    "ApplicationMode": cdk.stringToCloudFormation(properties.applicationMode),
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "RunConfiguration": convertCfnApplicationV2RunConfigurationPropertyToCloudFormation(properties.runConfiguration),
    "RuntimeEnvironment": cdk.stringToCloudFormation(properties.runtimeEnvironment),
    "ServiceExecutionRole": cdk.stringToCloudFormation(properties.serviceExecutionRole),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2PropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2Props | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2Props>();
  ret.addPropertyResult("applicationConfiguration", "ApplicationConfiguration", (properties.ApplicationConfiguration != null ? CfnApplicationV2ApplicationConfigurationPropertyFromCloudFormation(properties.ApplicationConfiguration) : undefined));
  ret.addPropertyResult("applicationDescription", "ApplicationDescription", (properties.ApplicationDescription != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDescription) : undefined));
  ret.addPropertyResult("applicationMaintenanceConfiguration", "ApplicationMaintenanceConfiguration", (properties.ApplicationMaintenanceConfiguration != null ? CfnApplicationV2ApplicationMaintenanceConfigurationPropertyFromCloudFormation(properties.ApplicationMaintenanceConfiguration) : undefined));
  ret.addPropertyResult("applicationMode", "ApplicationMode", (properties.ApplicationMode != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationMode) : undefined));
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("runConfiguration", "RunConfiguration", (properties.RunConfiguration != null ? CfnApplicationV2RunConfigurationPropertyFromCloudFormation(properties.RunConfiguration) : undefined));
  ret.addPropertyResult("runtimeEnvironment", "RuntimeEnvironment", (properties.RuntimeEnvironment != null ? cfn_parse.FromCloudFormation.getString(properties.RuntimeEnvironment) : undefined));
  ret.addPropertyResult("serviceExecutionRole", "ServiceExecutionRole", (properties.ServiceExecutionRole != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceExecutionRole) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds an Amazon CloudWatch log stream to monitor application configuration errors.
 *
 * > Only one *ApplicationCloudWatchLoggingOption* resource can be attached per application.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html
 */
export class CfnApplicationCloudWatchLoggingOptionV2 extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::KinesisAnalyticsV2::ApplicationCloudWatchLoggingOption";

  /**
   * Build a CfnApplicationCloudWatchLoggingOptionV2 from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplicationCloudWatchLoggingOptionV2 {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationCloudWatchLoggingOptionV2PropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplicationCloudWatchLoggingOptionV2(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html#cfn-kinesisanalyticsv2-applicationcloudwatchloggingoption-applicationname
   */
  public applicationName: string;

  /**
   * Provides a description of Amazon CloudWatch logging options, including the log stream Amazon Resource Name (ARN).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html#cfn-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption
   */
  public cloudWatchLoggingOption: CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationCloudWatchLoggingOptionV2Props) {
    super(scope, id, {
      "type": CfnApplicationCloudWatchLoggingOptionV2.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "applicationName", this);
    cdk.requireProperty(props, "cloudWatchLoggingOption", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.applicationName = props.applicationName;
    this.cloudWatchLoggingOption = props.cloudWatchLoggingOption;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationName": this.applicationName,
      "cloudWatchLoggingOption": this.cloudWatchLoggingOption
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplicationCloudWatchLoggingOptionV2.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationCloudWatchLoggingOptionV2PropsToCloudFormation(props);
  }
}

export namespace CfnApplicationCloudWatchLoggingOptionV2 {
  /**
   * Provides a description of Amazon CloudWatch logging options, including the log stream Amazon Resource Name (ARN).
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption.html
   */
  export interface CloudWatchLoggingOptionProperty {
    /**
     * The name of the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption.html#cfn-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption-applicationname
     */
    readonly applicationName: string;

    /**
     * Provides a description of Amazon CloudWatch logging options, including the log stream Amazon Resource Name (ARN).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption.html#cfn-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption-cloudwatchloggingoption
     */
    readonly cloudWatchLoggingOption: CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnApplicationCloudWatchLoggingOption\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html
 */
export interface CfnApplicationCloudWatchLoggingOptionV2Props {
  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html#cfn-kinesisanalyticsv2-applicationcloudwatchloggingoption-applicationname
   */
  readonly applicationName: string;

  /**
   * Provides a description of Amazon CloudWatch logging options, including the log stream Amazon Resource Name (ARN).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html#cfn-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption
   */
  readonly cloudWatchLoggingOption: CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`CloudWatchLoggingOptionProperty\`
 *
 * @param properties - the TypeScript properties of a \`CloudWatchLoggingOptionProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationName", cdk.requiredValidator)(properties.applicationName));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("cloudWatchLoggingOption", cdk.requiredValidator)(properties.cloudWatchLoggingOption));
  errors.collect(cdk.propertyValidator("cloudWatchLoggingOption", CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyValidator)(properties.cloudWatchLoggingOption));
  return errors.wrap("supplied properties not correct for \\"CloudWatchLoggingOptionProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "CloudWatchLoggingOption": convertCfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyToCloudFormation(properties.cloudWatchLoggingOption)
  };
}

// @ts-ignore TS6133
function CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty>();
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("cloudWatchLoggingOption", "CloudWatchLoggingOption", (properties.CloudWatchLoggingOption != null ? CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyFromCloudFormation(properties.CloudWatchLoggingOption) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationCloudWatchLoggingOptionV2Props\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationCloudWatchLoggingOptionV2Props\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationCloudWatchLoggingOptionV2PropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationName", cdk.requiredValidator)(properties.applicationName));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("cloudWatchLoggingOption", cdk.requiredValidator)(properties.cloudWatchLoggingOption));
  errors.collect(cdk.propertyValidator("cloudWatchLoggingOption", CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyValidator)(properties.cloudWatchLoggingOption));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationCloudWatchLoggingOptionV2Props\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationCloudWatchLoggingOptionV2PropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationCloudWatchLoggingOptionV2PropsValidator(properties).assertSuccess();
  return {
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "CloudWatchLoggingOption": convertCfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyToCloudFormation(properties.cloudWatchLoggingOption)
  };
}

// @ts-ignore TS6133
function CfnApplicationCloudWatchLoggingOptionV2PropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationCloudWatchLoggingOptionV2Props | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationCloudWatchLoggingOptionV2Props>();
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("cloudWatchLoggingOption", "CloudWatchLoggingOption", (properties.CloudWatchLoggingOption != null ? CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyFromCloudFormation(properties.CloudWatchLoggingOption) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds an external destination to your SQL-based Amazon Kinesis Data Analytics application.
 *
 * If you want Kinesis Data Analytics to deliver data from an in-application stream within your application to an external destination (such as an Kinesis data stream, a Kinesis Data Firehose delivery stream, or an Amazon Lambda function), you add the relevant configuration to your application using this operation. You can configure one or more outputs for your application. Each output configuration maps an in-application stream and an external destination.
 *
 * You can use one of the output configurations to deliver data from your in-application error stream to an external destination so that you can analyze the errors.
 *
 * Any configuration update, including adding a streaming source using this operation, results in a new version of the application. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_DescribeApplication.html) operation to find the current application version.
 *
 * > Creation of multiple outputs should be sequential (use of DependsOn) to avoid a problem with a stale application version ( *ConcurrentModificationException* ).
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html
 */
export class CfnApplicationOutputV2 extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::KinesisAnalyticsV2::ApplicationOutput";

  /**
   * Build a CfnApplicationOutputV2 from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplicationOutputV2 {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationOutputV2PropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplicationOutputV2(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html#cfn-kinesisanalyticsv2-applicationoutput-applicationname
   */
  public applicationName: string;

  /**
   * Describes a SQL-based Kinesis Data Analytics application's output configuration, in which you identify an in-application stream and a destination where you want the in-application stream data to be written.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html#cfn-kinesisanalyticsv2-applicationoutput-output
   */
  public output: cdk.IResolvable | CfnApplicationOutputV2.OutputProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationOutputV2Props) {
    super(scope, id, {
      "type": CfnApplicationOutputV2.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "applicationName", this);
    cdk.requireProperty(props, "output", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.applicationName = props.applicationName;
    this.output = props.output;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationName": this.applicationName,
      "output": this.output
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplicationOutputV2.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationOutputV2PropsToCloudFormation(props);
  }
}

export namespace CfnApplicationOutputV2 {
  /**
   * Describes a SQL-based Kinesis Data Analytics application's output configuration, in which you identify an in-application stream and a destination where you want the in-application stream data to be written.
   *
   * The destination can be a Kinesis data stream or a Kinesis Data Firehose delivery stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html
   */
  export interface OutputProperty {
    /**
     * The name of the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html#cfn-kinesisanalyticsv2-applicationoutput-output-applicationname
     */
    readonly applicationName: string;

    /**
     * Describes a SQL-based Kinesis Data Analytics application's output configuration, in which you identify an in-application stream and a destination where you want the in-application stream data to be written.
     *
     * The destination can be a Kinesis data stream or a Kinesis Data Firehose delivery stream.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html#cfn-kinesisanalyticsv2-applicationoutput-output-output
     */
    readonly output: cdk.IResolvable | CfnApplicationOutputV2.OutputProperty;
  }
}

/**
 * Properties for defining a \`CfnApplicationOutput\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html
 */
export interface CfnApplicationOutputV2Props {
  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html#cfn-kinesisanalyticsv2-applicationoutput-applicationname
   */
  readonly applicationName: string;

  /**
   * Describes a SQL-based Kinesis Data Analytics application's output configuration, in which you identify an in-application stream and a destination where you want the in-application stream data to be written.
   *
   * The destination can be a Kinesis data stream or a Kinesis Data Firehose delivery stream.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html#cfn-kinesisanalyticsv2-applicationoutput-output
   */
  readonly output: cdk.IResolvable | CfnApplicationOutputV2.OutputProperty;
}

/**
 * Determine whether the given properties match those of a \`OutputProperty\`
 *
 * @param properties - the TypeScript properties of a \`OutputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2OutputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationName", cdk.requiredValidator)(properties.applicationName));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("output", cdk.requiredValidator)(properties.output));
  errors.collect(cdk.propertyValidator("output", CfnApplicationOutputV2OutputPropertyValidator)(properties.output));
  return errors.wrap("supplied properties not correct for \\"OutputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2OutputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2OutputPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "Output": convertCfnApplicationOutputV2OutputPropertyToCloudFormation(properties.output)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2OutputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationOutputV2.OutputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2.OutputProperty>();
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("output", "Output", (properties.Output != null ? CfnApplicationOutputV2OutputPropertyFromCloudFormation(properties.Output) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationOutputV2Props\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationOutputV2Props\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2PropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationName", cdk.requiredValidator)(properties.applicationName));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("output", cdk.requiredValidator)(properties.output));
  errors.collect(cdk.propertyValidator("output", CfnApplicationOutputV2OutputPropertyValidator)(properties.output));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationOutputV2Props\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2PropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2PropsValidator(properties).assertSuccess();
  return {
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "Output": convertCfnApplicationOutputV2OutputPropertyToCloudFormation(properties.output)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2PropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationOutputV2Props | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2Props>();
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("output", "Output", (properties.Output != null ? CfnApplicationOutputV2OutputPropertyFromCloudFormation(properties.Output) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds a reference data source to an existing SQL-based Kinesis Data Analytics application.
 *
 * Kinesis Data Analytics reads reference data (that is, an Amazon S3 object) and creates an in-application table within your application. In the request, you provide the source (S3 bucket name and object key name), name of the in-application table to create, and the necessary mapping information that describes how data in an Amazon S3 object maps to columns in the resulting in-application table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html
 */
export class CfnApplicationReferenceDataSourceV2 extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::KinesisAnalyticsV2::ApplicationReferenceDataSource";

  /**
   * Build a CfnApplicationReferenceDataSourceV2 from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplicationReferenceDataSourceV2 {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationReferenceDataSourceV2PropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplicationReferenceDataSourceV2(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-applicationname
   */
  public applicationName: string;

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the reference data source by providing the source information (Amazon S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource
   */
  public referenceDataSource: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationReferenceDataSourceV2Props) {
    super(scope, id, {
      "type": CfnApplicationReferenceDataSourceV2.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "applicationName", this);
    cdk.requireProperty(props, "referenceDataSource", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.applicationName = props.applicationName;
    this.referenceDataSource = props.referenceDataSource;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationName": this.applicationName,
      "referenceDataSource": this.referenceDataSource
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplicationReferenceDataSourceV2.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationReferenceDataSourceV2PropsToCloudFormation(props);
  }
}

export namespace CfnApplicationReferenceDataSourceV2 {
  /**
   * For a SQL-based Kinesis Data Analytics application, describes the reference data source by providing the source information (Amazon S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource.html
   */
  export interface ReferenceDataSourceProperty {
    /**
     * The name of the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource-applicationname
     */
    readonly applicationName: string;

    /**
     * For a SQL-based Kinesis Data Analytics application, describes the reference data source by providing the source information (Amazon S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource-referencedatasource
     */
    readonly referenceDataSource: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty;
  }
}

/**
 * Properties for defining a \`CfnApplicationReferenceDataSource\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html
 */
export interface CfnApplicationReferenceDataSourceV2Props {
  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-applicationname
   */
  readonly applicationName: string;

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the reference data source by providing the source information (Amazon S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource
   */
  readonly referenceDataSource: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty;
}

/**
 * Determine whether the given properties match those of a \`ReferenceDataSourceProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReferenceDataSourceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationName", cdk.requiredValidator)(properties.applicationName));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("referenceDataSource", cdk.requiredValidator)(properties.referenceDataSource));
  errors.collect(cdk.propertyValidator("referenceDataSource", CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyValidator)(properties.referenceDataSource));
  return errors.wrap("supplied properties not correct for \\"ReferenceDataSourceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyValidator(properties).assertSuccess();
  return {
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "ReferenceDataSource": convertCfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyToCloudFormation(properties.referenceDataSource)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty>();
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("referenceDataSource", "ReferenceDataSource", (properties.ReferenceDataSource != null ? CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyFromCloudFormation(properties.ReferenceDataSource) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationReferenceDataSourceV2Props\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationReferenceDataSourceV2Props\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2PropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationName", cdk.requiredValidator)(properties.applicationName));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("referenceDataSource", cdk.requiredValidator)(properties.referenceDataSource));
  errors.collect(cdk.propertyValidator("referenceDataSource", CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyValidator)(properties.referenceDataSource));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationReferenceDataSourceV2Props\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2PropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2PropsValidator(properties).assertSuccess();
  return {
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "ReferenceDataSource": convertCfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyToCloudFormation(properties.referenceDataSource)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2PropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationReferenceDataSourceV2Props | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2Props>();
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("referenceDataSource", "ReferenceDataSource", (properties.ReferenceDataSource != null ? CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyFromCloudFormation(properties.ReferenceDataSource) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}"
`;
