// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`alexa-ask 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`Alexa::ASK::Skill\` resource creates an Alexa skill that enables customers to access new abilities.
 *
 * For more information about developing a skill, see the  .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html
 */
export class CfnSkill extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "Alexa::ASK::Skill";

  /**
   * Build a CfnSkill from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSkill {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSkillPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSkill(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
   */
  public authenticationConfiguration: CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable;

  /**
   * The vendor ID associated with the Amazon developer account that will host the skill.
   */
  public vendorId: string;

  /**
   * Configuration for the skill package that contains the components of the Alexa skill.
   */
  public skillPackage: cdk.IResolvable | CfnSkill.SkillPackageProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSkillProps) {
    super(scope, id, {
      "type": CfnSkill.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "authenticationConfiguration", this);
    cdk.requireProperty(props, "vendorId", this);
    cdk.requireProperty(props, "skillPackage", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.authenticationConfiguration = props.authenticationConfiguration;
    this.vendorId = props.vendorId;
    this.skillPackage = props.skillPackage;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "authenticationConfiguration": this.authenticationConfiguration,
      "vendorId": this.vendorId,
      "skillPackage": this.skillPackage
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSkill.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSkillPropsToCloudFormation(props);
  }
}

export namespace CfnSkill {
  /**
   * The \`AuthenticationConfiguration\` property type specifies the Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
   *
   * Only Login with Amazon security profiles created through the  are supported for authentication. A client ID, client secret, and refresh token are required. You can generate a client ID and client secret by creating a new  on the Amazon Developer Portal or you can retrieve them from an existing profile. You can then retrieve the refresh token using the Alexa Skills Kit CLI. For instructions, see  in the  .
   *
   * \`AuthenticationConfiguration\` is a property of the \`Alexa::ASK::Skill\` resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html
   */
  export interface AuthenticationConfigurationProperty {
    /**
     * Client ID from Login with Amazon (LWA).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html#cfn-ask-skill-authenticationconfiguration-clientid
     */
    readonly clientId: string;

    /**
     * Refresh token from Login with Amazon (LWA).
     *
     * This token is secret.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html#cfn-ask-skill-authenticationconfiguration-refreshtoken
     */
    readonly refreshToken: string;

    /**
     * Client secret from Login with Amazon (LWA).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-authenticationconfiguration.html#cfn-ask-skill-authenticationconfiguration-clientsecret
     */
    readonly clientSecret: string;
  }

  /**
   * The \`SkillPackage\` property type contains configuration details for the skill package that contains the components of the Alexa skill.
   *
   * Skill packages are retrieved from an Amazon S3 bucket and key and used to create and update the skill. More details about the skill package format are located in the  .
   *
   * \`SkillPackage\` is a property of the \`Alexa::ASK::Skill\` resource.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html
   */
  export interface SkillPackageProperty {
    /**
     * ARN of the IAM role that grants the Alexa service ( \`alexa-appkit.amazon.com\` ) permission to access the bucket and retrieve the skill package. This property is optional. If you do not provide it, the bucket must be publicly accessible or configured with a policy that allows this access. Otherwise, AWS CloudFormation cannot create the skill.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-s3bucketrole
     */
    readonly s3BucketRole?: string;

    /**
     * Overrides to the skill package to apply when creating or updating the skill.
     *
     * Values provided here do not modify the contents of the original skill package. Currently, only overriding values inside of the skill manifest component of the package is supported.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-overrides
     */
    readonly overrides?: cdk.IResolvable | CfnSkill.OverridesProperty;

    /**
     * If you have S3 versioning enabled, the version ID of the skill package.zip file.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-s3objectversion
     */
    readonly s3ObjectVersion?: string;

    /**
     * The name of the Amazon S3 bucket where the .zip file that contains the skill package is stored.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-s3bucket
     */
    readonly s3Bucket: string;

    /**
     * The location and name of the skill package .zip file.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-skillpackage.html#cfn-ask-skill-skillpackage-s3key
     */
    readonly s3Key: string;
  }

  /**
   * The \`Overrides\` property type provides overrides to the skill package to apply when creating or updating the skill.
   *
   * Values provided here do not modify the contents of the original skill package. Currently, only overriding values inside of the skill manifest component of the package is supported.
   *
   * \`Overrides\` is a property of the \`Alexa::ASK::Skill SkillPackage\` property type.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-overrides.html
   */
  export interface OverridesProperty {
    /**
     * Overrides to apply to the skill manifest inside of the skill package.
     *
     * The skill manifest contains metadata about the skill. For more information, see  .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ask-skill-overrides.html#cfn-ask-skill-overrides-manifest
     */
    readonly manifest?: any | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnSkill\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html
 */
export interface CfnSkillProps {
  /**
   * Login with Amazon (LWA) configuration used to authenticate with the Alexa service.
   *
   * Only Login with Amazon clients created through the  are supported. The client ID, client secret, and refresh token are required.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-authenticationconfiguration
   */
  readonly authenticationConfiguration: CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable;

  /**
   * The vendor ID associated with the Amazon developer account that will host the skill.
   *
   * Details for retrieving the vendor ID are in  . The provided LWA credentials must be linked to the developer account associated with this vendor ID.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-vendorid
   */
  readonly vendorId: string;

  /**
   * Configuration for the skill package that contains the components of the Alexa skill.
   *
   * Skill packages are retrieved from an Amazon S3 bucket and key and used to create and update the skill. For more information about the skill package format, see the  .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ask-skill.html#cfn-ask-skill-skillpackage
   */
  readonly skillPackage: cdk.IResolvable | CfnSkill.SkillPackageProperty;
}

/**
 * Determine whether the given properties match those of a \`AuthenticationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`AuthenticationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillAuthenticationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("clientId", cdk.requiredValidator)(properties.clientId));
  errors.collect(cdk.propertyValidator("clientId", cdk.validateString)(properties.clientId));
  errors.collect(cdk.propertyValidator("clientSecret", cdk.requiredValidator)(properties.clientSecret));
  errors.collect(cdk.propertyValidator("clientSecret", cdk.validateString)(properties.clientSecret));
  errors.collect(cdk.propertyValidator("refreshToken", cdk.requiredValidator)(properties.refreshToken));
  errors.collect(cdk.propertyValidator("refreshToken", cdk.validateString)(properties.refreshToken));
  return errors.wrap("supplied properties not correct for \\"AuthenticationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSkillAuthenticationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillAuthenticationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ClientId": cdk.stringToCloudFormation(properties.clientId),
    "ClientSecret": cdk.stringToCloudFormation(properties.clientSecret),
    "RefreshToken": cdk.stringToCloudFormation(properties.refreshToken)
  };
}

// @ts-ignore TS6133
function CfnSkillAuthenticationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSkill.AuthenticationConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkill.AuthenticationConfigurationProperty>();
  ret.addPropertyResult("clientId", "ClientId", (properties.ClientId != null ? cfn_parse.FromCloudFormation.getString(properties.ClientId) : undefined));
  ret.addPropertyResult("clientSecret", "ClientSecret", (properties.ClientSecret != null ? cfn_parse.FromCloudFormation.getString(properties.ClientSecret) : undefined));
  ret.addPropertyResult("refreshToken", "RefreshToken", (properties.RefreshToken != null ? cfn_parse.FromCloudFormation.getString(properties.RefreshToken) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`OverridesProperty\`
 *
 * @param properties - the TypeScript properties of a \`OverridesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillOverridesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("manifest", cdk.validateObject)(properties.manifest));
  return errors.wrap("supplied properties not correct for \\"OverridesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSkillOverridesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillOverridesPropertyValidator(properties).assertSuccess();
  return {
    "Manifest": cdk.objectToCloudFormation(properties.manifest)
  };
}

// @ts-ignore TS6133
function CfnSkillOverridesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSkill.OverridesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkill.OverridesProperty>();
  ret.addPropertyResult("manifest", "Manifest", (properties.Manifest != null ? cfn_parse.FromCloudFormation.getAny(properties.Manifest) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SkillPackageProperty\`
 *
 * @param properties - the TypeScript properties of a \`SkillPackageProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillSkillPackagePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("overrides", CfnSkillOverridesPropertyValidator)(properties.overrides));
  errors.collect(cdk.propertyValidator("s3Bucket", cdk.requiredValidator)(properties.s3Bucket));
  errors.collect(cdk.propertyValidator("s3Bucket", cdk.validateString)(properties.s3Bucket));
  errors.collect(cdk.propertyValidator("s3BucketRole", cdk.validateString)(properties.s3BucketRole));
  errors.collect(cdk.propertyValidator("s3Key", cdk.requiredValidator)(properties.s3Key));
  errors.collect(cdk.propertyValidator("s3Key", cdk.validateString)(properties.s3Key));
  errors.collect(cdk.propertyValidator("s3ObjectVersion", cdk.validateString)(properties.s3ObjectVersion));
  return errors.wrap("supplied properties not correct for \\"SkillPackageProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSkillSkillPackagePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillSkillPackagePropertyValidator(properties).assertSuccess();
  return {
    "Overrides": convertCfnSkillOverridesPropertyToCloudFormation(properties.overrides),
    "S3Bucket": cdk.stringToCloudFormation(properties.s3Bucket),
    "S3BucketRole": cdk.stringToCloudFormation(properties.s3BucketRole),
    "S3Key": cdk.stringToCloudFormation(properties.s3Key),
    "S3ObjectVersion": cdk.stringToCloudFormation(properties.s3ObjectVersion)
  };
}

// @ts-ignore TS6133
function CfnSkillSkillPackagePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSkill.SkillPackageProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkill.SkillPackageProperty>();
  ret.addPropertyResult("overrides", "Overrides", (properties.Overrides != null ? CfnSkillOverridesPropertyFromCloudFormation(properties.Overrides) : undefined));
  ret.addPropertyResult("s3Bucket", "S3Bucket", (properties.S3Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.S3Bucket) : undefined));
  ret.addPropertyResult("s3BucketRole", "S3BucketRole", (properties.S3BucketRole != null ? cfn_parse.FromCloudFormation.getString(properties.S3BucketRole) : undefined));
  ret.addPropertyResult("s3Key", "S3Key", (properties.S3Key != null ? cfn_parse.FromCloudFormation.getString(properties.S3Key) : undefined));
  ret.addPropertyResult("s3ObjectVersion", "S3ObjectVersion", (properties.S3ObjectVersion != null ? cfn_parse.FromCloudFormation.getString(properties.S3ObjectVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSkillProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSkillProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSkillPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authenticationConfiguration", cdk.requiredValidator)(properties.authenticationConfiguration));
  errors.collect(cdk.propertyValidator("authenticationConfiguration", CfnSkillAuthenticationConfigurationPropertyValidator)(properties.authenticationConfiguration));
  errors.collect(cdk.propertyValidator("skillPackage", cdk.requiredValidator)(properties.skillPackage));
  errors.collect(cdk.propertyValidator("skillPackage", CfnSkillSkillPackagePropertyValidator)(properties.skillPackage));
  errors.collect(cdk.propertyValidator("vendorId", cdk.requiredValidator)(properties.vendorId));
  errors.collect(cdk.propertyValidator("vendorId", cdk.validateString)(properties.vendorId));
  return errors.wrap("supplied properties not correct for \\"CfnSkillProps\\"");
}

// @ts-ignore TS6133
function convertCfnSkillPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSkillPropsValidator(properties).assertSuccess();
  return {
    "AuthenticationConfiguration": convertCfnSkillAuthenticationConfigurationPropertyToCloudFormation(properties.authenticationConfiguration),
    "SkillPackage": convertCfnSkillSkillPackagePropertyToCloudFormation(properties.skillPackage),
    "VendorId": cdk.stringToCloudFormation(properties.vendorId)
  };
}

// @ts-ignore TS6133
function CfnSkillPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSkillProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSkillProps>();
  ret.addPropertyResult("authenticationConfiguration", "AuthenticationConfiguration", (properties.AuthenticationConfiguration != null ? CfnSkillAuthenticationConfigurationPropertyFromCloudFormation(properties.AuthenticationConfiguration) : undefined));
  ret.addPropertyResult("skillPackage", "SkillPackage", (properties.SkillPackage != null ? CfnSkillSkillPackagePropertyFromCloudFormation(properties.SkillPackage) : undefined));
  ret.addPropertyResult("vendorId", "VendorId", (properties.VendorId != null ? cfn_parse.FromCloudFormation.getString(properties.VendorId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-chatbot 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`AWS::Chatbot::MicrosoftTeamsChannelConfiguration\` resource configures a Microsoft Teams channel to allow users to use AWS Chatbot with AWS CloudFormation templates.
 *
 * This resource requires some setup to be done in the AWS Chatbot console. To provide the required Microsoft Teams team and tenant IDs, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console, then copy and paste the IDs from the console. For more details, see steps 1-4 in [Setting Up AWS Chatbot with Microsoft Teams](https://docs.aws.amazon.com/chatbot/latest/adminguide/teams-setup.html#teams-client-setup) in the *AWS Chatbot Administrator Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html
 */
export class CfnMicrosoftTeamsChannelConfiguration extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Chatbot::MicrosoftTeamsChannelConfiguration";

  /**
   * Build a CfnMicrosoftTeamsChannelConfiguration from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnMicrosoftTeamsChannelConfiguration {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnMicrosoftTeamsChannelConfigurationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnMicrosoftTeamsChannelConfiguration(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Amazon Resource Name (ARN) of the configuration
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ID of the Microsoft Team authorized with AWS Chatbot .
   */
  public teamId: string;

  /**
   * The ID of the Microsoft Teams channel.
   */
  public teamsChannelId: string;

  /**
   * The ID of the Microsoft Teams tenant.
   */
  public teamsTenantId: string;

  /**
   * The name of the configuration.
   */
  public configurationName: string;

  /**
   * The ARN of the IAM role that defines the permissions for AWS Chatbot .
   */
  public iamRoleArn: string;

  /**
   * The ARNs of the SNS topics that deliver notifications to AWS Chatbot .
   */
  public snsTopicArns?: Array<string>;

  /**
   * Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.
   */
  public loggingLevel?: string;

  /**
   * The list of IAM policy ARNs that are applied as channel guardrails.
   */
  public guardrailPolicies?: Array<string>;

  /**
   * Enables use of a user role requirement in your chat configuration.
   */
  public userRoleRequired?: boolean | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnMicrosoftTeamsChannelConfigurationProps) {
    super(scope, id, {
      "type": CfnMicrosoftTeamsChannelConfiguration.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "teamId", this);
    cdk.requireProperty(props, "teamsChannelId", this);
    cdk.requireProperty(props, "teamsTenantId", this);
    cdk.requireProperty(props, "configurationName", this);
    cdk.requireProperty(props, "iamRoleArn", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.teamId = props.teamId;
    this.teamsChannelId = props.teamsChannelId;
    this.teamsTenantId = props.teamsTenantId;
    this.configurationName = props.configurationName;
    this.iamRoleArn = props.iamRoleArn;
    this.snsTopicArns = props.snsTopicArns;
    this.loggingLevel = props.loggingLevel;
    this.guardrailPolicies = props.guardrailPolicies;
    this.userRoleRequired = props.userRoleRequired;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "teamId": this.teamId,
      "teamsChannelId": this.teamsChannelId,
      "teamsTenantId": this.teamsTenantId,
      "configurationName": this.configurationName,
      "iamRoleArn": this.iamRoleArn,
      "snsTopicArns": this.snsTopicArns,
      "loggingLevel": this.loggingLevel,
      "guardrailPolicies": this.guardrailPolicies,
      "userRoleRequired": this.userRoleRequired
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnMicrosoftTeamsChannelConfiguration.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnMicrosoftTeamsChannelConfigurationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnMicrosoftTeamsChannelConfiguration\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html
 */
export interface CfnMicrosoftTeamsChannelConfigurationProps {
  /**
   * The ID of the Microsoft Team authorized with AWS Chatbot .
   *
   * To get the team ID, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console. Then you can copy and paste the team ID from the console. For more details, see steps 1-4 in [Get started with Microsoft Teams](https://docs.aws.amazon.com/chatbot/latest/adminguide/teams-setup.html#teams-client-setup) in the *AWS Chatbot Administrator Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-teamid
   */
  readonly teamId: string;

  /**
   * The ID of the Microsoft Teams channel.
   *
   * To get the channel ID, open Microsoft Teams, right click on the channel name in the left pane, then choose Copy. An example of the channel ID syntax is: \`19%3ab6ef35dc342d56ba5654e6fc6d25a071%40thread.tacv2\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-teamschannelid
   */
  readonly teamsChannelId: string;

  /**
   * The ID of the Microsoft Teams tenant.
   *
   * To get the tenant ID, you must perform the initial authorization flow with Microsoft Teams in the AWS Chatbot console. Then you can copy and paste the tenant ID from the console. For more details, see steps 1-4 in [Get started with Microsoft Teams](https://docs.aws.amazon.com/chatbot/latest/adminguide/teams-setup.html#teams-client-setup) in the *AWS Chatbot Administrator Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-teamstenantid
   */
  readonly teamsTenantId: string;

  /**
   * The name of the configuration.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-configurationname
   */
  readonly configurationName: string;

  /**
   * The ARN of the IAM role that defines the permissions for AWS Chatbot .
   *
   * This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see [IAM Policies for AWS Chatbot](https://docs.aws.amazon.com/chatbot/latest/adminguide/chatbot-iam-policies.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-iamrolearn
   */
  readonly iamRoleArn: string;

  /**
   * The ARNs of the SNS topics that deliver notifications to AWS Chatbot .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-snstopicarns
   */
  readonly snsTopicArns?: Array<string>;

  /**
   * Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.
   *
   * Logging levels include \`ERROR\` , \`INFO\` , or \`NONE\` .
   *
   * @default - "NONE"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-logginglevel
   */
  readonly loggingLevel?: string;

  /**
   * The list of IAM policy ARNs that are applied as channel guardrails.
   *
   * The AWS managed 'AdministratorAccess' policy is applied as a default if this is not set.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-guardrailpolicies
   */
  readonly guardrailPolicies?: Array<string>;

  /**
   * Enables use of a user role requirement in your chat configuration.
   *
   * @default - false
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-microsoftteamschannelconfiguration.html#cfn-chatbot-microsoftteamschannelconfiguration-userrolerequired
   */
  readonly userRoleRequired?: boolean | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`CfnMicrosoftTeamsChannelConfigurationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnMicrosoftTeamsChannelConfigurationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnMicrosoftTeamsChannelConfigurationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("configurationName", cdk.requiredValidator)(properties.configurationName));
  errors.collect(cdk.propertyValidator("configurationName", cdk.validateString)(properties.configurationName));
  errors.collect(cdk.propertyValidator("guardrailPolicies", cdk.listValidator(cdk.validateString))(properties.guardrailPolicies));
  errors.collect(cdk.propertyValidator("iamRoleArn", cdk.requiredValidator)(properties.iamRoleArn));
  errors.collect(cdk.propertyValidator("iamRoleArn", cdk.validateString)(properties.iamRoleArn));
  errors.collect(cdk.propertyValidator("loggingLevel", cdk.validateString)(properties.loggingLevel));
  errors.collect(cdk.propertyValidator("snsTopicArns", cdk.listValidator(cdk.validateString))(properties.snsTopicArns));
  errors.collect(cdk.propertyValidator("teamId", cdk.requiredValidator)(properties.teamId));
  errors.collect(cdk.propertyValidator("teamId", cdk.validateString)(properties.teamId));
  errors.collect(cdk.propertyValidator("teamsChannelId", cdk.requiredValidator)(properties.teamsChannelId));
  errors.collect(cdk.propertyValidator("teamsChannelId", cdk.validateString)(properties.teamsChannelId));
  errors.collect(cdk.propertyValidator("teamsTenantId", cdk.requiredValidator)(properties.teamsTenantId));
  errors.collect(cdk.propertyValidator("teamsTenantId", cdk.validateString)(properties.teamsTenantId));
  errors.collect(cdk.propertyValidator("userRoleRequired", cdk.validateBoolean)(properties.userRoleRequired));
  return errors.wrap("supplied properties not correct for \\"CfnMicrosoftTeamsChannelConfigurationProps\\"");
}

// @ts-ignore TS6133
function convertCfnMicrosoftTeamsChannelConfigurationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnMicrosoftTeamsChannelConfigurationPropsValidator(properties).assertSuccess();
  return {
    "ConfigurationName": cdk.stringToCloudFormation(properties.configurationName),
    "GuardrailPolicies": cdk.listMapper(cdk.stringToCloudFormation)(properties.guardrailPolicies),
    "IamRoleArn": cdk.stringToCloudFormation(properties.iamRoleArn),
    "LoggingLevel": cdk.stringToCloudFormation(properties.loggingLevel),
    "SnsTopicArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.snsTopicArns),
    "TeamId": cdk.stringToCloudFormation(properties.teamId),
    "TeamsChannelId": cdk.stringToCloudFormation(properties.teamsChannelId),
    "TeamsTenantId": cdk.stringToCloudFormation(properties.teamsTenantId),
    "UserRoleRequired": cdk.booleanToCloudFormation(properties.userRoleRequired)
  };
}

// @ts-ignore TS6133
function CfnMicrosoftTeamsChannelConfigurationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnMicrosoftTeamsChannelConfigurationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnMicrosoftTeamsChannelConfigurationProps>();
  ret.addPropertyResult("configurationName", "ConfigurationName", (properties.ConfigurationName != null ? cfn_parse.FromCloudFormation.getString(properties.ConfigurationName) : undefined));
  ret.addPropertyResult("guardrailPolicies", "GuardrailPolicies", (properties.GuardrailPolicies != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GuardrailPolicies) : undefined));
  ret.addPropertyResult("iamRoleArn", "IamRoleArn", (properties.IamRoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.IamRoleArn) : undefined));
  ret.addPropertyResult("loggingLevel", "LoggingLevel", (properties.LoggingLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LoggingLevel) : undefined));
  ret.addPropertyResult("snsTopicArns", "SnsTopicArns", (properties.SnsTopicArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SnsTopicArns) : undefined));
  ret.addPropertyResult("teamId", "TeamId", (properties.TeamId != null ? cfn_parse.FromCloudFormation.getString(properties.TeamId) : undefined));
  ret.addPropertyResult("teamsChannelId", "TeamsChannelId", (properties.TeamsChannelId != null ? cfn_parse.FromCloudFormation.getString(properties.TeamsChannelId) : undefined));
  ret.addPropertyResult("teamsTenantId", "TeamsTenantId", (properties.TeamsTenantId != null ? cfn_parse.FromCloudFormation.getString(properties.TeamsTenantId) : undefined));
  ret.addPropertyResult("userRoleRequired", "UserRoleRequired", (properties.UserRoleRequired != null ? cfn_parse.FromCloudFormation.getBoolean(properties.UserRoleRequired) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * The \`AWS::Chatbot::SlackChannelConfiguration\` resource configures a Slack channel to allow users to use AWS Chatbot with AWS CloudFormation templates.
 *
 * This resource requires some setup to be done in the AWS Chatbot console. To provide the required Slack workspace ID, you must perform the initial authorization flow with Slack in the AWS Chatbot console, then copy and paste the workspace ID from the console. For more details, see steps 1-4 in [Setting Up AWS Chatbot with Slack](https://docs.aws.amazon.com/chatbot/latest/adminguide/setting-up.html#Setup_intro) in the *AWS Chatbot User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html
 */
export class CfnSlackChannelConfiguration extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Chatbot::SlackChannelConfiguration";

  /**
   * Build a CfnSlackChannelConfiguration from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSlackChannelConfiguration {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSlackChannelConfigurationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSlackChannelConfiguration(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Amazon Resource Name (ARN) of the configuration
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The ID of the Slack workspace authorized with AWS Chatbot .
   */
  public slackWorkspaceId: string;

  /**
   * The ID of the Slack channel.
   */
  public slackChannelId: string;

  /**
   * The name of the configuration.
   */
  public configurationName: string;

  /**
   * The ARN of the IAM role that defines the permissions for AWS Chatbot .
   */
  public iamRoleArn: string;

  /**
   * The ARNs of the SNS topics that deliver notifications to AWS Chatbot .
   */
  public snsTopicArns?: Array<string>;

  /**
   * Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.
   */
  public loggingLevel?: string;

  /**
   * The list of IAM policy ARNs that are applied as channel guardrails.
   */
  public guardrailPolicies?: Array<string>;

  /**
   * Enables use of a user role requirement in your chat configuration.
   */
  public userRoleRequired?: boolean | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSlackChannelConfigurationProps) {
    super(scope, id, {
      "type": CfnSlackChannelConfiguration.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "slackWorkspaceId", this);
    cdk.requireProperty(props, "slackChannelId", this);
    cdk.requireProperty(props, "configurationName", this);
    cdk.requireProperty(props, "iamRoleArn", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.slackWorkspaceId = props.slackWorkspaceId;
    this.slackChannelId = props.slackChannelId;
    this.configurationName = props.configurationName;
    this.iamRoleArn = props.iamRoleArn;
    this.snsTopicArns = props.snsTopicArns;
    this.loggingLevel = props.loggingLevel;
    this.guardrailPolicies = props.guardrailPolicies;
    this.userRoleRequired = props.userRoleRequired;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "slackWorkspaceId": this.slackWorkspaceId,
      "slackChannelId": this.slackChannelId,
      "configurationName": this.configurationName,
      "iamRoleArn": this.iamRoleArn,
      "snsTopicArns": this.snsTopicArns,
      "loggingLevel": this.loggingLevel,
      "guardrailPolicies": this.guardrailPolicies,
      "userRoleRequired": this.userRoleRequired
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSlackChannelConfiguration.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSlackChannelConfigurationPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnSlackChannelConfiguration\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html
 */
export interface CfnSlackChannelConfigurationProps {
  /**
   * The ID of the Slack workspace authorized with AWS Chatbot .
   *
   * To get the workspace ID, you must perform the initial authorization flow with Slack in the AWS Chatbot console. Then you can copy and paste the workspace ID from the console. For more details, see steps 1-4 in [Setting Up AWS Chatbot with Slack](https://docs.aws.amazon.com/chatbot/latest/adminguide/setting-up.html#Setup_intro) in the *AWS Chatbot User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-slackworkspaceid
   */
  readonly slackWorkspaceId: string;

  /**
   * The ID of the Slack channel.
   *
   * To get the ID, open Slack, right click on the channel name in the left pane, then choose Copy Link. The channel ID is the 9-character string at the end of the URL. For example, \`ABCBBLZZZ\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-slackchannelid
   */
  readonly slackChannelId: string;

  /**
   * The name of the configuration.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-configurationname
   */
  readonly configurationName: string;

  /**
   * The ARN of the IAM role that defines the permissions for AWS Chatbot .
   *
   * This is a user-defined role that AWS Chatbot will assume. This is not the service-linked role. For more information, see [IAM Policies for AWS Chatbot](https://docs.aws.amazon.com/chatbot/latest/adminguide/chatbot-iam-policies.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-iamrolearn
   */
  readonly iamRoleArn: string;

  /**
   * The ARNs of the SNS topics that deliver notifications to AWS Chatbot .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-snstopicarns
   */
  readonly snsTopicArns?: Array<string>;

  /**
   * Specifies the logging level for this configuration. This property affects the log entries pushed to Amazon CloudWatch Logs.
   *
   * Logging levels include \`ERROR\` , \`INFO\` , or \`NONE\` .
   *
   * @default - "NONE"
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-logginglevel
   */
  readonly loggingLevel?: string;

  /**
   * The list of IAM policy ARNs that are applied as channel guardrails.
   *
   * The AWS managed 'AdministratorAccess' policy is applied as a default if this is not set.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-guardrailpolicies
   */
  readonly guardrailPolicies?: Array<string>;

  /**
   * Enables use of a user role requirement in your chat configuration.
   *
   * @default - false
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-chatbot-slackchannelconfiguration.html#cfn-chatbot-slackchannelconfiguration-userrolerequired
   */
  readonly userRoleRequired?: boolean | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`CfnSlackChannelConfigurationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSlackChannelConfigurationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSlackChannelConfigurationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("configurationName", cdk.requiredValidator)(properties.configurationName));
  errors.collect(cdk.propertyValidator("configurationName", cdk.validateString)(properties.configurationName));
  errors.collect(cdk.propertyValidator("guardrailPolicies", cdk.listValidator(cdk.validateString))(properties.guardrailPolicies));
  errors.collect(cdk.propertyValidator("iamRoleArn", cdk.requiredValidator)(properties.iamRoleArn));
  errors.collect(cdk.propertyValidator("iamRoleArn", cdk.validateString)(properties.iamRoleArn));
  errors.collect(cdk.propertyValidator("loggingLevel", cdk.validateString)(properties.loggingLevel));
  errors.collect(cdk.propertyValidator("slackChannelId", cdk.requiredValidator)(properties.slackChannelId));
  errors.collect(cdk.propertyValidator("slackChannelId", cdk.validateString)(properties.slackChannelId));
  errors.collect(cdk.propertyValidator("slackWorkspaceId", cdk.requiredValidator)(properties.slackWorkspaceId));
  errors.collect(cdk.propertyValidator("slackWorkspaceId", cdk.validateString)(properties.slackWorkspaceId));
  errors.collect(cdk.propertyValidator("snsTopicArns", cdk.listValidator(cdk.validateString))(properties.snsTopicArns));
  errors.collect(cdk.propertyValidator("userRoleRequired", cdk.validateBoolean)(properties.userRoleRequired));
  return errors.wrap("supplied properties not correct for \\"CfnSlackChannelConfigurationProps\\"");
}

// @ts-ignore TS6133
function convertCfnSlackChannelConfigurationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSlackChannelConfigurationPropsValidator(properties).assertSuccess();
  return {
    "ConfigurationName": cdk.stringToCloudFormation(properties.configurationName),
    "GuardrailPolicies": cdk.listMapper(cdk.stringToCloudFormation)(properties.guardrailPolicies),
    "IamRoleArn": cdk.stringToCloudFormation(properties.iamRoleArn),
    "LoggingLevel": cdk.stringToCloudFormation(properties.loggingLevel),
    "SlackChannelId": cdk.stringToCloudFormation(properties.slackChannelId),
    "SlackWorkspaceId": cdk.stringToCloudFormation(properties.slackWorkspaceId),
    "SnsTopicArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.snsTopicArns),
    "UserRoleRequired": cdk.booleanToCloudFormation(properties.userRoleRequired)
  };
}

// @ts-ignore TS6133
function CfnSlackChannelConfigurationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSlackChannelConfigurationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSlackChannelConfigurationProps>();
  ret.addPropertyResult("configurationName", "ConfigurationName", (properties.ConfigurationName != null ? cfn_parse.FromCloudFormation.getString(properties.ConfigurationName) : undefined));
  ret.addPropertyResult("guardrailPolicies", "GuardrailPolicies", (properties.GuardrailPolicies != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.GuardrailPolicies) : undefined));
  ret.addPropertyResult("iamRoleArn", "IamRoleArn", (properties.IamRoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.IamRoleArn) : undefined));
  ret.addPropertyResult("loggingLevel", "LoggingLevel", (properties.LoggingLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LoggingLevel) : undefined));
  ret.addPropertyResult("slackChannelId", "SlackChannelId", (properties.SlackChannelId != null ? cfn_parse.FromCloudFormation.getString(properties.SlackChannelId) : undefined));
  ret.addPropertyResult("slackWorkspaceId", "SlackWorkspaceId", (properties.SlackWorkspaceId != null ? cfn_parse.FromCloudFormation.getString(properties.SlackWorkspaceId) : undefined));
  ret.addPropertyResult("snsTopicArns", "SnsTopicArns", (properties.SnsTopicArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SnsTopicArns) : undefined));
  ret.addPropertyResult("userRoleRequired", "UserRoleRequired", (properties.UserRoleRequired != null ? cfn_parse.FromCloudFormation.getBoolean(properties.UserRoleRequired) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-sam 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * Definition of AWS::Serverless::Api.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html
 */
export class CfnApi extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::Api";

  /**
   * Build a CfnApi from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApi {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApiPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApi(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

  public auth?: CfnApi.AuthProperty | cdk.IResolvable;

  public binaryMediaTypes?: Array<string>;

  public cacheClusterEnabled?: boolean | cdk.IResolvable;

  public cacheClusterSize?: string;

  public canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

  public cors?: CfnApi.CorsProperty | cdk.IResolvable | string;

  public definitionBody?: any | cdk.IResolvable;

  public definitionUri?: CfnApi.DefinitionUriProperty | cdk.IResolvable | string;

  public description?: string;

  public disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  public domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

  public endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable;

  public gatewayResponses?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  public methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

  public minimumCompressionSize?: number;

  public models?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  public name?: string;

  public openApiVersion?: string;

  public stageName?: string;

  public readonly tags: cdk.TagManager;

  public tracingEnabled?: boolean | cdk.IResolvable;

  public variables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApiProps = {}) {
    super(scope, id, {
      "type": CfnApi.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.accessLogSetting = props.accessLogSetting;
    this.auth = props.auth;
    this.binaryMediaTypes = props.binaryMediaTypes;
    this.cacheClusterEnabled = props.cacheClusterEnabled;
    this.cacheClusterSize = props.cacheClusterSize;
    this.canarySetting = props.canarySetting;
    this.cors = props.cors;
    this.definitionBody = props.definitionBody;
    this.definitionUri = props.definitionUri;
    this.description = props.description;
    this.disableExecuteApiEndpoint = props.disableExecuteApiEndpoint;
    this.domain = props.domain;
    this.endpointConfiguration = props.endpointConfiguration;
    this.gatewayResponses = props.gatewayResponses;
    this.methodSettings = props.methodSettings;
    this.minimumCompressionSize = props.minimumCompressionSize;
    this.models = props.models;
    this.name = props.name;
    this.openApiVersion = props.openApiVersion;
    this.stageName = props.stageName;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Serverless::Api", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tracingEnabled = props.tracingEnabled;
    this.variables = props.variables;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "accessLogSetting": this.accessLogSetting,
      "auth": this.auth,
      "binaryMediaTypes": this.binaryMediaTypes,
      "cacheClusterEnabled": this.cacheClusterEnabled,
      "cacheClusterSize": this.cacheClusterSize,
      "canarySetting": this.canarySetting,
      "cors": this.cors,
      "definitionBody": this.definitionBody,
      "definitionUri": this.definitionUri,
      "description": this.description,
      "disableExecuteApiEndpoint": this.disableExecuteApiEndpoint,
      "domain": this.domain,
      "endpointConfiguration": this.endpointConfiguration,
      "gatewayResponses": this.gatewayResponses,
      "methodSettings": this.methodSettings,
      "minimumCompressionSize": this.minimumCompressionSize,
      "models": this.models,
      "name": this.name,
      "openApiVersion": this.openApiVersion,
      "stageName": this.stageName,
      "tags": this.tags.renderTags(),
      "tracingEnabled": this.tracingEnabled,
      "variables": this.variables
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApi.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApiPropsToCloudFormation(props);
  }
}

export namespace CfnApi {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html
   */
  export interface AccessLogSettingProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-destinationarn
     */
    readonly destinationArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-accesslogsetting.html#cfn-serverless-api-accesslogsetting-format
     */
    readonly format?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html
   */
  export interface AuthProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-adddefaultauthorizertocorspreflight
     */
    readonly addDefaultAuthorizerToCorsPreflight?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-authorizers
     */
    readonly authorizers?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-auth.html#cfn-serverless-api-auth-defaultauthorizer
     */
    readonly defaultAuthorizer?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html
   */
  export interface CanarySettingProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-deploymentid
     */
    readonly deploymentId?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-percenttraffic
     */
    readonly percentTraffic?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-stagevariableoverrides
     */
    readonly stageVariableOverrides?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-canarysetting.html#cfn-serverless-api-canarysetting-usestagecache
     */
    readonly useStageCache?: boolean | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html
   */
  export interface CorsProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-allowcredentials
     */
    readonly allowCredentials?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-allowheaders
     */
    readonly allowHeaders?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-allowmethods
     */
    readonly allowMethods?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-alloworigin
     */
    readonly allowOrigin: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-cors.html#cfn-serverless-api-cors-maxage
     */
    readonly maxAge?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html
   */
  export interface DefinitionUriProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-bucket
     */
    readonly bucket: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-key
     */
    readonly key: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-definitionuri.html#cfn-serverless-api-definitionuri-version
     */
    readonly version: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html
   */
  export interface DomainConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-basepath
     */
    readonly basePath?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-certificatearn
     */
    readonly certificateArn: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-domainname
     */
    readonly domainName: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-endpointconfiguration
     */
    readonly endpointConfiguration?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-mutualtlsauthentication
     */
    readonly mutualTlsAuthentication?: cdk.IResolvable | CfnApi.MutualTlsAuthenticationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-ownershipverificationcertificatearn
     */
    readonly ownershipVerificationCertificateArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-route53
     */
    readonly route53?: cdk.IResolvable | CfnApi.Route53ConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-domainconfiguration.html#cfn-serverless-api-domainconfiguration-securitypolicy
     */
    readonly securityPolicy?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-mutualtlsauthentication.html
   */
  export interface MutualTlsAuthenticationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-mutualtlsauthentication.html#cfn-serverless-api-mutualtlsauthentication-truststoreuri
     */
    readonly truststoreUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-mutualtlsauthentication.html#cfn-serverless-api-mutualtlsauthentication-truststoreversion
     */
    readonly truststoreVersion?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-route53configuration.html
   */
  export interface Route53ConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-route53configuration.html#cfn-serverless-api-route53configuration-distributeddomainname
     */
    readonly distributedDomainName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-route53configuration.html#cfn-serverless-api-route53configuration-evaluatetargethealth
     */
    readonly evaluateTargetHealth?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-route53configuration.html#cfn-serverless-api-route53configuration-hostedzoneid
     */
    readonly hostedZoneId?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-route53configuration.html#cfn-serverless-api-route53configuration-hostedzonename
     */
    readonly hostedZoneName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-route53configuration.html#cfn-serverless-api-route53configuration-ipv6
     */
    readonly ipV6?: boolean | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html
   */
  export interface EndpointConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-type
     */
    readonly type?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-api-endpointconfiguration.html#cfn-serverless-api-endpointconfiguration-vpcendpointids
     */
    readonly vpcEndpointIds?: Array<string>;
  }
}

/**
 * Properties for defining a \`CfnApi\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html
 */
export interface CfnApiProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-accesslogsetting
   */
  readonly accessLogSetting?: CfnApi.AccessLogSettingProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-auth
   */
  readonly auth?: CfnApi.AuthProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-binarymediatypes
   */
  readonly binaryMediaTypes?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-cacheclusterenabled
   */
  readonly cacheClusterEnabled?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-cacheclustersize
   */
  readonly cacheClusterSize?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-canarysetting
   */
  readonly canarySetting?: CfnApi.CanarySettingProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-cors
   */
  readonly cors?: CfnApi.CorsProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-definitionbody
   */
  readonly definitionBody?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-definitionuri
   */
  readonly definitionUri?: CfnApi.DefinitionUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-description
   */
  readonly description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-disableexecuteapiendpoint
   */
  readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-domain
   */
  readonly domain?: CfnApi.DomainConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-endpointconfiguration
   */
  readonly endpointConfiguration?: CfnApi.EndpointConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-gatewayresponses
   */
  readonly gatewayResponses?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-methodsettings
   */
  readonly methodSettings?: Array<any | cdk.IResolvable> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-minimumcompressionsize
   */
  readonly minimumCompressionSize?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-models
   */
  readonly models?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-name
   */
  readonly name?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-openapiversion
   */
  readonly openApiVersion?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-stagename
   */
  readonly stageName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-tags
   */
  readonly tags?: Array<cdk.IResolvable | Record<string, string>> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-tracingenabled
   */
  readonly tracingEnabled?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-api.html#cfn-serverless-api-variables
   */
  readonly variables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
}

/**
 * Determine whether the given properties match those of a \`AccessLogSettingProperty\`
 *
 * @param properties - the TypeScript properties of a \`AccessLogSettingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiAccessLogSettingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationArn", cdk.validateString)(properties.destinationArn));
  errors.collect(cdk.propertyValidator("format", cdk.validateString)(properties.format));
  return errors.wrap("supplied properties not correct for \\"AccessLogSettingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiAccessLogSettingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiAccessLogSettingPropertyValidator(properties).assertSuccess();
  return {
    "DestinationArn": cdk.stringToCloudFormation(properties.destinationArn),
    "Format": cdk.stringToCloudFormation(properties.format)
  };
}

// @ts-ignore TS6133
function CfnApiAccessLogSettingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.AccessLogSettingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.AccessLogSettingProperty>();
  ret.addPropertyResult("destinationArn", "DestinationArn", (properties.DestinationArn != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationArn) : undefined));
  ret.addPropertyResult("format", "Format", (properties.Format != null ? cfn_parse.FromCloudFormation.getString(properties.Format) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AuthProperty\`
 *
 * @param properties - the TypeScript properties of a \`AuthProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiAuthPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("addDefaultAuthorizerToCorsPreflight", cdk.validateBoolean)(properties.addDefaultAuthorizerToCorsPreflight));
  errors.collect(cdk.propertyValidator("authorizers", cdk.validateObject)(properties.authorizers));
  errors.collect(cdk.propertyValidator("defaultAuthorizer", cdk.validateString)(properties.defaultAuthorizer));
  return errors.wrap("supplied properties not correct for \\"AuthProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiAuthPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiAuthPropertyValidator(properties).assertSuccess();
  return {
    "AddDefaultAuthorizerToCorsPreflight": cdk.booleanToCloudFormation(properties.addDefaultAuthorizerToCorsPreflight),
    "Authorizers": cdk.objectToCloudFormation(properties.authorizers),
    "DefaultAuthorizer": cdk.stringToCloudFormation(properties.defaultAuthorizer)
  };
}

// @ts-ignore TS6133
function CfnApiAuthPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.AuthProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.AuthProperty>();
  ret.addPropertyResult("addDefaultAuthorizerToCorsPreflight", "AddDefaultAuthorizerToCorsPreflight", (properties.AddDefaultAuthorizerToCorsPreflight != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AddDefaultAuthorizerToCorsPreflight) : undefined));
  ret.addPropertyResult("authorizers", "Authorizers", (properties.Authorizers != null ? cfn_parse.FromCloudFormation.getAny(properties.Authorizers) : undefined));
  ret.addPropertyResult("defaultAuthorizer", "DefaultAuthorizer", (properties.DefaultAuthorizer != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultAuthorizer) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CanarySettingProperty\`
 *
 * @param properties - the TypeScript properties of a \`CanarySettingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiCanarySettingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("deploymentId", cdk.validateString)(properties.deploymentId));
  errors.collect(cdk.propertyValidator("percentTraffic", cdk.validateNumber)(properties.percentTraffic));
  errors.collect(cdk.propertyValidator("stageVariableOverrides", cdk.hashValidator(cdk.validateObject))(properties.stageVariableOverrides));
  errors.collect(cdk.propertyValidator("useStageCache", cdk.validateBoolean)(properties.useStageCache));
  return errors.wrap("supplied properties not correct for \\"CanarySettingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiCanarySettingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiCanarySettingPropertyValidator(properties).assertSuccess();
  return {
    "DeploymentId": cdk.stringToCloudFormation(properties.deploymentId),
    "PercentTraffic": cdk.numberToCloudFormation(properties.percentTraffic),
    "StageVariableOverrides": cdk.hashMapper(cdk.objectToCloudFormation)(properties.stageVariableOverrides),
    "UseStageCache": cdk.booleanToCloudFormation(properties.useStageCache)
  };
}

// @ts-ignore TS6133
function CfnApiCanarySettingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.CanarySettingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.CanarySettingProperty>();
  ret.addPropertyResult("deploymentId", "DeploymentId", (properties.DeploymentId != null ? cfn_parse.FromCloudFormation.getString(properties.DeploymentId) : undefined));
  ret.addPropertyResult("percentTraffic", "PercentTraffic", (properties.PercentTraffic != null ? cfn_parse.FromCloudFormation.getNumber(properties.PercentTraffic) : undefined));
  ret.addPropertyResult("stageVariableOverrides", "StageVariableOverrides", (properties.StageVariableOverrides != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.StageVariableOverrides) : undefined));
  ret.addPropertyResult("useStageCache", "UseStageCache", (properties.UseStageCache != null ? cfn_parse.FromCloudFormation.getBoolean(properties.UseStageCache) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CorsProperty\`
 *
 * @param properties - the TypeScript properties of a \`CorsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiCorsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allowCredentials", cdk.validateBoolean)(properties.allowCredentials));
  errors.collect(cdk.propertyValidator("allowHeaders", cdk.validateString)(properties.allowHeaders));
  errors.collect(cdk.propertyValidator("allowMethods", cdk.validateString)(properties.allowMethods));
  errors.collect(cdk.propertyValidator("allowOrigin", cdk.requiredValidator)(properties.allowOrigin));
  errors.collect(cdk.propertyValidator("allowOrigin", cdk.validateString)(properties.allowOrigin));
  errors.collect(cdk.propertyValidator("maxAge", cdk.validateString)(properties.maxAge));
  return errors.wrap("supplied properties not correct for \\"CorsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiCorsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiCorsPropertyValidator(properties).assertSuccess();
  return {
    "AllowCredentials": cdk.booleanToCloudFormation(properties.allowCredentials),
    "AllowHeaders": cdk.stringToCloudFormation(properties.allowHeaders),
    "AllowMethods": cdk.stringToCloudFormation(properties.allowMethods),
    "AllowOrigin": cdk.stringToCloudFormation(properties.allowOrigin),
    "MaxAge": cdk.stringToCloudFormation(properties.maxAge)
  };
}

// @ts-ignore TS6133
function CfnApiCorsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.CorsProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.CorsProperty>();
  ret.addPropertyResult("allowCredentials", "AllowCredentials", (properties.AllowCredentials != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AllowCredentials) : undefined));
  ret.addPropertyResult("allowHeaders", "AllowHeaders", (properties.AllowHeaders != null ? cfn_parse.FromCloudFormation.getString(properties.AllowHeaders) : undefined));
  ret.addPropertyResult("allowMethods", "AllowMethods", (properties.AllowMethods != null ? cfn_parse.FromCloudFormation.getString(properties.AllowMethods) : undefined));
  ret.addPropertyResult("allowOrigin", "AllowOrigin", (properties.AllowOrigin != null ? cfn_parse.FromCloudFormation.getString(properties.AllowOrigin) : undefined));
  ret.addPropertyResult("maxAge", "MaxAge", (properties.MaxAge != null ? cfn_parse.FromCloudFormation.getString(properties.MaxAge) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DefinitionUriProperty\`
 *
 * @param properties - the TypeScript properties of a \`DefinitionUriProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiDefinitionUriPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateNumber)(properties.version));
  return errors.wrap("supplied properties not correct for \\"DefinitionUriProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiDefinitionUriPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiDefinitionUriPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "Key": cdk.stringToCloudFormation(properties.key),
    "Version": cdk.numberToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnApiDefinitionUriPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.DefinitionUriProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.DefinitionUriProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getNumber(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MutualTlsAuthenticationProperty\`
 *
 * @param properties - the TypeScript properties of a \`MutualTlsAuthenticationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiMutualTlsAuthenticationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("truststoreUri", cdk.validateString)(properties.truststoreUri));
  errors.collect(cdk.propertyValidator("truststoreVersion", cdk.validateString)(properties.truststoreVersion));
  return errors.wrap("supplied properties not correct for \\"MutualTlsAuthenticationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiMutualTlsAuthenticationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiMutualTlsAuthenticationPropertyValidator(properties).assertSuccess();
  return {
    "TruststoreUri": cdk.stringToCloudFormation(properties.truststoreUri),
    "TruststoreVersion": cdk.stringToCloudFormation(properties.truststoreVersion)
  };
}

// @ts-ignore TS6133
function CfnApiMutualTlsAuthenticationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApi.MutualTlsAuthenticationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.MutualTlsAuthenticationProperty>();
  ret.addPropertyResult("truststoreUri", "TruststoreUri", (properties.TruststoreUri != null ? cfn_parse.FromCloudFormation.getString(properties.TruststoreUri) : undefined));
  ret.addPropertyResult("truststoreVersion", "TruststoreVersion", (properties.TruststoreVersion != null ? cfn_parse.FromCloudFormation.getString(properties.TruststoreVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`Route53ConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`Route53ConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiRoute53ConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("distributedDomainName", cdk.validateString)(properties.distributedDomainName));
  errors.collect(cdk.propertyValidator("evaluateTargetHealth", cdk.validateBoolean)(properties.evaluateTargetHealth));
  errors.collect(cdk.propertyValidator("hostedZoneId", cdk.validateString)(properties.hostedZoneId));
  errors.collect(cdk.propertyValidator("hostedZoneName", cdk.validateString)(properties.hostedZoneName));
  errors.collect(cdk.propertyValidator("ipV6", cdk.validateBoolean)(properties.ipV6));
  return errors.wrap("supplied properties not correct for \\"Route53ConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiRoute53ConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiRoute53ConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "DistributedDomainName": cdk.stringToCloudFormation(properties.distributedDomainName),
    "EvaluateTargetHealth": cdk.booleanToCloudFormation(properties.evaluateTargetHealth),
    "HostedZoneId": cdk.stringToCloudFormation(properties.hostedZoneId),
    "HostedZoneName": cdk.stringToCloudFormation(properties.hostedZoneName),
    "IpV6": cdk.booleanToCloudFormation(properties.ipV6)
  };
}

// @ts-ignore TS6133
function CfnApiRoute53ConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApi.Route53ConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.Route53ConfigurationProperty>();
  ret.addPropertyResult("distributedDomainName", "DistributedDomainName", (properties.DistributedDomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DistributedDomainName) : undefined));
  ret.addPropertyResult("evaluateTargetHealth", "EvaluateTargetHealth", (properties.EvaluateTargetHealth != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EvaluateTargetHealth) : undefined));
  ret.addPropertyResult("hostedZoneId", "HostedZoneId", (properties.HostedZoneId != null ? cfn_parse.FromCloudFormation.getString(properties.HostedZoneId) : undefined));
  ret.addPropertyResult("hostedZoneName", "HostedZoneName", (properties.HostedZoneName != null ? cfn_parse.FromCloudFormation.getString(properties.HostedZoneName) : undefined));
  ret.addPropertyResult("ipV6", "IpV6", (properties.IpV6 != null ? cfn_parse.FromCloudFormation.getBoolean(properties.IpV6) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DomainConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`DomainConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiDomainConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("basePath", cdk.listValidator(cdk.validateString))(properties.basePath));
  errors.collect(cdk.propertyValidator("certificateArn", cdk.requiredValidator)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("certificateArn", cdk.validateString)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("domainName", cdk.requiredValidator)(properties.domainName));
  errors.collect(cdk.propertyValidator("domainName", cdk.validateString)(properties.domainName));
  errors.collect(cdk.propertyValidator("endpointConfiguration", cdk.validateString)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("mutualTlsAuthentication", CfnApiMutualTlsAuthenticationPropertyValidator)(properties.mutualTlsAuthentication));
  errors.collect(cdk.propertyValidator("ownershipVerificationCertificateArn", cdk.validateString)(properties.ownershipVerificationCertificateArn));
  errors.collect(cdk.propertyValidator("route53", CfnApiRoute53ConfigurationPropertyValidator)(properties.route53));
  errors.collect(cdk.propertyValidator("securityPolicy", cdk.validateString)(properties.securityPolicy));
  return errors.wrap("supplied properties not correct for \\"DomainConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiDomainConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiDomainConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "BasePath": cdk.listMapper(cdk.stringToCloudFormation)(properties.basePath),
    "CertificateArn": cdk.stringToCloudFormation(properties.certificateArn),
    "DomainName": cdk.stringToCloudFormation(properties.domainName),
    "EndpointConfiguration": cdk.stringToCloudFormation(properties.endpointConfiguration),
    "MutualTlsAuthentication": convertCfnApiMutualTlsAuthenticationPropertyToCloudFormation(properties.mutualTlsAuthentication),
    "OwnershipVerificationCertificateArn": cdk.stringToCloudFormation(properties.ownershipVerificationCertificateArn),
    "Route53": convertCfnApiRoute53ConfigurationPropertyToCloudFormation(properties.route53),
    "SecurityPolicy": cdk.stringToCloudFormation(properties.securityPolicy)
  };
}

// @ts-ignore TS6133
function CfnApiDomainConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.DomainConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.DomainConfigurationProperty>();
  ret.addPropertyResult("basePath", "BasePath", (properties.BasePath != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BasePath) : undefined));
  ret.addPropertyResult("certificateArn", "CertificateArn", (properties.CertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.CertificateArn) : undefined));
  ret.addPropertyResult("domainName", "DomainName", (properties.DomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DomainName) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("mutualTlsAuthentication", "MutualTlsAuthentication", (properties.MutualTlsAuthentication != null ? CfnApiMutualTlsAuthenticationPropertyFromCloudFormation(properties.MutualTlsAuthentication) : undefined));
  ret.addPropertyResult("ownershipVerificationCertificateArn", "OwnershipVerificationCertificateArn", (properties.OwnershipVerificationCertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.OwnershipVerificationCertificateArn) : undefined));
  ret.addPropertyResult("route53", "Route53", (properties.Route53 != null ? CfnApiRoute53ConfigurationPropertyFromCloudFormation(properties.Route53) : undefined));
  ret.addPropertyResult("securityPolicy", "SecurityPolicy", (properties.SecurityPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.SecurityPolicy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EndpointConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`EndpointConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiEndpointConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  errors.collect(cdk.propertyValidator("vpcEndpointIds", cdk.listValidator(cdk.validateString))(properties.vpcEndpointIds));
  return errors.wrap("supplied properties not correct for \\"EndpointConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApiEndpointConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiEndpointConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Type": cdk.stringToCloudFormation(properties.type),
    "VpcEndpointIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.vpcEndpointIds)
  };
}

// @ts-ignore TS6133
function CfnApiEndpointConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApi.EndpointConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApi.EndpointConfigurationProperty>();
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addPropertyResult("vpcEndpointIds", "VpcEndpointIds", (properties.VpcEndpointIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.VpcEndpointIds) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApiProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnApiProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApiPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("binaryMediaTypes", cdk.listValidator(cdk.validateString))(properties.binaryMediaTypes));
  errors.collect(cdk.propertyValidator("cacheClusterEnabled", cdk.validateBoolean)(properties.cacheClusterEnabled));
  errors.collect(cdk.propertyValidator("cacheClusterSize", cdk.validateString)(properties.cacheClusterSize));
  errors.collect(cdk.propertyValidator("canarySetting", CfnApiCanarySettingPropertyValidator)(properties.canarySetting));
  errors.collect(cdk.propertyValidator("cors", cdk.unionValidator(CfnApiCorsPropertyValidator, cdk.validateString))(properties.cors));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("endpointConfiguration", CfnApiEndpointConfigurationPropertyValidator)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("gatewayResponses", cdk.hashValidator(cdk.validateObject))(properties.gatewayResponses));
  errors.collect(cdk.propertyValidator("methodSettings", cdk.listValidator(cdk.validateObject))(properties.methodSettings));
  errors.collect(cdk.propertyValidator("minimumCompressionSize", cdk.validateNumber)(properties.minimumCompressionSize));
  errors.collect(cdk.propertyValidator("models", cdk.hashValidator(cdk.validateObject))(properties.models));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("openApiVersion", cdk.validateString)(properties.openApiVersion));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.hashValidator(cdk.validateString)))(properties.tags));
  errors.collect(cdk.propertyValidator("tracingEnabled", cdk.validateBoolean)(properties.tracingEnabled));
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateObject))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"CfnApiProps\\"");
}

// @ts-ignore TS6133
function convertCfnApiPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApiPropsValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnApiAuthPropertyToCloudFormation(properties.auth),
    "BinaryMediaTypes": cdk.listMapper(cdk.stringToCloudFormation)(properties.binaryMediaTypes),
    "CacheClusterEnabled": cdk.booleanToCloudFormation(properties.cacheClusterEnabled),
    "CacheClusterSize": cdk.stringToCloudFormation(properties.cacheClusterSize),
    "CanarySetting": convertCfnApiCanarySettingPropertyToCloudFormation(properties.canarySetting),
    "Cors": cdk.unionMapper([CfnApiCorsPropertyValidator, cdk.validateString], [convertCfnApiCorsPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.cors),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "EndpointConfiguration": convertCfnApiEndpointConfigurationPropertyToCloudFormation(properties.endpointConfiguration),
    "GatewayResponses": cdk.hashMapper(cdk.objectToCloudFormation)(properties.gatewayResponses),
    "MethodSettings": cdk.listMapper(cdk.objectToCloudFormation)(properties.methodSettings),
    "MinimumCompressionSize": cdk.numberToCloudFormation(properties.minimumCompressionSize),
    "Models": cdk.hashMapper(cdk.objectToCloudFormation)(properties.models),
    "Name": cdk.stringToCloudFormation(properties.name),
    "OpenApiVersion": cdk.stringToCloudFormation(properties.openApiVersion),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "Tags": cdk.listMapper(cdk.hashMapper(cdk.stringToCloudFormation))(properties.tags),
    "TracingEnabled": cdk.booleanToCloudFormation(properties.tracingEnabled),
    "Variables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnApiPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApiProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApiProps>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("binaryMediaTypes", "BinaryMediaTypes", (properties.BinaryMediaTypes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.BinaryMediaTypes) : undefined));
  ret.addPropertyResult("cacheClusterEnabled", "CacheClusterEnabled", (properties.CacheClusterEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CacheClusterEnabled) : undefined));
  ret.addPropertyResult("cacheClusterSize", "CacheClusterSize", (properties.CacheClusterSize != null ? cfn_parse.FromCloudFormation.getString(properties.CacheClusterSize) : undefined));
  ret.addPropertyResult("canarySetting", "CanarySetting", (properties.CanarySetting != null ? CfnApiCanarySettingPropertyFromCloudFormation(properties.CanarySetting) : undefined));
  ret.addPropertyResult("cors", "Cors", (properties.Cors != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiCorsPropertyValidator, cdk.validateString], [CfnApiCorsPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Cors) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApiDefinitionUriPropertyValidator, cdk.validateString], [CfnApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? CfnApiEndpointConfigurationPropertyFromCloudFormation(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("gatewayResponses", "GatewayResponses", (properties.GatewayResponses != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.GatewayResponses) : undefined));
  ret.addPropertyResult("methodSettings", "MethodSettings", (properties.MethodSettings != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.MethodSettings) : undefined));
  ret.addPropertyResult("minimumCompressionSize", "MinimumCompressionSize", (properties.MinimumCompressionSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinimumCompressionSize) : undefined));
  ret.addPropertyResult("models", "Models", (properties.Models != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Models) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("openApiVersion", "OpenApiVersion", (properties.OpenApiVersion != null ? cfn_parse.FromCloudFormation.getString(properties.OpenApiVersion) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString))(properties.Tags) : undefined));
  ret.addPropertyResult("tracingEnabled", "TracingEnabled", (properties.TracingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TracingEnabled) : undefined));
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::Application.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html
 */
export class CfnApplication extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::Application";

  /**
   * Build a CfnApplication from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplication {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplication(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public location?: cdk.IResolvable | CfnApplication.LocationProperty | string;

  public notificationArns?: Array<string>;

  public parameters?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  public readonly tags: cdk.TagManager;

  public timeoutInMinutes?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationProps = {}) {
    super(scope, id, {
      "type": CfnApplication.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.location = props.location;
    this.notificationArns = props.notificationArns;
    this.parameters = props.parameters;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Serverless::Application", props.tags, {
      "tagPropertyName": "tags"
    });
    this.timeoutInMinutes = props.timeoutInMinutes;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "location": this.location,
      "notificationArns": this.notificationArns,
      "parameters": this.parameters,
      "tags": this.tags.renderTags(),
      "timeoutInMinutes": this.timeoutInMinutes
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplication.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationPropsToCloudFormation(props);
  }
}

export namespace CfnApplication {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-application-location.html
   */
  export interface LocationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-application-location.html#cfn-serverless-application-location-applicationid
     */
    readonly applicationId: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-application-location.html#cfn-serverless-application-location-semanticversion
     */
    readonly semanticVersion: string;
  }
}

/**
 * Properties for defining a \`CfnApplication\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html
 */
export interface CfnApplicationProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-location
   */
  readonly location?: cdk.IResolvable | CfnApplication.LocationProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-notificationarns
   */
  readonly notificationArns?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-parameters
   */
  readonly parameters?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-tags
   */
  readonly tags?: Array<cdk.IResolvable | Record<string, string>> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-application.html#cfn-serverless-application-timeoutinminutes
   */
  readonly timeoutInMinutes?: number;
}

/**
 * Determine whether the given properties match those of a \`LocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationLocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationId", cdk.requiredValidator)(properties.applicationId));
  errors.collect(cdk.propertyValidator("applicationId", cdk.validateString)(properties.applicationId));
  errors.collect(cdk.propertyValidator("semanticVersion", cdk.requiredValidator)(properties.semanticVersion));
  errors.collect(cdk.propertyValidator("semanticVersion", cdk.validateString)(properties.semanticVersion));
  return errors.wrap("supplied properties not correct for \\"LocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationLocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationLocationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationId": cdk.stringToCloudFormation(properties.applicationId),
    "SemanticVersion": cdk.stringToCloudFormation(properties.semanticVersion)
  };
}

// @ts-ignore TS6133
function CfnApplicationLocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplication.LocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplication.LocationProperty>();
  ret.addPropertyResult("applicationId", "ApplicationId", (properties.ApplicationId != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationId) : undefined));
  ret.addPropertyResult("semanticVersion", "SemanticVersion", (properties.SemanticVersion != null ? cfn_parse.FromCloudFormation.getString(properties.SemanticVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("location", cdk.unionValidator(CfnApplicationLocationPropertyValidator, cdk.validateString))(properties.location));
  errors.collect(cdk.propertyValidator("notificationArns", cdk.listValidator(cdk.validateString))(properties.notificationArns));
  errors.collect(cdk.propertyValidator("parameters", cdk.hashValidator(cdk.validateObject))(properties.parameters));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.hashValidator(cdk.validateString)))(properties.tags));
  errors.collect(cdk.propertyValidator("timeoutInMinutes", cdk.validateNumber)(properties.timeoutInMinutes));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationProps\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationPropsValidator(properties).assertSuccess();
  return {
    "Location": cdk.unionMapper([CfnApplicationLocationPropertyValidator, cdk.validateString], [convertCfnApplicationLocationPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.location),
    "NotificationArns": cdk.listMapper(cdk.stringToCloudFormation)(properties.notificationArns),
    "Parameters": cdk.hashMapper(cdk.objectToCloudFormation)(properties.parameters),
    "Tags": cdk.listMapper(cdk.hashMapper(cdk.stringToCloudFormation))(properties.tags),
    "TimeoutInMinutes": cdk.numberToCloudFormation(properties.timeoutInMinutes)
  };
}

// @ts-ignore TS6133
function CfnApplicationPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationProps>();
  ret.addPropertyResult("location", "Location", (properties.Location != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnApplicationLocationPropertyValidator, cdk.validateString], [CfnApplicationLocationPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Location) : undefined));
  ret.addPropertyResult("notificationArns", "NotificationArns", (properties.NotificationArns != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.NotificationArns) : undefined));
  ret.addPropertyResult("parameters", "Parameters", (properties.Parameters != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Parameters) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString))(properties.Tags) : undefined));
  ret.addPropertyResult("timeoutInMinutes", "TimeoutInMinutes", (properties.TimeoutInMinutes != null ? cfn_parse.FromCloudFormation.getNumber(properties.TimeoutInMinutes) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::Function.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html
 */
export class CfnFunction extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::Function";

  /**
   * Build a CfnFunction from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnFunction {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnFunctionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnFunction(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public architectures?: Array<string>;

  public assumeRolePolicyDocument?: any | cdk.IResolvable;

  public autoPublishAlias?: string;

  public autoPublishCodeSha256?: string;

  public codeSigningConfigArn?: string;

  public codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

  public deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

  public deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

  public description?: string;

  public environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

  public eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

  public events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

  public fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

  public functionName?: string;

  public handler?: string;

  public imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

  public imageUri?: string;

  public inlineCode?: string;

  public kmsKeyArn?: string;

  public layers?: Array<string>;

  public memorySize?: number;

  public packageType?: string;

  public permissionsBoundary?: string;

  public policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

  public provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

  public reservedConcurrentExecutions?: number;

  public role?: string;

  public runtime?: string;

  public readonly tags: cdk.TagManager;

  public timeout?: number;

  public tracing?: string;

  public versionDescription?: string;

  public vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnFunctionProps = {}) {
    super(scope, id, {
      "type": CfnFunction.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.architectures = props.architectures;
    this.assumeRolePolicyDocument = props.assumeRolePolicyDocument;
    this.autoPublishAlias = props.autoPublishAlias;
    this.autoPublishCodeSha256 = props.autoPublishCodeSha256;
    this.codeSigningConfigArn = props.codeSigningConfigArn;
    this.codeUri = props.codeUri;
    this.deadLetterQueue = props.deadLetterQueue;
    this.deploymentPreference = props.deploymentPreference;
    this.description = props.description;
    this.environment = props.environment;
    this.eventInvokeConfig = props.eventInvokeConfig;
    this.events = props.events;
    this.fileSystemConfigs = props.fileSystemConfigs;
    this.functionName = props.functionName;
    this.handler = props.handler;
    this.imageConfig = props.imageConfig;
    this.imageUri = props.imageUri;
    this.inlineCode = props.inlineCode;
    this.kmsKeyArn = props.kmsKeyArn;
    this.layers = props.layers;
    this.memorySize = props.memorySize;
    this.packageType = props.packageType;
    this.permissionsBoundary = props.permissionsBoundary;
    this.policies = props.policies;
    this.provisionedConcurrencyConfig = props.provisionedConcurrencyConfig;
    this.reservedConcurrentExecutions = props.reservedConcurrentExecutions;
    this.role = props.role;
    this.runtime = props.runtime;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Serverless::Function", props.tags, {
      "tagPropertyName": "tags"
    });
    this.timeout = props.timeout;
    this.tracing = props.tracing;
    this.versionDescription = props.versionDescription;
    this.vpcConfig = props.vpcConfig;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "architectures": this.architectures,
      "assumeRolePolicyDocument": this.assumeRolePolicyDocument,
      "autoPublishAlias": this.autoPublishAlias,
      "autoPublishCodeSha256": this.autoPublishCodeSha256,
      "codeSigningConfigArn": this.codeSigningConfigArn,
      "codeUri": this.codeUri,
      "deadLetterQueue": this.deadLetterQueue,
      "deploymentPreference": this.deploymentPreference,
      "description": this.description,
      "environment": this.environment,
      "eventInvokeConfig": this.eventInvokeConfig,
      "events": this.events,
      "fileSystemConfigs": this.fileSystemConfigs,
      "functionName": this.functionName,
      "handler": this.handler,
      "imageConfig": this.imageConfig,
      "imageUri": this.imageUri,
      "inlineCode": this.inlineCode,
      "kmsKeyArn": this.kmsKeyArn,
      "layers": this.layers,
      "memorySize": this.memorySize,
      "packageType": this.packageType,
      "permissionsBoundary": this.permissionsBoundary,
      "policies": this.policies,
      "provisionedConcurrencyConfig": this.provisionedConcurrencyConfig,
      "reservedConcurrentExecutions": this.reservedConcurrentExecutions,
      "role": this.role,
      "runtime": this.runtime,
      "tags": this.tags.renderTags(),
      "timeout": this.timeout,
      "tracing": this.tracing,
      "versionDescription": this.versionDescription,
      "vpcConfig": this.vpcConfig
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnFunction.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnFunctionPropsToCloudFormation(props);
  }
}

export namespace CfnFunction {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html
   */
  export interface CodeUriProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-bucket
     */
    readonly bucket: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-key
     */
    readonly key: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-codeuri.html#cfn-serverless-function-codeuri-version
     */
    readonly version?: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html
   */
  export interface DeadLetterQueueProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-targetarn
     */
    readonly targetArn: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deadletterqueue.html#cfn-serverless-function-deadletterqueue-type
     */
    readonly type: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html
   */
  export interface DeploymentPreferenceProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-alarms
     */
    readonly alarms?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-hooks
     */
    readonly hooks?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-role
     */
    readonly role?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-deploymentpreference.html#cfn-serverless-function-deploymentpreference-type
     */
    readonly type?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html
   */
  export interface FunctionEnvironmentProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-functionenvironment.html#cfn-serverless-function-functionenvironment-variables
     */
    readonly variables: cdk.IResolvable | Record<string, any | cdk.IResolvable>;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html
   */
  export interface EventInvokeConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-destinationconfig
     */
    readonly destinationConfig?: CfnFunction.EventInvokeDestinationConfigProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-maximumeventageinseconds
     */
    readonly maximumEventAgeInSeconds?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokeconfig.html#cfn-serverless-function-eventinvokeconfig-maximumretryattempts
     */
    readonly maximumRetryAttempts?: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokedestinationconfig.html
   */
  export interface EventInvokeDestinationConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokedestinationconfig.html#cfn-serverless-function-eventinvokedestinationconfig-onfailure
     */
    readonly onFailure: CfnFunction.DestinationProperty | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventinvokedestinationconfig.html#cfn-serverless-function-eventinvokedestinationconfig-onsuccess
     */
    readonly onSuccess: CfnFunction.DestinationProperty | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-destination.html
   */
  export interface DestinationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-destination.html#cfn-serverless-function-destination-destination
     */
    readonly destination: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-destination.html#cfn-serverless-function-destination-type
     */
    readonly type?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html
   */
  export interface EventSourceProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-properties
     */
    readonly properties: cdk.IResolvable | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty | CfnFunction.PropertiesProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-eventsource.html#cfn-serverless-function-eventsource-type
     */
    readonly type: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-properties.html
   */
  export interface PropertiesProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-properties.html#cfn-serverless-function-properties-bucket
     */
    readonly bucket: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-properties.html#cfn-serverless-function-properties-events
     */
    readonly events: Array<string> | cdk.IResolvable | string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-properties.html#cfn-serverless-function-properties-filter
     */
    readonly filter?: cdk.IResolvable | CfnFunction.S3NotificationFilterProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3notificationfilter.html
   */
  export interface S3NotificationFilterProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3notificationfilter.html#cfn-serverless-function-s3notificationfilter-s3key
     */
    readonly s3Key: cdk.IResolvable | CfnFunction.S3KeyFilterProperty;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3keyfilter.html
   */
  export interface S3KeyFilterProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3keyfilter.html#cfn-serverless-function-s3keyfilter-rules
     */
    readonly rules: Array<cdk.IResolvable | CfnFunction.S3KeyFilterRuleProperty> | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3keyfilterrule.html
   */
  export interface S3KeyFilterRuleProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3keyfilterrule.html#cfn-serverless-function-s3keyfilterrule-name
     */
    readonly name: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-s3keyfilterrule.html#cfn-serverless-function-s3keyfilterrule-value
     */
    readonly value: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html
   */
  export interface FileSystemConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-arn
     */
    readonly arn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-filesystemconfig.html#cfn-serverless-function-filesystemconfig-localmountpath
     */
    readonly localMountPath?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html
   */
  export interface ImageConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-command
     */
    readonly command?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-entrypoint
     */
    readonly entryPoint?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-imageconfig.html#cfn-serverless-function-imageconfig-workingdirectory
     */
    readonly workingDirectory?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html
   */
  export interface PoliciesProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-statement
     */
    readonly statement: Array<any | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-policies.html#cfn-serverless-function-policies-version
     */
    readonly version?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html
   */
  export interface ProvisionedConcurrencyConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-provisionedconcurrencyconfig.html#cfn-serverless-function-provisionedconcurrencyconfig-provisionedconcurrentexecutions
     */
    readonly provisionedConcurrentExecutions: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html
   */
  export interface VpcConfigProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-securitygroupids
     */
    readonly securityGroupIds: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-function-vpcconfig.html#cfn-serverless-function-vpcconfig-subnetids
     */
    readonly subnetIds: Array<string>;
  }
}

/**
 * Properties for defining a \`CfnFunction\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html
 */
export interface CfnFunctionProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-architectures
   */
  readonly architectures?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-assumerolepolicydocument
   */
  readonly assumeRolePolicyDocument?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-autopublishalias
   */
  readonly autoPublishAlias?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-autopublishcodesha256
   */
  readonly autoPublishCodeSha256?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-codesigningconfigarn
   */
  readonly codeSigningConfigArn?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-codeuri
   */
  readonly codeUri?: CfnFunction.CodeUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-deadletterqueue
   */
  readonly deadLetterQueue?: CfnFunction.DeadLetterQueueProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-deploymentpreference
   */
  readonly deploymentPreference?: CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-description
   */
  readonly description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-environment
   */
  readonly environment?: CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-eventinvokeconfig
   */
  readonly eventInvokeConfig?: CfnFunction.EventInvokeConfigProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-events
   */
  readonly events?: cdk.IResolvable | Record<string, CfnFunction.EventSourceProperty | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-filesystemconfigs
   */
  readonly fileSystemConfigs?: Array<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-functionname
   */
  readonly functionName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-handler
   */
  readonly handler?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-imageconfig
   */
  readonly imageConfig?: CfnFunction.ImageConfigProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-imageuri
   */
  readonly imageUri?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-inlinecode
   */
  readonly inlineCode?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-kmskeyarn
   */
  readonly kmsKeyArn?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-layers
   */
  readonly layers?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-memorysize
   */
  readonly memorySize?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-packagetype
   */
  readonly packageType?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-permissionsboundary
   */
  readonly permissionsBoundary?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-policies
   */
  readonly policies?: Array<CfnFunction.PoliciesProperty | CfnFunction.PoliciesProperty | string> | cdk.IResolvable | CfnFunction.PoliciesProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-provisionedconcurrencyconfig
   */
  readonly provisionedConcurrencyConfig?: cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-reservedconcurrentexecutions
   */
  readonly reservedConcurrentExecutions?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-role
   */
  readonly role?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-runtime
   */
  readonly runtime?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-tags
   */
  readonly tags?: Array<cdk.IResolvable | Record<string, string>> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-timeout
   */
  readonly timeout?: number;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-tracing
   */
  readonly tracing?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-versiondescription
   */
  readonly versionDescription?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-function.html#cfn-serverless-function-vpcconfig
   */
  readonly vpcConfig?: cdk.IResolvable | CfnFunction.VpcConfigProperty;
}

/**
 * Determine whether the given properties match those of a \`CodeUriProperty\`
 *
 * @param properties - the TypeScript properties of a \`CodeUriProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionCodeUriPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("version", cdk.validateNumber)(properties.version));
  return errors.wrap("supplied properties not correct for \\"CodeUriProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionCodeUriPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionCodeUriPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "Key": cdk.stringToCloudFormation(properties.key),
    "Version": cdk.numberToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnFunctionCodeUriPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.CodeUriProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.CodeUriProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getNumber(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeadLetterQueueProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeadLetterQueueProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionDeadLetterQueuePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("targetArn", cdk.requiredValidator)(properties.targetArn));
  errors.collect(cdk.propertyValidator("targetArn", cdk.validateString)(properties.targetArn));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"DeadLetterQueueProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionDeadLetterQueuePropertyValidator(properties).assertSuccess();
  return {
    "TargetArn": cdk.stringToCloudFormation(properties.targetArn),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.DeadLetterQueueProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.DeadLetterQueueProperty>();
  ret.addPropertyResult("targetArn", "TargetArn", (properties.TargetArn != null ? cfn_parse.FromCloudFormation.getString(properties.TargetArn) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeploymentPreferenceProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeploymentPreferenceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionDeploymentPreferencePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("alarms", cdk.listValidator(cdk.validateString))(properties.alarms));
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  errors.collect(cdk.propertyValidator("hooks", cdk.hashValidator(cdk.validateObject))(properties.hooks));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"DeploymentPreferenceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionDeploymentPreferencePropertyValidator(properties).assertSuccess();
  return {
    "Alarms": cdk.listMapper(cdk.stringToCloudFormation)(properties.alarms),
    "Enabled": cdk.booleanToCloudFormation(properties.enabled),
    "Hooks": cdk.hashMapper(cdk.objectToCloudFormation)(properties.hooks),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.DeploymentPreferenceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.DeploymentPreferenceProperty>();
  ret.addPropertyResult("alarms", "Alarms", (properties.Alarms != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Alarms) : undefined));
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addPropertyResult("hooks", "Hooks", (properties.Hooks != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Hooks) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FunctionEnvironmentProperty\`
 *
 * @param properties - the TypeScript properties of a \`FunctionEnvironmentProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionFunctionEnvironmentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("variables", cdk.requiredValidator)(properties.variables));
  errors.collect(cdk.propertyValidator("variables", cdk.hashValidator(cdk.validateObject))(properties.variables));
  return errors.wrap("supplied properties not correct for \\"FunctionEnvironmentProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionFunctionEnvironmentPropertyValidator(properties).assertSuccess();
  return {
    "Variables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.variables)
  };
}

// @ts-ignore TS6133
function CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.FunctionEnvironmentProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.FunctionEnvironmentProperty>();
  ret.addPropertyResult("variables", "Variables", (properties.Variables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.Variables) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DestinationProperty\`
 *
 * @param properties - the TypeScript properties of a \`DestinationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionDestinationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destination", cdk.requiredValidator)(properties.destination));
  errors.collect(cdk.propertyValidator("destination", cdk.validateString)(properties.destination));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"DestinationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionDestinationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionDestinationPropertyValidator(properties).assertSuccess();
  return {
    "Destination": cdk.stringToCloudFormation(properties.destination),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnFunctionDestinationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.DestinationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.DestinationProperty>();
  ret.addPropertyResult("destination", "Destination", (properties.Destination != null ? cfn_parse.FromCloudFormation.getString(properties.Destination) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventInvokeDestinationConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventInvokeDestinationConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionEventInvokeDestinationConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("onFailure", cdk.requiredValidator)(properties.onFailure));
  errors.collect(cdk.propertyValidator("onFailure", CfnFunctionDestinationPropertyValidator)(properties.onFailure));
  errors.collect(cdk.propertyValidator("onSuccess", cdk.requiredValidator)(properties.onSuccess));
  errors.collect(cdk.propertyValidator("onSuccess", CfnFunctionDestinationPropertyValidator)(properties.onSuccess));
  return errors.wrap("supplied properties not correct for \\"EventInvokeDestinationConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionEventInvokeDestinationConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionEventInvokeDestinationConfigPropertyValidator(properties).assertSuccess();
  return {
    "OnFailure": convertCfnFunctionDestinationPropertyToCloudFormation(properties.onFailure),
    "OnSuccess": convertCfnFunctionDestinationPropertyToCloudFormation(properties.onSuccess)
  };
}

// @ts-ignore TS6133
function CfnFunctionEventInvokeDestinationConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.EventInvokeDestinationConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.EventInvokeDestinationConfigProperty>();
  ret.addPropertyResult("onFailure", "OnFailure", (properties.OnFailure != null ? CfnFunctionDestinationPropertyFromCloudFormation(properties.OnFailure) : undefined));
  ret.addPropertyResult("onSuccess", "OnSuccess", (properties.OnSuccess != null ? CfnFunctionDestinationPropertyFromCloudFormation(properties.OnSuccess) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventInvokeConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventInvokeConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionEventInvokeConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationConfig", CfnFunctionEventInvokeDestinationConfigPropertyValidator)(properties.destinationConfig));
  errors.collect(cdk.propertyValidator("maximumEventAgeInSeconds", cdk.validateNumber)(properties.maximumEventAgeInSeconds));
  errors.collect(cdk.propertyValidator("maximumRetryAttempts", cdk.validateNumber)(properties.maximumRetryAttempts));
  return errors.wrap("supplied properties not correct for \\"EventInvokeConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionEventInvokeConfigPropertyValidator(properties).assertSuccess();
  return {
    "DestinationConfig": convertCfnFunctionEventInvokeDestinationConfigPropertyToCloudFormation(properties.destinationConfig),
    "MaximumEventAgeInSeconds": cdk.numberToCloudFormation(properties.maximumEventAgeInSeconds),
    "MaximumRetryAttempts": cdk.numberToCloudFormation(properties.maximumRetryAttempts)
  };
}

// @ts-ignore TS6133
function CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.EventInvokeConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.EventInvokeConfigProperty>();
  ret.addPropertyResult("destinationConfig", "DestinationConfig", (properties.DestinationConfig != null ? CfnFunctionEventInvokeDestinationConfigPropertyFromCloudFormation(properties.DestinationConfig) : undefined));
  ret.addPropertyResult("maximumEventAgeInSeconds", "MaximumEventAgeInSeconds", (properties.MaximumEventAgeInSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumEventAgeInSeconds) : undefined));
  ret.addPropertyResult("maximumRetryAttempts", "MaximumRetryAttempts", (properties.MaximumRetryAttempts != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumRetryAttempts) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3KeyFilterRuleProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3KeyFilterRuleProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionS3KeyFilterRulePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("value", cdk.requiredValidator)(properties.value));
  errors.collect(cdk.propertyValidator("value", cdk.validateString)(properties.value));
  return errors.wrap("supplied properties not correct for \\"S3KeyFilterRuleProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionS3KeyFilterRulePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionS3KeyFilterRulePropertyValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name),
    "Value": cdk.stringToCloudFormation(properties.value)
  };
}

// @ts-ignore TS6133
function CfnFunctionS3KeyFilterRulePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.S3KeyFilterRuleProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.S3KeyFilterRuleProperty>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("value", "Value", (properties.Value != null ? cfn_parse.FromCloudFormation.getString(properties.Value) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3KeyFilterProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3KeyFilterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionS3KeyFilterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("rules", cdk.requiredValidator)(properties.rules));
  errors.collect(cdk.propertyValidator("rules", cdk.listValidator(CfnFunctionS3KeyFilterRulePropertyValidator))(properties.rules));
  return errors.wrap("supplied properties not correct for \\"S3KeyFilterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionS3KeyFilterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionS3KeyFilterPropertyValidator(properties).assertSuccess();
  return {
    "Rules": cdk.listMapper(convertCfnFunctionS3KeyFilterRulePropertyToCloudFormation)(properties.rules)
  };
}

// @ts-ignore TS6133
function CfnFunctionS3KeyFilterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.S3KeyFilterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.S3KeyFilterProperty>();
  ret.addPropertyResult("rules", "Rules", (properties.Rules != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionS3KeyFilterRulePropertyFromCloudFormation)(properties.Rules) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3NotificationFilterProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3NotificationFilterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionS3NotificationFilterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("s3Key", cdk.requiredValidator)(properties.s3Key));
  errors.collect(cdk.propertyValidator("s3Key", CfnFunctionS3KeyFilterPropertyValidator)(properties.s3Key));
  return errors.wrap("supplied properties not correct for \\"S3NotificationFilterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionS3NotificationFilterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionS3NotificationFilterPropertyValidator(properties).assertSuccess();
  return {
    "S3Key": convertCfnFunctionS3KeyFilterPropertyToCloudFormation(properties.s3Key)
  };
}

// @ts-ignore TS6133
function CfnFunctionS3NotificationFilterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.S3NotificationFilterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.S3NotificationFilterProperty>();
  ret.addPropertyResult("s3Key", "S3Key", (properties.S3Key != null ? CfnFunctionS3KeyFilterPropertyFromCloudFormation(properties.S3Key) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PropertiesProperty\`
 *
 * @param properties - the TypeScript properties of a \`PropertiesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionPropertiesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("events", cdk.requiredValidator)(properties.events));
  errors.collect(cdk.propertyValidator("events", cdk.unionValidator(cdk.listValidator(cdk.validateString), cdk.validateString))(properties.events));
  errors.collect(cdk.propertyValidator("filter", CfnFunctionS3NotificationFilterPropertyValidator)(properties.filter));
  return errors.wrap("supplied properties not correct for \\"PropertiesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionPropertiesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionPropertiesPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "Events": cdk.unionMapper([cdk.listValidator(cdk.validateString), cdk.validateString], [cdk.listMapper(cdk.stringToCloudFormation), cdk.stringToCloudFormation])(properties.events),
    "Filter": convertCfnFunctionS3NotificationFilterPropertyToCloudFormation(properties.filter)
  };
}

// @ts-ignore TS6133
function CfnFunctionPropertiesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.PropertiesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.PropertiesProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.validateString), cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString), cfn_parse.FromCloudFormation.getString])(properties.Events) : undefined));
  ret.addPropertyResult("filter", "Filter", (properties.Filter != null ? CfnFunctionS3NotificationFilterPropertyFromCloudFormation(properties.Filter) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventSourceProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventSourceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionEventSourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("properties", cdk.requiredValidator)(properties.properties));
  errors.collect(cdk.propertyValidator("properties", cdk.unionValidator(CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator))(properties.properties));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"EventSourceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionEventSourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionEventSourcePropertyValidator(properties).assertSuccess();
  return {
    "Properties": cdk.unionMapper([CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator], [convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation, convertCfnFunctionPropertiesPropertyToCloudFormation])(properties.properties),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnFunctionEventSourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.EventSourceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.EventSourceProperty>();
  ret.addPropertyResult("properties", "Properties", (properties.Properties != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator, CfnFunctionPropertiesPropertyValidator], [CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation, CfnFunctionPropertiesPropertyFromCloudFormation])(properties.Properties) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FileSystemConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`FileSystemConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionFileSystemConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  errors.collect(cdk.propertyValidator("localMountPath", cdk.validateString)(properties.localMountPath));
  return errors.wrap("supplied properties not correct for \\"FileSystemConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionFileSystemConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionFileSystemConfigPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn),
    "LocalMountPath": cdk.stringToCloudFormation(properties.localMountPath)
  };
}

// @ts-ignore TS6133
function CfnFunctionFileSystemConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.FileSystemConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.FileSystemConfigProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addPropertyResult("localMountPath", "LocalMountPath", (properties.LocalMountPath != null ? cfn_parse.FromCloudFormation.getString(properties.LocalMountPath) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ImageConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`ImageConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionImageConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("command", cdk.listValidator(cdk.validateString))(properties.command));
  errors.collect(cdk.propertyValidator("entryPoint", cdk.listValidator(cdk.validateString))(properties.entryPoint));
  errors.collect(cdk.propertyValidator("workingDirectory", cdk.validateString)(properties.workingDirectory));
  return errors.wrap("supplied properties not correct for \\"ImageConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionImageConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionImageConfigPropertyValidator(properties).assertSuccess();
  return {
    "Command": cdk.listMapper(cdk.stringToCloudFormation)(properties.command),
    "EntryPoint": cdk.listMapper(cdk.stringToCloudFormation)(properties.entryPoint),
    "WorkingDirectory": cdk.stringToCloudFormation(properties.workingDirectory)
  };
}

// @ts-ignore TS6133
function CfnFunctionImageConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunction.ImageConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.ImageConfigProperty>();
  ret.addPropertyResult("command", "Command", (properties.Command != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Command) : undefined));
  ret.addPropertyResult("entryPoint", "EntryPoint", (properties.EntryPoint != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.EntryPoint) : undefined));
  ret.addPropertyResult("workingDirectory", "WorkingDirectory", (properties.WorkingDirectory != null ? cfn_parse.FromCloudFormation.getString(properties.WorkingDirectory) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PoliciesProperty\`
 *
 * @param properties - the TypeScript properties of a \`PoliciesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionPoliciesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("statement", cdk.requiredValidator)(properties.statement));
  errors.collect(cdk.propertyValidator("statement", cdk.listValidator(cdk.validateObject))(properties.statement));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \\"PoliciesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionPoliciesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionPoliciesPropertyValidator(properties).assertSuccess();
  return {
    "Statement": cdk.listMapper(cdk.objectToCloudFormation)(properties.statement),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnFunctionPoliciesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.PoliciesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.PoliciesProperty>();
  ret.addPropertyResult("statement", "Statement", (properties.Statement != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.Statement) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ProvisionedConcurrencyConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`ProvisionedConcurrencyConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionProvisionedConcurrencyConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("provisionedConcurrentExecutions", cdk.requiredValidator)(properties.provisionedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("provisionedConcurrentExecutions", cdk.validateString)(properties.provisionedConcurrentExecutions));
  return errors.wrap("supplied properties not correct for \\"ProvisionedConcurrencyConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionProvisionedConcurrencyConfigPropertyValidator(properties).assertSuccess();
  return {
    "ProvisionedConcurrentExecutions": cdk.stringToCloudFormation(properties.provisionedConcurrentExecutions)
  };
}

// @ts-ignore TS6133
function CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.ProvisionedConcurrencyConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.ProvisionedConcurrencyConfigProperty>();
  ret.addPropertyResult("provisionedConcurrentExecutions", "ProvisionedConcurrentExecutions", (properties.ProvisionedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getString(properties.ProvisionedConcurrentExecutions) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VpcConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`VpcConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionVpcConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.requiredValidator)(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.requiredValidator)(properties.subnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  return errors.wrap("supplied properties not correct for \\"VpcConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionVpcConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionVpcConfigPropertyValidator(properties).assertSuccess();
  return {
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds)
  };
}

// @ts-ignore TS6133
function CfnFunctionVpcConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnFunction.VpcConfigProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunction.VpcConfigProperty>();
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnFunctionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnFunctionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnFunctionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("architectures", cdk.listValidator(cdk.validateString))(properties.architectures));
  errors.collect(cdk.propertyValidator("assumeRolePolicyDocument", cdk.validateObject)(properties.assumeRolePolicyDocument));
  errors.collect(cdk.propertyValidator("autoPublishAlias", cdk.validateString)(properties.autoPublishAlias));
  errors.collect(cdk.propertyValidator("autoPublishCodeSha256", cdk.validateString)(properties.autoPublishCodeSha256));
  errors.collect(cdk.propertyValidator("codeSigningConfigArn", cdk.validateString)(properties.codeSigningConfigArn));
  errors.collect(cdk.propertyValidator("codeUri", cdk.unionValidator(CfnFunctionCodeUriPropertyValidator, cdk.validateString))(properties.codeUri));
  errors.collect(cdk.propertyValidator("deadLetterQueue", CfnFunctionDeadLetterQueuePropertyValidator)(properties.deadLetterQueue));
  errors.collect(cdk.propertyValidator("deploymentPreference", CfnFunctionDeploymentPreferencePropertyValidator)(properties.deploymentPreference));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("environment", CfnFunctionFunctionEnvironmentPropertyValidator)(properties.environment));
  errors.collect(cdk.propertyValidator("eventInvokeConfig", CfnFunctionEventInvokeConfigPropertyValidator)(properties.eventInvokeConfig));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnFunctionEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("fileSystemConfigs", cdk.listValidator(CfnFunctionFileSystemConfigPropertyValidator))(properties.fileSystemConfigs));
  errors.collect(cdk.propertyValidator("functionName", cdk.validateString)(properties.functionName));
  errors.collect(cdk.propertyValidator("handler", cdk.validateString)(properties.handler));
  errors.collect(cdk.propertyValidator("imageConfig", CfnFunctionImageConfigPropertyValidator)(properties.imageConfig));
  errors.collect(cdk.propertyValidator("imageUri", cdk.validateString)(properties.imageUri));
  errors.collect(cdk.propertyValidator("inlineCode", cdk.validateString)(properties.inlineCode));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("layers", cdk.listValidator(cdk.validateString))(properties.layers));
  errors.collect(cdk.propertyValidator("memorySize", cdk.validateNumber)(properties.memorySize));
  errors.collect(cdk.propertyValidator("packageType", cdk.validateString)(properties.packageType));
  errors.collect(cdk.propertyValidator("permissionsBoundary", cdk.validateString)(properties.permissionsBoundary));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("provisionedConcurrencyConfig", CfnFunctionProvisionedConcurrencyConfigPropertyValidator)(properties.provisionedConcurrencyConfig));
  errors.collect(cdk.propertyValidator("reservedConcurrentExecutions", cdk.validateNumber)(properties.reservedConcurrentExecutions));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("runtime", cdk.validateString)(properties.runtime));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.hashValidator(cdk.validateString)))(properties.tags));
  errors.collect(cdk.propertyValidator("timeout", cdk.validateNumber)(properties.timeout));
  errors.collect(cdk.propertyValidator("tracing", cdk.validateString)(properties.tracing));
  errors.collect(cdk.propertyValidator("versionDescription", cdk.validateString)(properties.versionDescription));
  errors.collect(cdk.propertyValidator("vpcConfig", CfnFunctionVpcConfigPropertyValidator)(properties.vpcConfig));
  return errors.wrap("supplied properties not correct for \\"CfnFunctionProps\\"");
}

// @ts-ignore TS6133
function convertCfnFunctionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnFunctionPropsValidator(properties).assertSuccess();
  return {
    "Architectures": cdk.listMapper(cdk.stringToCloudFormation)(properties.architectures),
    "AssumeRolePolicyDocument": cdk.objectToCloudFormation(properties.assumeRolePolicyDocument),
    "AutoPublishAlias": cdk.stringToCloudFormation(properties.autoPublishAlias),
    "AutoPublishCodeSha256": cdk.stringToCloudFormation(properties.autoPublishCodeSha256),
    "CodeSigningConfigArn": cdk.stringToCloudFormation(properties.codeSigningConfigArn),
    "CodeUri": cdk.unionMapper([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [convertCfnFunctionCodeUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.codeUri),
    "DeadLetterQueue": convertCfnFunctionDeadLetterQueuePropertyToCloudFormation(properties.deadLetterQueue),
    "DeploymentPreference": convertCfnFunctionDeploymentPreferencePropertyToCloudFormation(properties.deploymentPreference),
    "Description": cdk.stringToCloudFormation(properties.description),
    "Environment": convertCfnFunctionFunctionEnvironmentPropertyToCloudFormation(properties.environment),
    "EventInvokeConfig": convertCfnFunctionEventInvokeConfigPropertyToCloudFormation(properties.eventInvokeConfig),
    "Events": cdk.hashMapper(convertCfnFunctionEventSourcePropertyToCloudFormation)(properties.events),
    "FileSystemConfigs": cdk.listMapper(convertCfnFunctionFileSystemConfigPropertyToCloudFormation)(properties.fileSystemConfigs),
    "FunctionName": cdk.stringToCloudFormation(properties.functionName),
    "Handler": cdk.stringToCloudFormation(properties.handler),
    "ImageConfig": convertCfnFunctionImageConfigPropertyToCloudFormation(properties.imageConfig),
    "ImageUri": cdk.stringToCloudFormation(properties.imageUri),
    "InlineCode": cdk.stringToCloudFormation(properties.inlineCode),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Layers": cdk.listMapper(cdk.stringToCloudFormation)(properties.layers),
    "MemorySize": cdk.numberToCloudFormation(properties.memorySize),
    "PackageType": cdk.stringToCloudFormation(properties.packageType),
    "PermissionsBoundary": cdk.stringToCloudFormation(properties.permissionsBoundary),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [convertCfnFunctionPoliciesPropertyToCloudFormation, convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnFunctionPoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "ProvisionedConcurrencyConfig": convertCfnFunctionProvisionedConcurrencyConfigPropertyToCloudFormation(properties.provisionedConcurrencyConfig),
    "ReservedConcurrentExecutions": cdk.numberToCloudFormation(properties.reservedConcurrentExecutions),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Runtime": cdk.stringToCloudFormation(properties.runtime),
    "Tags": cdk.listMapper(cdk.hashMapper(cdk.stringToCloudFormation))(properties.tags),
    "Timeout": cdk.numberToCloudFormation(properties.timeout),
    "Tracing": cdk.stringToCloudFormation(properties.tracing),
    "VersionDescription": cdk.stringToCloudFormation(properties.versionDescription),
    "VpcConfig": convertCfnFunctionVpcConfigPropertyToCloudFormation(properties.vpcConfig)
  };
}

// @ts-ignore TS6133
function CfnFunctionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnFunctionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnFunctionProps>();
  ret.addPropertyResult("architectures", "Architectures", (properties.Architectures != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Architectures) : undefined));
  ret.addPropertyResult("assumeRolePolicyDocument", "AssumeRolePolicyDocument", (properties.AssumeRolePolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.AssumeRolePolicyDocument) : undefined));
  ret.addPropertyResult("autoPublishAlias", "AutoPublishAlias", (properties.AutoPublishAlias != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishAlias) : undefined));
  ret.addPropertyResult("autoPublishCodeSha256", "AutoPublishCodeSha256", (properties.AutoPublishCodeSha256 != null ? cfn_parse.FromCloudFormation.getString(properties.AutoPublishCodeSha256) : undefined));
  ret.addPropertyResult("codeSigningConfigArn", "CodeSigningConfigArn", (properties.CodeSigningConfigArn != null ? cfn_parse.FromCloudFormation.getString(properties.CodeSigningConfigArn) : undefined));
  ret.addPropertyResult("codeUri", "CodeUri", (properties.CodeUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionCodeUriPropertyValidator, cdk.validateString], [CfnFunctionCodeUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.CodeUri) : undefined));
  ret.addPropertyResult("deadLetterQueue", "DeadLetterQueue", (properties.DeadLetterQueue != null ? CfnFunctionDeadLetterQueuePropertyFromCloudFormation(properties.DeadLetterQueue) : undefined));
  ret.addPropertyResult("deploymentPreference", "DeploymentPreference", (properties.DeploymentPreference != null ? CfnFunctionDeploymentPreferencePropertyFromCloudFormation(properties.DeploymentPreference) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("environment", "Environment", (properties.Environment != null ? CfnFunctionFunctionEnvironmentPropertyFromCloudFormation(properties.Environment) : undefined));
  ret.addPropertyResult("eventInvokeConfig", "EventInvokeConfig", (properties.EventInvokeConfig != null ? CfnFunctionEventInvokeConfigPropertyFromCloudFormation(properties.EventInvokeConfig) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnFunctionEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("fileSystemConfigs", "FileSystemConfigs", (properties.FileSystemConfigs != null ? cfn_parse.FromCloudFormation.getArray(CfnFunctionFileSystemConfigPropertyFromCloudFormation)(properties.FileSystemConfigs) : undefined));
  ret.addPropertyResult("functionName", "FunctionName", (properties.FunctionName != null ? cfn_parse.FromCloudFormation.getString(properties.FunctionName) : undefined));
  ret.addPropertyResult("handler", "Handler", (properties.Handler != null ? cfn_parse.FromCloudFormation.getString(properties.Handler) : undefined));
  ret.addPropertyResult("imageConfig", "ImageConfig", (properties.ImageConfig != null ? CfnFunctionImageConfigPropertyFromCloudFormation(properties.ImageConfig) : undefined));
  ret.addPropertyResult("imageUri", "ImageUri", (properties.ImageUri != null ? cfn_parse.FromCloudFormation.getString(properties.ImageUri) : undefined));
  ret.addPropertyResult("inlineCode", "InlineCode", (properties.InlineCode != null ? cfn_parse.FromCloudFormation.getString(properties.InlineCode) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("layers", "Layers", (properties.Layers != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Layers) : undefined));
  ret.addPropertyResult("memorySize", "MemorySize", (properties.MemorySize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MemorySize) : undefined));
  ret.addPropertyResult("packageType", "PackageType", (properties.PackageType != null ? cfn_parse.FromCloudFormation.getString(properties.PackageType) : undefined));
  ret.addPropertyResult("permissionsBoundary", "PermissionsBoundary", (properties.PermissionsBoundary != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundary) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString)), CfnFunctionPoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnFunctionPoliciesPropertyValidator, CfnFunctionPoliciesPropertyValidator, cdk.validateString], [CfnFunctionPoliciesPropertyFromCloudFormation, CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnFunctionPoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("provisionedConcurrencyConfig", "ProvisionedConcurrencyConfig", (properties.ProvisionedConcurrencyConfig != null ? CfnFunctionProvisionedConcurrencyConfigPropertyFromCloudFormation(properties.ProvisionedConcurrencyConfig) : undefined));
  ret.addPropertyResult("reservedConcurrentExecutions", "ReservedConcurrentExecutions", (properties.ReservedConcurrentExecutions != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReservedConcurrentExecutions) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("runtime", "Runtime", (properties.Runtime != null ? cfn_parse.FromCloudFormation.getString(properties.Runtime) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString))(properties.Tags) : undefined));
  ret.addPropertyResult("timeout", "Timeout", (properties.Timeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.Timeout) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? cfn_parse.FromCloudFormation.getString(properties.Tracing) : undefined));
  ret.addPropertyResult("versionDescription", "VersionDescription", (properties.VersionDescription != null ? cfn_parse.FromCloudFormation.getString(properties.VersionDescription) : undefined));
  ret.addPropertyResult("vpcConfig", "VpcConfig", (properties.VpcConfig != null ? CfnFunctionVpcConfigPropertyFromCloudFormation(properties.VpcConfig) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::HttpApi.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html
 */
export class CfnHttpApi extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::HttpApi";

  /**
   * Build a CfnHttpApi from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnHttpApi {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnHttpApiPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnHttpApi(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public accessLogSetting?: CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable;

  public auth?: CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable;

  public corsConfiguration?: boolean | CfnHttpApi.CorsConfigurationProperty | cdk.IResolvable;

  public defaultRouteSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

  public definitionBody?: any | cdk.IResolvable;

  public definitionUri?: CfnHttpApi.DefinitionUriProperty | cdk.IResolvable | string;

  public description?: string;

  public disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  public domain?: CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable;

  public failOnWarnings?: boolean | cdk.IResolvable;

  public routeSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

  public stageName?: string;

  public stageVariables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  public readonly tags: cdk.TagManager;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnHttpApiProps = {}) {
    super(scope, id, {
      "type": CfnHttpApi.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.accessLogSetting = props.accessLogSetting;
    this.auth = props.auth;
    this.corsConfiguration = props.corsConfiguration;
    this.defaultRouteSettings = props.defaultRouteSettings;
    this.definitionBody = props.definitionBody;
    this.definitionUri = props.definitionUri;
    this.description = props.description;
    this.disableExecuteApiEndpoint = props.disableExecuteApiEndpoint;
    this.domain = props.domain;
    this.failOnWarnings = props.failOnWarnings;
    this.routeSettings = props.routeSettings;
    this.stageName = props.stageName;
    this.stageVariables = props.stageVariables;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Serverless::HttpApi", props.tags, {
      "tagPropertyName": "tags"
    });
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "accessLogSetting": this.accessLogSetting,
      "auth": this.auth,
      "corsConfiguration": this.corsConfiguration,
      "defaultRouteSettings": this.defaultRouteSettings,
      "definitionBody": this.definitionBody,
      "definitionUri": this.definitionUri,
      "description": this.description,
      "disableExecuteApiEndpoint": this.disableExecuteApiEndpoint,
      "domain": this.domain,
      "failOnWarnings": this.failOnWarnings,
      "routeSettings": this.routeSettings,
      "stageName": this.stageName,
      "stageVariables": this.stageVariables,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnHttpApi.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnHttpApiPropsToCloudFormation(props);
  }
}

export namespace CfnHttpApi {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html
   */
  export interface AccessLogSettingProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-destinationarn
     */
    readonly destinationArn?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-accesslogsetting.html#cfn-serverless-httpapi-accesslogsetting-format
     */
    readonly format?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html
   */
  export interface HttpApiAuthProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-authorizers
     */
    readonly authorizers?: any | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapiauth.html#cfn-serverless-httpapi-httpapiauth-defaultauthorizer
     */
    readonly defaultAuthorizer?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html
   */
  export interface CorsConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-allowcredentials
     */
    readonly allowCredentials?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-allowheaders
     */
    readonly allowHeaders?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-allowmethods
     */
    readonly allowMethods?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-alloworigins
     */
    readonly allowOrigins?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-exposeheaders
     */
    readonly exposeHeaders?: Array<string>;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-corsconfiguration.html#cfn-serverless-httpapi-corsconfiguration-maxage
     */
    readonly maxAge?: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html
   */
  export interface RouteSettingsProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-datatraceenabled
     */
    readonly dataTraceEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-detailedmetricsenabled
     */
    readonly detailedMetricsEnabled?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-logginglevel
     */
    readonly loggingLevel?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-throttlingburstlimit
     */
    readonly throttlingBurstLimit?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-routesettings.html#cfn-serverless-httpapi-routesettings-throttlingratelimit
     */
    readonly throttlingRateLimit?: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html
   */
  export interface DefinitionUriProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-bucket
     */
    readonly bucket: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-key
     */
    readonly key: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-definitionuri.html#cfn-serverless-httpapi-definitionuri-version
     */
    readonly version: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html
   */
  export interface HttpApiDomainConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-basepath
     */
    readonly basePath?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-certificatearn
     */
    readonly certificateArn: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-domainname
     */
    readonly domainName: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-endpointconfiguration
     */
    readonly endpointConfiguration?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-mutualtlsauthentication
     */
    readonly mutualTlsAuthentication?: cdk.IResolvable | CfnHttpApi.MutualTlsAuthenticationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-route53
     */
    readonly route53?: cdk.IResolvable | CfnHttpApi.Route53ConfigurationProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-httpapidomainconfiguration.html#cfn-serverless-httpapi-httpapidomainconfiguration-securitypolicy
     */
    readonly securityPolicy?: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-mutualtlsauthentication.html
   */
  export interface MutualTlsAuthenticationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-mutualtlsauthentication.html#cfn-serverless-httpapi-mutualtlsauthentication-truststoreuri
     */
    readonly truststoreUri?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-mutualtlsauthentication.html#cfn-serverless-httpapi-mutualtlsauthentication-truststoreversion
     */
    readonly truststoreVersion?: boolean | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-route53configuration.html
   */
  export interface Route53ConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-route53configuration.html#cfn-serverless-httpapi-route53configuration-distributeddomainname
     */
    readonly distributedDomainName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-route53configuration.html#cfn-serverless-httpapi-route53configuration-evaluatetargethealth
     */
    readonly evaluateTargetHealth?: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-route53configuration.html#cfn-serverless-httpapi-route53configuration-hostedzoneid
     */
    readonly hostedZoneId?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-route53configuration.html#cfn-serverless-httpapi-route53configuration-hostedzonename
     */
    readonly hostedZoneName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-httpapi-route53configuration.html#cfn-serverless-httpapi-route53configuration-ipv6
     */
    readonly ipV6?: boolean | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnHttpApi\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html
 */
export interface CfnHttpApiProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-accesslogsetting
   */
  readonly accessLogSetting?: CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-auth
   */
  readonly auth?: CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-corsconfiguration
   */
  readonly corsConfiguration?: boolean | CfnHttpApi.CorsConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-defaultroutesettings
   */
  readonly defaultRouteSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-definitionbody
   */
  readonly definitionBody?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-definitionuri
   */
  readonly definitionUri?: CfnHttpApi.DefinitionUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-description
   */
  readonly description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-disableexecuteapiendpoint
   */
  readonly disableExecuteApiEndpoint?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-domain
   */
  readonly domain?: CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-failonwarnings
   */
  readonly failOnWarnings?: boolean | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-routesettings
   */
  readonly routeSettings?: cdk.IResolvable | CfnHttpApi.RouteSettingsProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-stagename
   */
  readonly stageName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-stagevariables
   */
  readonly stageVariables?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-httpapi.html#cfn-serverless-httpapi-tags
   */
  readonly tags?: Array<cdk.IResolvable | Record<string, string>> | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`AccessLogSettingProperty\`
 *
 * @param properties - the TypeScript properties of a \`AccessLogSettingProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiAccessLogSettingPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationArn", cdk.validateString)(properties.destinationArn));
  errors.collect(cdk.propertyValidator("format", cdk.validateString)(properties.format));
  return errors.wrap("supplied properties not correct for \\"AccessLogSettingProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiAccessLogSettingPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiAccessLogSettingPropertyValidator(properties).assertSuccess();
  return {
    "DestinationArn": cdk.stringToCloudFormation(properties.destinationArn),
    "Format": cdk.stringToCloudFormation(properties.format)
  };
}

// @ts-ignore TS6133
function CfnHttpApiAccessLogSettingPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.AccessLogSettingProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.AccessLogSettingProperty>();
  ret.addPropertyResult("destinationArn", "DestinationArn", (properties.DestinationArn != null ? cfn_parse.FromCloudFormation.getString(properties.DestinationArn) : undefined));
  ret.addPropertyResult("format", "Format", (properties.Format != null ? cfn_parse.FromCloudFormation.getString(properties.Format) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`HttpApiAuthProperty\`
 *
 * @param properties - the TypeScript properties of a \`HttpApiAuthProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiHttpApiAuthPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("authorizers", cdk.validateObject)(properties.authorizers));
  errors.collect(cdk.propertyValidator("defaultAuthorizer", cdk.validateString)(properties.defaultAuthorizer));
  return errors.wrap("supplied properties not correct for \\"HttpApiAuthProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiHttpApiAuthPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiHttpApiAuthPropertyValidator(properties).assertSuccess();
  return {
    "Authorizers": cdk.objectToCloudFormation(properties.authorizers),
    "DefaultAuthorizer": cdk.stringToCloudFormation(properties.defaultAuthorizer)
  };
}

// @ts-ignore TS6133
function CfnHttpApiHttpApiAuthPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.HttpApiAuthProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.HttpApiAuthProperty>();
  ret.addPropertyResult("authorizers", "Authorizers", (properties.Authorizers != null ? cfn_parse.FromCloudFormation.getAny(properties.Authorizers) : undefined));
  ret.addPropertyResult("defaultAuthorizer", "DefaultAuthorizer", (properties.DefaultAuthorizer != null ? cfn_parse.FromCloudFormation.getString(properties.DefaultAuthorizer) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CorsConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CorsConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiCorsConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allowCredentials", cdk.validateBoolean)(properties.allowCredentials));
  errors.collect(cdk.propertyValidator("allowHeaders", cdk.listValidator(cdk.validateString))(properties.allowHeaders));
  errors.collect(cdk.propertyValidator("allowMethods", cdk.listValidator(cdk.validateString))(properties.allowMethods));
  errors.collect(cdk.propertyValidator("allowOrigins", cdk.listValidator(cdk.validateString))(properties.allowOrigins));
  errors.collect(cdk.propertyValidator("exposeHeaders", cdk.listValidator(cdk.validateString))(properties.exposeHeaders));
  errors.collect(cdk.propertyValidator("maxAge", cdk.validateNumber)(properties.maxAge));
  return errors.wrap("supplied properties not correct for \\"CorsConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiCorsConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiCorsConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AllowCredentials": cdk.booleanToCloudFormation(properties.allowCredentials),
    "AllowHeaders": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowHeaders),
    "AllowMethods": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowMethods),
    "AllowOrigins": cdk.listMapper(cdk.stringToCloudFormation)(properties.allowOrigins),
    "ExposeHeaders": cdk.listMapper(cdk.stringToCloudFormation)(properties.exposeHeaders),
    "MaxAge": cdk.numberToCloudFormation(properties.maxAge)
  };
}

// @ts-ignore TS6133
function CfnHttpApiCorsConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.CorsConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.CorsConfigurationProperty>();
  ret.addPropertyResult("allowCredentials", "AllowCredentials", (properties.AllowCredentials != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AllowCredentials) : undefined));
  ret.addPropertyResult("allowHeaders", "AllowHeaders", (properties.AllowHeaders != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowHeaders) : undefined));
  ret.addPropertyResult("allowMethods", "AllowMethods", (properties.AllowMethods != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowMethods) : undefined));
  ret.addPropertyResult("allowOrigins", "AllowOrigins", (properties.AllowOrigins != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.AllowOrigins) : undefined));
  ret.addPropertyResult("exposeHeaders", "ExposeHeaders", (properties.ExposeHeaders != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.ExposeHeaders) : undefined));
  ret.addPropertyResult("maxAge", "MaxAge", (properties.MaxAge != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaxAge) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RouteSettingsProperty\`
 *
 * @param properties - the TypeScript properties of a \`RouteSettingsProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiRouteSettingsPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("dataTraceEnabled", cdk.validateBoolean)(properties.dataTraceEnabled));
  errors.collect(cdk.propertyValidator("detailedMetricsEnabled", cdk.validateBoolean)(properties.detailedMetricsEnabled));
  errors.collect(cdk.propertyValidator("loggingLevel", cdk.validateString)(properties.loggingLevel));
  errors.collect(cdk.propertyValidator("throttlingBurstLimit", cdk.validateNumber)(properties.throttlingBurstLimit));
  errors.collect(cdk.propertyValidator("throttlingRateLimit", cdk.validateNumber)(properties.throttlingRateLimit));
  return errors.wrap("supplied properties not correct for \\"RouteSettingsProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiRouteSettingsPropertyValidator(properties).assertSuccess();
  return {
    "DataTraceEnabled": cdk.booleanToCloudFormation(properties.dataTraceEnabled),
    "DetailedMetricsEnabled": cdk.booleanToCloudFormation(properties.detailedMetricsEnabled),
    "LoggingLevel": cdk.stringToCloudFormation(properties.loggingLevel),
    "ThrottlingBurstLimit": cdk.numberToCloudFormation(properties.throttlingBurstLimit),
    "ThrottlingRateLimit": cdk.numberToCloudFormation(properties.throttlingRateLimit)
  };
}

// @ts-ignore TS6133
function CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnHttpApi.RouteSettingsProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.RouteSettingsProperty>();
  ret.addPropertyResult("dataTraceEnabled", "DataTraceEnabled", (properties.DataTraceEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DataTraceEnabled) : undefined));
  ret.addPropertyResult("detailedMetricsEnabled", "DetailedMetricsEnabled", (properties.DetailedMetricsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DetailedMetricsEnabled) : undefined));
  ret.addPropertyResult("loggingLevel", "LoggingLevel", (properties.LoggingLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LoggingLevel) : undefined));
  ret.addPropertyResult("throttlingBurstLimit", "ThrottlingBurstLimit", (properties.ThrottlingBurstLimit != null ? cfn_parse.FromCloudFormation.getNumber(properties.ThrottlingBurstLimit) : undefined));
  ret.addPropertyResult("throttlingRateLimit", "ThrottlingRateLimit", (properties.ThrottlingRateLimit != null ? cfn_parse.FromCloudFormation.getNumber(properties.ThrottlingRateLimit) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DefinitionUriProperty\`
 *
 * @param properties - the TypeScript properties of a \`DefinitionUriProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiDefinitionUriPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateNumber)(properties.version));
  return errors.wrap("supplied properties not correct for \\"DefinitionUriProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiDefinitionUriPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiDefinitionUriPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "Key": cdk.stringToCloudFormation(properties.key),
    "Version": cdk.numberToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnHttpApiDefinitionUriPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.DefinitionUriProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.DefinitionUriProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getNumber(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MutualTlsAuthenticationProperty\`
 *
 * @param properties - the TypeScript properties of a \`MutualTlsAuthenticationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiMutualTlsAuthenticationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("truststoreUri", cdk.validateString)(properties.truststoreUri));
  errors.collect(cdk.propertyValidator("truststoreVersion", cdk.validateBoolean)(properties.truststoreVersion));
  return errors.wrap("supplied properties not correct for \\"MutualTlsAuthenticationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiMutualTlsAuthenticationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiMutualTlsAuthenticationPropertyValidator(properties).assertSuccess();
  return {
    "TruststoreUri": cdk.stringToCloudFormation(properties.truststoreUri),
    "TruststoreVersion": cdk.booleanToCloudFormation(properties.truststoreVersion)
  };
}

// @ts-ignore TS6133
function CfnHttpApiMutualTlsAuthenticationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnHttpApi.MutualTlsAuthenticationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.MutualTlsAuthenticationProperty>();
  ret.addPropertyResult("truststoreUri", "TruststoreUri", (properties.TruststoreUri != null ? cfn_parse.FromCloudFormation.getString(properties.TruststoreUri) : undefined));
  ret.addPropertyResult("truststoreVersion", "TruststoreVersion", (properties.TruststoreVersion != null ? cfn_parse.FromCloudFormation.getBoolean(properties.TruststoreVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`Route53ConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`Route53ConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiRoute53ConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("distributedDomainName", cdk.validateString)(properties.distributedDomainName));
  errors.collect(cdk.propertyValidator("evaluateTargetHealth", cdk.validateBoolean)(properties.evaluateTargetHealth));
  errors.collect(cdk.propertyValidator("hostedZoneId", cdk.validateString)(properties.hostedZoneId));
  errors.collect(cdk.propertyValidator("hostedZoneName", cdk.validateString)(properties.hostedZoneName));
  errors.collect(cdk.propertyValidator("ipV6", cdk.validateBoolean)(properties.ipV6));
  return errors.wrap("supplied properties not correct for \\"Route53ConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiRoute53ConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiRoute53ConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "DistributedDomainName": cdk.stringToCloudFormation(properties.distributedDomainName),
    "EvaluateTargetHealth": cdk.booleanToCloudFormation(properties.evaluateTargetHealth),
    "HostedZoneId": cdk.stringToCloudFormation(properties.hostedZoneId),
    "HostedZoneName": cdk.stringToCloudFormation(properties.hostedZoneName),
    "IpV6": cdk.booleanToCloudFormation(properties.ipV6)
  };
}

// @ts-ignore TS6133
function CfnHttpApiRoute53ConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnHttpApi.Route53ConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.Route53ConfigurationProperty>();
  ret.addPropertyResult("distributedDomainName", "DistributedDomainName", (properties.DistributedDomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DistributedDomainName) : undefined));
  ret.addPropertyResult("evaluateTargetHealth", "EvaluateTargetHealth", (properties.EvaluateTargetHealth != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EvaluateTargetHealth) : undefined));
  ret.addPropertyResult("hostedZoneId", "HostedZoneId", (properties.HostedZoneId != null ? cfn_parse.FromCloudFormation.getString(properties.HostedZoneId) : undefined));
  ret.addPropertyResult("hostedZoneName", "HostedZoneName", (properties.HostedZoneName != null ? cfn_parse.FromCloudFormation.getString(properties.HostedZoneName) : undefined));
  ret.addPropertyResult("ipV6", "IpV6", (properties.IpV6 != null ? cfn_parse.FromCloudFormation.getBoolean(properties.IpV6) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`HttpApiDomainConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`HttpApiDomainConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiHttpApiDomainConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("basePath", cdk.validateString)(properties.basePath));
  errors.collect(cdk.propertyValidator("certificateArn", cdk.requiredValidator)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("certificateArn", cdk.validateString)(properties.certificateArn));
  errors.collect(cdk.propertyValidator("domainName", cdk.requiredValidator)(properties.domainName));
  errors.collect(cdk.propertyValidator("domainName", cdk.validateString)(properties.domainName));
  errors.collect(cdk.propertyValidator("endpointConfiguration", cdk.validateString)(properties.endpointConfiguration));
  errors.collect(cdk.propertyValidator("mutualTlsAuthentication", CfnHttpApiMutualTlsAuthenticationPropertyValidator)(properties.mutualTlsAuthentication));
  errors.collect(cdk.propertyValidator("route53", CfnHttpApiRoute53ConfigurationPropertyValidator)(properties.route53));
  errors.collect(cdk.propertyValidator("securityPolicy", cdk.validateString)(properties.securityPolicy));
  return errors.wrap("supplied properties not correct for \\"HttpApiDomainConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiHttpApiDomainConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiHttpApiDomainConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "BasePath": cdk.stringToCloudFormation(properties.basePath),
    "CertificateArn": cdk.stringToCloudFormation(properties.certificateArn),
    "DomainName": cdk.stringToCloudFormation(properties.domainName),
    "EndpointConfiguration": cdk.stringToCloudFormation(properties.endpointConfiguration),
    "MutualTlsAuthentication": convertCfnHttpApiMutualTlsAuthenticationPropertyToCloudFormation(properties.mutualTlsAuthentication),
    "Route53": convertCfnHttpApiRoute53ConfigurationPropertyToCloudFormation(properties.route53),
    "SecurityPolicy": cdk.stringToCloudFormation(properties.securityPolicy)
  };
}

// @ts-ignore TS6133
function CfnHttpApiHttpApiDomainConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApi.HttpApiDomainConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApi.HttpApiDomainConfigurationProperty>();
  ret.addPropertyResult("basePath", "BasePath", (properties.BasePath != null ? cfn_parse.FromCloudFormation.getString(properties.BasePath) : undefined));
  ret.addPropertyResult("certificateArn", "CertificateArn", (properties.CertificateArn != null ? cfn_parse.FromCloudFormation.getString(properties.CertificateArn) : undefined));
  ret.addPropertyResult("domainName", "DomainName", (properties.DomainName != null ? cfn_parse.FromCloudFormation.getString(properties.DomainName) : undefined));
  ret.addPropertyResult("endpointConfiguration", "EndpointConfiguration", (properties.EndpointConfiguration != null ? cfn_parse.FromCloudFormation.getString(properties.EndpointConfiguration) : undefined));
  ret.addPropertyResult("mutualTlsAuthentication", "MutualTlsAuthentication", (properties.MutualTlsAuthentication != null ? CfnHttpApiMutualTlsAuthenticationPropertyFromCloudFormation(properties.MutualTlsAuthentication) : undefined));
  ret.addPropertyResult("route53", "Route53", (properties.Route53 != null ? CfnHttpApiRoute53ConfigurationPropertyFromCloudFormation(properties.Route53) : undefined));
  ret.addPropertyResult("securityPolicy", "SecurityPolicy", (properties.SecurityPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.SecurityPolicy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnHttpApiProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnHttpApiProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnHttpApiPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("accessLogSetting", CfnHttpApiAccessLogSettingPropertyValidator)(properties.accessLogSetting));
  errors.collect(cdk.propertyValidator("auth", CfnHttpApiHttpApiAuthPropertyValidator)(properties.auth));
  errors.collect(cdk.propertyValidator("corsConfiguration", cdk.unionValidator(cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator))(properties.corsConfiguration));
  errors.collect(cdk.propertyValidator("defaultRouteSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.defaultRouteSettings));
  errors.collect(cdk.propertyValidator("definitionBody", cdk.validateObject)(properties.definitionBody));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("disableExecuteApiEndpoint", cdk.validateBoolean)(properties.disableExecuteApiEndpoint));
  errors.collect(cdk.propertyValidator("domain", CfnHttpApiHttpApiDomainConfigurationPropertyValidator)(properties.domain));
  errors.collect(cdk.propertyValidator("failOnWarnings", cdk.validateBoolean)(properties.failOnWarnings));
  errors.collect(cdk.propertyValidator("routeSettings", CfnHttpApiRouteSettingsPropertyValidator)(properties.routeSettings));
  errors.collect(cdk.propertyValidator("stageName", cdk.validateString)(properties.stageName));
  errors.collect(cdk.propertyValidator("stageVariables", cdk.hashValidator(cdk.validateObject))(properties.stageVariables));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.hashValidator(cdk.validateString)))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnHttpApiProps\\"");
}

// @ts-ignore TS6133
function convertCfnHttpApiPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnHttpApiPropsValidator(properties).assertSuccess();
  return {
    "AccessLogSetting": convertCfnHttpApiAccessLogSettingPropertyToCloudFormation(properties.accessLogSetting),
    "Auth": convertCfnHttpApiHttpApiAuthPropertyToCloudFormation(properties.auth),
    "CorsConfiguration": cdk.unionMapper([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cdk.booleanToCloudFormation, convertCfnHttpApiCorsConfigurationPropertyToCloudFormation])(properties.corsConfiguration),
    "DefaultRouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.defaultRouteSettings),
    "DefinitionBody": cdk.objectToCloudFormation(properties.definitionBody),
    "DefinitionUri": cdk.unionMapper([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [convertCfnHttpApiDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "DisableExecuteApiEndpoint": cdk.booleanToCloudFormation(properties.disableExecuteApiEndpoint),
    "Domain": convertCfnHttpApiHttpApiDomainConfigurationPropertyToCloudFormation(properties.domain),
    "FailOnWarnings": cdk.booleanToCloudFormation(properties.failOnWarnings),
    "RouteSettings": convertCfnHttpApiRouteSettingsPropertyToCloudFormation(properties.routeSettings),
    "StageName": cdk.stringToCloudFormation(properties.stageName),
    "StageVariables": cdk.hashMapper(cdk.objectToCloudFormation)(properties.stageVariables),
    "Tags": cdk.listMapper(cdk.hashMapper(cdk.stringToCloudFormation))(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnHttpApiPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnHttpApiProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnHttpApiProps>();
  ret.addPropertyResult("accessLogSetting", "AccessLogSetting", (properties.AccessLogSetting != null ? CfnHttpApiAccessLogSettingPropertyFromCloudFormation(properties.AccessLogSetting) : undefined));
  ret.addPropertyResult("auth", "Auth", (properties.Auth != null ? CfnHttpApiHttpApiAuthPropertyFromCloudFormation(properties.Auth) : undefined));
  ret.addPropertyResult("corsConfiguration", "CorsConfiguration", (properties.CorsConfiguration != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateBoolean, CfnHttpApiCorsConfigurationPropertyValidator], [cfn_parse.FromCloudFormation.getBoolean, CfnHttpApiCorsConfigurationPropertyFromCloudFormation])(properties.CorsConfiguration) : undefined));
  ret.addPropertyResult("defaultRouteSettings", "DefaultRouteSettings", (properties.DefaultRouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.DefaultRouteSettings) : undefined));
  ret.addPropertyResult("definitionBody", "DefinitionBody", (properties.DefinitionBody != null ? cfn_parse.FromCloudFormation.getAny(properties.DefinitionBody) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnHttpApiDefinitionUriPropertyValidator, cdk.validateString], [CfnHttpApiDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("disableExecuteApiEndpoint", "DisableExecuteApiEndpoint", (properties.DisableExecuteApiEndpoint != null ? cfn_parse.FromCloudFormation.getBoolean(properties.DisableExecuteApiEndpoint) : undefined));
  ret.addPropertyResult("domain", "Domain", (properties.Domain != null ? CfnHttpApiHttpApiDomainConfigurationPropertyFromCloudFormation(properties.Domain) : undefined));
  ret.addPropertyResult("failOnWarnings", "FailOnWarnings", (properties.FailOnWarnings != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FailOnWarnings) : undefined));
  ret.addPropertyResult("routeSettings", "RouteSettings", (properties.RouteSettings != null ? CfnHttpApiRouteSettingsPropertyFromCloudFormation(properties.RouteSettings) : undefined));
  ret.addPropertyResult("stageName", "StageName", (properties.StageName != null ? cfn_parse.FromCloudFormation.getString(properties.StageName) : undefined));
  ret.addPropertyResult("stageVariables", "StageVariables", (properties.StageVariables != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.StageVariables) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString))(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::LayerVersion.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html
 */
export class CfnLayerVersion extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::LayerVersion";

  /**
   * Build a CfnLayerVersion from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnLayerVersion {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnLayerVersionPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnLayerVersion(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public compatibleRuntimes?: Array<string>;

  public contentUri?: CfnLayerVersion.ContentUriProperty | cdk.IResolvable | string;

  public description?: string;

  public layerName?: string;

  public licenseInfo?: string;

  public retentionPolicy?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnLayerVersionProps = {}) {
    super(scope, id, {
      "type": CfnLayerVersion.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.compatibleRuntimes = props.compatibleRuntimes;
    this.contentUri = props.contentUri;
    this.description = props.description;
    this.layerName = props.layerName;
    this.licenseInfo = props.licenseInfo;
    this.retentionPolicy = props.retentionPolicy;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "compatibleRuntimes": this.compatibleRuntimes,
      "contentUri": this.contentUri,
      "description": this.description,
      "layerName": this.layerName,
      "licenseInfo": this.licenseInfo,
      "retentionPolicy": this.retentionPolicy
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnLayerVersion.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnLayerVersionPropsToCloudFormation(props);
  }
}

export namespace CfnLayerVersion {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-contenturi.html
   */
  export interface ContentUriProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-contenturi.html#cfn-serverless-layerversion-contenturi-bucket
     */
    readonly bucket: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-contenturi.html#cfn-serverless-layerversion-contenturi-key
     */
    readonly key: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-layerversion-contenturi.html#cfn-serverless-layerversion-contenturi-version
     */
    readonly version?: number;
  }
}

/**
 * Properties for defining a \`CfnLayerVersion\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html
 */
export interface CfnLayerVersionProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-compatibleruntimes
   */
  readonly compatibleRuntimes?: Array<string>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-contenturi
   */
  readonly contentUri?: CfnLayerVersion.ContentUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-description
   */
  readonly description?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-layername
   */
  readonly layerName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-licenseinfo
   */
  readonly licenseInfo?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-layerversion.html#cfn-serverless-layerversion-retentionpolicy
   */
  readonly retentionPolicy?: string;
}

/**
 * Determine whether the given properties match those of a \`ContentUriProperty\`
 *
 * @param properties - the TypeScript properties of a \`ContentUriProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLayerVersionContentUriPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("version", cdk.validateNumber)(properties.version));
  return errors.wrap("supplied properties not correct for \\"ContentUriProperty\\"");
}

// @ts-ignore TS6133
function convertCfnLayerVersionContentUriPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLayerVersionContentUriPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "Key": cdk.stringToCloudFormation(properties.key),
    "Version": cdk.numberToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnLayerVersionContentUriPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLayerVersion.ContentUriProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLayerVersion.ContentUriProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getNumber(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnLayerVersionProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnLayerVersionProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnLayerVersionPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("compatibleRuntimes", cdk.listValidator(cdk.validateString))(properties.compatibleRuntimes));
  errors.collect(cdk.propertyValidator("contentUri", cdk.unionValidator(CfnLayerVersionContentUriPropertyValidator, cdk.validateString))(properties.contentUri));
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("layerName", cdk.validateString)(properties.layerName));
  errors.collect(cdk.propertyValidator("licenseInfo", cdk.validateString)(properties.licenseInfo));
  errors.collect(cdk.propertyValidator("retentionPolicy", cdk.validateString)(properties.retentionPolicy));
  return errors.wrap("supplied properties not correct for \\"CfnLayerVersionProps\\"");
}

// @ts-ignore TS6133
function convertCfnLayerVersionPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnLayerVersionPropsValidator(properties).assertSuccess();
  return {
    "CompatibleRuntimes": cdk.listMapper(cdk.stringToCloudFormation)(properties.compatibleRuntimes),
    "ContentUri": cdk.unionMapper([CfnLayerVersionContentUriPropertyValidator, cdk.validateString], [convertCfnLayerVersionContentUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.contentUri),
    "Description": cdk.stringToCloudFormation(properties.description),
    "LayerName": cdk.stringToCloudFormation(properties.layerName),
    "LicenseInfo": cdk.stringToCloudFormation(properties.licenseInfo),
    "RetentionPolicy": cdk.stringToCloudFormation(properties.retentionPolicy)
  };
}

// @ts-ignore TS6133
function CfnLayerVersionPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnLayerVersionProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnLayerVersionProps>();
  ret.addPropertyResult("compatibleRuntimes", "CompatibleRuntimes", (properties.CompatibleRuntimes != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.CompatibleRuntimes) : undefined));
  ret.addPropertyResult("contentUri", "ContentUri", (properties.ContentUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnLayerVersionContentUriPropertyValidator, cdk.validateString], [CfnLayerVersionContentUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.ContentUri) : undefined));
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("layerName", "LayerName", (properties.LayerName != null ? cfn_parse.FromCloudFormation.getString(properties.LayerName) : undefined));
  ret.addPropertyResult("licenseInfo", "LicenseInfo", (properties.LicenseInfo != null ? cfn_parse.FromCloudFormation.getString(properties.LicenseInfo) : undefined));
  ret.addPropertyResult("retentionPolicy", "RetentionPolicy", (properties.RetentionPolicy != null ? cfn_parse.FromCloudFormation.getString(properties.RetentionPolicy) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::SimpleTable.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html
 */
export class CfnSimpleTable extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::SimpleTable";

  /**
   * Build a CfnSimpleTable from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSimpleTable {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSimpleTablePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSimpleTable(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public primaryKey?: cdk.IResolvable | CfnSimpleTable.PrimaryKeyProperty;

  public provisionedThroughput?: cdk.IResolvable | CfnSimpleTable.ProvisionedThroughputProperty;

  public sseSpecification?: cdk.IResolvable | CfnSimpleTable.SSESpecificationProperty;

  public tableName?: string;

  public readonly tags: cdk.TagManager;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnSimpleTableProps = {}) {
    super(scope, id, {
      "type": CfnSimpleTable.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.primaryKey = props.primaryKey;
    this.provisionedThroughput = props.provisionedThroughput;
    this.sseSpecification = props.sseSpecification;
    this.tableName = props.tableName;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Serverless::SimpleTable", props.tags, {
      "tagPropertyName": "tags"
    });
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "primaryKey": this.primaryKey,
      "provisionedThroughput": this.provisionedThroughput,
      "sseSpecification": this.sseSpecification,
      "tableName": this.tableName,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSimpleTable.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSimpleTablePropsToCloudFormation(props);
  }
}

export namespace CfnSimpleTable {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-primarykey.html
   */
  export interface PrimaryKeyProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-primarykey.html#cfn-serverless-simpletable-primarykey-name
     */
    readonly name?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-primarykey.html#cfn-serverless-simpletable-primarykey-type
     */
    readonly type: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-provisionedthroughput.html
   */
  export interface ProvisionedThroughputProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-provisionedthroughput.html#cfn-serverless-simpletable-provisionedthroughput-readcapacityunits
     */
    readonly readCapacityUnits?: number;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-provisionedthroughput.html#cfn-serverless-simpletable-provisionedthroughput-writecapacityunits
     */
    readonly writeCapacityUnits: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-ssespecification.html
   */
  export interface SSESpecificationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-simpletable-ssespecification.html#cfn-serverless-simpletable-ssespecification-sseenabled
     */
    readonly sseEnabled?: boolean | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnSimpleTable\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html
 */
export interface CfnSimpleTableProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-primarykey
   */
  readonly primaryKey?: cdk.IResolvable | CfnSimpleTable.PrimaryKeyProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-provisionedthroughput
   */
  readonly provisionedThroughput?: cdk.IResolvable | CfnSimpleTable.ProvisionedThroughputProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-ssespecification
   */
  readonly sseSpecification?: cdk.IResolvable | CfnSimpleTable.SSESpecificationProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-tablename
   */
  readonly tableName?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-simpletable.html#cfn-serverless-simpletable-tags
   */
  readonly tags?: Array<cdk.IResolvable | Record<string, string>> | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`PrimaryKeyProperty\`
 *
 * @param properties - the TypeScript properties of a \`PrimaryKeyProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSimpleTablePrimaryKeyPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"PrimaryKeyProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSimpleTablePrimaryKeyPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSimpleTablePrimaryKeyPropertyValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnSimpleTablePrimaryKeyPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSimpleTable.PrimaryKeyProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSimpleTable.PrimaryKeyProperty>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ProvisionedThroughputProperty\`
 *
 * @param properties - the TypeScript properties of a \`ProvisionedThroughputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSimpleTableProvisionedThroughputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("readCapacityUnits", cdk.validateNumber)(properties.readCapacityUnits));
  errors.collect(cdk.propertyValidator("writeCapacityUnits", cdk.requiredValidator)(properties.writeCapacityUnits));
  errors.collect(cdk.propertyValidator("writeCapacityUnits", cdk.validateNumber)(properties.writeCapacityUnits));
  return errors.wrap("supplied properties not correct for \\"ProvisionedThroughputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSimpleTableProvisionedThroughputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSimpleTableProvisionedThroughputPropertyValidator(properties).assertSuccess();
  return {
    "ReadCapacityUnits": cdk.numberToCloudFormation(properties.readCapacityUnits),
    "WriteCapacityUnits": cdk.numberToCloudFormation(properties.writeCapacityUnits)
  };
}

// @ts-ignore TS6133
function CfnSimpleTableProvisionedThroughputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSimpleTable.ProvisionedThroughputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSimpleTable.ProvisionedThroughputProperty>();
  ret.addPropertyResult("readCapacityUnits", "ReadCapacityUnits", (properties.ReadCapacityUnits != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReadCapacityUnits) : undefined));
  ret.addPropertyResult("writeCapacityUnits", "WriteCapacityUnits", (properties.WriteCapacityUnits != null ? cfn_parse.FromCloudFormation.getNumber(properties.WriteCapacityUnits) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SSESpecificationProperty\`
 *
 * @param properties - the TypeScript properties of a \`SSESpecificationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSimpleTableSSESpecificationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("sseEnabled", cdk.validateBoolean)(properties.sseEnabled));
  return errors.wrap("supplied properties not correct for \\"SSESpecificationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSimpleTableSSESpecificationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSimpleTableSSESpecificationPropertyValidator(properties).assertSuccess();
  return {
    "SSEEnabled": cdk.booleanToCloudFormation(properties.sseEnabled)
  };
}

// @ts-ignore TS6133
function CfnSimpleTableSSESpecificationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSimpleTable.SSESpecificationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSimpleTable.SSESpecificationProperty>();
  ret.addPropertyResult("sseEnabled", "SSEEnabled", (properties.SSEEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SSEEnabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnSimpleTableProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnSimpleTableProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSimpleTablePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("primaryKey", CfnSimpleTablePrimaryKeyPropertyValidator)(properties.primaryKey));
  errors.collect(cdk.propertyValidator("provisionedThroughput", CfnSimpleTableProvisionedThroughputPropertyValidator)(properties.provisionedThroughput));
  errors.collect(cdk.propertyValidator("sseSpecification", CfnSimpleTableSSESpecificationPropertyValidator)(properties.sseSpecification));
  errors.collect(cdk.propertyValidator("tableName", cdk.validateString)(properties.tableName));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.hashValidator(cdk.validateString)))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnSimpleTableProps\\"");
}

// @ts-ignore TS6133
function convertCfnSimpleTablePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSimpleTablePropsValidator(properties).assertSuccess();
  return {
    "PrimaryKey": convertCfnSimpleTablePrimaryKeyPropertyToCloudFormation(properties.primaryKey),
    "ProvisionedThroughput": convertCfnSimpleTableProvisionedThroughputPropertyToCloudFormation(properties.provisionedThroughput),
    "SSESpecification": convertCfnSimpleTableSSESpecificationPropertyToCloudFormation(properties.sseSpecification),
    "TableName": cdk.stringToCloudFormation(properties.tableName),
    "Tags": cdk.listMapper(cdk.hashMapper(cdk.stringToCloudFormation))(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnSimpleTablePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSimpleTableProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSimpleTableProps>();
  ret.addPropertyResult("primaryKey", "PrimaryKey", (properties.PrimaryKey != null ? CfnSimpleTablePrimaryKeyPropertyFromCloudFormation(properties.PrimaryKey) : undefined));
  ret.addPropertyResult("provisionedThroughput", "ProvisionedThroughput", (properties.ProvisionedThroughput != null ? CfnSimpleTableProvisionedThroughputPropertyFromCloudFormation(properties.ProvisionedThroughput) : undefined));
  ret.addPropertyResult("sseSpecification", "SSESpecification", (properties.SSESpecification != null ? CfnSimpleTableSSESpecificationPropertyFromCloudFormation(properties.SSESpecification) : undefined));
  ret.addPropertyResult("tableName", "TableName", (properties.TableName != null ? cfn_parse.FromCloudFormation.getString(properties.TableName) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString))(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Definition of AWS::Serverless::StateMachine.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html
 */
export class CfnStateMachine extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Serverless::StateMachine";

  /**
   * Build a CfnStateMachine from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnStateMachine {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnStateMachinePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnStateMachine(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  public definition?: any | cdk.IResolvable;

  public definitionSubstitutions?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  public definitionUri?: CfnStateMachine.DefinitionUriProperty | cdk.IResolvable | string;

  public events?: cdk.IResolvable | Record<string, CfnStateMachine.EventSourceProperty | cdk.IResolvable>;

  public logging?: cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty;

  public name?: string;

  public permissionsBoundaries?: string;

  public policies?: Array<CfnStateMachine.PoliciesProperty | CfnStateMachine.PoliciesProperty | string> | cdk.IResolvable | CfnStateMachine.PoliciesProperty | string;

  public role?: string;

  public readonly tags: cdk.TagManager;

  public tracing?: cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty;

  public type?: string;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnStateMachineProps = {}) {
    super(scope, id, {
      "type": CfnStateMachine.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.definition = props.definition;
    this.definitionSubstitutions = props.definitionSubstitutions;
    this.definitionUri = props.definitionUri;
    this.events = props.events;
    this.logging = props.logging;
    this.name = props.name;
    this.permissionsBoundaries = props.permissionsBoundaries;
    this.policies = props.policies;
    this.role = props.role;
    this.tags = new cdk.TagManager(cdk.TagType.MAP, "AWS::Serverless::StateMachine", props.tags, {
      "tagPropertyName": "tags"
    });
    this.tracing = props.tracing;
    this.type = props.type;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "definition": this.definition,
      "definitionSubstitutions": this.definitionSubstitutions,
      "definitionUri": this.definitionUri,
      "events": this.events,
      "logging": this.logging,
      "name": this.name,
      "permissionsBoundaries": this.permissionsBoundaries,
      "policies": this.policies,
      "role": this.role,
      "tags": this.tags.renderTags(),
      "tracing": this.tracing,
      "type": this.type
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnStateMachine.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnStateMachinePropsToCloudFormation(props);
  }
}

export namespace CfnStateMachine {
  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html
   */
  export interface DefinitionUriProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-bucket
     */
    readonly bucket: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-key
     */
    readonly key: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-definitionuri.html#cfn-serverless-statemachine-definitionuri-version
     */
    readonly version?: number;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html
   */
  export interface EventSourceProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-properties
     */
    readonly properties: cdk.IResolvable | CfnStateMachine.PropertiesProperty | CfnStateMachine.PropertiesProperty | CfnStateMachine.PropertiesProperty | CfnStateMachine.PropertiesProperty;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-eventsource.html#cfn-serverless-statemachine-eventsource-type
     */
    readonly type: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-properties.html
   */
  export interface PropertiesProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-properties.html#cfn-serverless-statemachine-properties-eventbusname
     */
    readonly eventBusName?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-properties.html#cfn-serverless-statemachine-properties-input
     */
    readonly input?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-properties.html#cfn-serverless-statemachine-properties-inputpath
     */
    readonly inputPath?: string;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-properties.html#cfn-serverless-statemachine-properties-pattern
     */
    readonly pattern: any | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html
   */
  export interface LoggingConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-destinations
     */
    readonly destinations: Array<cdk.IResolvable | CfnStateMachine.LogDestinationProperty> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-includeexecutiondata
     */
    readonly includeExecutionData: boolean | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-loggingconfiguration.html#cfn-serverless-statemachine-loggingconfiguration-level
     */
    readonly level: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-logdestination.html
   */
  export interface LogDestinationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-logdestination.html#cfn-serverless-statemachine-logdestination-cloudwatchlogsloggroup
     */
    readonly cloudWatchLogsLogGroup: CfnStateMachine.CloudWatchLogsLogGroupProperty | cdk.IResolvable;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-cloudwatchlogsloggroup.html
   */
  export interface CloudWatchLogsLogGroupProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-cloudwatchlogsloggroup.html#cfn-serverless-statemachine-cloudwatchlogsloggroup-loggrouparn
     */
    readonly logGroupArn: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html
   */
  export interface PoliciesProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-statement
     */
    readonly statement: Array<any | cdk.IResolvable> | cdk.IResolvable;

    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-policies.html#cfn-serverless-statemachine-policies-version
     */
    readonly version: string;
  }

  /**
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html
   */
  export interface TracingConfigurationProperty {
    /**
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-serverless-statemachine-tracingconfiguration.html#cfn-serverless-statemachine-tracingconfiguration-enabled
     */
    readonly enabled?: boolean | cdk.IResolvable;
  }
}

/**
 * Properties for defining a \`CfnStateMachine\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html
 */
export interface CfnStateMachineProps {
  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-definition
   */
  readonly definition?: any | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-definitionsubstitutions
   */
  readonly definitionSubstitutions?: cdk.IResolvable | Record<string, any | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-definitionuri
   */
  readonly definitionUri?: CfnStateMachine.DefinitionUriProperty | cdk.IResolvable | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-events
   */
  readonly events?: cdk.IResolvable | Record<string, CfnStateMachine.EventSourceProperty | cdk.IResolvable>;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-logging
   */
  readonly logging?: cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-name
   */
  readonly name?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-permissionsboundaries
   */
  readonly permissionsBoundaries?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-policies
   */
  readonly policies?: Array<CfnStateMachine.PoliciesProperty | CfnStateMachine.PoliciesProperty | string> | cdk.IResolvable | CfnStateMachine.PoliciesProperty | string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-role
   */
  readonly role?: string;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-tags
   */
  readonly tags?: Array<cdk.IResolvable | Record<string, string>> | cdk.IResolvable;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-tracing
   */
  readonly tracing?: cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty;

  /**
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-serverless-statemachine.html#cfn-serverless-statemachine-type
   */
  readonly type?: string;
}

/**
 * Determine whether the given properties match those of a \`DefinitionUriProperty\`
 *
 * @param properties - the TypeScript properties of a \`DefinitionUriProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineDefinitionUriPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucket", cdk.requiredValidator)(properties.bucket));
  errors.collect(cdk.propertyValidator("bucket", cdk.validateString)(properties.bucket));
  errors.collect(cdk.propertyValidator("key", cdk.requiredValidator)(properties.key));
  errors.collect(cdk.propertyValidator("key", cdk.validateString)(properties.key));
  errors.collect(cdk.propertyValidator("version", cdk.validateNumber)(properties.version));
  return errors.wrap("supplied properties not correct for \\"DefinitionUriProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineDefinitionUriPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineDefinitionUriPropertyValidator(properties).assertSuccess();
  return {
    "Bucket": cdk.stringToCloudFormation(properties.bucket),
    "Key": cdk.stringToCloudFormation(properties.key),
    "Version": cdk.numberToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnStateMachineDefinitionUriPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachine.DefinitionUriProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.DefinitionUriProperty>();
  ret.addPropertyResult("bucket", "Bucket", (properties.Bucket != null ? cfn_parse.FromCloudFormation.getString(properties.Bucket) : undefined));
  ret.addPropertyResult("key", "Key", (properties.Key != null ? cfn_parse.FromCloudFormation.getString(properties.Key) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getNumber(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PropertiesProperty\`
 *
 * @param properties - the TypeScript properties of a \`PropertiesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachinePropertiesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("eventBusName", cdk.validateString)(properties.eventBusName));
  errors.collect(cdk.propertyValidator("input", cdk.validateString)(properties.input));
  errors.collect(cdk.propertyValidator("inputPath", cdk.validateString)(properties.inputPath));
  errors.collect(cdk.propertyValidator("pattern", cdk.requiredValidator)(properties.pattern));
  errors.collect(cdk.propertyValidator("pattern", cdk.validateObject)(properties.pattern));
  return errors.wrap("supplied properties not correct for \\"PropertiesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachinePropertiesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachinePropertiesPropertyValidator(properties).assertSuccess();
  return {
    "EventBusName": cdk.stringToCloudFormation(properties.eventBusName),
    "Input": cdk.stringToCloudFormation(properties.input),
    "InputPath": cdk.stringToCloudFormation(properties.inputPath),
    "Pattern": cdk.objectToCloudFormation(properties.pattern)
  };
}

// @ts-ignore TS6133
function CfnStateMachinePropertiesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.PropertiesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.PropertiesProperty>();
  ret.addPropertyResult("eventBusName", "EventBusName", (properties.EventBusName != null ? cfn_parse.FromCloudFormation.getString(properties.EventBusName) : undefined));
  ret.addPropertyResult("input", "Input", (properties.Input != null ? cfn_parse.FromCloudFormation.getString(properties.Input) : undefined));
  ret.addPropertyResult("inputPath", "InputPath", (properties.InputPath != null ? cfn_parse.FromCloudFormation.getString(properties.InputPath) : undefined));
  ret.addPropertyResult("pattern", "Pattern", (properties.Pattern != null ? cfn_parse.FromCloudFormation.getAny(properties.Pattern) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventSourceProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventSourceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineEventSourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("properties", cdk.requiredValidator)(properties.properties));
  errors.collect(cdk.propertyValidator("properties", cdk.unionValidator(CfnStateMachinePropertiesPropertyValidator, CfnStateMachinePropertiesPropertyValidator, CfnStateMachinePropertiesPropertyValidator, CfnStateMachinePropertiesPropertyValidator))(properties.properties));
  errors.collect(cdk.propertyValidator("type", cdk.requiredValidator)(properties.type));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"EventSourceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineEventSourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineEventSourcePropertyValidator(properties).assertSuccess();
  return {
    "Properties": cdk.unionMapper([CfnStateMachinePropertiesPropertyValidator, CfnStateMachinePropertiesPropertyValidator, CfnStateMachinePropertiesPropertyValidator, CfnStateMachinePropertiesPropertyValidator], [convertCfnStateMachinePropertiesPropertyToCloudFormation, convertCfnStateMachinePropertiesPropertyToCloudFormation, convertCfnStateMachinePropertiesPropertyToCloudFormation, convertCfnStateMachinePropertiesPropertyToCloudFormation])(properties.properties),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnStateMachineEventSourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachine.EventSourceProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.EventSourceProperty>();
  ret.addPropertyResult("properties", "Properties", (properties.Properties != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachinePropertiesPropertyValidator, CfnStateMachinePropertiesPropertyValidator, CfnStateMachinePropertiesPropertyValidator, CfnStateMachinePropertiesPropertyValidator], [CfnStateMachinePropertiesPropertyFromCloudFormation, CfnStateMachinePropertiesPropertyFromCloudFormation, CfnStateMachinePropertiesPropertyFromCloudFormation, CfnStateMachinePropertiesPropertyFromCloudFormation])(properties.Properties) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CloudWatchLogsLogGroupProperty\`
 *
 * @param properties - the TypeScript properties of a \`CloudWatchLogsLogGroupProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineCloudWatchLogsLogGroupPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("logGroupArn", cdk.requiredValidator)(properties.logGroupArn));
  errors.collect(cdk.propertyValidator("logGroupArn", cdk.validateString)(properties.logGroupArn));
  return errors.wrap("supplied properties not correct for \\"CloudWatchLogsLogGroupProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineCloudWatchLogsLogGroupPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineCloudWatchLogsLogGroupPropertyValidator(properties).assertSuccess();
  return {
    "LogGroupArn": cdk.stringToCloudFormation(properties.logGroupArn)
  };
}

// @ts-ignore TS6133
function CfnStateMachineCloudWatchLogsLogGroupPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachine.CloudWatchLogsLogGroupProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.CloudWatchLogsLogGroupProperty>();
  ret.addPropertyResult("logGroupArn", "LogGroupArn", (properties.LogGroupArn != null ? cfn_parse.FromCloudFormation.getString(properties.LogGroupArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LogDestinationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LogDestinationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineLogDestinationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("cloudWatchLogsLogGroup", cdk.requiredValidator)(properties.cloudWatchLogsLogGroup));
  errors.collect(cdk.propertyValidator("cloudWatchLogsLogGroup", CfnStateMachineCloudWatchLogsLogGroupPropertyValidator)(properties.cloudWatchLogsLogGroup));
  return errors.wrap("supplied properties not correct for \\"LogDestinationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineLogDestinationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineLogDestinationPropertyValidator(properties).assertSuccess();
  return {
    "CloudWatchLogsLogGroup": convertCfnStateMachineCloudWatchLogsLogGroupPropertyToCloudFormation(properties.cloudWatchLogsLogGroup)
  };
}

// @ts-ignore TS6133
function CfnStateMachineLogDestinationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.LogDestinationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.LogDestinationProperty>();
  ret.addPropertyResult("cloudWatchLogsLogGroup", "CloudWatchLogsLogGroup", (properties.CloudWatchLogsLogGroup != null ? CfnStateMachineCloudWatchLogsLogGroupPropertyFromCloudFormation(properties.CloudWatchLogsLogGroup) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LoggingConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`LoggingConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineLoggingConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinations", cdk.requiredValidator)(properties.destinations));
  errors.collect(cdk.propertyValidator("destinations", cdk.listValidator(CfnStateMachineLogDestinationPropertyValidator))(properties.destinations));
  errors.collect(cdk.propertyValidator("includeExecutionData", cdk.requiredValidator)(properties.includeExecutionData));
  errors.collect(cdk.propertyValidator("includeExecutionData", cdk.validateBoolean)(properties.includeExecutionData));
  errors.collect(cdk.propertyValidator("level", cdk.requiredValidator)(properties.level));
  errors.collect(cdk.propertyValidator("level", cdk.validateString)(properties.level));
  return errors.wrap("supplied properties not correct for \\"LoggingConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineLoggingConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineLoggingConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Destinations": cdk.listMapper(convertCfnStateMachineLogDestinationPropertyToCloudFormation)(properties.destinations),
    "IncludeExecutionData": cdk.booleanToCloudFormation(properties.includeExecutionData),
    "Level": cdk.stringToCloudFormation(properties.level)
  };
}

// @ts-ignore TS6133
function CfnStateMachineLoggingConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.LoggingConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.LoggingConfigurationProperty>();
  ret.addPropertyResult("destinations", "Destinations", (properties.Destinations != null ? cfn_parse.FromCloudFormation.getArray(CfnStateMachineLogDestinationPropertyFromCloudFormation)(properties.Destinations) : undefined));
  ret.addPropertyResult("includeExecutionData", "IncludeExecutionData", (properties.IncludeExecutionData != null ? cfn_parse.FromCloudFormation.getBoolean(properties.IncludeExecutionData) : undefined));
  ret.addPropertyResult("level", "Level", (properties.Level != null ? cfn_parse.FromCloudFormation.getString(properties.Level) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PoliciesProperty\`
 *
 * @param properties - the TypeScript properties of a \`PoliciesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachinePoliciesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("statement", cdk.requiredValidator)(properties.statement));
  errors.collect(cdk.propertyValidator("statement", cdk.listValidator(cdk.validateObject))(properties.statement));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \\"PoliciesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachinePoliciesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachinePoliciesPropertyValidator(properties).assertSuccess();
  return {
    "Statement": cdk.listMapper(cdk.objectToCloudFormation)(properties.statement),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnStateMachinePoliciesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.PoliciesProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.PoliciesProperty>();
  ret.addPropertyResult("statement", "Statement", (properties.Statement != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getAny)(properties.Statement) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TracingConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`TracingConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachineTracingConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("enabled", cdk.validateBoolean)(properties.enabled));
  return errors.wrap("supplied properties not correct for \\"TracingConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachineTracingConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachineTracingConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Enabled": cdk.booleanToCloudFormation(properties.enabled)
  };
}

// @ts-ignore TS6133
function CfnStateMachineTracingConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnStateMachine.TracingConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachine.TracingConfigurationProperty>();
  ret.addPropertyResult("enabled", "Enabled", (properties.Enabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.Enabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnStateMachineProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnStateMachineProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnStateMachinePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("definition", cdk.validateObject)(properties.definition));
  errors.collect(cdk.propertyValidator("definitionSubstitutions", cdk.hashValidator(cdk.validateObject))(properties.definitionSubstitutions));
  errors.collect(cdk.propertyValidator("definitionUri", cdk.unionValidator(CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString))(properties.definitionUri));
  errors.collect(cdk.propertyValidator("events", cdk.hashValidator(CfnStateMachineEventSourcePropertyValidator))(properties.events));
  errors.collect(cdk.propertyValidator("logging", CfnStateMachineLoggingConfigurationPropertyValidator)(properties.logging));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("permissionsBoundaries", cdk.validateString)(properties.permissionsBoundaries));
  errors.collect(cdk.propertyValidator("policies", cdk.unionValidator(cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString))(properties.policies));
  errors.collect(cdk.propertyValidator("role", cdk.validateString)(properties.role));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.hashValidator(cdk.validateString)))(properties.tags));
  errors.collect(cdk.propertyValidator("tracing", CfnStateMachineTracingConfigurationPropertyValidator)(properties.tracing));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"CfnStateMachineProps\\"");
}

// @ts-ignore TS6133
function convertCfnStateMachinePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnStateMachinePropsValidator(properties).assertSuccess();
  return {
    "Definition": cdk.objectToCloudFormation(properties.definition),
    "DefinitionSubstitutions": cdk.hashMapper(cdk.objectToCloudFormation)(properties.definitionSubstitutions),
    "DefinitionUri": cdk.unionMapper([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [convertCfnStateMachineDefinitionUriPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.definitionUri),
    "Events": cdk.hashMapper(convertCfnStateMachineEventSourcePropertyToCloudFormation)(properties.events),
    "Logging": convertCfnStateMachineLoggingConfigurationPropertyToCloudFormation(properties.logging),
    "Name": cdk.stringToCloudFormation(properties.name),
    "PermissionsBoundaries": cdk.stringToCloudFormation(properties.permissionsBoundaries),
    "Policies": cdk.unionMapper([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cdk.listMapper(cdk.unionMapper([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [convertCfnStateMachinePoliciesPropertyToCloudFormation, convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])), convertCfnStateMachinePoliciesPropertyToCloudFormation, cdk.stringToCloudFormation])(properties.policies),
    "Role": cdk.stringToCloudFormation(properties.role),
    "Tags": cdk.listMapper(cdk.hashMapper(cdk.stringToCloudFormation))(properties.tags),
    "Tracing": convertCfnStateMachineTracingConfigurationPropertyToCloudFormation(properties.tracing),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnStateMachinePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnStateMachineProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnStateMachineProps>();
  ret.addPropertyResult("definition", "Definition", (properties.Definition != null ? cfn_parse.FromCloudFormation.getAny(properties.Definition) : undefined));
  ret.addPropertyResult("definitionSubstitutions", "DefinitionSubstitutions", (properties.DefinitionSubstitutions != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getAny)(properties.DefinitionSubstitutions) : undefined));
  ret.addPropertyResult("definitionUri", "DefinitionUri", (properties.DefinitionUri != null ? cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachineDefinitionUriPropertyValidator, cdk.validateString], [CfnStateMachineDefinitionUriPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.DefinitionUri) : undefined));
  ret.addPropertyResult("events", "Events", (properties.Events != null ? cfn_parse.FromCloudFormation.getMap(CfnStateMachineEventSourcePropertyFromCloudFormation)(properties.Events) : undefined));
  ret.addPropertyResult("logging", "Logging", (properties.Logging != null ? CfnStateMachineLoggingConfigurationPropertyFromCloudFormation(properties.Logging) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("permissionsBoundaries", "PermissionsBoundaries", (properties.PermissionsBoundaries != null ? cfn_parse.FromCloudFormation.getString(properties.PermissionsBoundaries) : undefined));
  ret.addPropertyResult("policies", "Policies", (properties.Policies != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.listValidator(cdk.unionValidator(CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString)), CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getTypeUnion([CfnStateMachinePoliciesPropertyValidator, CfnStateMachinePoliciesPropertyValidator, cdk.validateString], [CfnStateMachinePoliciesPropertyFromCloudFormation, CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])), CfnStateMachinePoliciesPropertyFromCloudFormation, cfn_parse.FromCloudFormation.getString])(properties.Policies) : undefined));
  ret.addPropertyResult("role", "Role", (properties.Role != null ? cfn_parse.FromCloudFormation.getString(properties.Role) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString))(properties.Tags) : undefined));
  ret.addPropertyResult("tracing", "Tracing", (properties.Tracing != null ? CfnStateMachineTracingConfigurationPropertyFromCloudFormation(properties.Tracing) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-scheduler 1`] = `
{
  "augmentations": undefined,
  "metrics": undefined,
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * A *schedule* is the main resource you create, configure, and manage using Amazon EventBridge Scheduler.
 *
 * Every schedule has a *schedule expression* that determines when, and with what frequency, the schedule runs. EventBridge Scheduler supports three types of schedules: rate, cron, and one-time schedules. For more information about different schedule types, see [Schedule types](https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html) in the *EventBridge Scheduler User Guide* .
 *
 * When you create a schedule, you configure a target for the schedule to invoke. A target is an API operation that EventBridge Scheduler calls on your behalf every time your schedule runs. EventBridge Scheduler supports two types of targets: *templated* targets invoke common API operations across a core groups of services, and customizeable *universal* targets that you can use to call more than 6,000 operations across over 270 services. For more information about configuring targets, see [Managing targets](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-targets.html) in the *EventBridge Scheduler User Guide* .
 *
 * For more information about managing schedules, changing the schedule state, setting up flexible time windows, and configuring a dead-letter queue for a schedule, see [Managing a schedule](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-schedule.html) in the *EventBridge Scheduler User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html
 */
export class CfnSchedule extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Scheduler::Schedule";

  /**
   * Build a CfnSchedule from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnSchedule {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnSchedulePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnSchedule(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Name (ARN) for the Amazon EventBridge Scheduler schedule.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The description you specify for the schedule.
   */
  public description?: string;

  /**
   * The date, in UTC, before which the schedule can invoke its target.
   */
  public endDate?: string;

  /**
   * Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
   */
  public flexibleTimeWindow: CfnSchedule.FlexibleTimeWindowProperty | cdk.IResolvable;

  /**
   * The name of the schedule group associated with this schedule.
   */
  public groupName?: string;

  /**
   * The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
   */
  public kmsKeyArn?: string;

  /**
   * The name of the schedule.
   */
  public name?: string;

  /**
   * The expression that defines when the schedule runs. The following formats are supported.
   */
  public scheduleExpression: string;

  /**
   * The timezone in which the scheduling expression is evaluated.
   */
  public scheduleExpressionTimezone?: string;

  /**
   * The date, in UTC, after which the schedule can begin invoking its target.
   */
  public startDate?: string;

  /**
   * Specifies whether the schedule is enabled or disabled.
   */
  public state?: string;

  /**
   * The schedule's target details.
   */
  public target: cdk.IResolvable | CfnSchedule.TargetProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnScheduleProps) {
    super(scope, id, {
      "type": CfnSchedule.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "flexibleTimeWindow", this);
    cdk.requireProperty(props, "scheduleExpression", this);
    cdk.requireProperty(props, "target", this);

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.description = props.description;
    this.endDate = props.endDate;
    this.flexibleTimeWindow = props.flexibleTimeWindow;
    this.groupName = props.groupName;
    this.kmsKeyArn = props.kmsKeyArn;
    this.name = props.name;
    this.scheduleExpression = props.scheduleExpression;
    this.scheduleExpressionTimezone = props.scheduleExpressionTimezone;
    this.startDate = props.startDate;
    this.state = props.state;
    this.target = props.target;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "description": this.description,
      "endDate": this.endDate,
      "flexibleTimeWindow": this.flexibleTimeWindow,
      "groupName": this.groupName,
      "kmsKeyArn": this.kmsKeyArn,
      "name": this.name,
      "scheduleExpression": this.scheduleExpression,
      "scheduleExpressionTimezone": this.scheduleExpressionTimezone,
      "startDate": this.startDate,
      "state": this.state,
      "target": this.target
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnSchedule.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnSchedulePropsToCloudFormation(props);
  }
}

export namespace CfnSchedule {
  /**
   * Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html
   */
  export interface FlexibleTimeWindowProperty {
    /**
     * Determines whether the schedule is invoked within a flexible time window.
     *
     * *Allowed Values* : \`OFF\` | \`FLEXIBLE\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-mode
     */
    readonly mode: string;

    /**
     * The maximum time window during which a schedule can be invoked.
     *
     * *Minimum* : \`1\`
     *
     * *Maximum* : \`1440\`
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html#cfn-scheduler-schedule-flexibletimewindow-maximumwindowinminutes
     */
    readonly maximumWindowInMinutes?: number;
  }

  /**
   * The schedule's target.
   *
   * EventBridge Scheduler supports templated target that invoke common API operations, as well as universal targets that you can customize to invoke over 6,000 API operations across more than 270 services. You can only specify one templated or universal target for a schedule.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html
   */
  export interface TargetProperty {
    /**
     * The Amazon Resource Name (ARN) of the target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-arn
     */
    readonly arn: string;

    /**
     * The Amazon Resource Name (ARN) of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-rolearn
     */
    readonly roleArn: string;

    /**
     * An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule.
     *
     * If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-deadletterconfig
     */
    readonly deadLetterConfig?: CfnSchedule.DeadLetterConfigProperty | cdk.IResolvable;

    /**
     * A \`RetryPolicy\` object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-retrypolicy
     */
    readonly retryPolicy?: cdk.IResolvable | CfnSchedule.RetryPolicyProperty;

    /**
     * The text, or well-formed JSON, passed to the target.
     *
     * If you are configuring a templated Lambda , AWS Step Functions , or Amazon EventBridge target, the input must be a well-formed JSON. For all other target types, a JSON is not required. If you do not specify anything for this field, Amazon EventBridge Scheduler delivers a default notification to the target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-input
     */
    readonly input?: string;

    /**
     * The templated target type for the Amazon ECS [\`RunTask\`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) API operation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-ecsparameters
     */
    readonly ecsParameters?: CfnSchedule.EcsParametersProperty | cdk.IResolvable;

    /**
     * The templated target type for the EventBridge [\`PutEvents\`](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html) API operation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-eventbridgeparameters
     */
    readonly eventBridgeParameters?: CfnSchedule.EventBridgeParametersProperty | cdk.IResolvable;

    /**
     * The templated target type for the Amazon Kinesis [\`PutRecord\`](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html) API operation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-kinesisparameters
     */
    readonly kinesisParameters?: cdk.IResolvable | CfnSchedule.KinesisParametersProperty;

    /**
     * The templated target type for the Amazon SageMaker [\`StartPipelineExecution\`](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html) API operation.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-sagemakerpipelineparameters
     */
    readonly sageMakerPipelineParameters?: cdk.IResolvable | CfnSchedule.SageMakerPipelineParametersProperty;

    /**
     * The templated target type for the Amazon SQS [\`SendMessage\`](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html) API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see [Using the Amazon SQS message deduplication ID](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html) in the *Amazon SQS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html#cfn-scheduler-schedule-target-sqsparameters
     */
    readonly sqsParameters?: cdk.IResolvable | CfnSchedule.SqsParametersProperty;
  }

  /**
   * An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule.
   *
   * If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-deadletterconfig.html
   */
  export interface DeadLetterConfigProperty {
    /**
     * The Amazon Resource Name (ARN) of the SQS queue specified as the destination for the dead-letter queue.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-deadletterconfig.html#cfn-scheduler-schedule-deadletterconfig-arn
     */
    readonly arn?: string;
  }

  /**
   * A \`RetryPolicy\` object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-retrypolicy.html
   */
  export interface RetryPolicyProperty {
    /**
     * The maximum amount of time, in seconds, to continue to make retry attempts.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-retrypolicy.html#cfn-scheduler-schedule-retrypolicy-maximumeventageinseconds
     */
    readonly maximumEventAgeInSeconds?: number;

    /**
     * The maximum number of retry attempts to make before the request fails.
     *
     * Retry attempts with exponential backoff continue until either the maximum number of attempts is made or until the duration of the \`MaximumEventAgeInSeconds\` is reached.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-retrypolicy.html#cfn-scheduler-schedule-retrypolicy-maximumretryattempts
     */
    readonly maximumRetryAttempts?: number;
  }

  /**
   * The templated target type for the Amazon ECS [\`RunTask\`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) API operation.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html
   */
  export interface EcsParametersProperty {
    /**
     * The Amazon Resource Name (ARN) of the task definition to use if the event target is an Amazon ECS task.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-taskdefinitionarn
     */
    readonly taskDefinitionArn: string;

    /**
     * The number of tasks to create based on \`TaskDefinition\` .
     *
     * The default is \`1\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-taskcount
     */
    readonly taskCount?: number;

    /**
     * Specifies the launch type on which your task is running.
     *
     * The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The \`FARGATE\` value is supported only in the Regions where Fargate with Amazon ECS is supported. For more information, see [AWS Fargate on Amazon ECS](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html) in the *Amazon ECS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-launchtype
     */
    readonly launchType?: string;

    /**
     * This structure specifies the network configuration for an ECS task.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-networkconfiguration
     */
    readonly networkConfiguration?: cdk.IResolvable | CfnSchedule.NetworkConfigurationProperty;

    /**
     * Specifies the platform version for the task.
     *
     * Specify only the numeric portion of the platform version, such as \`1.1.0\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-platformversion
     */
    readonly platformVersion?: string;

    /**
     * Specifies an ECS task group for the task.
     *
     * The maximum length is 255 characters.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-group
     */
    readonly group?: string;

    /**
     * The capacity provider strategy to use for the task.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-capacityproviderstrategy
     */
    readonly capacityProviderStrategy?: Array<CfnSchedule.CapacityProviderStrategyItemProperty | cdk.IResolvable> | cdk.IResolvable;

    /**
     * Specifies whether to enable Amazon ECS managed tags for the task.
     *
     * For more information, see [Tagging Your Amazon ECS Resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the *Amazon ECS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-enableecsmanagedtags
     */
    readonly enableEcsManagedTags?: boolean | cdk.IResolvable;

    /**
     * Whether or not to enable the execute command functionality for the containers in this task.
     *
     * If true, this enables execute command functionality on all containers in the task.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-enableexecutecommand
     */
    readonly enableExecuteCommand?: boolean | cdk.IResolvable;

    /**
     * An array of placement constraint objects to use for the task.
     *
     * You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-placementconstraints
     */
    readonly placementConstraints?: Array<cdk.IResolvable | CfnSchedule.PlacementConstraintProperty> | cdk.IResolvable;

    /**
     * The task placement strategy for a task or service.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-placementstrategy
     */
    readonly placementStrategy?: Array<cdk.IResolvable | CfnSchedule.PlacementStrategyProperty> | cdk.IResolvable;

    /**
     * Specifies whether to propagate the tags from the task definition to the task.
     *
     * If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use Amazon ECS's [\`TagResource\`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html) API action.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-propagatetags
     */
    readonly propagateTags?: string;

    /**
     * The reference ID to use for the task.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-referenceid
     */
    readonly referenceId?: string;

    /**
     * The metadata that you apply to the task to help you categorize and organize them.
     *
     * Each tag consists of a key and an optional value, both of which you define. For more information, see [\`RunTask\`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) in the *Amazon ECS API Reference* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html#cfn-scheduler-schedule-ecsparameters-tags
     */
    readonly tags?: Array<cdk.IResolvable | Record<string, string>> | cdk.IResolvable;
  }

  /**
   * Specifies the network configuration for an ECS task.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-networkconfiguration.html
   */
  export interface NetworkConfigurationProperty {
    /**
     * Specifies the Amazon VPC subnets and security groups for the task, and whether a public IP address is to be used.
     *
     * This structure is relevant only for ECS tasks that use the awsvpc network mode.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-networkconfiguration.html#cfn-scheduler-schedule-networkconfiguration-awsvpcconfiguration
     */
    readonly awsvpcConfiguration?: CfnSchedule.AwsVpcConfigurationProperty | cdk.IResolvable;
  }

  /**
   * This structure specifies the VPC subnets and security groups for the task, and whether a public IP address is to be used.
   *
   * This structure is relevant only for ECS tasks that use the awsvpc network mode.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-awsvpcconfiguration.html
   */
  export interface AwsVpcConfigurationProperty {
    /**
     * Specifies the subnets associated with the task.
     *
     * These subnets must all be in the same VPC. You can specify as many as 16 subnets.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-awsvpcconfiguration.html#cfn-scheduler-schedule-awsvpcconfiguration-subnets
     */
    readonly subnets: Array<string>;

    /**
     * Specifies the security groups associated with the task.
     *
     * These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-awsvpcconfiguration.html#cfn-scheduler-schedule-awsvpcconfiguration-securitygroups
     */
    readonly securityGroups?: Array<string>;

    /**
     * Specifies whether the task's elastic network interface receives a public IP address.
     *
     * You can specify \`ENABLED\` only when \`LaunchType\` in \`EcsParameters\` is set to \`FARGATE\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-awsvpcconfiguration.html#cfn-scheduler-schedule-awsvpcconfiguration-assignpublicip
     */
    readonly assignPublicIp?: string;
  }

  /**
   * The details of a capacity provider strategy.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-capacityproviderstrategyitem.html
   */
  export interface CapacityProviderStrategyItemProperty {
    /**
     * The short name of the capacity provider.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-capacityproviderstrategyitem.html#cfn-scheduler-schedule-capacityproviderstrategyitem-capacityprovider
     */
    readonly capacityProvider: string;

    /**
     * The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider.
     *
     * The weight value is taken into consideration after the base value, if defined, is satisfied.
     *
     * @default - 0
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-capacityproviderstrategyitem.html#cfn-scheduler-schedule-capacityproviderstrategyitem-weight
     */
    readonly weight?: number;

    /**
     * The base value designates how many tasks, at a minimum, to run on the specified capacity provider.
     *
     * Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of \`0\` is used.
     *
     * @default - 0
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-capacityproviderstrategyitem.html#cfn-scheduler-schedule-capacityproviderstrategyitem-base
     */
    readonly base?: number;
  }

  /**
   * An object representing a constraint on task placement.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementconstraint.html
   */
  export interface PlacementConstraintProperty {
    /**
     * The type of constraint.
     *
     * Use \`distinctInstance\` to ensure that each task in a particular group is running on a different container instance. Use \`memberOf\` to restrict the selection to a group of valid candidates.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementconstraint.html#cfn-scheduler-schedule-placementconstraint-type
     */
    readonly type?: string;

    /**
     * A cluster query language expression to apply to the constraint.
     *
     * You cannot specify an expression if the constraint type is \`distinctInstance\` . For more information, see [Cluster query language](https://docs.aws.amazon.com/latest/developerguide/cluster-query-language.html) in the *Amazon ECS Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementconstraint.html#cfn-scheduler-schedule-placementconstraint-expression
     */
    readonly expression?: string;
  }

  /**
   * The task placement strategy for a task or service.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementstrategy.html
   */
  export interface PlacementStrategyProperty {
    /**
     * The type of placement strategy.
     *
     * The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementstrategy.html#cfn-scheduler-schedule-placementstrategy-type
     */
    readonly type?: string;

    /**
     * The field to apply the placement strategy against.
     *
     * For the spread placement strategy, valid values are \`instanceId\` (or \`instanceId\` , which has the same effect), or any platform or custom attribute that is applied to a container instance, such as \`attribute:ecs.availability-zone\` . For the binpack placement strategy, valid values are \`cpu\` and \`memory\` . For the random placement strategy, this field is not used.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementstrategy.html#cfn-scheduler-schedule-placementstrategy-field
     */
    readonly field?: string;
  }

  /**
   * The templated target type for the EventBridge [\`PutEvents\`](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html) API operation.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-eventbridgeparameters.html
   */
  export interface EventBridgeParametersProperty {
    /**
     * A free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-eventbridgeparameters.html#cfn-scheduler-schedule-eventbridgeparameters-detailtype
     */
    readonly detailType: string;

    /**
     * The source of the event.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-eventbridgeparameters.html#cfn-scheduler-schedule-eventbridgeparameters-source
     */
    readonly source: string;
  }

  /**
   * The templated target type for the Amazon Kinesis [\`PutRecord\`](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html) API operation.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-kinesisparameters.html
   */
  export interface KinesisParametersProperty {
    /**
     * Specifies the shard to which EventBridge Scheduler sends the event.
     *
     * For more information, see [Amazon Kinesis Data Streams terminology and concepts](https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html) in the *Amazon Kinesis Streams Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-kinesisparameters.html#cfn-scheduler-schedule-kinesisparameters-partitionkey
     */
    readonly partitionKey: string;
  }

  /**
   * The templated target type for the Amazon SageMaker [\`StartPipelineExecution\`](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html) API operation.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sagemakerpipelineparameters.html
   */
  export interface SageMakerPipelineParametersProperty {
    /**
     * List of parameter names and values to use when executing the SageMaker Model Building Pipeline.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sagemakerpipelineparameters.html#cfn-scheduler-schedule-sagemakerpipelineparameters-pipelineparameterlist
     */
    readonly pipelineParameterList?: Array<cdk.IResolvable | CfnSchedule.SageMakerPipelineParameterProperty> | cdk.IResolvable;
  }

  /**
   * The name and value pair of a parameter to use to start execution of a SageMaker Model Building Pipeline.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sagemakerpipelineparameter.html
   */
  export interface SageMakerPipelineParameterProperty {
    /**
     * Name of parameter to start execution of a SageMaker Model Building Pipeline.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sagemakerpipelineparameter.html#cfn-scheduler-schedule-sagemakerpipelineparameter-name
     */
    readonly name: string;

    /**
     * Value of parameter to start execution of a SageMaker Model Building Pipeline.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sagemakerpipelineparameter.html#cfn-scheduler-schedule-sagemakerpipelineparameter-value
     */
    readonly value: string;
  }

  /**
   * The templated target type for the Amazon SQS [\`SendMessage\`](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html) API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see [Using the Amazon SQS message deduplication ID](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html) in the *Amazon SQS Developer Guide* .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sqsparameters.html
   */
  export interface SqsParametersProperty {
    /**
     * The FIFO message group ID to use as the target.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sqsparameters.html#cfn-scheduler-schedule-sqsparameters-messagegroupid
     */
    readonly messageGroupId?: string;
  }
}

/**
 * Properties for defining a \`CfnSchedule\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html
 */
export interface CfnScheduleProps {
  /**
   * The description you specify for the schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-description
   */
  readonly description?: string;

  /**
   * The date, in UTC, before which the schedule can invoke its target.
   *
   * Depending on the schedule's recurrence expression, invocations might stop on, or before, the \`EndDate\` you specify.
   * EventBridge Scheduler ignores \`EndDate\` for one-time schedules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-enddate
   */
  readonly endDate?: string;

  /**
   * Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-flexibletimewindow
   */
  readonly flexibleTimeWindow: CfnSchedule.FlexibleTimeWindowProperty | cdk.IResolvable;

  /**
   * The name of the schedule group associated with this schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-groupname
   */
  readonly groupName?: string;

  /**
   * The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-kmskeyarn
   */
  readonly kmsKeyArn?: string;

  /**
   * The name of the schedule.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-name
   */
  readonly name?: string;

  /**
   * The expression that defines when the schedule runs. The following formats are supported.
   *
   * - \`at\` expression - \`at(yyyy-mm-ddThh:mm:ss)\`
   * - \`rate\` expression - \`rate(unit value)\`
   * - \`cron\` expression - \`cron(fields)\`
   *
   * You can use \`at\` expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use \`rate\` and \`cron\` expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month.
   *
   * A \`cron\` expression consists of six fields separated by white spaces: \`(minutes hours day_of_month month day_of_week year)\` .
   *
   * A \`rate\` expression consists of a *value* as a positive integer, and a *unit* with the following options: \`minute\` | \`minutes\` | \`hour\` | \`hours\` | \`day\` | \`days\`
   *
   * For more information and examples, see [Schedule types on EventBridge Scheduler](https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html) in the *EventBridge Scheduler User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-scheduleexpression
   */
  readonly scheduleExpression: string;

  /**
   * The timezone in which the scheduling expression is evaluated.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-scheduleexpressiontimezone
   */
  readonly scheduleExpressionTimezone?: string;

  /**
   * The date, in UTC, after which the schedule can begin invoking its target.
   *
   * Depending on the schedule's recurrence expression, invocations might occur on, or after, the \`StartDate\` you specify.
   * EventBridge Scheduler ignores \`StartDate\` for one-time schedules.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-startdate
   */
  readonly startDate?: string;

  /**
   * Specifies whether the schedule is enabled or disabled.
   *
   * *Allowed Values* : \`ENABLED\` | \`DISABLED\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-state
   */
  readonly state?: string;

  /**
   * The schedule's target details.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html#cfn-scheduler-schedule-target
   */
  readonly target: cdk.IResolvable | CfnSchedule.TargetProperty;
}

/**
 * Determine whether the given properties match those of a \`FlexibleTimeWindowProperty\`
 *
 * @param properties - the TypeScript properties of a \`FlexibleTimeWindowProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleFlexibleTimeWindowPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("maximumWindowInMinutes", cdk.validateNumber)(properties.maximumWindowInMinutes));
  errors.collect(cdk.propertyValidator("mode", cdk.requiredValidator)(properties.mode));
  errors.collect(cdk.propertyValidator("mode", cdk.validateString)(properties.mode));
  return errors.wrap("supplied properties not correct for \\"FlexibleTimeWindowProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleFlexibleTimeWindowPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleFlexibleTimeWindowPropertyValidator(properties).assertSuccess();
  return {
    "MaximumWindowInMinutes": cdk.numberToCloudFormation(properties.maximumWindowInMinutes),
    "Mode": cdk.stringToCloudFormation(properties.mode)
  };
}

// @ts-ignore TS6133
function CfnScheduleFlexibleTimeWindowPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.FlexibleTimeWindowProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.FlexibleTimeWindowProperty>();
  ret.addPropertyResult("maximumWindowInMinutes", "MaximumWindowInMinutes", (properties.MaximumWindowInMinutes != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumWindowInMinutes) : undefined));
  ret.addPropertyResult("mode", "Mode", (properties.Mode != null ? cfn_parse.FromCloudFormation.getString(properties.Mode) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeadLetterConfigProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeadLetterConfigProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleDeadLetterConfigPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  return errors.wrap("supplied properties not correct for \\"DeadLetterConfigProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleDeadLetterConfigPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleDeadLetterConfigPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn)
  };
}

// @ts-ignore TS6133
function CfnScheduleDeadLetterConfigPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.DeadLetterConfigProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.DeadLetterConfigProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RetryPolicyProperty\`
 *
 * @param properties - the TypeScript properties of a \`RetryPolicyProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleRetryPolicyPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("maximumEventAgeInSeconds", cdk.validateNumber)(properties.maximumEventAgeInSeconds));
  errors.collect(cdk.propertyValidator("maximumRetryAttempts", cdk.validateNumber)(properties.maximumRetryAttempts));
  return errors.wrap("supplied properties not correct for \\"RetryPolicyProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleRetryPolicyPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleRetryPolicyPropertyValidator(properties).assertSuccess();
  return {
    "MaximumEventAgeInSeconds": cdk.numberToCloudFormation(properties.maximumEventAgeInSeconds),
    "MaximumRetryAttempts": cdk.numberToCloudFormation(properties.maximumRetryAttempts)
  };
}

// @ts-ignore TS6133
function CfnScheduleRetryPolicyPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.RetryPolicyProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.RetryPolicyProperty>();
  ret.addPropertyResult("maximumEventAgeInSeconds", "MaximumEventAgeInSeconds", (properties.MaximumEventAgeInSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumEventAgeInSeconds) : undefined));
  ret.addPropertyResult("maximumRetryAttempts", "MaximumRetryAttempts", (properties.MaximumRetryAttempts != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumRetryAttempts) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`AwsVpcConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`AwsVpcConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleAwsVpcConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("assignPublicIp", cdk.validateString)(properties.assignPublicIp));
  errors.collect(cdk.propertyValidator("securityGroups", cdk.listValidator(cdk.validateString))(properties.securityGroups));
  errors.collect(cdk.propertyValidator("subnets", cdk.requiredValidator)(properties.subnets));
  errors.collect(cdk.propertyValidator("subnets", cdk.listValidator(cdk.validateString))(properties.subnets));
  return errors.wrap("supplied properties not correct for \\"AwsVpcConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleAwsVpcConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleAwsVpcConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AssignPublicIp": cdk.stringToCloudFormation(properties.assignPublicIp),
    "SecurityGroups": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroups),
    "Subnets": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnets)
  };
}

// @ts-ignore TS6133
function CfnScheduleAwsVpcConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.AwsVpcConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.AwsVpcConfigurationProperty>();
  ret.addPropertyResult("assignPublicIp", "AssignPublicIp", (properties.AssignPublicIp != null ? cfn_parse.FromCloudFormation.getString(properties.AssignPublicIp) : undefined));
  ret.addPropertyResult("securityGroups", "SecurityGroups", (properties.SecurityGroups != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroups) : undefined));
  ret.addPropertyResult("subnets", "Subnets", (properties.Subnets != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Subnets) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`NetworkConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`NetworkConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleNetworkConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("awsvpcConfiguration", CfnScheduleAwsVpcConfigurationPropertyValidator)(properties.awsvpcConfiguration));
  return errors.wrap("supplied properties not correct for \\"NetworkConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleNetworkConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleNetworkConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AwsvpcConfiguration": convertCfnScheduleAwsVpcConfigurationPropertyToCloudFormation(properties.awsvpcConfiguration)
  };
}

// @ts-ignore TS6133
function CfnScheduleNetworkConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.NetworkConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.NetworkConfigurationProperty>();
  ret.addPropertyResult("awsvpcConfiguration", "AwsvpcConfiguration", (properties.AwsvpcConfiguration != null ? CfnScheduleAwsVpcConfigurationPropertyFromCloudFormation(properties.AwsvpcConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CapacityProviderStrategyItemProperty\`
 *
 * @param properties - the TypeScript properties of a \`CapacityProviderStrategyItemProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleCapacityProviderStrategyItemPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("base", cdk.validateNumber)(properties.base));
  errors.collect(cdk.propertyValidator("capacityProvider", cdk.requiredValidator)(properties.capacityProvider));
  errors.collect(cdk.propertyValidator("capacityProvider", cdk.validateString)(properties.capacityProvider));
  errors.collect(cdk.propertyValidator("weight", cdk.validateNumber)(properties.weight));
  return errors.wrap("supplied properties not correct for \\"CapacityProviderStrategyItemProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleCapacityProviderStrategyItemPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleCapacityProviderStrategyItemPropertyValidator(properties).assertSuccess();
  return {
    "Base": cdk.numberToCloudFormation(properties.base),
    "CapacityProvider": cdk.stringToCloudFormation(properties.capacityProvider),
    "Weight": cdk.numberToCloudFormation(properties.weight)
  };
}

// @ts-ignore TS6133
function CfnScheduleCapacityProviderStrategyItemPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.CapacityProviderStrategyItemProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.CapacityProviderStrategyItemProperty>();
  ret.addPropertyResult("base", "Base", (properties.Base != null ? cfn_parse.FromCloudFormation.getNumber(properties.Base) : undefined));
  ret.addPropertyResult("capacityProvider", "CapacityProvider", (properties.CapacityProvider != null ? cfn_parse.FromCloudFormation.getString(properties.CapacityProvider) : undefined));
  ret.addPropertyResult("weight", "Weight", (properties.Weight != null ? cfn_parse.FromCloudFormation.getNumber(properties.Weight) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PlacementConstraintProperty\`
 *
 * @param properties - the TypeScript properties of a \`PlacementConstraintProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSchedulePlacementConstraintPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("expression", cdk.validateString)(properties.expression));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"PlacementConstraintProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSchedulePlacementConstraintPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSchedulePlacementConstraintPropertyValidator(properties).assertSuccess();
  return {
    "Expression": cdk.stringToCloudFormation(properties.expression),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnSchedulePlacementConstraintPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.PlacementConstraintProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.PlacementConstraintProperty>();
  ret.addPropertyResult("expression", "Expression", (properties.Expression != null ? cfn_parse.FromCloudFormation.getString(properties.Expression) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PlacementStrategyProperty\`
 *
 * @param properties - the TypeScript properties of a \`PlacementStrategyProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSchedulePlacementStrategyPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("field", cdk.validateString)(properties.field));
  errors.collect(cdk.propertyValidator("type", cdk.validateString)(properties.type));
  return errors.wrap("supplied properties not correct for \\"PlacementStrategyProperty\\"");
}

// @ts-ignore TS6133
function convertCfnSchedulePlacementStrategyPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSchedulePlacementStrategyPropertyValidator(properties).assertSuccess();
  return {
    "Field": cdk.stringToCloudFormation(properties.field),
    "Type": cdk.stringToCloudFormation(properties.type)
  };
}

// @ts-ignore TS6133
function CfnSchedulePlacementStrategyPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.PlacementStrategyProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.PlacementStrategyProperty>();
  ret.addPropertyResult("field", "Field", (properties.Field != null ? cfn_parse.FromCloudFormation.getString(properties.Field) : undefined));
  ret.addPropertyResult("type", "Type", (properties.Type != null ? cfn_parse.FromCloudFormation.getString(properties.Type) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EcsParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`EcsParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleEcsParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("capacityProviderStrategy", cdk.listValidator(CfnScheduleCapacityProviderStrategyItemPropertyValidator))(properties.capacityProviderStrategy));
  errors.collect(cdk.propertyValidator("enableEcsManagedTags", cdk.validateBoolean)(properties.enableEcsManagedTags));
  errors.collect(cdk.propertyValidator("enableExecuteCommand", cdk.validateBoolean)(properties.enableExecuteCommand));
  errors.collect(cdk.propertyValidator("group", cdk.validateString)(properties.group));
  errors.collect(cdk.propertyValidator("launchType", cdk.validateString)(properties.launchType));
  errors.collect(cdk.propertyValidator("networkConfiguration", CfnScheduleNetworkConfigurationPropertyValidator)(properties.networkConfiguration));
  errors.collect(cdk.propertyValidator("placementConstraints", cdk.listValidator(CfnSchedulePlacementConstraintPropertyValidator))(properties.placementConstraints));
  errors.collect(cdk.propertyValidator("placementStrategy", cdk.listValidator(CfnSchedulePlacementStrategyPropertyValidator))(properties.placementStrategy));
  errors.collect(cdk.propertyValidator("platformVersion", cdk.validateString)(properties.platformVersion));
  errors.collect(cdk.propertyValidator("propagateTags", cdk.validateString)(properties.propagateTags));
  errors.collect(cdk.propertyValidator("referenceId", cdk.validateString)(properties.referenceId));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.hashValidator(cdk.validateString)))(properties.tags));
  errors.collect(cdk.propertyValidator("taskCount", cdk.validateNumber)(properties.taskCount));
  errors.collect(cdk.propertyValidator("taskDefinitionArn", cdk.requiredValidator)(properties.taskDefinitionArn));
  errors.collect(cdk.propertyValidator("taskDefinitionArn", cdk.validateString)(properties.taskDefinitionArn));
  return errors.wrap("supplied properties not correct for \\"EcsParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleEcsParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleEcsParametersPropertyValidator(properties).assertSuccess();
  return {
    "CapacityProviderStrategy": cdk.listMapper(convertCfnScheduleCapacityProviderStrategyItemPropertyToCloudFormation)(properties.capacityProviderStrategy),
    "EnableECSManagedTags": cdk.booleanToCloudFormation(properties.enableEcsManagedTags),
    "EnableExecuteCommand": cdk.booleanToCloudFormation(properties.enableExecuteCommand),
    "Group": cdk.stringToCloudFormation(properties.group),
    "LaunchType": cdk.stringToCloudFormation(properties.launchType),
    "NetworkConfiguration": convertCfnScheduleNetworkConfigurationPropertyToCloudFormation(properties.networkConfiguration),
    "PlacementConstraints": cdk.listMapper(convertCfnSchedulePlacementConstraintPropertyToCloudFormation)(properties.placementConstraints),
    "PlacementStrategy": cdk.listMapper(convertCfnSchedulePlacementStrategyPropertyToCloudFormation)(properties.placementStrategy),
    "PlatformVersion": cdk.stringToCloudFormation(properties.platformVersion),
    "PropagateTags": cdk.stringToCloudFormation(properties.propagateTags),
    "ReferenceId": cdk.stringToCloudFormation(properties.referenceId),
    "Tags": cdk.listMapper(cdk.hashMapper(cdk.stringToCloudFormation))(properties.tags),
    "TaskCount": cdk.numberToCloudFormation(properties.taskCount),
    "TaskDefinitionArn": cdk.stringToCloudFormation(properties.taskDefinitionArn)
  };
}

// @ts-ignore TS6133
function CfnScheduleEcsParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.EcsParametersProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.EcsParametersProperty>();
  ret.addPropertyResult("capacityProviderStrategy", "CapacityProviderStrategy", (properties.CapacityProviderStrategy != null ? cfn_parse.FromCloudFormation.getArray(CfnScheduleCapacityProviderStrategyItemPropertyFromCloudFormation)(properties.CapacityProviderStrategy) : undefined));
  ret.addPropertyResult("enableEcsManagedTags", "EnableECSManagedTags", (properties.EnableECSManagedTags != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableECSManagedTags) : undefined));
  ret.addPropertyResult("enableExecuteCommand", "EnableExecuteCommand", (properties.EnableExecuteCommand != null ? cfn_parse.FromCloudFormation.getBoolean(properties.EnableExecuteCommand) : undefined));
  ret.addPropertyResult("group", "Group", (properties.Group != null ? cfn_parse.FromCloudFormation.getString(properties.Group) : undefined));
  ret.addPropertyResult("launchType", "LaunchType", (properties.LaunchType != null ? cfn_parse.FromCloudFormation.getString(properties.LaunchType) : undefined));
  ret.addPropertyResult("networkConfiguration", "NetworkConfiguration", (properties.NetworkConfiguration != null ? CfnScheduleNetworkConfigurationPropertyFromCloudFormation(properties.NetworkConfiguration) : undefined));
  ret.addPropertyResult("placementConstraints", "PlacementConstraints", (properties.PlacementConstraints != null ? cfn_parse.FromCloudFormation.getArray(CfnSchedulePlacementConstraintPropertyFromCloudFormation)(properties.PlacementConstraints) : undefined));
  ret.addPropertyResult("placementStrategy", "PlacementStrategy", (properties.PlacementStrategy != null ? cfn_parse.FromCloudFormation.getArray(CfnSchedulePlacementStrategyPropertyFromCloudFormation)(properties.PlacementStrategy) : undefined));
  ret.addPropertyResult("platformVersion", "PlatformVersion", (properties.PlatformVersion != null ? cfn_parse.FromCloudFormation.getString(properties.PlatformVersion) : undefined));
  ret.addPropertyResult("propagateTags", "PropagateTags", (properties.PropagateTags != null ? cfn_parse.FromCloudFormation.getString(properties.PropagateTags) : undefined));
  ret.addPropertyResult("referenceId", "ReferenceId", (properties.ReferenceId != null ? cfn_parse.FromCloudFormation.getString(properties.ReferenceId) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString))(properties.Tags) : undefined));
  ret.addPropertyResult("taskCount", "TaskCount", (properties.TaskCount != null ? cfn_parse.FromCloudFormation.getNumber(properties.TaskCount) : undefined));
  ret.addPropertyResult("taskDefinitionArn", "TaskDefinitionArn", (properties.TaskDefinitionArn != null ? cfn_parse.FromCloudFormation.getString(properties.TaskDefinitionArn) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EventBridgeParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`EventBridgeParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleEventBridgeParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("detailType", cdk.requiredValidator)(properties.detailType));
  errors.collect(cdk.propertyValidator("detailType", cdk.validateString)(properties.detailType));
  errors.collect(cdk.propertyValidator("source", cdk.requiredValidator)(properties.source));
  errors.collect(cdk.propertyValidator("source", cdk.validateString)(properties.source));
  return errors.wrap("supplied properties not correct for \\"EventBridgeParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleEventBridgeParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleEventBridgeParametersPropertyValidator(properties).assertSuccess();
  return {
    "DetailType": cdk.stringToCloudFormation(properties.detailType),
    "Source": cdk.stringToCloudFormation(properties.source)
  };
}

// @ts-ignore TS6133
function CfnScheduleEventBridgeParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnSchedule.EventBridgeParametersProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.EventBridgeParametersProperty>();
  ret.addPropertyResult("detailType", "DetailType", (properties.DetailType != null ? cfn_parse.FromCloudFormation.getString(properties.DetailType) : undefined));
  ret.addPropertyResult("source", "Source", (properties.Source != null ? cfn_parse.FromCloudFormation.getString(properties.Source) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KinesisParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`KinesisParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleKinesisParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("partitionKey", cdk.requiredValidator)(properties.partitionKey));
  errors.collect(cdk.propertyValidator("partitionKey", cdk.validateString)(properties.partitionKey));
  return errors.wrap("supplied properties not correct for \\"KinesisParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleKinesisParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleKinesisParametersPropertyValidator(properties).assertSuccess();
  return {
    "PartitionKey": cdk.stringToCloudFormation(properties.partitionKey)
  };
}

// @ts-ignore TS6133
function CfnScheduleKinesisParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.KinesisParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.KinesisParametersProperty>();
  ret.addPropertyResult("partitionKey", "PartitionKey", (properties.PartitionKey != null ? cfn_parse.FromCloudFormation.getString(properties.PartitionKey) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SageMakerPipelineParameterProperty\`
 *
 * @param properties - the TypeScript properties of a \`SageMakerPipelineParameterProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleSageMakerPipelineParameterPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("value", cdk.requiredValidator)(properties.value));
  errors.collect(cdk.propertyValidator("value", cdk.validateString)(properties.value));
  return errors.wrap("supplied properties not correct for \\"SageMakerPipelineParameterProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleSageMakerPipelineParameterPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleSageMakerPipelineParameterPropertyValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name),
    "Value": cdk.stringToCloudFormation(properties.value)
  };
}

// @ts-ignore TS6133
function CfnScheduleSageMakerPipelineParameterPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.SageMakerPipelineParameterProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.SageMakerPipelineParameterProperty>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("value", "Value", (properties.Value != null ? cfn_parse.FromCloudFormation.getString(properties.Value) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SageMakerPipelineParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`SageMakerPipelineParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleSageMakerPipelineParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("pipelineParameterList", cdk.listValidator(CfnScheduleSageMakerPipelineParameterPropertyValidator))(properties.pipelineParameterList));
  return errors.wrap("supplied properties not correct for \\"SageMakerPipelineParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleSageMakerPipelineParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleSageMakerPipelineParametersPropertyValidator(properties).assertSuccess();
  return {
    "PipelineParameterList": cdk.listMapper(convertCfnScheduleSageMakerPipelineParameterPropertyToCloudFormation)(properties.pipelineParameterList)
  };
}

// @ts-ignore TS6133
function CfnScheduleSageMakerPipelineParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.SageMakerPipelineParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.SageMakerPipelineParametersProperty>();
  ret.addPropertyResult("pipelineParameterList", "PipelineParameterList", (properties.PipelineParameterList != null ? cfn_parse.FromCloudFormation.getArray(CfnScheduleSageMakerPipelineParameterPropertyFromCloudFormation)(properties.PipelineParameterList) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SqsParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`SqsParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleSqsParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("messageGroupId", cdk.validateString)(properties.messageGroupId));
  return errors.wrap("supplied properties not correct for \\"SqsParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleSqsParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleSqsParametersPropertyValidator(properties).assertSuccess();
  return {
    "MessageGroupId": cdk.stringToCloudFormation(properties.messageGroupId)
  };
}

// @ts-ignore TS6133
function CfnScheduleSqsParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.SqsParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.SqsParametersProperty>();
  ret.addPropertyResult("messageGroupId", "MessageGroupId", (properties.MessageGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.MessageGroupId) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`TargetProperty\`
 *
 * @param properties - the TypeScript properties of a \`TargetProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleTargetPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("arn", cdk.requiredValidator)(properties.arn));
  errors.collect(cdk.propertyValidator("arn", cdk.validateString)(properties.arn));
  errors.collect(cdk.propertyValidator("deadLetterConfig", CfnScheduleDeadLetterConfigPropertyValidator)(properties.deadLetterConfig));
  errors.collect(cdk.propertyValidator("ecsParameters", CfnScheduleEcsParametersPropertyValidator)(properties.ecsParameters));
  errors.collect(cdk.propertyValidator("eventBridgeParameters", CfnScheduleEventBridgeParametersPropertyValidator)(properties.eventBridgeParameters));
  errors.collect(cdk.propertyValidator("input", cdk.validateString)(properties.input));
  errors.collect(cdk.propertyValidator("kinesisParameters", CfnScheduleKinesisParametersPropertyValidator)(properties.kinesisParameters));
  errors.collect(cdk.propertyValidator("retryPolicy", CfnScheduleRetryPolicyPropertyValidator)(properties.retryPolicy));
  errors.collect(cdk.propertyValidator("roleArn", cdk.requiredValidator)(properties.roleArn));
  errors.collect(cdk.propertyValidator("roleArn", cdk.validateString)(properties.roleArn));
  errors.collect(cdk.propertyValidator("sageMakerPipelineParameters", CfnScheduleSageMakerPipelineParametersPropertyValidator)(properties.sageMakerPipelineParameters));
  errors.collect(cdk.propertyValidator("sqsParameters", CfnScheduleSqsParametersPropertyValidator)(properties.sqsParameters));
  return errors.wrap("supplied properties not correct for \\"TargetProperty\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleTargetPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleTargetPropertyValidator(properties).assertSuccess();
  return {
    "Arn": cdk.stringToCloudFormation(properties.arn),
    "DeadLetterConfig": convertCfnScheduleDeadLetterConfigPropertyToCloudFormation(properties.deadLetterConfig),
    "EcsParameters": convertCfnScheduleEcsParametersPropertyToCloudFormation(properties.ecsParameters),
    "EventBridgeParameters": convertCfnScheduleEventBridgeParametersPropertyToCloudFormation(properties.eventBridgeParameters),
    "Input": cdk.stringToCloudFormation(properties.input),
    "KinesisParameters": convertCfnScheduleKinesisParametersPropertyToCloudFormation(properties.kinesisParameters),
    "RetryPolicy": convertCfnScheduleRetryPolicyPropertyToCloudFormation(properties.retryPolicy),
    "RoleArn": cdk.stringToCloudFormation(properties.roleArn),
    "SageMakerPipelineParameters": convertCfnScheduleSageMakerPipelineParametersPropertyToCloudFormation(properties.sageMakerPipelineParameters),
    "SqsParameters": convertCfnScheduleSqsParametersPropertyToCloudFormation(properties.sqsParameters)
  };
}

// @ts-ignore TS6133
function CfnScheduleTargetPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnSchedule.TargetProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnSchedule.TargetProperty>();
  ret.addPropertyResult("arn", "Arn", (properties.Arn != null ? cfn_parse.FromCloudFormation.getString(properties.Arn) : undefined));
  ret.addPropertyResult("deadLetterConfig", "DeadLetterConfig", (properties.DeadLetterConfig != null ? CfnScheduleDeadLetterConfigPropertyFromCloudFormation(properties.DeadLetterConfig) : undefined));
  ret.addPropertyResult("ecsParameters", "EcsParameters", (properties.EcsParameters != null ? CfnScheduleEcsParametersPropertyFromCloudFormation(properties.EcsParameters) : undefined));
  ret.addPropertyResult("eventBridgeParameters", "EventBridgeParameters", (properties.EventBridgeParameters != null ? CfnScheduleEventBridgeParametersPropertyFromCloudFormation(properties.EventBridgeParameters) : undefined));
  ret.addPropertyResult("input", "Input", (properties.Input != null ? cfn_parse.FromCloudFormation.getString(properties.Input) : undefined));
  ret.addPropertyResult("kinesisParameters", "KinesisParameters", (properties.KinesisParameters != null ? CfnScheduleKinesisParametersPropertyFromCloudFormation(properties.KinesisParameters) : undefined));
  ret.addPropertyResult("retryPolicy", "RetryPolicy", (properties.RetryPolicy != null ? CfnScheduleRetryPolicyPropertyFromCloudFormation(properties.RetryPolicy) : undefined));
  ret.addPropertyResult("roleArn", "RoleArn", (properties.RoleArn != null ? cfn_parse.FromCloudFormation.getString(properties.RoleArn) : undefined));
  ret.addPropertyResult("sageMakerPipelineParameters", "SageMakerPipelineParameters", (properties.SageMakerPipelineParameters != null ? CfnScheduleSageMakerPipelineParametersPropertyFromCloudFormation(properties.SageMakerPipelineParameters) : undefined));
  ret.addPropertyResult("sqsParameters", "SqsParameters", (properties.SqsParameters != null ? CfnScheduleSqsParametersPropertyFromCloudFormation(properties.SqsParameters) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnScheduleProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnScheduleProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnSchedulePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("description", cdk.validateString)(properties.description));
  errors.collect(cdk.propertyValidator("endDate", cdk.validateString)(properties.endDate));
  errors.collect(cdk.propertyValidator("flexibleTimeWindow", cdk.requiredValidator)(properties.flexibleTimeWindow));
  errors.collect(cdk.propertyValidator("flexibleTimeWindow", CfnScheduleFlexibleTimeWindowPropertyValidator)(properties.flexibleTimeWindow));
  errors.collect(cdk.propertyValidator("groupName", cdk.validateString)(properties.groupName));
  errors.collect(cdk.propertyValidator("kmsKeyArn", cdk.validateString)(properties.kmsKeyArn));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("scheduleExpression", cdk.requiredValidator)(properties.scheduleExpression));
  errors.collect(cdk.propertyValidator("scheduleExpression", cdk.validateString)(properties.scheduleExpression));
  errors.collect(cdk.propertyValidator("scheduleExpressionTimezone", cdk.validateString)(properties.scheduleExpressionTimezone));
  errors.collect(cdk.propertyValidator("startDate", cdk.validateString)(properties.startDate));
  errors.collect(cdk.propertyValidator("state", cdk.validateString)(properties.state));
  errors.collect(cdk.propertyValidator("target", cdk.requiredValidator)(properties.target));
  errors.collect(cdk.propertyValidator("target", CfnScheduleTargetPropertyValidator)(properties.target));
  return errors.wrap("supplied properties not correct for \\"CfnScheduleProps\\"");
}

// @ts-ignore TS6133
function convertCfnSchedulePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnSchedulePropsValidator(properties).assertSuccess();
  return {
    "Description": cdk.stringToCloudFormation(properties.description),
    "EndDate": cdk.stringToCloudFormation(properties.endDate),
    "FlexibleTimeWindow": convertCfnScheduleFlexibleTimeWindowPropertyToCloudFormation(properties.flexibleTimeWindow),
    "GroupName": cdk.stringToCloudFormation(properties.groupName),
    "KmsKeyArn": cdk.stringToCloudFormation(properties.kmsKeyArn),
    "Name": cdk.stringToCloudFormation(properties.name),
    "ScheduleExpression": cdk.stringToCloudFormation(properties.scheduleExpression),
    "ScheduleExpressionTimezone": cdk.stringToCloudFormation(properties.scheduleExpressionTimezone),
    "StartDate": cdk.stringToCloudFormation(properties.startDate),
    "State": cdk.stringToCloudFormation(properties.state),
    "Target": convertCfnScheduleTargetPropertyToCloudFormation(properties.target)
  };
}

// @ts-ignore TS6133
function CfnSchedulePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnScheduleProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnScheduleProps>();
  ret.addPropertyResult("description", "Description", (properties.Description != null ? cfn_parse.FromCloudFormation.getString(properties.Description) : undefined));
  ret.addPropertyResult("endDate", "EndDate", (properties.EndDate != null ? cfn_parse.FromCloudFormation.getString(properties.EndDate) : undefined));
  ret.addPropertyResult("flexibleTimeWindow", "FlexibleTimeWindow", (properties.FlexibleTimeWindow != null ? CfnScheduleFlexibleTimeWindowPropertyFromCloudFormation(properties.FlexibleTimeWindow) : undefined));
  ret.addPropertyResult("groupName", "GroupName", (properties.GroupName != null ? cfn_parse.FromCloudFormation.getString(properties.GroupName) : undefined));
  ret.addPropertyResult("kmsKeyArn", "KmsKeyArn", (properties.KmsKeyArn != null ? cfn_parse.FromCloudFormation.getString(properties.KmsKeyArn) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("scheduleExpression", "ScheduleExpression", (properties.ScheduleExpression != null ? cfn_parse.FromCloudFormation.getString(properties.ScheduleExpression) : undefined));
  ret.addPropertyResult("scheduleExpressionTimezone", "ScheduleExpressionTimezone", (properties.ScheduleExpressionTimezone != null ? cfn_parse.FromCloudFormation.getString(properties.ScheduleExpressionTimezone) : undefined));
  ret.addPropertyResult("startDate", "StartDate", (properties.StartDate != null ? cfn_parse.FromCloudFormation.getString(properties.StartDate) : undefined));
  ret.addPropertyResult("state", "State", (properties.State != null ? cfn_parse.FromCloudFormation.getString(properties.State) : undefined));
  ret.addPropertyResult("target", "Target", (properties.Target != null ? CfnScheduleTargetPropertyFromCloudFormation(properties.Target) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * A *schedule group* is an Amazon EventBridge Scheduler resource you use to organize your schedules.
 *
 * Your AWS account comes with a \`default\` scheduler group. You associate a new schedule with the \`default\` group or with schedule groups that you create and manage. You can create up to [500 schedule groups](https://docs.aws.amazon.com/scheduler/latest/UserGuide/scheduler-quotas.html) in your AWS account. With EventBridge Scheduler, you apply [tags](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) to schedule groups, not to individual schedules to organize your resources.
 *
 * For more information about managing schedule groups, see [Managing a schedule group](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-schedule-group.html) in the *EventBridge Scheduler User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html
 */
export class CfnScheduleGroup extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::Scheduler::ScheduleGroup";

  /**
   * Build a CfnScheduleGroup from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnScheduleGroup {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnScheduleGroupPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnScheduleGroup(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * The Amazon Resource Name (ARN) of the schedule group.
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * The date and time at which the schedule group was created.
   *
   * @cloudformationAttribute CreationDate
   */
  public readonly attrCreationDate: string;

  /**
   * The time at which the schedule group was last modified.
   *
   * @cloudformationAttribute LastModificationDate
   */
  public readonly attrLastModificationDate: string;

  /**
   * Specifies the state of the schedule group.
   *
   * *Allowed Values* : \`ACTIVE\` | \`DELETING\`
   *
   * @cloudformationAttribute State
   */
  public readonly attrState: string;

  /**
   * The name of the schedule group.
   */
  public name?: string;

  /**
   * An array of key-value pairs to apply to this resource.
   */
  public readonly tags: cdk.TagManager;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnScheduleGroupProps = {}) {
    super(scope, id, {
      "type": CfnScheduleGroup.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrCreationDate = cdk.Token.asString(this.getAtt("CreationDate", cdk.ResolutionTypeHint.STRING));
    this.attrLastModificationDate = cdk.Token.asString(this.getAtt("LastModificationDate", cdk.ResolutionTypeHint.STRING));
    this.attrState = cdk.Token.asString(this.getAtt("State", cdk.ResolutionTypeHint.STRING));
    this.name = props.name;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::Scheduler::ScheduleGroup", props.tags, {
      "tagPropertyName": "tags"
    });
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "name": this.name,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnScheduleGroup.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnScheduleGroupPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnScheduleGroup\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html
 */
export interface CfnScheduleGroupProps {
  /**
   * The name of the schedule group.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html#cfn-scheduler-schedulegroup-name
   */
  readonly name?: string;

  /**
   * An array of key-value pairs to apply to this resource.
   *
   * For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html#cfn-scheduler-schedulegroup-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`CfnScheduleGroupProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnScheduleGroupProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnScheduleGroupPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnScheduleGroupProps\\"");
}

// @ts-ignore TS6133
function convertCfnScheduleGroupPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnScheduleGroupPropsValidator(properties).assertSuccess();
  return {
    "Name": cdk.stringToCloudFormation(properties.name),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnScheduleGroupPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnScheduleGroupProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnScheduleGroupProps>();
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`aws-sqs 1`] = `
{
  "augmentations": "// Copyright 2012-2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.
/* eslint-disable prettier/prettier,max-len */
import * as cw from "aws-cdk-lib/aws-cloudwatch";
import { QueueBase } from "./queue-base";

declare module "./queue-base" {
  interface IQueue {
    /**
     * Return the given named metric for this Queue
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The approximate age of the oldest non-deleted message in the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateAgeOfOldestMessage(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages in the queue that are delayed and not available for reading immediately.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesDelayed(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages that are in flight.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesNotVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages available for retrieval from the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of ReceiveMessage API calls that did not return a message.
     *
     * Sum over 5 minutes
     */
    metricNumberOfEmptyReceives(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages deleted from the queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesDeleted(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages returned by calls to the ReceiveMessage action.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesReceived(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages added to a queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesSent(props?: cw.MetricOptions): cw.Metric;

    /**
     * The size of messages added to a queue.
     *
     * Average over 5 minutes
     */
    metricSentMessageSize(props?: cw.MetricOptions): cw.Metric;
  }
}



declare module "./queue-base" {
  interface QueueBase {
    /**
     * Return the given named metric for this Queue
     */
    metric(metricName: string, props?: cw.MetricOptions): cw.Metric;

    /**
     * The approximate age of the oldest non-deleted message in the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateAgeOfOldestMessage(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages in the queue that are delayed and not available for reading immediately.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesDelayed(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages that are in flight.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesNotVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages available for retrieval from the queue.
     *
     * Maximum over 5 minutes
     */
    metricApproximateNumberOfMessagesVisible(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of ReceiveMessage API calls that did not return a message.
     *
     * Sum over 5 minutes
     */
    metricNumberOfEmptyReceives(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages deleted from the queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesDeleted(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages returned by calls to the ReceiveMessage action.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesReceived(props?: cw.MetricOptions): cw.Metric;

    /**
     * The number of messages added to a queue.
     *
     * Sum over 5 minutes
     */
    metricNumberOfMessagesSent(props?: cw.MetricOptions): cw.Metric;

    /**
     * The size of messages added to a queue.
     *
     * Average over 5 minutes
     */
    metricSentMessageSize(props?: cw.MetricOptions): cw.Metric;
  }
}

QueueBase.prototype.metric = function(metricName: string, props?: cw.MetricOptions) {
  return new cw.Metric({
    "namespace": "AWS/SQS",
    "metricName": metricName,
    "dimensionsMap": {
      "QueueName": this.queueName
    },
    ...props
  }).attachTo(this);
};
QueueBase.prototype.metricApproximateAgeOfOldestMessage = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateAgeOfOldestMessage", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricApproximateNumberOfMessagesDelayed = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateNumberOfMessagesDelayed", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricApproximateNumberOfMessagesNotVisible = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateNumberOfMessagesNotVisible", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricApproximateNumberOfMessagesVisible = function(props?: cw.MetricOptions) {
  return this.metric("ApproximateNumberOfMessagesVisible", {
    "statistic": "Maximum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfEmptyReceives = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfEmptyReceives", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfMessagesDeleted = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfMessagesDeleted", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfMessagesReceived = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfMessagesReceived", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricNumberOfMessagesSent = function(props?: cw.MetricOptions) {
  return this.metric("NumberOfMessagesSent", {
    "statistic": "Sum",
    ...props
  });
};
QueueBase.prototype.metricSentMessageSize = function(props?: cw.MetricOptions) {
  return this.metric("SentMessageSize", {
    "statistic": "Average",
    ...props
  });
};",
  "metrics": "/* eslint-disable prettier/prettier,max-len */
export interface MetricWithDims<D> {
  readonly namespace: string;

  readonly metricName: string;

  readonly statistic: string;

  readonly dimensionsMap: D;
}

export class SQSMetrics {
  public static numberOfMessagesSentAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfMessagesSent",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateNumberOfMessagesDelayedAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateNumberOfMessagesDelayed",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfMessagesReceivedAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfMessagesReceived",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfMessagesDeletedAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfMessagesDeleted",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateNumberOfMessagesNotVisibleAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateNumberOfMessagesNotVisible",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateNumberOfMessagesVisibleAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateNumberOfMessagesVisible",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static approximateAgeOfOldestMessageAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "ApproximateAgeOfOldestMessage",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static numberOfEmptyReceivesAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "NumberOfEmptyReceives",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }

  public static sentMessageSizeAverage(dimensions: { QueueName: string; }): MetricWithDims<{ QueueName: string; }> {
    return {
      "namespace": "AWS/SQS",
      "metricName": "SentMessageSize",
      "dimensionsMap": dimensions,
      "statistic": "Average"
    };
  }
}",
  "module": "/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * The \`AWS::SQS::Queue\` resource creates an Amazon SQS standard or FIFO queue.
 *
 * Keep the following caveats in mind:
 *
 * - If you don't specify the \`FifoQueue\` property, Amazon SQS creates a standard queue.
 *
 * > You can't change the queue type after you create it and you can't convert an existing standard queue into a FIFO queue. You must either create a new FIFO queue for your application or delete your existing standard queue and recreate it as a FIFO queue. For more information, see [Moving from a standard queue to a FIFO queue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues-moving.html) in the *Amazon SQS Developer Guide* .
 * - If you don't provide a value for a property, the queue is created with the default value for the property.
 * - If you delete a queue, you must wait at least 60 seconds before creating a queue with the same name.
 * - To successfully create a new queue, you must provide a queue name that adheres to the [limits related to queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/limits-queues.html) and is unique within the scope of your queues.
 *
 * For more information about creating FIFO (first-in-first-out) queues, see [Creating an Amazon SQS queue ( AWS CloudFormation )](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/screate-queue-cloudformation.html) in the *Amazon SQS Developer Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html
 */
export class CfnQueue extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::SQS::Queue";

  /**
   * Build a CfnQueue from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnQueue {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnQueuePropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnQueue(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Returns the URLs of the queues from the policy.
   *
   * @cloudformationAttribute QueueUrl
   */
  public readonly attrQueueUrl: string;

  /**
   * Returns the Amazon Resource Name (ARN) of the queue. For example: \`arn:aws:sqs:us-east-2:123456789012:mystack-myqueue-15PG5C2FC1CW8\` .
   *
   * @cloudformationAttribute Arn
   */
  public readonly attrArn: string;

  /**
   * Returns the queue name. For example: \`mystack-myqueue-1VF9BKQH5BJVI\` .
   *
   * @cloudformationAttribute QueueName
   */
  public readonly attrQueueName: string;

  /**
   * For first-in-first-out (FIFO) queues, specifies whether to enable content-based deduplication.
   */
  public contentBasedDeduplication?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether message deduplication occurs at the message group or queue level.
   */
  public deduplicationScope?: string;

  /**
   * The time in seconds for which the delivery of all messages in the queue is delayed.
   */
  public delaySeconds?: number;

  /**
   * If set to true, creates a FIFO queue.
   */
  public fifoQueue?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether the FIFO queue throughput quota applies to the entire queue or per message group.
   */
  public fifoThroughputLimit?: string;

  /**
   * The length of time in seconds for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again.
   */
  public kmsDataKeyReusePeriodSeconds?: number;

  /**
   * The ID of an AWS Key Management Service (KMS) for Amazon SQS , or a custom KMS.
   */
  public kmsMasterKeyId?: string;

  /**
   * Enables server-side queue encryption using SQS owned encryption keys.
   */
  public sqsManagedSseEnabled?: boolean | cdk.IResolvable;

  /**
   * The limit of how many bytes that a message can contain before Amazon SQS rejects it.
   */
  public maximumMessageSize?: number;

  /**
   * The number of seconds that Amazon SQS retains a message.
   */
  public messageRetentionPeriod?: number;

  /**
   * A name for the queue.
   */
  public queueName?: string;

  /**
   * Specifies the duration, in seconds, that the ReceiveMessage action call waits until a message is in the queue in order to include it in the response, rather than returning an empty response if a message isn't yet available.
   */
  public receiveMessageWaitTimeSeconds?: number;

  /**
   * The string that includes the parameters for the permissions for the dead-letter queue redrive permission and which source queues can specify dead-letter queues as a JSON object.
   */
  public redriveAllowPolicy?: any | cdk.IResolvable | string;

  /**
   * The string that includes the parameters for the dead-letter queue functionality of the source queue as a JSON object.
   */
  public redrivePolicy?: any | cdk.IResolvable | string;

  /**
   * The tags that you attach to this queue.
   */
  public readonly tags: cdk.TagManager;

  /**
   * The length of time during which a message will be unavailable after a message is delivered from the queue.
   */
  public visibilityTimeout?: number;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnQueueProps = {}) {
    super(scope, id, {
      "type": CfnQueue.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    this.attrQueueUrl = cdk.Token.asString(this.getAtt("QueueUrl", cdk.ResolutionTypeHint.STRING));
    this.attrArn = cdk.Token.asString(this.getAtt("Arn", cdk.ResolutionTypeHint.STRING));
    this.attrQueueName = cdk.Token.asString(this.getAtt("QueueName", cdk.ResolutionTypeHint.STRING));
    this.contentBasedDeduplication = props.contentBasedDeduplication;
    this.deduplicationScope = props.deduplicationScope;
    this.delaySeconds = props.delaySeconds;
    this.fifoQueue = props.fifoQueue;
    this.fifoThroughputLimit = props.fifoThroughputLimit;
    this.kmsDataKeyReusePeriodSeconds = props.kmsDataKeyReusePeriodSeconds;
    this.kmsMasterKeyId = props.kmsMasterKeyId;
    this.sqsManagedSseEnabled = props.sqsManagedSseEnabled;
    this.maximumMessageSize = props.maximumMessageSize;
    this.messageRetentionPeriod = props.messageRetentionPeriod;
    this.queueName = props.queueName;
    this.receiveMessageWaitTimeSeconds = props.receiveMessageWaitTimeSeconds;
    this.redriveAllowPolicy = props.redriveAllowPolicy;
    this.redrivePolicy = props.redrivePolicy;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::SQS::Queue", props.tags, {
      "tagPropertyName": "tags"
    });
    this.visibilityTimeout = props.visibilityTimeout;
    if ((this.node.scope != null && cdk.Resource.isResource(this.node.scope))) {
      this.node.addValidation({
        "validate": () => ((this.cfnOptions.deletionPolicy === undefined) ? ["'AWS::SQS::Queue' is a stateful resource type, and you must specify a Removal Policy for it. Call 'resource.applyRemovalPolicy()'."] : [])
      });
    }
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "contentBasedDeduplication": this.contentBasedDeduplication,
      "deduplicationScope": this.deduplicationScope,
      "delaySeconds": this.delaySeconds,
      "fifoQueue": this.fifoQueue,
      "fifoThroughputLimit": this.fifoThroughputLimit,
      "kmsDataKeyReusePeriodSeconds": this.kmsDataKeyReusePeriodSeconds,
      "kmsMasterKeyId": this.kmsMasterKeyId,
      "sqsManagedSseEnabled": this.sqsManagedSseEnabled,
      "maximumMessageSize": this.maximumMessageSize,
      "messageRetentionPeriod": this.messageRetentionPeriod,
      "queueName": this.queueName,
      "receiveMessageWaitTimeSeconds": this.receiveMessageWaitTimeSeconds,
      "redriveAllowPolicy": this.redriveAllowPolicy,
      "redrivePolicy": this.redrivePolicy,
      "tags": this.tags.renderTags(),
      "visibilityTimeout": this.visibilityTimeout
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnQueue.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnQueuePropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnQueue\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html
 */
export interface CfnQueueProps {
  /**
   * For first-in-first-out (FIFO) queues, specifies whether to enable content-based deduplication.
   *
   * During the deduplication interval, Amazon SQS treats messages that are sent with identical content as duplicates and delivers only one copy of the message. For more information, see the \`ContentBasedDeduplication\` attribute for the \`[CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html)\` action in the *Amazon SQS API Reference* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-contentbaseddeduplication
   */
  readonly contentBasedDeduplication?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether message deduplication occurs at the message group or queue level.
   *
   * Valid values are \`messageGroup\` and \`queue\` .
   *
   * To enable high throughput for a FIFO queue, set this attribute to \`messageGroup\` *and* set the \`FifoThroughputLimit\` attribute to \`perMessageGroupId\` . If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-deduplicationscope
   */
  readonly deduplicationScope?: string;

  /**
   * The time in seconds for which the delivery of all messages in the queue is delayed.
   *
   * You can specify an integer value of \`0\` to \`900\` (15 minutes). The default value is \`0\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-delayseconds
   */
  readonly delaySeconds?: number;

  /**
   * If set to true, creates a FIFO queue.
   *
   * If you don't specify this property, Amazon SQS creates a standard queue. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-fifoqueue
   */
  readonly fifoQueue?: boolean | cdk.IResolvable;

  /**
   * For high throughput for FIFO queues, specifies whether the FIFO queue throughput quota applies to the entire queue or per message group.
   *
   * Valid values are \`perQueue\` and \`perMessageGroupId\` .
   *
   * To enable high throughput for a FIFO queue, set this attribute to \`perMessageGroupId\` *and* set the \`DeduplicationScope\` attribute to \`messageGroup\` . If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-fifothroughputlimit
   */
  readonly fifoThroughputLimit?: string;

  /**
   * The length of time in seconds for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again.
   *
   * The value must be an integer between 60 (1 minute) and 86,400 (24 hours). The default is 300 (5 minutes).
   *
   * > A shorter time period provides better security, but results in more calls to AWS KMS , which might incur charges after Free Tier. For more information, see [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html#sqs-how-does-the-data-key-reuse-period-work) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-kmsdatakeyreuseperiodseconds
   */
  readonly kmsDataKeyReusePeriodSeconds?: number;

  /**
   * The ID of an AWS Key Management Service (KMS) for Amazon SQS , or a custom KMS.
   *
   * To use the AWS managed KMS for Amazon SQS , specify a (default) alias ARN, alias name (e.g. \`alias/aws/sqs\` ), key ARN, or key ID. For more information, see the following:
   *
   * - [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html) in the *Amazon SQS Developer Guide*
   * - [CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html) in the *Amazon SQS API Reference*
   * - [Request Parameters](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the *AWS Key Management Service API Reference*
   * - The Key Management Service (KMS) section of the [AWS Key Management Service Best Practices](https://docs.aws.amazon.com/https://d0.awsstatic.com/whitepapers/aws-kms-best-practices.pdf) whitepaper
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-kmsmasterkeyid
   */
  readonly kmsMasterKeyId?: string;

  /**
   * Enables server-side queue encryption using SQS owned encryption keys.
   *
   * Only one server-side encryption option is supported per queue (for example, [SSE-KMS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sse-existing-queue.html) or [SSE-SQS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sqs-sse-queue.html) ).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-sqsmanagedsseenabled
   */
  readonly sqsManagedSseEnabled?: boolean | cdk.IResolvable;

  /**
   * The limit of how many bytes that a message can contain before Amazon SQS rejects it.
   *
   * You can specify an integer value from \`1,024\` bytes (1 KiB) to \`262,144\` bytes (256 KiB). The default value is \`262,144\` (256 KiB).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-maximummessagesize
   */
  readonly maximumMessageSize?: number;

  /**
   * The number of seconds that Amazon SQS retains a message.
   *
   * You can specify an integer value from \`60\` seconds (1 minute) to \`1,209,600\` seconds (14 days). The default value is \`345,600\` seconds (4 days).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-messageretentionperiod
   */
  readonly messageRetentionPeriod?: number;

  /**
   * A name for the queue.
   *
   * To create a FIFO queue, the name of your FIFO queue must end with the \`.fifo\` suffix. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Amazon SQS Developer Guide* .
   *
   * If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the queue name. For more information, see [Name type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html) in the *AWS CloudFormation User Guide* .
   *
   * > If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-queuename
   */
  readonly queueName?: string;

  /**
   * Specifies the duration, in seconds, that the ReceiveMessage action call waits until a message is in the queue in order to include it in the response, rather than returning an empty response if a message isn't yet available.
   *
   * You can specify an integer from 1 to 20. Short polling is used as the default or when you specify 0 for this property. For more information, see [Consuming messages using long polling](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html#sqs-long-polling) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-receivemessagewaittimeseconds
   */
  readonly receiveMessageWaitTimeSeconds?: number;

  /**
   * The string that includes the parameters for the permissions for the dead-letter queue redrive permission and which source queues can specify dead-letter queues as a JSON object.
   *
   * The parameters are as follows:
   *
   * - \`redrivePermission\` : The permission type that defines which source queues can specify the current queue as the dead-letter queue. Valid values are:
   *
   * - \`allowAll\` : (Default) Any source queues in this AWS account in the same Region can specify this queue as the dead-letter queue.
   * - \`denyAll\` : No source queues can specify this queue as the dead-letter queue.
   * - \`byQueue\` : Only queues specified by the \`sourceQueueArns\` parameter can specify this queue as the dead-letter queue.
   * - \`sourceQueueArns\` : The Amazon Resource Names (ARN)s of the source queues that can specify this queue as the dead-letter queue and redrive messages. You can specify this parameter only when the \`redrivePermission\` parameter is set to \`byQueue\` . You can specify up to 10 source queue ARNs. To allow more than 10 source queues to specify dead-letter queues, set the \`redrivePermission\` parameter to \`allowAll\` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-redriveallowpolicy
   */
  readonly redriveAllowPolicy?: any | cdk.IResolvable | string;

  /**
   * The string that includes the parameters for the dead-letter queue functionality of the source queue as a JSON object.
   *
   * The parameters are as follows:
   *
   * - \`deadLetterTargetArn\` : The Amazon Resource Name (ARN) of the dead-letter queue to which Amazon SQS moves messages after the value of \`maxReceiveCount\` is exceeded.
   * - \`maxReceiveCount\` : The number of times a message is delivered to the source queue before being moved to the dead-letter queue. When the \`ReceiveCount\` for a message exceeds the \`maxReceiveCount\` for a queue, Amazon SQS moves the message to the dead-letter-queue.
   *
   * > The dead-letter queue of a FIFO queue must also be a FIFO queue. Similarly, the dead-letter queue of a standard queue must also be a standard queue.
   *
   * *JSON*
   *
   * \`{ "deadLetterTargetArn" : *String* , "maxReceiveCount" : *Integer* }\`
   *
   * *YAML*
   *
   * \`deadLetterTargetArn : *String*\`
   *
   * \`maxReceiveCount : *Integer*\`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-redrivepolicy
   */
  readonly redrivePolicy?: any | cdk.IResolvable | string;

  /**
   * The tags that you attach to this queue.
   *
   * For more information, see [Resource tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) in the *AWS CloudFormation User Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-tags
   */
  readonly tags?: Array<cdk.CfnTag>;

  /**
   * The length of time during which a message will be unavailable after a message is delivered from the queue.
   *
   * This blocks other components from receiving the same message and gives the initial component time to process and delete the message from the queue.
   *
   * Values must be from 0 to 43,200 seconds (12 hours). If you don't specify a value, AWS CloudFormation uses the default value of 30 seconds.
   *
   * For more information about Amazon SQS queue visibility timeouts, see [Visibility timeout](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queue.html#cfn-sqs-queue-visibilitytimeout
   */
  readonly visibilityTimeout?: number;
}

/**
 * Determine whether the given properties match those of a \`CfnQueueProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnQueueProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnQueuePropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("contentBasedDeduplication", cdk.validateBoolean)(properties.contentBasedDeduplication));
  errors.collect(cdk.propertyValidator("deduplicationScope", cdk.validateString)(properties.deduplicationScope));
  errors.collect(cdk.propertyValidator("delaySeconds", cdk.validateNumber)(properties.delaySeconds));
  errors.collect(cdk.propertyValidator("fifoQueue", cdk.validateBoolean)(properties.fifoQueue));
  errors.collect(cdk.propertyValidator("fifoThroughputLimit", cdk.validateString)(properties.fifoThroughputLimit));
  errors.collect(cdk.propertyValidator("kmsDataKeyReusePeriodSeconds", cdk.validateNumber)(properties.kmsDataKeyReusePeriodSeconds));
  errors.collect(cdk.propertyValidator("kmsMasterKeyId", cdk.validateString)(properties.kmsMasterKeyId));
  errors.collect(cdk.propertyValidator("maximumMessageSize", cdk.validateNumber)(properties.maximumMessageSize));
  errors.collect(cdk.propertyValidator("messageRetentionPeriod", cdk.validateNumber)(properties.messageRetentionPeriod));
  errors.collect(cdk.propertyValidator("queueName", cdk.validateString)(properties.queueName));
  errors.collect(cdk.propertyValidator("receiveMessageWaitTimeSeconds", cdk.validateNumber)(properties.receiveMessageWaitTimeSeconds));
  errors.collect(cdk.propertyValidator("redriveAllowPolicy", cdk.unionValidator(cdk.validateObject, cdk.validateString))(properties.redriveAllowPolicy));
  errors.collect(cdk.propertyValidator("redrivePolicy", cdk.unionValidator(cdk.validateObject, cdk.validateString))(properties.redrivePolicy));
  errors.collect(cdk.propertyValidator("sqsManagedSseEnabled", cdk.validateBoolean)(properties.sqsManagedSseEnabled));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  errors.collect(cdk.propertyValidator("visibilityTimeout", cdk.validateNumber)(properties.visibilityTimeout));
  return errors.wrap("supplied properties not correct for \\"CfnQueueProps\\"");
}

// @ts-ignore TS6133
function convertCfnQueuePropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnQueuePropsValidator(properties).assertSuccess();
  return {
    "ContentBasedDeduplication": cdk.booleanToCloudFormation(properties.contentBasedDeduplication),
    "DeduplicationScope": cdk.stringToCloudFormation(properties.deduplicationScope),
    "DelaySeconds": cdk.numberToCloudFormation(properties.delaySeconds),
    "FifoQueue": cdk.booleanToCloudFormation(properties.fifoQueue),
    "FifoThroughputLimit": cdk.stringToCloudFormation(properties.fifoThroughputLimit),
    "KmsDataKeyReusePeriodSeconds": cdk.numberToCloudFormation(properties.kmsDataKeyReusePeriodSeconds),
    "KmsMasterKeyId": cdk.stringToCloudFormation(properties.kmsMasterKeyId),
    "MaximumMessageSize": cdk.numberToCloudFormation(properties.maximumMessageSize),
    "MessageRetentionPeriod": cdk.numberToCloudFormation(properties.messageRetentionPeriod),
    "QueueName": cdk.stringToCloudFormation(properties.queueName),
    "ReceiveMessageWaitTimeSeconds": cdk.numberToCloudFormation(properties.receiveMessageWaitTimeSeconds),
    "RedriveAllowPolicy": cdk.unionMapper([cdk.validateObject, cdk.validateString], [cdk.objectToCloudFormation, cdk.stringToCloudFormation])(properties.redriveAllowPolicy),
    "RedrivePolicy": cdk.unionMapper([cdk.validateObject, cdk.validateString], [cdk.objectToCloudFormation, cdk.stringToCloudFormation])(properties.redrivePolicy),
    "SqsManagedSseEnabled": cdk.booleanToCloudFormation(properties.sqsManagedSseEnabled),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags),
    "VisibilityTimeout": cdk.numberToCloudFormation(properties.visibilityTimeout)
  };
}

// @ts-ignore TS6133
function CfnQueuePropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnQueueProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnQueueProps>();
  ret.addPropertyResult("contentBasedDeduplication", "ContentBasedDeduplication", (properties.ContentBasedDeduplication != null ? cfn_parse.FromCloudFormation.getBoolean(properties.ContentBasedDeduplication) : undefined));
  ret.addPropertyResult("deduplicationScope", "DeduplicationScope", (properties.DeduplicationScope != null ? cfn_parse.FromCloudFormation.getString(properties.DeduplicationScope) : undefined));
  ret.addPropertyResult("delaySeconds", "DelaySeconds", (properties.DelaySeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.DelaySeconds) : undefined));
  ret.addPropertyResult("fifoQueue", "FifoQueue", (properties.FifoQueue != null ? cfn_parse.FromCloudFormation.getBoolean(properties.FifoQueue) : undefined));
  ret.addPropertyResult("fifoThroughputLimit", "FifoThroughputLimit", (properties.FifoThroughputLimit != null ? cfn_parse.FromCloudFormation.getString(properties.FifoThroughputLimit) : undefined));
  ret.addPropertyResult("kmsDataKeyReusePeriodSeconds", "KmsDataKeyReusePeriodSeconds", (properties.KmsDataKeyReusePeriodSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.KmsDataKeyReusePeriodSeconds) : undefined));
  ret.addPropertyResult("kmsMasterKeyId", "KmsMasterKeyId", (properties.KmsMasterKeyId != null ? cfn_parse.FromCloudFormation.getString(properties.KmsMasterKeyId) : undefined));
  ret.addPropertyResult("maximumMessageSize", "MaximumMessageSize", (properties.MaximumMessageSize != null ? cfn_parse.FromCloudFormation.getNumber(properties.MaximumMessageSize) : undefined));
  ret.addPropertyResult("messageRetentionPeriod", "MessageRetentionPeriod", (properties.MessageRetentionPeriod != null ? cfn_parse.FromCloudFormation.getNumber(properties.MessageRetentionPeriod) : undefined));
  ret.addPropertyResult("queueName", "QueueName", (properties.QueueName != null ? cfn_parse.FromCloudFormation.getString(properties.QueueName) : undefined));
  ret.addPropertyResult("receiveMessageWaitTimeSeconds", "ReceiveMessageWaitTimeSeconds", (properties.ReceiveMessageWaitTimeSeconds != null ? cfn_parse.FromCloudFormation.getNumber(properties.ReceiveMessageWaitTimeSeconds) : undefined));
  ret.addPropertyResult("redriveAllowPolicy", "RedriveAllowPolicy", (properties.RedriveAllowPolicy != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateObject, cdk.validateString], [cfn_parse.FromCloudFormation.getAny, cfn_parse.FromCloudFormation.getString])(properties.RedriveAllowPolicy) : undefined));
  ret.addPropertyResult("redrivePolicy", "RedrivePolicy", (properties.RedrivePolicy != null ? cfn_parse.FromCloudFormation.getTypeUnion([cdk.validateObject, cdk.validateString], [cfn_parse.FromCloudFormation.getAny, cfn_parse.FromCloudFormation.getString])(properties.RedrivePolicy) : undefined));
  ret.addPropertyResult("sqsManagedSseEnabled", "SqsManagedSseEnabled", (properties.SqsManagedSseEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SqsManagedSseEnabled) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addPropertyResult("visibilityTimeout", "VisibilityTimeout", (properties.VisibilityTimeout != null ? cfn_parse.FromCloudFormation.getNumber(properties.VisibilityTimeout) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * The \`AWS::SQS::QueuePolicy\` type applies a policy to Amazon SQS queues.
 *
 * For an example snippet, see [Declaring an Amazon SQS policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-iam.html#scenario-sqs-policy) in the *AWS CloudFormation User Guide* .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html
 */
export class CfnQueuePolicy extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::SQS::QueuePolicy";

  /**
   * Build a CfnQueuePolicy from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnQueuePolicy {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnQueuePolicyPropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnQueuePolicy(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * A policy document that contains the permissions for the specified Amazon SQS queues.
   */
  public policyDocument: any | cdk.IResolvable;

  /**
   * The URLs of the queues to which you want to add the policy.
   */
  public queues: Array<string>;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnQueuePolicyProps) {
    super(scope, id, {
      "type": CfnQueuePolicy.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "policyDocument", this);
    cdk.requireProperty(props, "queues", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.policyDocument = props.policyDocument;
    this.queues = props.queues;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "policyDocument": this.policyDocument,
      "queues": this.queues
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnQueuePolicy.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnQueuePolicyPropsToCloudFormation(props);
  }
}

/**
 * Properties for defining a \`CfnQueuePolicy\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html
 */
export interface CfnQueuePolicyProps {
  /**
   * A policy document that contains the permissions for the specified Amazon SQS queues.
   *
   * For more information about Amazon SQS policies, see [Using custom policies with the Amazon SQS access policy language](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-creating-custom-policies.html) in the *Amazon SQS Developer Guide* .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html#cfn-sqs-queuepolicy-policydocument
   */
  readonly policyDocument: any | cdk.IResolvable;

  /**
   * The URLs of the queues to which you want to add the policy.
   *
   * You can use the \`[Ref](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-ref.html)\` function to specify an \`[AWS::SQS::Queue](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queues.html)\` resource.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-queuepolicy.html#cfn-sqs-queuepolicy-queues
   */
  readonly queues: Array<string>;
}

/**
 * Determine whether the given properties match those of a \`CfnQueuePolicyProps\`
 *
 * @param properties - the TypeScript properties of a \`CfnQueuePolicyProps\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnQueuePolicyPropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("policyDocument", cdk.requiredValidator)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("policyDocument", cdk.validateObject)(properties.policyDocument));
  errors.collect(cdk.propertyValidator("queues", cdk.requiredValidator)(properties.queues));
  errors.collect(cdk.propertyValidator("queues", cdk.listValidator(cdk.validateString))(properties.queues));
  return errors.wrap("supplied properties not correct for \\"CfnQueuePolicyProps\\"");
}

// @ts-ignore TS6133
function convertCfnQueuePolicyPropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnQueuePolicyPropsValidator(properties).assertSuccess();
  return {
    "PolicyDocument": cdk.objectToCloudFormation(properties.policyDocument),
    "Queues": cdk.listMapper(cdk.stringToCloudFormation)(properties.queues)
  };
}

// @ts-ignore TS6133
function CfnQueuePolicyPropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnQueuePolicyProps | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnQueuePolicyProps>();
  ret.addPropertyResult("policyDocument", "PolicyDocument", (properties.PolicyDocument != null ? cfn_parse.FromCloudFormation.getAny(properties.PolicyDocument) : undefined));
  ret.addPropertyResult("queues", "Queues", (properties.Queues != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.Queues) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}",
}
`;

exports[`can codegen service with arbitrary suffix 1`] = `
"/* eslint-disable prettier/prettier,max-len */
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";
import * as cfn_parse from "aws-cdk-lib/core/lib/helpers-internal";

/**
 * Creates an Amazon Kinesis Data Analytics application.
 *
 * For information about creating a Kinesis Data Analytics application, see [Creating an Application](https://docs.aws.amazon.com/kinesisanalytics/latest/java/getting-started.html) .
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html
 */
export class CfnApplicationV2 extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::KinesisAnalyticsV2::Application";

  /**
   * Build a CfnApplicationV2 from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplicationV2 {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationV2PropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplicationV2(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * Use this parameter to configure the application.
   */
  public applicationConfiguration?: CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable;

  /**
   * The description of the application.
   */
  public applicationDescription?: string;

  /**
   * To create a Kinesis Data Analytics Studio notebook, you must set the mode to \`INTERACTIVE\` .
   */
  public applicationMode?: string;

  /**
   * The name of the application.
   */
  public applicationName?: string;

  /**
   * The runtime environment for the application.
   */
  public runtimeEnvironment: string;

  /**
   * Specifies the IAM role that the application uses to access external resources.
   */
  public serviceExecutionRole: string;

  /**
   * Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.
   */
  public runConfiguration?: cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty;

  /**
   * Describes the maintenance configuration for the application.
   */
  public applicationMaintenanceConfiguration?: CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable;

  /**
   * A list of one or more tags to assign to the application.
   */
  public readonly tags: cdk.TagManager;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationV2Props) {
    super(scope, id, {
      "type": CfnApplicationV2.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "runtimeEnvironment", this);
    cdk.requireProperty(props, "serviceExecutionRole", this);

    this.applicationConfiguration = props.applicationConfiguration;
    this.applicationDescription = props.applicationDescription;
    this.applicationMode = props.applicationMode;
    this.applicationName = props.applicationName;
    this.runtimeEnvironment = props.runtimeEnvironment;
    this.serviceExecutionRole = props.serviceExecutionRole;
    this.runConfiguration = props.runConfiguration;
    this.applicationMaintenanceConfiguration = props.applicationMaintenanceConfiguration;
    this.tags = new cdk.TagManager(cdk.TagType.STANDARD, "AWS::KinesisAnalyticsV2::Application", props.tags, {
      "tagPropertyName": "tags"
    });
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationConfiguration": this.applicationConfiguration,
      "applicationDescription": this.applicationDescription,
      "applicationMode": this.applicationMode,
      "applicationName": this.applicationName,
      "runtimeEnvironment": this.runtimeEnvironment,
      "serviceExecutionRole": this.serviceExecutionRole,
      "runConfiguration": this.runConfiguration,
      "applicationMaintenanceConfiguration": this.applicationMaintenanceConfiguration,
      "tags": this.tags.renderTags()
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplicationV2.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationV2PropsToCloudFormation(props);
  }
}

export namespace CfnApplicationV2 {
  /**
   * Specifies the creation parameters for a Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html
   */
  export interface ApplicationConfigurationProperty {
    /**
     * The code location and type parameters for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-applicationcodeconfiguration
     */
    readonly applicationCodeConfiguration?: CfnApplicationV2.ApplicationCodeConfigurationProperty | cdk.IResolvable;

    /**
     * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-applicationsnapshotconfiguration
     */
    readonly applicationSnapshotConfiguration?: CfnApplicationV2.ApplicationSnapshotConfigurationProperty | cdk.IResolvable;

    /**
     * Describes execution properties for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-environmentproperties
     */
    readonly environmentProperties?: CfnApplicationV2.EnvironmentPropertiesProperty | cdk.IResolvable;

    /**
     * The creation and update parameters for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-flinkapplicationconfiguration
     */
    readonly flinkApplicationConfiguration?: CfnApplicationV2.FlinkApplicationConfigurationProperty | cdk.IResolvable;

    /**
     * The creation and update parameters for a SQL-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-sqlapplicationconfiguration
     */
    readonly sqlApplicationConfiguration?: cdk.IResolvable | CfnApplicationV2.SqlApplicationConfigurationProperty;

    /**
     * The configuration parameters for a Kinesis Data Analytics Studio notebook.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-zeppelinapplicationconfiguration
     */
    readonly zeppelinApplicationConfiguration?: cdk.IResolvable | CfnApplicationV2.ZeppelinApplicationConfigurationProperty;

    /**
     * The array of descriptions of VPC configurations available to the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationconfiguration.html#cfn-kinesisanalyticsv2-application-applicationconfiguration-vpcconfigurations
     */
    readonly vpcConfigurations?: Array<cdk.IResolvable | CfnApplicationV2.VpcConfigurationProperty> | cdk.IResolvable;
  }

  /**
   * Describes code configuration for an application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationcodeconfiguration.html
   */
  export interface ApplicationCodeConfigurationProperty {
    /**
     * The location and type of the application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationcodeconfiguration.html#cfn-kinesisanalyticsv2-application-applicationcodeconfiguration-codecontent
     */
    readonly codeContent: CfnApplicationV2.CodeContentProperty | cdk.IResolvable;

    /**
     * Specifies whether the code content is in text or zip format.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationcodeconfiguration.html#cfn-kinesisanalyticsv2-application-applicationcodeconfiguration-codecontenttype
     */
    readonly codeContentType: string;
  }

  /**
   * Specifies either the application code, or the location of the application code, for a Flink-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-codecontent.html
   */
  export interface CodeContentProperty {
    /**
     * The zip-format code for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-codecontent.html#cfn-kinesisanalyticsv2-application-codecontent-zipfilecontent
     */
    readonly zipFileContent?: string;

    /**
     * Information about the Amazon S3 bucket that contains the application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-codecontent.html#cfn-kinesisanalyticsv2-application-codecontent-s3contentlocation
     */
    readonly s3ContentLocation?: cdk.IResolvable | CfnApplicationV2.S3ContentLocationProperty;

    /**
     * The text-format code for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-codecontent.html#cfn-kinesisanalyticsv2-application-codecontent-textcontent
     */
    readonly textContent?: string;
  }

  /**
   * The location of an application or a custom artifact.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentlocation.html
   */
  export interface S3ContentLocationProperty {
    /**
     * The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentlocation.html#cfn-kinesisanalyticsv2-application-s3contentlocation-bucketarn
     */
    readonly bucketArn: string;

    /**
     * The file key for the object containing the application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentlocation.html#cfn-kinesisanalyticsv2-application-s3contentlocation-filekey
     */
    readonly fileKey: string;

    /**
     * The version of the object containing the application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentlocation.html#cfn-kinesisanalyticsv2-application-s3contentlocation-objectversion
     */
    readonly objectVersion?: string;
  }

  /**
   * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationsnapshotconfiguration.html
   */
  export interface ApplicationSnapshotConfigurationProperty {
    /**
     * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationsnapshotconfiguration.html#cfn-kinesisanalyticsv2-application-applicationsnapshotconfiguration-snapshotsenabled
     */
    readonly snapshotsEnabled: boolean | cdk.IResolvable;
  }

  /**
   * Describes execution properties for a Flink-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-environmentproperties.html
   */
  export interface EnvironmentPropertiesProperty {
    /**
     * Describes the execution property groups.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-environmentproperties.html#cfn-kinesisanalyticsv2-application-environmentproperties-propertygroups
     */
    readonly propertyGroups?: Array<cdk.IResolvable | CfnApplicationV2.PropertyGroupProperty> | cdk.IResolvable;
  }

  /**
   * Property key-value pairs passed into an application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-propertygroup.html
   */
  export interface PropertyGroupProperty {
    /**
     * Describes the key of an application execution property key-value pair.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-propertygroup.html#cfn-kinesisanalyticsv2-application-propertygroup-propertygroupid
     */
    readonly propertyGroupId?: string;

    /**
     * Describes the value of an application execution property key-value pair.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-propertygroup.html#cfn-kinesisanalyticsv2-application-propertygroup-propertymap
     */
    readonly propertyMap?: cdk.IResolvable | Record<string, string>;
  }

  /**
   * Describes configuration parameters for a Flink-based Kinesis Data Analytics application or a Studio notebook.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-flinkapplicationconfiguration.html
   */
  export interface FlinkApplicationConfigurationProperty {
    /**
     * Describes an application's checkpointing configuration.
     *
     * Checkpointing is the process of persisting application state for fault tolerance. For more information, see [Checkpoints for Fault Tolerance](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance) in the [Apache Flink Documentation](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-flinkapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-flinkapplicationconfiguration-checkpointconfiguration
     */
    readonly checkpointConfiguration?: CfnApplicationV2.CheckpointConfigurationProperty | cdk.IResolvable;

    /**
     * Describes configuration parameters for Amazon CloudWatch logging for an application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-flinkapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-flinkapplicationconfiguration-monitoringconfiguration
     */
    readonly monitoringConfiguration?: cdk.IResolvable | CfnApplicationV2.MonitoringConfigurationProperty;

    /**
     * Describes parameters for how an application executes multiple tasks simultaneously.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-flinkapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-flinkapplicationconfiguration-parallelismconfiguration
     */
    readonly parallelismConfiguration?: cdk.IResolvable | CfnApplicationV2.ParallelismConfigurationProperty;
  }

  /**
   * Describes an application's checkpointing configuration.
   *
   * Checkpointing is the process of persisting application state for fault tolerance. For more information, see [Checkpoints for Fault Tolerance](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance) in the [Apache Flink Documentation](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-checkpointconfiguration.html
   */
  export interface CheckpointConfigurationProperty {
    /**
     * Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior.
     *
     * You must set this property to \`CUSTOM\` in order to set the \`CheckpointingEnabled\` , \`CheckpointInterval\` , or \`MinPauseBetweenCheckpoints\` parameters.
     *
     * > If this value is set to \`DEFAULT\` , the application will use the following values, even if they are set to other values using APIs or application code:
     * >
     * > - *CheckpointingEnabled:* true
     * > - *CheckpointInterval:* 60000
     * > - *MinPauseBetweenCheckpoints:* 5000
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-checkpointconfiguration.html#cfn-kinesisanalyticsv2-application-checkpointconfiguration-configurationtype
     */
    readonly configurationType: string;

    /**
     * Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
     *
     * > If \`CheckpointConfiguration.ConfigurationType\` is \`DEFAULT\` , the application will use a \`CheckpointingEnabled\` value of \`true\` , even if this value is set to another value using this API or in application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-checkpointconfiguration.html#cfn-kinesisanalyticsv2-application-checkpointconfiguration-checkpointingenabled
     */
    readonly checkpointingEnabled?: boolean | cdk.IResolvable;

    /**
     * Describes the interval in milliseconds between checkpoint operations.
     *
     * > If \`CheckpointConfiguration.ConfigurationType\` is \`DEFAULT\` , the application will use a \`CheckpointInterval\` value of 60000, even if this value is set to another value using this API or in application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-checkpointconfiguration.html#cfn-kinesisanalyticsv2-application-checkpointconfiguration-checkpointinterval
     */
    readonly checkpointInterval?: number;

    /**
     * Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.
     *
     * If a checkpoint operation takes longer than the \`CheckpointInterval\` , the application otherwise performs continual checkpoint operations. For more information, see [Tuning Checkpointing](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/large_state_tuning.html#tuning-checkpointing) in the [Apache Flink Documentation](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/) .
     *
     * > If \`CheckpointConfiguration.ConfigurationType\` is \`DEFAULT\` , the application will use a \`MinPauseBetweenCheckpoints\` value of 5000, even if this value is set using this API or in application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-checkpointconfiguration.html#cfn-kinesisanalyticsv2-application-checkpointconfiguration-minpausebetweencheckpoints
     */
    readonly minPauseBetweenCheckpoints?: number;
  }

  /**
   * Describes configuration parameters for Amazon CloudWatch logging for a Java-based Kinesis Data Analytics application.
   *
   * For more information about CloudWatch logging, see [Monitoring](https://docs.aws.amazon.com/kinesisanalytics/latest/java/monitoring-overview) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-monitoringconfiguration.html
   */
  export interface MonitoringConfigurationProperty {
    /**
     * Describes whether to use the default CloudWatch logging configuration for an application.
     *
     * You must set this property to \`CUSTOM\` in order to set the \`LogLevel\` or \`MetricsLevel\` parameters.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-monitoringconfiguration.html#cfn-kinesisanalyticsv2-application-monitoringconfiguration-configurationtype
     */
    readonly configurationType: string;

    /**
     * Describes the granularity of the CloudWatch Logs for an application.
     *
     * The \`Parallelism\` level is not recommended for applications with a Parallelism over 64 due to excessive costs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-monitoringconfiguration.html#cfn-kinesisanalyticsv2-application-monitoringconfiguration-metricslevel
     */
    readonly metricsLevel?: string;

    /**
     * Describes the verbosity of the CloudWatch Logs for an application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-monitoringconfiguration.html#cfn-kinesisanalyticsv2-application-monitoringconfiguration-loglevel
     */
    readonly logLevel?: string;
  }

  /**
   * Describes parameters for how a Flink-based Kinesis Data Analytics application executes multiple tasks simultaneously.
   *
   * For more information about parallelism, see [Parallel Execution](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/parallel.html) in the [Apache Flink Documentation](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-parallelismconfiguration.html
   */
  export interface ParallelismConfigurationProperty {
    /**
     * Describes whether the application uses the default parallelism for the Kinesis Data Analytics service.
     *
     * You must set this property to \`CUSTOM\` in order to change your application's \`AutoScalingEnabled\` , \`Parallelism\` , or \`ParallelismPerKPU\` properties.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-parallelismconfiguration.html#cfn-kinesisanalyticsv2-application-parallelismconfiguration-configurationtype
     */
    readonly configurationType: string;

    /**
     * Describes the number of parallel tasks that a Java-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application.
     *
     * For more information about KPUs, see [Amazon Kinesis Data Analytics Pricing](https://docs.aws.amazon.com/kinesis/data-analytics/pricing/) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-parallelismconfiguration.html#cfn-kinesisanalyticsv2-application-parallelismconfiguration-parallelismperkpu
     */
    readonly parallelismPerKpu?: number;

    /**
     * Describes the initial number of parallel tasks that a Java-based Kinesis Data Analytics application can perform.
     *
     * The Kinesis Data Analytics service can increase this number automatically if [ParallelismConfiguration:AutoScalingEnabled](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_ParallelismConfiguration.html#kinesisanalytics-Type-ParallelismConfiguration-AutoScalingEnabled.html) is set to \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-parallelismconfiguration.html#cfn-kinesisanalyticsv2-application-parallelismconfiguration-parallelism
     */
    readonly parallelism?: number;

    /**
     * Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-parallelismconfiguration.html#cfn-kinesisanalyticsv2-application-parallelismconfiguration-autoscalingenabled
     */
    readonly autoScalingEnabled?: boolean | cdk.IResolvable;
  }

  /**
   * Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-sqlapplicationconfiguration.html
   */
  export interface SqlApplicationConfigurationProperty {
    /**
     * The array of [Input](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_Input.html) objects describing the input streams used by the application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-sqlapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-sqlapplicationconfiguration-inputs
     */
    readonly inputs?: Array<CfnApplicationV2.InputProperty | cdk.IResolvable> | cdk.IResolvable;
  }

  /**
   * When you configure the application input for a SQL-based Kinesis Data Analytics application, you specify the streaming source, the in-application stream name that is created, and the mapping between the two.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html
   */
  export interface InputProperty {
    /**
     * The name prefix to use when creating an in-application stream.
     *
     * Suppose that you specify a prefix " \`MyInApplicationStream\` ." Kinesis Data Analytics then creates one or more (as per the \`InputParallelism\` count you specified) in-application streams with the names " \`MyInApplicationStream_001\` ," " \`MyInApplicationStream_002\` ," and so on.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html#cfn-kinesisanalyticsv2-application-input-nameprefix
     */
    readonly namePrefix: string;

    /**
     * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
     *
     * Also used to describe the format of the reference data source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html#cfn-kinesisanalyticsv2-application-input-inputschema
     */
    readonly inputSchema: CfnApplicationV2.InputSchemaProperty | cdk.IResolvable;

    /**
     * If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html#cfn-kinesisanalyticsv2-application-input-kinesisstreamsinput
     */
    readonly kinesisStreamsInput?: cdk.IResolvable | CfnApplicationV2.KinesisStreamsInputProperty;

    /**
     * If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html#cfn-kinesisanalyticsv2-application-input-kinesisfirehoseinput
     */
    readonly kinesisFirehoseInput?: cdk.IResolvable | CfnApplicationV2.KinesisFirehoseInputProperty;

    /**
     * The [InputProcessingConfiguration](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_InputProcessingConfiguration.html) for the input. An input processor transforms records as they are received from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is [InputLambdaProcessor](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_InputLambdaProcessor.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html#cfn-kinesisanalyticsv2-application-input-inputprocessingconfiguration
     */
    readonly inputProcessingConfiguration?: CfnApplicationV2.InputProcessingConfigurationProperty | cdk.IResolvable;

    /**
     * Describes the number of in-application streams to create.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-input.html#cfn-kinesisanalyticsv2-application-input-inputparallelism
     */
    readonly inputParallelism?: CfnApplicationV2.InputParallelismProperty | cdk.IResolvable;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputschema.html
   */
  export interface InputSchemaProperty {
    /**
     * Specifies the encoding of the records in the streaming source.
     *
     * For example, UTF-8.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputschema.html#cfn-kinesisanalyticsv2-application-inputschema-recordencoding
     */
    readonly recordEncoding?: string;

    /**
     * A list of \`RecordColumn\` objects.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputschema.html#cfn-kinesisanalyticsv2-application-inputschema-recordcolumns
     */
    readonly recordColumns: Array<cdk.IResolvable | CfnApplicationV2.RecordColumnProperty> | cdk.IResolvable;

    /**
     * Specifies the format of the records on the streaming source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputschema.html#cfn-kinesisanalyticsv2-application-inputschema-recordformat
     */
    readonly recordFormat: cdk.IResolvable | CfnApplicationV2.RecordFormatProperty;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
   *
   * Also used to describe the format of the reference data source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordcolumn.html
   */
  export interface RecordColumnProperty {
    /**
     * A reference to the data element in the streaming input or the reference data source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordcolumn.html#cfn-kinesisanalyticsv2-application-recordcolumn-mapping
     */
    readonly mapping?: string;

    /**
     * The name of the column that is created in the in-application input stream or reference table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordcolumn.html#cfn-kinesisanalyticsv2-application-recordcolumn-name
     */
    readonly name: string;

    /**
     * The type of column created in the in-application input stream or reference table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordcolumn.html#cfn-kinesisanalyticsv2-application-recordcolumn-sqltype
     */
    readonly sqlType: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the record format and relevant mapping information that should be applied to schematize the records on the stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordformat.html
   */
  export interface RecordFormatProperty {
    /**
     * The type of record format.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordformat.html#cfn-kinesisanalyticsv2-application-recordformat-recordformattype
     */
    readonly recordFormatType: string;

    /**
     * When you configure application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-recordformat.html#cfn-kinesisanalyticsv2-application-recordformat-mappingparameters
     */
    readonly mappingParameters?: cdk.IResolvable | CfnApplicationV2.MappingParametersProperty;
  }

  /**
   * When you configure a SQL-based Kinesis Data Analytics application's input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mappingparameters.html
   */
  export interface MappingParametersProperty {
    /**
     * Provides additional mapping information when the record format uses delimiters (for example, CSV).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mappingparameters.html#cfn-kinesisanalyticsv2-application-mappingparameters-csvmappingparameters
     */
    readonly csvMappingParameters?: CfnApplicationV2.CSVMappingParametersProperty | cdk.IResolvable;

    /**
     * Provides additional mapping information when JSON is the record format on the streaming source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mappingparameters.html#cfn-kinesisanalyticsv2-application-mappingparameters-jsonmappingparameters
     */
    readonly jsonMappingParameters?: cdk.IResolvable | CfnApplicationV2.JSONMappingParametersProperty;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, provides additional mapping information when the record format uses delimiters, such as CSV.
   *
   * For example, the following sample records use CSV format, where the records use the *'\\n'* as the row delimiter and a comma (",") as the column delimiter:
   *
   * \`"name1", "address1"\`
   *
   * \`"name2", "address2"\`
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-csvmappingparameters.html
   */
  export interface CSVMappingParametersProperty {
    /**
     * The column delimiter.
     *
     * For example, in a CSV format, a comma (",") is the typical column delimiter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-csvmappingparameters.html#cfn-kinesisanalyticsv2-application-csvmappingparameters-recordcolumndelimiter
     */
    readonly recordColumnDelimiter: string;

    /**
     * The row delimiter.
     *
     * For example, in a CSV format, *'\\n'* is the typical row delimiter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-csvmappingparameters.html#cfn-kinesisanalyticsv2-application-csvmappingparameters-recordrowdelimiter
     */
    readonly recordRowDelimiter: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, provides additional mapping information when JSON is the record format on the streaming source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-jsonmappingparameters.html
   */
  export interface JSONMappingParametersProperty {
    /**
     * The path to the top-level parent that contains the records.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-jsonmappingparameters.html#cfn-kinesisanalyticsv2-application-jsonmappingparameters-recordrowpath
     */
    readonly recordRowPath: string;
  }

  /**
   * Identifies a Kinesis data stream as the streaming source.
   *
   * You provide the stream's Amazon Resource Name (ARN).
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-kinesisstreamsinput.html
   */
  export interface KinesisStreamsInputProperty {
    /**
     * The ARN of the input Kinesis data stream to read.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-kinesisstreamsinput.html#cfn-kinesisanalyticsv2-application-kinesisstreamsinput-resourcearn
     */
    readonly resourceArn: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, identifies a Kinesis Data Firehose delivery stream as the streaming source.
   *
   * You provide the delivery stream's Amazon Resource Name (ARN).
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-kinesisfirehoseinput.html
   */
  export interface KinesisFirehoseInputProperty {
    /**
     * The Amazon Resource Name (ARN) of the delivery stream.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-kinesisfirehoseinput.html#cfn-kinesisanalyticsv2-application-kinesisfirehoseinput-resourcearn
     */
    readonly resourceArn: string;
  }

  /**
   * For an SQL-based Amazon Kinesis Data Analytics application, describes a processor that is used to preprocess the records in the stream before being processed by your application code.
   *
   * Currently, the only input processor available is [Amazon Lambda](https://docs.aws.amazon.com/lambda/) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputprocessingconfiguration.html
   */
  export interface InputProcessingConfigurationProperty {
    /**
     * The [InputLambdaProcessor](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_InputLambdaProcessor.html) that is used to preprocess the records in the stream before being processed by your application code.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputprocessingconfiguration.html#cfn-kinesisanalyticsv2-application-inputprocessingconfiguration-inputlambdaprocessor
     */
    readonly inputLambdaProcessor?: CfnApplicationV2.InputLambdaProcessorProperty | cdk.IResolvable;
  }

  /**
   * An object that contains the Amazon Resource Name (ARN) of the Amazon Lambda function that is used to preprocess records in the stream in a SQL-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputlambdaprocessor.html
   */
  export interface InputLambdaProcessorProperty {
    /**
     * The ARN of the Amazon Lambda function that operates on records in the stream.
     *
     * > To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com//general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputlambdaprocessor.html#cfn-kinesisanalyticsv2-application-inputlambdaprocessor-resourcearn
     */
    readonly resourceArn: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the number of in-application streams to create for a given streaming source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputparallelism.html
   */
  export interface InputParallelismProperty {
    /**
     * The number of in-application streams to create.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-inputparallelism.html#cfn-kinesisanalyticsv2-application-inputparallelism-count
     */
    readonly count?: number;
  }

  /**
   * The configuration of a Kinesis Data Analytics Studio notebook.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinapplicationconfiguration.html
   */
  export interface ZeppelinApplicationConfigurationProperty {
    /**
     * The Amazon Glue Data Catalog that you use in queries in a Kinesis Data Analytics Studio notebook.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-zeppelinapplicationconfiguration-catalogconfiguration
     */
    readonly catalogConfiguration?: CfnApplicationV2.CatalogConfigurationProperty | cdk.IResolvable;

    /**
     * The monitoring configuration of a Kinesis Data Analytics Studio notebook.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-zeppelinapplicationconfiguration-monitoringconfiguration
     */
    readonly monitoringConfiguration?: cdk.IResolvable | CfnApplicationV2.ZeppelinMonitoringConfigurationProperty;

    /**
     * The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-zeppelinapplicationconfiguration-deployasapplicationconfiguration
     */
    readonly deployAsApplicationConfiguration?: CfnApplicationV2.DeployAsApplicationConfigurationProperty | cdk.IResolvable;

    /**
     * A list of \`CustomArtifactConfiguration\` objects.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-zeppelinapplicationconfiguration-customartifactsconfiguration
     */
    readonly customArtifactsConfiguration?: Array<CfnApplicationV2.CustomArtifactConfigurationProperty | cdk.IResolvable> | cdk.IResolvable;
  }

  /**
   * The configuration parameters for the default Amazon Glue database.
   *
   * You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-catalogconfiguration.html
   */
  export interface CatalogConfigurationProperty {
    /**
     * The configuration parameters for the default Amazon Glue database.
     *
     * You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-catalogconfiguration.html#cfn-kinesisanalyticsv2-application-catalogconfiguration-gluedatacatalogconfiguration
     */
    readonly glueDataCatalogConfiguration?: CfnApplicationV2.GlueDataCatalogConfigurationProperty | cdk.IResolvable;
  }

  /**
   * The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-gluedatacatalogconfiguration.html
   */
  export interface GlueDataCatalogConfigurationProperty {
    /**
     * The Amazon Resource Name (ARN) of the database.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-gluedatacatalogconfiguration.html#cfn-kinesisanalyticsv2-application-gluedatacatalogconfiguration-databasearn
     */
    readonly databaseArn?: string;
  }

  /**
   * Describes configuration parameters for Amazon CloudWatch logging for a Kinesis Data Analytics Studio notebook.
   *
   * For more information about CloudWatch logging, see [Monitoring](https://docs.aws.amazon.com/kinesisanalytics/latest/java/monitoring-overview.html) .
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinmonitoringconfiguration.html
   */
  export interface ZeppelinMonitoringConfigurationProperty {
    /**
     * The verbosity of the CloudWatch Logs for an application.
     *
     * You can set it to \`INFO\` , \`WARN\` , \`ERROR\` , or \`DEBUG\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-zeppelinmonitoringconfiguration.html#cfn-kinesisanalyticsv2-application-zeppelinmonitoringconfiguration-loglevel
     */
    readonly logLevel?: string;
  }

  /**
   * The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-deployasapplicationconfiguration.html
   */
  export interface DeployAsApplicationConfigurationProperty {
    /**
     * The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-deployasapplicationconfiguration.html#cfn-kinesisanalyticsv2-application-deployasapplicationconfiguration-s3contentlocation
     */
    readonly s3ContentLocation: cdk.IResolvable | CfnApplicationV2.S3ContentBaseLocationProperty;
  }

  /**
   * The base location of the Amazon Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentbaselocation.html
   */
  export interface S3ContentBaseLocationProperty {
    /**
     * The Amazon Resource Name (ARN) of the S3 bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentbaselocation.html#cfn-kinesisanalyticsv2-application-s3contentbaselocation-bucketarn
     */
    readonly bucketArn: string;

    /**
     * The base path for the S3 bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-s3contentbaselocation.html#cfn-kinesisanalyticsv2-application-s3contentbaselocation-basepath
     */
    readonly basePath?: string;
  }

  /**
   * The configuration of connectors and user-defined functions.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-customartifactconfiguration.html
   */
  export interface CustomArtifactConfigurationProperty {
    /**
     * Set this to either \`UDF\` or \`DEPENDENCY_JAR\` .
     *
     * \`UDF\` stands for user-defined functions. This type of artifact must be in an S3 bucket. A \`DEPENDENCY_JAR\` can be in either Maven or an S3 bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-customartifactconfiguration.html#cfn-kinesisanalyticsv2-application-customartifactconfiguration-artifacttype
     */
    readonly artifactType: string;

    /**
     * The parameters required to fully specify a Maven reference.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-customartifactconfiguration.html#cfn-kinesisanalyticsv2-application-customartifactconfiguration-mavenreference
     */
    readonly mavenReference?: cdk.IResolvable | CfnApplicationV2.MavenReferenceProperty;

    /**
     * The location of the custom artifacts.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-customartifactconfiguration.html#cfn-kinesisanalyticsv2-application-customartifactconfiguration-s3contentlocation
     */
    readonly s3ContentLocation?: cdk.IResolvable | CfnApplicationV2.S3ContentLocationProperty;
  }

  /**
   * The information required to specify a Maven reference.
   *
   * You can use Maven references to specify dependency JAR files.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mavenreference.html
   */
  export interface MavenReferenceProperty {
    /**
     * The artifact ID of the Maven reference.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mavenreference.html#cfn-kinesisanalyticsv2-application-mavenreference-artifactid
     */
    readonly artifactId: string;

    /**
     * The group ID of the Maven reference.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mavenreference.html#cfn-kinesisanalyticsv2-application-mavenreference-groupid
     */
    readonly groupId: string;

    /**
     * The version of the Maven reference.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-mavenreference.html#cfn-kinesisanalyticsv2-application-mavenreference-version
     */
    readonly version: string;
  }

  /**
   * Describes the parameters of a VPC used by the application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-vpcconfiguration.html
   */
  export interface VpcConfigurationProperty {
    /**
     * The array of [SecurityGroup](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html) IDs used by the VPC configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-vpcconfiguration.html#cfn-kinesisanalyticsv2-application-vpcconfiguration-securitygroupids
     */
    readonly securityGroupIds: Array<string>;

    /**
     * The array of [Subnet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html) IDs used by the VPC configuration.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-vpcconfiguration.html#cfn-kinesisanalyticsv2-application-vpcconfiguration-subnetids
     */
    readonly subnetIds: Array<string>;
  }

  /**
   * Describes the starting parameters for an Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html
   */
  export interface RunConfigurationProperty {
    /**
     * Describes the restore behavior of a restarting application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-applicationrestoreconfiguration
     */
    readonly applicationRestoreConfiguration?: CfnApplicationV2.ApplicationRestoreConfigurationProperty | cdk.IResolvable;

    /**
     * Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-runconfiguration.html#cfn-kinesisanalyticsv2-application-runconfiguration-flinkrunconfiguration
     */
    readonly flinkRunConfiguration?: CfnApplicationV2.FlinkRunConfigurationProperty | cdk.IResolvable;
  }

  /**
   * Specifies the method and snapshot to use when restarting an application using previously saved application state.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationrestoreconfiguration.html
   */
  export interface ApplicationRestoreConfigurationProperty {
    /**
     * Specifies how the application should be restored.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationrestoreconfiguration.html#cfn-kinesisanalyticsv2-application-applicationrestoreconfiguration-applicationrestoretype
     */
    readonly applicationRestoreType: string;

    /**
     * The identifier of an existing snapshot of application state to use to restart an application.
     *
     * The application uses this value if \`RESTORE_FROM_CUSTOM_SNAPSHOT\` is specified for the \`ApplicationRestoreType\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationrestoreconfiguration.html#cfn-kinesisanalyticsv2-application-applicationrestoreconfiguration-snapshotname
     */
    readonly snapshotName?: string;
  }

  /**
   * Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-flinkrunconfiguration.html
   */
  export interface FlinkRunConfigurationProperty {
    /**
     * When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program.
     *
     * This will happen if the program is updated between snapshots to remove stateful parameters, and state data in the snapshot no longer corresponds to valid application data. For more information, see [Allowing Non-Restored State](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/savepoints.html#allowing-non-restored-state) in the [Apache Flink documentation](https://docs.aws.amazon.com/https://ci.apache.org/projects/flink/flink-docs-release-1.8/) .
     *
     * > This value defaults to \`false\` . If you update your application without specifying this parameter, \`AllowNonRestoredState\` will be set to \`false\` , even if it was previously set to \`true\` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-flinkrunconfiguration.html#cfn-kinesisanalyticsv2-application-flinkrunconfiguration-allownonrestoredstate
     */
    readonly allowNonRestoredState?: boolean | cdk.IResolvable;
  }

  /**
   * Specifies the maintence window parameters for a Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html
   */
  export interface ApplicationMaintenanceConfigurationProperty {
    /**
     * Specifies the start time of the maintence window.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-application-applicationmaintenanceconfiguration.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration-applicationmaintenancewindowstarttime
     */
    readonly applicationMaintenanceWindowStartTime: string;
  }
}

/**
 * Properties for defining a \`CfnApplication\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html
 */
export interface CfnApplicationV2Props {
  /**
   * Use this parameter to configure the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationconfiguration
   */
  readonly applicationConfiguration?: CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable;

  /**
   * The description of the application.
   *
   * @default - ""
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationdescription
   */
  readonly applicationDescription?: string;

  /**
   * To create a Kinesis Data Analytics Studio notebook, you must set the mode to \`INTERACTIVE\` .
   *
   * However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationmode
   */
  readonly applicationMode?: string;

  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationname
   */
  readonly applicationName?: string;

  /**
   * The runtime environment for the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-runtimeenvironment
   */
  readonly runtimeEnvironment: string;

  /**
   * Specifies the IAM role that the application uses to access external resources.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-serviceexecutionrole
   */
  readonly serviceExecutionRole: string;

  /**
   * Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.
   *
   * This section is evaluated only on stack updates for applications in running RUNNING state and has no effect during manual application start.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-runconfiguration
   */
  readonly runConfiguration?: cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty;

  /**
   * Describes the maintenance configuration for the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-applicationmaintenanceconfiguration
   */
  readonly applicationMaintenanceConfiguration?: CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable;

  /**
   * A list of one or more tags to assign to the application.
   *
   * A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-application.html#cfn-kinesisanalyticsv2-application-tags
   */
  readonly tags?: Array<cdk.CfnTag>;
}

/**
 * Determine whether the given properties match those of a \`S3ContentLocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3ContentLocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2S3ContentLocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucketArn", cdk.requiredValidator)(properties.bucketArn));
  errors.collect(cdk.propertyValidator("bucketArn", cdk.validateString)(properties.bucketArn));
  errors.collect(cdk.propertyValidator("fileKey", cdk.requiredValidator)(properties.fileKey));
  errors.collect(cdk.propertyValidator("fileKey", cdk.validateString)(properties.fileKey));
  errors.collect(cdk.propertyValidator("objectVersion", cdk.validateString)(properties.objectVersion));
  return errors.wrap("supplied properties not correct for \\"S3ContentLocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2S3ContentLocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2S3ContentLocationPropertyValidator(properties).assertSuccess();
  return {
    "BucketARN": cdk.stringToCloudFormation(properties.bucketArn),
    "FileKey": cdk.stringToCloudFormation(properties.fileKey),
    "ObjectVersion": cdk.stringToCloudFormation(properties.objectVersion)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2S3ContentLocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.S3ContentLocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.S3ContentLocationProperty>();
  ret.addPropertyResult("bucketArn", "BucketARN", (properties.BucketARN != null ? cfn_parse.FromCloudFormation.getString(properties.BucketARN) : undefined));
  ret.addPropertyResult("fileKey", "FileKey", (properties.FileKey != null ? cfn_parse.FromCloudFormation.getString(properties.FileKey) : undefined));
  ret.addPropertyResult("objectVersion", "ObjectVersion", (properties.ObjectVersion != null ? cfn_parse.FromCloudFormation.getString(properties.ObjectVersion) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CodeContentProperty\`
 *
 * @param properties - the TypeScript properties of a \`CodeContentProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2CodeContentPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("s3ContentLocation", CfnApplicationV2S3ContentLocationPropertyValidator)(properties.s3ContentLocation));
  errors.collect(cdk.propertyValidator("textContent", cdk.validateString)(properties.textContent));
  errors.collect(cdk.propertyValidator("zipFileContent", cdk.validateString)(properties.zipFileContent));
  return errors.wrap("supplied properties not correct for \\"CodeContentProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2CodeContentPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2CodeContentPropertyValidator(properties).assertSuccess();
  return {
    "S3ContentLocation": convertCfnApplicationV2S3ContentLocationPropertyToCloudFormation(properties.s3ContentLocation),
    "TextContent": cdk.stringToCloudFormation(properties.textContent),
    "ZipFileContent": cdk.stringToCloudFormation(properties.zipFileContent)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2CodeContentPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.CodeContentProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.CodeContentProperty>();
  ret.addPropertyResult("s3ContentLocation", "S3ContentLocation", (properties.S3ContentLocation != null ? CfnApplicationV2S3ContentLocationPropertyFromCloudFormation(properties.S3ContentLocation) : undefined));
  ret.addPropertyResult("textContent", "TextContent", (properties.TextContent != null ? cfn_parse.FromCloudFormation.getString(properties.TextContent) : undefined));
  ret.addPropertyResult("zipFileContent", "ZipFileContent", (properties.ZipFileContent != null ? cfn_parse.FromCloudFormation.getString(properties.ZipFileContent) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApplicationCodeConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationCodeConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ApplicationCodeConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("codeContent", cdk.requiredValidator)(properties.codeContent));
  errors.collect(cdk.propertyValidator("codeContent", CfnApplicationV2CodeContentPropertyValidator)(properties.codeContent));
  errors.collect(cdk.propertyValidator("codeContentType", cdk.requiredValidator)(properties.codeContentType));
  errors.collect(cdk.propertyValidator("codeContentType", cdk.validateString)(properties.codeContentType));
  return errors.wrap("supplied properties not correct for \\"ApplicationCodeConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ApplicationCodeConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ApplicationCodeConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "CodeContent": convertCfnApplicationV2CodeContentPropertyToCloudFormation(properties.codeContent),
    "CodeContentType": cdk.stringToCloudFormation(properties.codeContentType)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ApplicationCodeConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.ApplicationCodeConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ApplicationCodeConfigurationProperty>();
  ret.addPropertyResult("codeContent", "CodeContent", (properties.CodeContent != null ? CfnApplicationV2CodeContentPropertyFromCloudFormation(properties.CodeContent) : undefined));
  ret.addPropertyResult("codeContentType", "CodeContentType", (properties.CodeContentType != null ? cfn_parse.FromCloudFormation.getString(properties.CodeContentType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApplicationSnapshotConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationSnapshotConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ApplicationSnapshotConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("snapshotsEnabled", cdk.requiredValidator)(properties.snapshotsEnabled));
  errors.collect(cdk.propertyValidator("snapshotsEnabled", cdk.validateBoolean)(properties.snapshotsEnabled));
  return errors.wrap("supplied properties not correct for \\"ApplicationSnapshotConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ApplicationSnapshotConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ApplicationSnapshotConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "SnapshotsEnabled": cdk.booleanToCloudFormation(properties.snapshotsEnabled)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ApplicationSnapshotConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.ApplicationSnapshotConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ApplicationSnapshotConfigurationProperty>();
  ret.addPropertyResult("snapshotsEnabled", "SnapshotsEnabled", (properties.SnapshotsEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.SnapshotsEnabled) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`PropertyGroupProperty\`
 *
 * @param properties - the TypeScript properties of a \`PropertyGroupProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2PropertyGroupPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("propertyGroupId", cdk.validateString)(properties.propertyGroupId));
  errors.collect(cdk.propertyValidator("propertyMap", cdk.hashValidator(cdk.validateString))(properties.propertyMap));
  return errors.wrap("supplied properties not correct for \\"PropertyGroupProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2PropertyGroupPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2PropertyGroupPropertyValidator(properties).assertSuccess();
  return {
    "PropertyGroupId": cdk.stringToCloudFormation(properties.propertyGroupId),
    "PropertyMap": cdk.hashMapper(cdk.stringToCloudFormation)(properties.propertyMap)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2PropertyGroupPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.PropertyGroupProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.PropertyGroupProperty>();
  ret.addPropertyResult("propertyGroupId", "PropertyGroupId", (properties.PropertyGroupId != null ? cfn_parse.FromCloudFormation.getString(properties.PropertyGroupId) : undefined));
  ret.addPropertyResult("propertyMap", "PropertyMap", (properties.PropertyMap != null ? cfn_parse.FromCloudFormation.getMap(cfn_parse.FromCloudFormation.getString)(properties.PropertyMap) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`EnvironmentPropertiesProperty\`
 *
 * @param properties - the TypeScript properties of a \`EnvironmentPropertiesProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2EnvironmentPropertiesPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("propertyGroups", cdk.listValidator(CfnApplicationV2PropertyGroupPropertyValidator))(properties.propertyGroups));
  return errors.wrap("supplied properties not correct for \\"EnvironmentPropertiesProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2EnvironmentPropertiesPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2EnvironmentPropertiesPropertyValidator(properties).assertSuccess();
  return {
    "PropertyGroups": cdk.listMapper(convertCfnApplicationV2PropertyGroupPropertyToCloudFormation)(properties.propertyGroups)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2EnvironmentPropertiesPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.EnvironmentPropertiesProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.EnvironmentPropertiesProperty>();
  ret.addPropertyResult("propertyGroups", "PropertyGroups", (properties.PropertyGroups != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2PropertyGroupPropertyFromCloudFormation)(properties.PropertyGroups) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CheckpointConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CheckpointConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2CheckpointConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("checkpointInterval", cdk.validateNumber)(properties.checkpointInterval));
  errors.collect(cdk.propertyValidator("checkpointingEnabled", cdk.validateBoolean)(properties.checkpointingEnabled));
  errors.collect(cdk.propertyValidator("configurationType", cdk.requiredValidator)(properties.configurationType));
  errors.collect(cdk.propertyValidator("configurationType", cdk.validateString)(properties.configurationType));
  errors.collect(cdk.propertyValidator("minPauseBetweenCheckpoints", cdk.validateNumber)(properties.minPauseBetweenCheckpoints));
  return errors.wrap("supplied properties not correct for \\"CheckpointConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2CheckpointConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2CheckpointConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "CheckpointInterval": cdk.numberToCloudFormation(properties.checkpointInterval),
    "CheckpointingEnabled": cdk.booleanToCloudFormation(properties.checkpointingEnabled),
    "ConfigurationType": cdk.stringToCloudFormation(properties.configurationType),
    "MinPauseBetweenCheckpoints": cdk.numberToCloudFormation(properties.minPauseBetweenCheckpoints)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2CheckpointConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.CheckpointConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.CheckpointConfigurationProperty>();
  ret.addPropertyResult("checkpointingEnabled", "CheckpointingEnabled", (properties.CheckpointingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.CheckpointingEnabled) : undefined));
  ret.addPropertyResult("checkpointInterval", "CheckpointInterval", (properties.CheckpointInterval != null ? cfn_parse.FromCloudFormation.getNumber(properties.CheckpointInterval) : undefined));
  ret.addPropertyResult("configurationType", "ConfigurationType", (properties.ConfigurationType != null ? cfn_parse.FromCloudFormation.getString(properties.ConfigurationType) : undefined));
  ret.addPropertyResult("minPauseBetweenCheckpoints", "MinPauseBetweenCheckpoints", (properties.MinPauseBetweenCheckpoints != null ? cfn_parse.FromCloudFormation.getNumber(properties.MinPauseBetweenCheckpoints) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MonitoringConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`MonitoringConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2MonitoringConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("configurationType", cdk.requiredValidator)(properties.configurationType));
  errors.collect(cdk.propertyValidator("configurationType", cdk.validateString)(properties.configurationType));
  errors.collect(cdk.propertyValidator("logLevel", cdk.validateString)(properties.logLevel));
  errors.collect(cdk.propertyValidator("metricsLevel", cdk.validateString)(properties.metricsLevel));
  return errors.wrap("supplied properties not correct for \\"MonitoringConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2MonitoringConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2MonitoringConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ConfigurationType": cdk.stringToCloudFormation(properties.configurationType),
    "LogLevel": cdk.stringToCloudFormation(properties.logLevel),
    "MetricsLevel": cdk.stringToCloudFormation(properties.metricsLevel)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2MonitoringConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.MonitoringConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.MonitoringConfigurationProperty>();
  ret.addPropertyResult("configurationType", "ConfigurationType", (properties.ConfigurationType != null ? cfn_parse.FromCloudFormation.getString(properties.ConfigurationType) : undefined));
  ret.addPropertyResult("logLevel", "LogLevel", (properties.LogLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LogLevel) : undefined));
  ret.addPropertyResult("metricsLevel", "MetricsLevel", (properties.MetricsLevel != null ? cfn_parse.FromCloudFormation.getString(properties.MetricsLevel) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ParallelismConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ParallelismConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ParallelismConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("autoScalingEnabled", cdk.validateBoolean)(properties.autoScalingEnabled));
  errors.collect(cdk.propertyValidator("configurationType", cdk.requiredValidator)(properties.configurationType));
  errors.collect(cdk.propertyValidator("configurationType", cdk.validateString)(properties.configurationType));
  errors.collect(cdk.propertyValidator("parallelism", cdk.validateNumber)(properties.parallelism));
  errors.collect(cdk.propertyValidator("parallelismPerKpu", cdk.validateNumber)(properties.parallelismPerKpu));
  return errors.wrap("supplied properties not correct for \\"ParallelismConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ParallelismConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ParallelismConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AutoScalingEnabled": cdk.booleanToCloudFormation(properties.autoScalingEnabled),
    "ConfigurationType": cdk.stringToCloudFormation(properties.configurationType),
    "Parallelism": cdk.numberToCloudFormation(properties.parallelism),
    "ParallelismPerKPU": cdk.numberToCloudFormation(properties.parallelismPerKpu)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ParallelismConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.ParallelismConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ParallelismConfigurationProperty>();
  ret.addPropertyResult("autoScalingEnabled", "AutoScalingEnabled", (properties.AutoScalingEnabled != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AutoScalingEnabled) : undefined));
  ret.addPropertyResult("configurationType", "ConfigurationType", (properties.ConfigurationType != null ? cfn_parse.FromCloudFormation.getString(properties.ConfigurationType) : undefined));
  ret.addPropertyResult("parallelism", "Parallelism", (properties.Parallelism != null ? cfn_parse.FromCloudFormation.getNumber(properties.Parallelism) : undefined));
  ret.addPropertyResult("parallelismPerKpu", "ParallelismPerKPU", (properties.ParallelismPerKPU != null ? cfn_parse.FromCloudFormation.getNumber(properties.ParallelismPerKPU) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FlinkApplicationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`FlinkApplicationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2FlinkApplicationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("checkpointConfiguration", CfnApplicationV2CheckpointConfigurationPropertyValidator)(properties.checkpointConfiguration));
  errors.collect(cdk.propertyValidator("monitoringConfiguration", CfnApplicationV2MonitoringConfigurationPropertyValidator)(properties.monitoringConfiguration));
  errors.collect(cdk.propertyValidator("parallelismConfiguration", CfnApplicationV2ParallelismConfigurationPropertyValidator)(properties.parallelismConfiguration));
  return errors.wrap("supplied properties not correct for \\"FlinkApplicationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2FlinkApplicationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2FlinkApplicationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "CheckpointConfiguration": convertCfnApplicationV2CheckpointConfigurationPropertyToCloudFormation(properties.checkpointConfiguration),
    "MonitoringConfiguration": convertCfnApplicationV2MonitoringConfigurationPropertyToCloudFormation(properties.monitoringConfiguration),
    "ParallelismConfiguration": convertCfnApplicationV2ParallelismConfigurationPropertyToCloudFormation(properties.parallelismConfiguration)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2FlinkApplicationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.FlinkApplicationConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.FlinkApplicationConfigurationProperty>();
  ret.addPropertyResult("checkpointConfiguration", "CheckpointConfiguration", (properties.CheckpointConfiguration != null ? CfnApplicationV2CheckpointConfigurationPropertyFromCloudFormation(properties.CheckpointConfiguration) : undefined));
  ret.addPropertyResult("monitoringConfiguration", "MonitoringConfiguration", (properties.MonitoringConfiguration != null ? CfnApplicationV2MonitoringConfigurationPropertyFromCloudFormation(properties.MonitoringConfiguration) : undefined));
  ret.addPropertyResult("parallelismConfiguration", "ParallelismConfiguration", (properties.ParallelismConfiguration != null ? CfnApplicationV2ParallelismConfigurationPropertyFromCloudFormation(properties.ParallelismConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RecordColumnProperty\`
 *
 * @param properties - the TypeScript properties of a \`RecordColumnProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2RecordColumnPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("mapping", cdk.validateString)(properties.mapping));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("sqlType", cdk.requiredValidator)(properties.sqlType));
  errors.collect(cdk.propertyValidator("sqlType", cdk.validateString)(properties.sqlType));
  return errors.wrap("supplied properties not correct for \\"RecordColumnProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2RecordColumnPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2RecordColumnPropertyValidator(properties).assertSuccess();
  return {
    "Mapping": cdk.stringToCloudFormation(properties.mapping),
    "Name": cdk.stringToCloudFormation(properties.name),
    "SqlType": cdk.stringToCloudFormation(properties.sqlType)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2RecordColumnPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.RecordColumnProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.RecordColumnProperty>();
  ret.addPropertyResult("mapping", "Mapping", (properties.Mapping != null ? cfn_parse.FromCloudFormation.getString(properties.Mapping) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("sqlType", "SqlType", (properties.SqlType != null ? cfn_parse.FromCloudFormation.getString(properties.SqlType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CSVMappingParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`CSVMappingParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2CSVMappingParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordColumnDelimiter", cdk.requiredValidator)(properties.recordColumnDelimiter));
  errors.collect(cdk.propertyValidator("recordColumnDelimiter", cdk.validateString)(properties.recordColumnDelimiter));
  errors.collect(cdk.propertyValidator("recordRowDelimiter", cdk.requiredValidator)(properties.recordRowDelimiter));
  errors.collect(cdk.propertyValidator("recordRowDelimiter", cdk.validateString)(properties.recordRowDelimiter));
  return errors.wrap("supplied properties not correct for \\"CSVMappingParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2CSVMappingParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2CSVMappingParametersPropertyValidator(properties).assertSuccess();
  return {
    "RecordColumnDelimiter": cdk.stringToCloudFormation(properties.recordColumnDelimiter),
    "RecordRowDelimiter": cdk.stringToCloudFormation(properties.recordRowDelimiter)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2CSVMappingParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.CSVMappingParametersProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.CSVMappingParametersProperty>();
  ret.addPropertyResult("recordColumnDelimiter", "RecordColumnDelimiter", (properties.RecordColumnDelimiter != null ? cfn_parse.FromCloudFormation.getString(properties.RecordColumnDelimiter) : undefined));
  ret.addPropertyResult("recordRowDelimiter", "RecordRowDelimiter", (properties.RecordRowDelimiter != null ? cfn_parse.FromCloudFormation.getString(properties.RecordRowDelimiter) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`JSONMappingParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`JSONMappingParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2JSONMappingParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordRowPath", cdk.requiredValidator)(properties.recordRowPath));
  errors.collect(cdk.propertyValidator("recordRowPath", cdk.validateString)(properties.recordRowPath));
  return errors.wrap("supplied properties not correct for \\"JSONMappingParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2JSONMappingParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2JSONMappingParametersPropertyValidator(properties).assertSuccess();
  return {
    "RecordRowPath": cdk.stringToCloudFormation(properties.recordRowPath)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2JSONMappingParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.JSONMappingParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.JSONMappingParametersProperty>();
  ret.addPropertyResult("recordRowPath", "RecordRowPath", (properties.RecordRowPath != null ? cfn_parse.FromCloudFormation.getString(properties.RecordRowPath) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MappingParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`MappingParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2MappingParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("csvMappingParameters", CfnApplicationV2CSVMappingParametersPropertyValidator)(properties.csvMappingParameters));
  errors.collect(cdk.propertyValidator("jsonMappingParameters", CfnApplicationV2JSONMappingParametersPropertyValidator)(properties.jsonMappingParameters));
  return errors.wrap("supplied properties not correct for \\"MappingParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2MappingParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2MappingParametersPropertyValidator(properties).assertSuccess();
  return {
    "CSVMappingParameters": convertCfnApplicationV2CSVMappingParametersPropertyToCloudFormation(properties.csvMappingParameters),
    "JSONMappingParameters": convertCfnApplicationV2JSONMappingParametersPropertyToCloudFormation(properties.jsonMappingParameters)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2MappingParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.MappingParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.MappingParametersProperty>();
  ret.addPropertyResult("csvMappingParameters", "CSVMappingParameters", (properties.CSVMappingParameters != null ? CfnApplicationV2CSVMappingParametersPropertyFromCloudFormation(properties.CSVMappingParameters) : undefined));
  ret.addPropertyResult("jsonMappingParameters", "JSONMappingParameters", (properties.JSONMappingParameters != null ? CfnApplicationV2JSONMappingParametersPropertyFromCloudFormation(properties.JSONMappingParameters) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RecordFormatProperty\`
 *
 * @param properties - the TypeScript properties of a \`RecordFormatProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2RecordFormatPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("mappingParameters", CfnApplicationV2MappingParametersPropertyValidator)(properties.mappingParameters));
  errors.collect(cdk.propertyValidator("recordFormatType", cdk.requiredValidator)(properties.recordFormatType));
  errors.collect(cdk.propertyValidator("recordFormatType", cdk.validateString)(properties.recordFormatType));
  return errors.wrap("supplied properties not correct for \\"RecordFormatProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2RecordFormatPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2RecordFormatPropertyValidator(properties).assertSuccess();
  return {
    "MappingParameters": convertCfnApplicationV2MappingParametersPropertyToCloudFormation(properties.mappingParameters),
    "RecordFormatType": cdk.stringToCloudFormation(properties.recordFormatType)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2RecordFormatPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.RecordFormatProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.RecordFormatProperty>();
  ret.addPropertyResult("mappingParameters", "MappingParameters", (properties.MappingParameters != null ? CfnApplicationV2MappingParametersPropertyFromCloudFormation(properties.MappingParameters) : undefined));
  ret.addPropertyResult("recordFormatType", "RecordFormatType", (properties.RecordFormatType != null ? cfn_parse.FromCloudFormation.getString(properties.RecordFormatType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InputSchemaProperty\`
 *
 * @param properties - the TypeScript properties of a \`InputSchemaProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2InputSchemaPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordColumns", cdk.requiredValidator)(properties.recordColumns));
  errors.collect(cdk.propertyValidator("recordColumns", cdk.listValidator(CfnApplicationV2RecordColumnPropertyValidator))(properties.recordColumns));
  errors.collect(cdk.propertyValidator("recordEncoding", cdk.validateString)(properties.recordEncoding));
  errors.collect(cdk.propertyValidator("recordFormat", cdk.requiredValidator)(properties.recordFormat));
  errors.collect(cdk.propertyValidator("recordFormat", CfnApplicationV2RecordFormatPropertyValidator)(properties.recordFormat));
  return errors.wrap("supplied properties not correct for \\"InputSchemaProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2InputSchemaPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2InputSchemaPropertyValidator(properties).assertSuccess();
  return {
    "RecordColumns": cdk.listMapper(convertCfnApplicationV2RecordColumnPropertyToCloudFormation)(properties.recordColumns),
    "RecordEncoding": cdk.stringToCloudFormation(properties.recordEncoding),
    "RecordFormat": convertCfnApplicationV2RecordFormatPropertyToCloudFormation(properties.recordFormat)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2InputSchemaPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.InputSchemaProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.InputSchemaProperty>();
  ret.addPropertyResult("recordColumns", "RecordColumns", (properties.RecordColumns != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2RecordColumnPropertyFromCloudFormation)(properties.RecordColumns) : undefined));
  ret.addPropertyResult("recordEncoding", "RecordEncoding", (properties.RecordEncoding != null ? cfn_parse.FromCloudFormation.getString(properties.RecordEncoding) : undefined));
  ret.addPropertyResult("recordFormat", "RecordFormat", (properties.RecordFormat != null ? CfnApplicationV2RecordFormatPropertyFromCloudFormation(properties.RecordFormat) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KinesisStreamsInputProperty\`
 *
 * @param properties - the TypeScript properties of a \`KinesisStreamsInputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2KinesisStreamsInputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceArn", cdk.requiredValidator)(properties.resourceArn));
  errors.collect(cdk.propertyValidator("resourceArn", cdk.validateString)(properties.resourceArn));
  return errors.wrap("supplied properties not correct for \\"KinesisStreamsInputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2KinesisStreamsInputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2KinesisStreamsInputPropertyValidator(properties).assertSuccess();
  return {
    "ResourceARN": cdk.stringToCloudFormation(properties.resourceArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2KinesisStreamsInputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.KinesisStreamsInputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.KinesisStreamsInputProperty>();
  ret.addPropertyResult("resourceArn", "ResourceARN", (properties.ResourceARN != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KinesisFirehoseInputProperty\`
 *
 * @param properties - the TypeScript properties of a \`KinesisFirehoseInputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2KinesisFirehoseInputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceArn", cdk.requiredValidator)(properties.resourceArn));
  errors.collect(cdk.propertyValidator("resourceArn", cdk.validateString)(properties.resourceArn));
  return errors.wrap("supplied properties not correct for \\"KinesisFirehoseInputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2KinesisFirehoseInputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2KinesisFirehoseInputPropertyValidator(properties).assertSuccess();
  return {
    "ResourceARN": cdk.stringToCloudFormation(properties.resourceArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2KinesisFirehoseInputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.KinesisFirehoseInputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.KinesisFirehoseInputProperty>();
  ret.addPropertyResult("resourceArn", "ResourceARN", (properties.ResourceARN != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InputLambdaProcessorProperty\`
 *
 * @param properties - the TypeScript properties of a \`InputLambdaProcessorProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2InputLambdaProcessorPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceArn", cdk.requiredValidator)(properties.resourceArn));
  errors.collect(cdk.propertyValidator("resourceArn", cdk.validateString)(properties.resourceArn));
  return errors.wrap("supplied properties not correct for \\"InputLambdaProcessorProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2InputLambdaProcessorPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2InputLambdaProcessorPropertyValidator(properties).assertSuccess();
  return {
    "ResourceARN": cdk.stringToCloudFormation(properties.resourceArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2InputLambdaProcessorPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.InputLambdaProcessorProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.InputLambdaProcessorProperty>();
  ret.addPropertyResult("resourceArn", "ResourceARN", (properties.ResourceARN != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InputProcessingConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`InputProcessingConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2InputProcessingConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("inputLambdaProcessor", CfnApplicationV2InputLambdaProcessorPropertyValidator)(properties.inputLambdaProcessor));
  return errors.wrap("supplied properties not correct for \\"InputProcessingConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2InputProcessingConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2InputProcessingConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "InputLambdaProcessor": convertCfnApplicationV2InputLambdaProcessorPropertyToCloudFormation(properties.inputLambdaProcessor)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2InputProcessingConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.InputProcessingConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.InputProcessingConfigurationProperty>();
  ret.addPropertyResult("inputLambdaProcessor", "InputLambdaProcessor", (properties.InputLambdaProcessor != null ? CfnApplicationV2InputLambdaProcessorPropertyFromCloudFormation(properties.InputLambdaProcessor) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InputParallelismProperty\`
 *
 * @param properties - the TypeScript properties of a \`InputParallelismProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2InputParallelismPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("count", cdk.validateNumber)(properties.count));
  return errors.wrap("supplied properties not correct for \\"InputParallelismProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2InputParallelismPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2InputParallelismPropertyValidator(properties).assertSuccess();
  return {
    "Count": cdk.numberToCloudFormation(properties.count)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2InputParallelismPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.InputParallelismProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.InputParallelismProperty>();
  ret.addPropertyResult("count", "Count", (properties.Count != null ? cfn_parse.FromCloudFormation.getNumber(properties.Count) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`InputProperty\`
 *
 * @param properties - the TypeScript properties of a \`InputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2InputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("inputParallelism", CfnApplicationV2InputParallelismPropertyValidator)(properties.inputParallelism));
  errors.collect(cdk.propertyValidator("inputProcessingConfiguration", CfnApplicationV2InputProcessingConfigurationPropertyValidator)(properties.inputProcessingConfiguration));
  errors.collect(cdk.propertyValidator("inputSchema", cdk.requiredValidator)(properties.inputSchema));
  errors.collect(cdk.propertyValidator("inputSchema", CfnApplicationV2InputSchemaPropertyValidator)(properties.inputSchema));
  errors.collect(cdk.propertyValidator("kinesisFirehoseInput", CfnApplicationV2KinesisFirehoseInputPropertyValidator)(properties.kinesisFirehoseInput));
  errors.collect(cdk.propertyValidator("kinesisStreamsInput", CfnApplicationV2KinesisStreamsInputPropertyValidator)(properties.kinesisStreamsInput));
  errors.collect(cdk.propertyValidator("namePrefix", cdk.requiredValidator)(properties.namePrefix));
  errors.collect(cdk.propertyValidator("namePrefix", cdk.validateString)(properties.namePrefix));
  return errors.wrap("supplied properties not correct for \\"InputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2InputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2InputPropertyValidator(properties).assertSuccess();
  return {
    "InputParallelism": convertCfnApplicationV2InputParallelismPropertyToCloudFormation(properties.inputParallelism),
    "InputProcessingConfiguration": convertCfnApplicationV2InputProcessingConfigurationPropertyToCloudFormation(properties.inputProcessingConfiguration),
    "InputSchema": convertCfnApplicationV2InputSchemaPropertyToCloudFormation(properties.inputSchema),
    "KinesisFirehoseInput": convertCfnApplicationV2KinesisFirehoseInputPropertyToCloudFormation(properties.kinesisFirehoseInput),
    "KinesisStreamsInput": convertCfnApplicationV2KinesisStreamsInputPropertyToCloudFormation(properties.kinesisStreamsInput),
    "NamePrefix": cdk.stringToCloudFormation(properties.namePrefix)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2InputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.InputProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.InputProperty>();
  ret.addPropertyResult("inputParallelism", "InputParallelism", (properties.InputParallelism != null ? CfnApplicationV2InputParallelismPropertyFromCloudFormation(properties.InputParallelism) : undefined));
  ret.addPropertyResult("inputProcessingConfiguration", "InputProcessingConfiguration", (properties.InputProcessingConfiguration != null ? CfnApplicationV2InputProcessingConfigurationPropertyFromCloudFormation(properties.InputProcessingConfiguration) : undefined));
  ret.addPropertyResult("inputSchema", "InputSchema", (properties.InputSchema != null ? CfnApplicationV2InputSchemaPropertyFromCloudFormation(properties.InputSchema) : undefined));
  ret.addPropertyResult("kinesisFirehoseInput", "KinesisFirehoseInput", (properties.KinesisFirehoseInput != null ? CfnApplicationV2KinesisFirehoseInputPropertyFromCloudFormation(properties.KinesisFirehoseInput) : undefined));
  ret.addPropertyResult("kinesisStreamsInput", "KinesisStreamsInput", (properties.KinesisStreamsInput != null ? CfnApplicationV2KinesisStreamsInputPropertyFromCloudFormation(properties.KinesisStreamsInput) : undefined));
  ret.addPropertyResult("namePrefix", "NamePrefix", (properties.NamePrefix != null ? cfn_parse.FromCloudFormation.getString(properties.NamePrefix) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`SqlApplicationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`SqlApplicationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2SqlApplicationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("inputs", cdk.listValidator(CfnApplicationV2InputPropertyValidator))(properties.inputs));
  return errors.wrap("supplied properties not correct for \\"SqlApplicationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2SqlApplicationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2SqlApplicationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "Inputs": cdk.listMapper(convertCfnApplicationV2InputPropertyToCloudFormation)(properties.inputs)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2SqlApplicationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.SqlApplicationConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.SqlApplicationConfigurationProperty>();
  ret.addPropertyResult("inputs", "Inputs", (properties.Inputs != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2InputPropertyFromCloudFormation)(properties.Inputs) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`GlueDataCatalogConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`GlueDataCatalogConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2GlueDataCatalogConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("databaseArn", cdk.validateString)(properties.databaseArn));
  return errors.wrap("supplied properties not correct for \\"GlueDataCatalogConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2GlueDataCatalogConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2GlueDataCatalogConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "DatabaseARN": cdk.stringToCloudFormation(properties.databaseArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2GlueDataCatalogConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.GlueDataCatalogConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.GlueDataCatalogConfigurationProperty>();
  ret.addPropertyResult("databaseArn", "DatabaseARN", (properties.DatabaseARN != null ? cfn_parse.FromCloudFormation.getString(properties.DatabaseARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CatalogConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CatalogConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2CatalogConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("glueDataCatalogConfiguration", CfnApplicationV2GlueDataCatalogConfigurationPropertyValidator)(properties.glueDataCatalogConfiguration));
  return errors.wrap("supplied properties not correct for \\"CatalogConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2CatalogConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2CatalogConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "GlueDataCatalogConfiguration": convertCfnApplicationV2GlueDataCatalogConfigurationPropertyToCloudFormation(properties.glueDataCatalogConfiguration)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2CatalogConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.CatalogConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.CatalogConfigurationProperty>();
  ret.addPropertyResult("glueDataCatalogConfiguration", "GlueDataCatalogConfiguration", (properties.GlueDataCatalogConfiguration != null ? CfnApplicationV2GlueDataCatalogConfigurationPropertyFromCloudFormation(properties.GlueDataCatalogConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ZeppelinMonitoringConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ZeppelinMonitoringConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ZeppelinMonitoringConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("logLevel", cdk.validateString)(properties.logLevel));
  return errors.wrap("supplied properties not correct for \\"ZeppelinMonitoringConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ZeppelinMonitoringConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ZeppelinMonitoringConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "LogLevel": cdk.stringToCloudFormation(properties.logLevel)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ZeppelinMonitoringConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.ZeppelinMonitoringConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ZeppelinMonitoringConfigurationProperty>();
  ret.addPropertyResult("logLevel", "LogLevel", (properties.LogLevel != null ? cfn_parse.FromCloudFormation.getString(properties.LogLevel) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3ContentBaseLocationProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3ContentBaseLocationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2S3ContentBaseLocationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("basePath", cdk.validateString)(properties.basePath));
  errors.collect(cdk.propertyValidator("bucketArn", cdk.requiredValidator)(properties.bucketArn));
  errors.collect(cdk.propertyValidator("bucketArn", cdk.validateString)(properties.bucketArn));
  return errors.wrap("supplied properties not correct for \\"S3ContentBaseLocationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2S3ContentBaseLocationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2S3ContentBaseLocationPropertyValidator(properties).assertSuccess();
  return {
    "BasePath": cdk.stringToCloudFormation(properties.basePath),
    "BucketARN": cdk.stringToCloudFormation(properties.bucketArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2S3ContentBaseLocationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.S3ContentBaseLocationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.S3ContentBaseLocationProperty>();
  ret.addPropertyResult("basePath", "BasePath", (properties.BasePath != null ? cfn_parse.FromCloudFormation.getString(properties.BasePath) : undefined));
  ret.addPropertyResult("bucketArn", "BucketARN", (properties.BucketARN != null ? cfn_parse.FromCloudFormation.getString(properties.BucketARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`DeployAsApplicationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`DeployAsApplicationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2DeployAsApplicationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("s3ContentLocation", cdk.requiredValidator)(properties.s3ContentLocation));
  errors.collect(cdk.propertyValidator("s3ContentLocation", CfnApplicationV2S3ContentBaseLocationPropertyValidator)(properties.s3ContentLocation));
  return errors.wrap("supplied properties not correct for \\"DeployAsApplicationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2DeployAsApplicationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2DeployAsApplicationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "S3ContentLocation": convertCfnApplicationV2S3ContentBaseLocationPropertyToCloudFormation(properties.s3ContentLocation)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2DeployAsApplicationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.DeployAsApplicationConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.DeployAsApplicationConfigurationProperty>();
  ret.addPropertyResult("s3ContentLocation", "S3ContentLocation", (properties.S3ContentLocation != null ? CfnApplicationV2S3ContentBaseLocationPropertyFromCloudFormation(properties.S3ContentLocation) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MavenReferenceProperty\`
 *
 * @param properties - the TypeScript properties of a \`MavenReferenceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2MavenReferencePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("artifactId", cdk.requiredValidator)(properties.artifactId));
  errors.collect(cdk.propertyValidator("artifactId", cdk.validateString)(properties.artifactId));
  errors.collect(cdk.propertyValidator("groupId", cdk.requiredValidator)(properties.groupId));
  errors.collect(cdk.propertyValidator("groupId", cdk.validateString)(properties.groupId));
  errors.collect(cdk.propertyValidator("version", cdk.requiredValidator)(properties.version));
  errors.collect(cdk.propertyValidator("version", cdk.validateString)(properties.version));
  return errors.wrap("supplied properties not correct for \\"MavenReferenceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2MavenReferencePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2MavenReferencePropertyValidator(properties).assertSuccess();
  return {
    "ArtifactId": cdk.stringToCloudFormation(properties.artifactId),
    "GroupId": cdk.stringToCloudFormation(properties.groupId),
    "Version": cdk.stringToCloudFormation(properties.version)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2MavenReferencePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.MavenReferenceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.MavenReferenceProperty>();
  ret.addPropertyResult("artifactId", "ArtifactId", (properties.ArtifactId != null ? cfn_parse.FromCloudFormation.getString(properties.ArtifactId) : undefined));
  ret.addPropertyResult("groupId", "GroupId", (properties.GroupId != null ? cfn_parse.FromCloudFormation.getString(properties.GroupId) : undefined));
  ret.addPropertyResult("version", "Version", (properties.Version != null ? cfn_parse.FromCloudFormation.getString(properties.Version) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CustomArtifactConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`CustomArtifactConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2CustomArtifactConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("artifactType", cdk.requiredValidator)(properties.artifactType));
  errors.collect(cdk.propertyValidator("artifactType", cdk.validateString)(properties.artifactType));
  errors.collect(cdk.propertyValidator("mavenReference", CfnApplicationV2MavenReferencePropertyValidator)(properties.mavenReference));
  errors.collect(cdk.propertyValidator("s3ContentLocation", CfnApplicationV2S3ContentLocationPropertyValidator)(properties.s3ContentLocation));
  return errors.wrap("supplied properties not correct for \\"CustomArtifactConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2CustomArtifactConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2CustomArtifactConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ArtifactType": cdk.stringToCloudFormation(properties.artifactType),
    "MavenReference": convertCfnApplicationV2MavenReferencePropertyToCloudFormation(properties.mavenReference),
    "S3ContentLocation": convertCfnApplicationV2S3ContentLocationPropertyToCloudFormation(properties.s3ContentLocation)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2CustomArtifactConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.CustomArtifactConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.CustomArtifactConfigurationProperty>();
  ret.addPropertyResult("artifactType", "ArtifactType", (properties.ArtifactType != null ? cfn_parse.FromCloudFormation.getString(properties.ArtifactType) : undefined));
  ret.addPropertyResult("mavenReference", "MavenReference", (properties.MavenReference != null ? CfnApplicationV2MavenReferencePropertyFromCloudFormation(properties.MavenReference) : undefined));
  ret.addPropertyResult("s3ContentLocation", "S3ContentLocation", (properties.S3ContentLocation != null ? CfnApplicationV2S3ContentLocationPropertyFromCloudFormation(properties.S3ContentLocation) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ZeppelinApplicationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ZeppelinApplicationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ZeppelinApplicationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("catalogConfiguration", CfnApplicationV2CatalogConfigurationPropertyValidator)(properties.catalogConfiguration));
  errors.collect(cdk.propertyValidator("customArtifactsConfiguration", cdk.listValidator(CfnApplicationV2CustomArtifactConfigurationPropertyValidator))(properties.customArtifactsConfiguration));
  errors.collect(cdk.propertyValidator("deployAsApplicationConfiguration", CfnApplicationV2DeployAsApplicationConfigurationPropertyValidator)(properties.deployAsApplicationConfiguration));
  errors.collect(cdk.propertyValidator("monitoringConfiguration", CfnApplicationV2ZeppelinMonitoringConfigurationPropertyValidator)(properties.monitoringConfiguration));
  return errors.wrap("supplied properties not correct for \\"ZeppelinApplicationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ZeppelinApplicationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ZeppelinApplicationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "CatalogConfiguration": convertCfnApplicationV2CatalogConfigurationPropertyToCloudFormation(properties.catalogConfiguration),
    "CustomArtifactsConfiguration": cdk.listMapper(convertCfnApplicationV2CustomArtifactConfigurationPropertyToCloudFormation)(properties.customArtifactsConfiguration),
    "DeployAsApplicationConfiguration": convertCfnApplicationV2DeployAsApplicationConfigurationPropertyToCloudFormation(properties.deployAsApplicationConfiguration),
    "MonitoringConfiguration": convertCfnApplicationV2ZeppelinMonitoringConfigurationPropertyToCloudFormation(properties.monitoringConfiguration)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ZeppelinApplicationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.ZeppelinApplicationConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ZeppelinApplicationConfigurationProperty>();
  ret.addPropertyResult("catalogConfiguration", "CatalogConfiguration", (properties.CatalogConfiguration != null ? CfnApplicationV2CatalogConfigurationPropertyFromCloudFormation(properties.CatalogConfiguration) : undefined));
  ret.addPropertyResult("customArtifactsConfiguration", "CustomArtifactsConfiguration", (properties.CustomArtifactsConfiguration != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2CustomArtifactConfigurationPropertyFromCloudFormation)(properties.CustomArtifactsConfiguration) : undefined));
  ret.addPropertyResult("deployAsApplicationConfiguration", "DeployAsApplicationConfiguration", (properties.DeployAsApplicationConfiguration != null ? CfnApplicationV2DeployAsApplicationConfigurationPropertyFromCloudFormation(properties.DeployAsApplicationConfiguration) : undefined));
  ret.addPropertyResult("monitoringConfiguration", "MonitoringConfiguration", (properties.MonitoringConfiguration != null ? CfnApplicationV2ZeppelinMonitoringConfigurationPropertyFromCloudFormation(properties.MonitoringConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`VpcConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`VpcConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2VpcConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.requiredValidator)(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("securityGroupIds", cdk.listValidator(cdk.validateString))(properties.securityGroupIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.requiredValidator)(properties.subnetIds));
  errors.collect(cdk.propertyValidator("subnetIds", cdk.listValidator(cdk.validateString))(properties.subnetIds));
  return errors.wrap("supplied properties not correct for \\"VpcConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2VpcConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2VpcConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "SecurityGroupIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.securityGroupIds),
    "SubnetIds": cdk.listMapper(cdk.stringToCloudFormation)(properties.subnetIds)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2VpcConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.VpcConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.VpcConfigurationProperty>();
  ret.addPropertyResult("securityGroupIds", "SecurityGroupIds", (properties.SecurityGroupIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SecurityGroupIds) : undefined));
  ret.addPropertyResult("subnetIds", "SubnetIds", (properties.SubnetIds != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getString)(properties.SubnetIds) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApplicationConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ApplicationConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationCodeConfiguration", CfnApplicationV2ApplicationCodeConfigurationPropertyValidator)(properties.applicationCodeConfiguration));
  errors.collect(cdk.propertyValidator("applicationSnapshotConfiguration", CfnApplicationV2ApplicationSnapshotConfigurationPropertyValidator)(properties.applicationSnapshotConfiguration));
  errors.collect(cdk.propertyValidator("environmentProperties", CfnApplicationV2EnvironmentPropertiesPropertyValidator)(properties.environmentProperties));
  errors.collect(cdk.propertyValidator("flinkApplicationConfiguration", CfnApplicationV2FlinkApplicationConfigurationPropertyValidator)(properties.flinkApplicationConfiguration));
  errors.collect(cdk.propertyValidator("sqlApplicationConfiguration", CfnApplicationV2SqlApplicationConfigurationPropertyValidator)(properties.sqlApplicationConfiguration));
  errors.collect(cdk.propertyValidator("vpcConfigurations", cdk.listValidator(CfnApplicationV2VpcConfigurationPropertyValidator))(properties.vpcConfigurations));
  errors.collect(cdk.propertyValidator("zeppelinApplicationConfiguration", CfnApplicationV2ZeppelinApplicationConfigurationPropertyValidator)(properties.zeppelinApplicationConfiguration));
  return errors.wrap("supplied properties not correct for \\"ApplicationConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ApplicationConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ApplicationConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationCodeConfiguration": convertCfnApplicationV2ApplicationCodeConfigurationPropertyToCloudFormation(properties.applicationCodeConfiguration),
    "ApplicationSnapshotConfiguration": convertCfnApplicationV2ApplicationSnapshotConfigurationPropertyToCloudFormation(properties.applicationSnapshotConfiguration),
    "EnvironmentProperties": convertCfnApplicationV2EnvironmentPropertiesPropertyToCloudFormation(properties.environmentProperties),
    "FlinkApplicationConfiguration": convertCfnApplicationV2FlinkApplicationConfigurationPropertyToCloudFormation(properties.flinkApplicationConfiguration),
    "SqlApplicationConfiguration": convertCfnApplicationV2SqlApplicationConfigurationPropertyToCloudFormation(properties.sqlApplicationConfiguration),
    "VpcConfigurations": cdk.listMapper(convertCfnApplicationV2VpcConfigurationPropertyToCloudFormation)(properties.vpcConfigurations),
    "ZeppelinApplicationConfiguration": convertCfnApplicationV2ZeppelinApplicationConfigurationPropertyToCloudFormation(properties.zeppelinApplicationConfiguration)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ApplicationConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.ApplicationConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ApplicationConfigurationProperty>();
  ret.addPropertyResult("applicationCodeConfiguration", "ApplicationCodeConfiguration", (properties.ApplicationCodeConfiguration != null ? CfnApplicationV2ApplicationCodeConfigurationPropertyFromCloudFormation(properties.ApplicationCodeConfiguration) : undefined));
  ret.addPropertyResult("applicationSnapshotConfiguration", "ApplicationSnapshotConfiguration", (properties.ApplicationSnapshotConfiguration != null ? CfnApplicationV2ApplicationSnapshotConfigurationPropertyFromCloudFormation(properties.ApplicationSnapshotConfiguration) : undefined));
  ret.addPropertyResult("environmentProperties", "EnvironmentProperties", (properties.EnvironmentProperties != null ? CfnApplicationV2EnvironmentPropertiesPropertyFromCloudFormation(properties.EnvironmentProperties) : undefined));
  ret.addPropertyResult("flinkApplicationConfiguration", "FlinkApplicationConfiguration", (properties.FlinkApplicationConfiguration != null ? CfnApplicationV2FlinkApplicationConfigurationPropertyFromCloudFormation(properties.FlinkApplicationConfiguration) : undefined));
  ret.addPropertyResult("sqlApplicationConfiguration", "SqlApplicationConfiguration", (properties.SqlApplicationConfiguration != null ? CfnApplicationV2SqlApplicationConfigurationPropertyFromCloudFormation(properties.SqlApplicationConfiguration) : undefined));
  ret.addPropertyResult("vpcConfigurations", "VpcConfigurations", (properties.VpcConfigurations != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationV2VpcConfigurationPropertyFromCloudFormation)(properties.VpcConfigurations) : undefined));
  ret.addPropertyResult("zeppelinApplicationConfiguration", "ZeppelinApplicationConfiguration", (properties.ZeppelinApplicationConfiguration != null ? CfnApplicationV2ZeppelinApplicationConfigurationPropertyFromCloudFormation(properties.ZeppelinApplicationConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApplicationRestoreConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationRestoreConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ApplicationRestoreConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationRestoreType", cdk.requiredValidator)(properties.applicationRestoreType));
  errors.collect(cdk.propertyValidator("applicationRestoreType", cdk.validateString)(properties.applicationRestoreType));
  errors.collect(cdk.propertyValidator("snapshotName", cdk.validateString)(properties.snapshotName));
  return errors.wrap("supplied properties not correct for \\"ApplicationRestoreConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ApplicationRestoreConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ApplicationRestoreConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationRestoreType": cdk.stringToCloudFormation(properties.applicationRestoreType),
    "SnapshotName": cdk.stringToCloudFormation(properties.snapshotName)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ApplicationRestoreConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.ApplicationRestoreConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ApplicationRestoreConfigurationProperty>();
  ret.addPropertyResult("applicationRestoreType", "ApplicationRestoreType", (properties.ApplicationRestoreType != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationRestoreType) : undefined));
  ret.addPropertyResult("snapshotName", "SnapshotName", (properties.SnapshotName != null ? cfn_parse.FromCloudFormation.getString(properties.SnapshotName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`FlinkRunConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`FlinkRunConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2FlinkRunConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("allowNonRestoredState", cdk.validateBoolean)(properties.allowNonRestoredState));
  return errors.wrap("supplied properties not correct for \\"FlinkRunConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2FlinkRunConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2FlinkRunConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "AllowNonRestoredState": cdk.booleanToCloudFormation(properties.allowNonRestoredState)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2FlinkRunConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.FlinkRunConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.FlinkRunConfigurationProperty>();
  ret.addPropertyResult("allowNonRestoredState", "AllowNonRestoredState", (properties.AllowNonRestoredState != null ? cfn_parse.FromCloudFormation.getBoolean(properties.AllowNonRestoredState) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RunConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`RunConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2RunConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationRestoreConfiguration", CfnApplicationV2ApplicationRestoreConfigurationPropertyValidator)(properties.applicationRestoreConfiguration));
  errors.collect(cdk.propertyValidator("flinkRunConfiguration", CfnApplicationV2FlinkRunConfigurationPropertyValidator)(properties.flinkRunConfiguration));
  return errors.wrap("supplied properties not correct for \\"RunConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2RunConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2RunConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationRestoreConfiguration": convertCfnApplicationV2ApplicationRestoreConfigurationPropertyToCloudFormation(properties.applicationRestoreConfiguration),
    "FlinkRunConfiguration": convertCfnApplicationV2FlinkRunConfigurationPropertyToCloudFormation(properties.flinkRunConfiguration)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2RunConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationV2.RunConfigurationProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.RunConfigurationProperty>();
  ret.addPropertyResult("applicationRestoreConfiguration", "ApplicationRestoreConfiguration", (properties.ApplicationRestoreConfiguration != null ? CfnApplicationV2ApplicationRestoreConfigurationPropertyFromCloudFormation(properties.ApplicationRestoreConfiguration) : undefined));
  ret.addPropertyResult("flinkRunConfiguration", "FlinkRunConfiguration", (properties.FlinkRunConfiguration != null ? CfnApplicationV2FlinkRunConfigurationPropertyFromCloudFormation(properties.FlinkRunConfiguration) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ApplicationMaintenanceConfigurationProperty\`
 *
 * @param properties - the TypeScript properties of a \`ApplicationMaintenanceConfigurationProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationMaintenanceWindowStartTime", cdk.requiredValidator)(properties.applicationMaintenanceWindowStartTime));
  errors.collect(cdk.propertyValidator("applicationMaintenanceWindowStartTime", cdk.validateString)(properties.applicationMaintenanceWindowStartTime));
  return errors.wrap("supplied properties not correct for \\"ApplicationMaintenanceConfigurationProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2ApplicationMaintenanceConfigurationPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator(properties).assertSuccess();
  return {
    "ApplicationMaintenanceWindowStartTime": cdk.stringToCloudFormation(properties.applicationMaintenanceWindowStartTime)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2ApplicationMaintenanceConfigurationPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2.ApplicationMaintenanceConfigurationProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2.ApplicationMaintenanceConfigurationProperty>();
  ret.addPropertyResult("applicationMaintenanceWindowStartTime", "ApplicationMaintenanceWindowStartTime", (properties.ApplicationMaintenanceWindowStartTime != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationMaintenanceWindowStartTime) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationV2Props\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationV2Props\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationV2PropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationConfiguration", CfnApplicationV2ApplicationConfigurationPropertyValidator)(properties.applicationConfiguration));
  errors.collect(cdk.propertyValidator("applicationDescription", cdk.validateString)(properties.applicationDescription));
  errors.collect(cdk.propertyValidator("applicationMaintenanceConfiguration", CfnApplicationV2ApplicationMaintenanceConfigurationPropertyValidator)(properties.applicationMaintenanceConfiguration));
  errors.collect(cdk.propertyValidator("applicationMode", cdk.validateString)(properties.applicationMode));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("runConfiguration", CfnApplicationV2RunConfigurationPropertyValidator)(properties.runConfiguration));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.requiredValidator)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("runtimeEnvironment", cdk.validateString)(properties.runtimeEnvironment));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.requiredValidator)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("serviceExecutionRole", cdk.validateString)(properties.serviceExecutionRole));
  errors.collect(cdk.propertyValidator("tags", cdk.listValidator(cdk.validateCfnTag))(properties.tags));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationV2Props\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationV2PropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationV2PropsValidator(properties).assertSuccess();
  return {
    "ApplicationConfiguration": convertCfnApplicationV2ApplicationConfigurationPropertyToCloudFormation(properties.applicationConfiguration),
    "ApplicationDescription": cdk.stringToCloudFormation(properties.applicationDescription),
    "ApplicationMaintenanceConfiguration": convertCfnApplicationV2ApplicationMaintenanceConfigurationPropertyToCloudFormation(properties.applicationMaintenanceConfiguration),
    "ApplicationMode": cdk.stringToCloudFormation(properties.applicationMode),
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "RunConfiguration": convertCfnApplicationV2RunConfigurationPropertyToCloudFormation(properties.runConfiguration),
    "RuntimeEnvironment": cdk.stringToCloudFormation(properties.runtimeEnvironment),
    "ServiceExecutionRole": cdk.stringToCloudFormation(properties.serviceExecutionRole),
    "Tags": cdk.listMapper(cdk.cfnTagToCloudFormation)(properties.tags)
  };
}

// @ts-ignore TS6133
function CfnApplicationV2PropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationV2Props | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationV2Props>();
  ret.addPropertyResult("applicationConfiguration", "ApplicationConfiguration", (properties.ApplicationConfiguration != null ? CfnApplicationV2ApplicationConfigurationPropertyFromCloudFormation(properties.ApplicationConfiguration) : undefined));
  ret.addPropertyResult("applicationDescription", "ApplicationDescription", (properties.ApplicationDescription != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationDescription) : undefined));
  ret.addPropertyResult("applicationMaintenanceConfiguration", "ApplicationMaintenanceConfiguration", (properties.ApplicationMaintenanceConfiguration != null ? CfnApplicationV2ApplicationMaintenanceConfigurationPropertyFromCloudFormation(properties.ApplicationMaintenanceConfiguration) : undefined));
  ret.addPropertyResult("applicationMode", "ApplicationMode", (properties.ApplicationMode != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationMode) : undefined));
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("runConfiguration", "RunConfiguration", (properties.RunConfiguration != null ? CfnApplicationV2RunConfigurationPropertyFromCloudFormation(properties.RunConfiguration) : undefined));
  ret.addPropertyResult("runtimeEnvironment", "RuntimeEnvironment", (properties.RuntimeEnvironment != null ? cfn_parse.FromCloudFormation.getString(properties.RuntimeEnvironment) : undefined));
  ret.addPropertyResult("serviceExecutionRole", "ServiceExecutionRole", (properties.ServiceExecutionRole != null ? cfn_parse.FromCloudFormation.getString(properties.ServiceExecutionRole) : undefined));
  ret.addPropertyResult("tags", "Tags", (properties.Tags != null ? cfn_parse.FromCloudFormation.getArray(cfn_parse.FromCloudFormation.getCfnTag)(properties.Tags) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds an Amazon CloudWatch log stream to monitor application configuration errors.
 *
 * > Only one *ApplicationCloudWatchLoggingOption* resource can be attached per application.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html
 */
export class CfnApplicationCloudWatchLoggingOptionV2 extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::KinesisAnalyticsV2::ApplicationCloudWatchLoggingOption";

  /**
   * Build a CfnApplicationCloudWatchLoggingOptionV2 from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplicationCloudWatchLoggingOptionV2 {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationCloudWatchLoggingOptionV2PropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplicationCloudWatchLoggingOptionV2(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The name of the application.
   */
  public applicationName: string;

  /**
   * Provides a description of Amazon CloudWatch logging options, including the log stream Amazon Resource Name (ARN).
   */
  public cloudWatchLoggingOption: CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty | cdk.IResolvable;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationCloudWatchLoggingOptionV2Props) {
    super(scope, id, {
      "type": CfnApplicationCloudWatchLoggingOptionV2.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "applicationName", this);
    cdk.requireProperty(props, "cloudWatchLoggingOption", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.applicationName = props.applicationName;
    this.cloudWatchLoggingOption = props.cloudWatchLoggingOption;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationName": this.applicationName,
      "cloudWatchLoggingOption": this.cloudWatchLoggingOption
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplicationCloudWatchLoggingOptionV2.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationCloudWatchLoggingOptionV2PropsToCloudFormation(props);
  }
}

export namespace CfnApplicationCloudWatchLoggingOptionV2 {
  /**
   * Provides a description of Amazon CloudWatch logging options, including the log stream Amazon Resource Name (ARN).
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption.html
   */
  export interface CloudWatchLoggingOptionProperty {
    /**
     * The ARN of the CloudWatch log to receive application messages.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption.html#cfn-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption-logstreamarn
     */
    readonly logStreamArn: string;
  }
}

/**
 * Properties for defining a \`CfnApplicationCloudWatchLoggingOption\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html
 */
export interface CfnApplicationCloudWatchLoggingOptionV2Props {
  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html#cfn-kinesisanalyticsv2-applicationcloudwatchloggingoption-applicationname
   */
  readonly applicationName: string;

  /**
   * Provides a description of Amazon CloudWatch logging options, including the log stream Amazon Resource Name (ARN).
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationcloudwatchloggingoption.html#cfn-kinesisanalyticsv2-applicationcloudwatchloggingoption-cloudwatchloggingoption
   */
  readonly cloudWatchLoggingOption: CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty | cdk.IResolvable;
}

/**
 * Determine whether the given properties match those of a \`CloudWatchLoggingOptionProperty\`
 *
 * @param properties - the TypeScript properties of a \`CloudWatchLoggingOptionProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("logStreamArn", cdk.requiredValidator)(properties.logStreamArn));
  errors.collect(cdk.propertyValidator("logStreamArn", cdk.validateString)(properties.logStreamArn));
  return errors.wrap("supplied properties not correct for \\"CloudWatchLoggingOptionProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyValidator(properties).assertSuccess();
  return {
    "LogStreamARN": cdk.stringToCloudFormation(properties.logStreamArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationCloudWatchLoggingOptionV2.CloudWatchLoggingOptionProperty>();
  ret.addPropertyResult("logStreamArn", "LogStreamARN", (properties.LogStreamARN != null ? cfn_parse.FromCloudFormation.getString(properties.LogStreamARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationCloudWatchLoggingOptionV2Props\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationCloudWatchLoggingOptionV2Props\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationCloudWatchLoggingOptionV2PropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationName", cdk.requiredValidator)(properties.applicationName));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("cloudWatchLoggingOption", cdk.requiredValidator)(properties.cloudWatchLoggingOption));
  errors.collect(cdk.propertyValidator("cloudWatchLoggingOption", CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyValidator)(properties.cloudWatchLoggingOption));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationCloudWatchLoggingOptionV2Props\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationCloudWatchLoggingOptionV2PropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationCloudWatchLoggingOptionV2PropsValidator(properties).assertSuccess();
  return {
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "CloudWatchLoggingOption": convertCfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyToCloudFormation(properties.cloudWatchLoggingOption)
  };
}

// @ts-ignore TS6133
function CfnApplicationCloudWatchLoggingOptionV2PropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationCloudWatchLoggingOptionV2Props | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationCloudWatchLoggingOptionV2Props>();
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("cloudWatchLoggingOption", "CloudWatchLoggingOption", (properties.CloudWatchLoggingOption != null ? CfnApplicationCloudWatchLoggingOptionV2CloudWatchLoggingOptionPropertyFromCloudFormation(properties.CloudWatchLoggingOption) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds an external destination to your SQL-based Amazon Kinesis Data Analytics application.
 *
 * If you want Kinesis Data Analytics to deliver data from an in-application stream within your application to an external destination (such as an Kinesis data stream, a Kinesis Data Firehose delivery stream, or an Amazon Lambda function), you add the relevant configuration to your application using this operation. You can configure one or more outputs for your application. Each output configuration maps an in-application stream and an external destination.
 *
 * You can use one of the output configurations to deliver data from your in-application error stream to an external destination so that you can analyze the errors.
 *
 * Any configuration update, including adding a streaming source using this operation, results in a new version of the application. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_DescribeApplication.html) operation to find the current application version.
 *
 * > Creation of multiple outputs should be sequential (use of DependsOn) to avoid a problem with a stale application version ( *ConcurrentModificationException* ).
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html
 */
export class CfnApplicationOutputV2 extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::KinesisAnalyticsV2::ApplicationOutput";

  /**
   * Build a CfnApplicationOutputV2 from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplicationOutputV2 {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationOutputV2PropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplicationOutputV2(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The name of the application.
   */
  public applicationName: string;

  /**
   * Describes a SQL-based Kinesis Data Analytics application's output configuration, in which you identify an in-application stream and a destination where you want the in-application stream data to be written.
   */
  public output: cdk.IResolvable | CfnApplicationOutputV2.OutputProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationOutputV2Props) {
    super(scope, id, {
      "type": CfnApplicationOutputV2.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "applicationName", this);
    cdk.requireProperty(props, "output", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.applicationName = props.applicationName;
    this.output = props.output;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationName": this.applicationName,
      "output": this.output
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplicationOutputV2.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationOutputV2PropsToCloudFormation(props);
  }
}

export namespace CfnApplicationOutputV2 {
  /**
   * Describes a SQL-based Kinesis Data Analytics application's output configuration, in which you identify an in-application stream and a destination where you want the in-application stream data to be written.
   *
   * The destination can be a Kinesis data stream or a Kinesis Data Firehose delivery stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html
   */
  export interface OutputProperty {
    /**
     * Describes the data format when records are written to the destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html#cfn-kinesisanalyticsv2-applicationoutput-output-destinationschema
     */
    readonly destinationSchema: CfnApplicationOutputV2.DestinationSchemaProperty | cdk.IResolvable;

    /**
     * Identifies an Amazon Lambda function as the destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html#cfn-kinesisanalyticsv2-applicationoutput-output-lambdaoutput
     */
    readonly lambdaOutput?: cdk.IResolvable | CfnApplicationOutputV2.LambdaOutputProperty;

    /**
     * Identifies a Kinesis Data Firehose delivery stream as the destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html#cfn-kinesisanalyticsv2-applicationoutput-output-kinesisfirehoseoutput
     */
    readonly kinesisFirehoseOutput?: cdk.IResolvable | CfnApplicationOutputV2.KinesisFirehoseOutputProperty;

    /**
     * Identifies a Kinesis data stream as the destination.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html#cfn-kinesisanalyticsv2-applicationoutput-output-kinesisstreamsoutput
     */
    readonly kinesisStreamsOutput?: cdk.IResolvable | CfnApplicationOutputV2.KinesisStreamsOutputProperty;

    /**
     * The name of the in-application stream.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-output.html#cfn-kinesisanalyticsv2-applicationoutput-output-name
     */
    readonly name?: string;
  }

  /**
   * Describes the data format when records are written to the destination in a SQL-based Kinesis Data Analytics application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-destinationschema.html
   */
  export interface DestinationSchemaProperty {
    /**
     * Specifies the format of the records on the output stream.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-destinationschema.html#cfn-kinesisanalyticsv2-applicationoutput-destinationschema-recordformattype
     */
    readonly recordFormatType?: string;
  }

  /**
   * When you configure a SQL-based Kinesis Data Analytics application's output, identifies an Amazon Lambda function as the destination.
   *
   * You provide the function Amazon Resource Name (ARN) of the Lambda function.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-lambdaoutput.html
   */
  export interface LambdaOutputProperty {
    /**
     * The Amazon Resource Name (ARN) of the destination Lambda function to write to.
     *
     * > To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: Amazon Lambda](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda)
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-lambdaoutput.html#cfn-kinesisanalyticsv2-applicationoutput-lambdaoutput-resourcearn
     */
    readonly resourceArn: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, when configuring application output, identifies a Kinesis Data Firehose delivery stream as the destination.
   *
   * You provide the stream Amazon Resource Name (ARN) of the delivery stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-kinesisfirehoseoutput.html
   */
  export interface KinesisFirehoseOutputProperty {
    /**
     * The ARN of the destination delivery stream to write to.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-kinesisfirehoseoutput.html#cfn-kinesisanalyticsv2-applicationoutput-kinesisfirehoseoutput-resourcearn
     */
    readonly resourceArn: string;
  }

  /**
   * When you configure a SQL-based Kinesis Data Analytics application's output, identifies a Kinesis data stream as the destination.
   *
   * You provide the stream Amazon Resource Name (ARN).
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-kinesisstreamsoutput.html
   */
  export interface KinesisStreamsOutputProperty {
    /**
     * The ARN of the destination Kinesis data stream to write to.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationoutput-kinesisstreamsoutput.html#cfn-kinesisanalyticsv2-applicationoutput-kinesisstreamsoutput-resourcearn
     */
    readonly resourceArn: string;
  }
}

/**
 * Properties for defining a \`CfnApplicationOutput\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html
 */
export interface CfnApplicationOutputV2Props {
  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html#cfn-kinesisanalyticsv2-applicationoutput-applicationname
   */
  readonly applicationName: string;

  /**
   * Describes a SQL-based Kinesis Data Analytics application's output configuration, in which you identify an in-application stream and a destination where you want the in-application stream data to be written.
   *
   * The destination can be a Kinesis data stream or a Kinesis Data Firehose delivery stream.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationoutput.html#cfn-kinesisanalyticsv2-applicationoutput-output
   */
  readonly output: cdk.IResolvable | CfnApplicationOutputV2.OutputProperty;
}

/**
 * Determine whether the given properties match those of a \`DestinationSchemaProperty\`
 *
 * @param properties - the TypeScript properties of a \`DestinationSchemaProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2DestinationSchemaPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordFormatType", cdk.validateString)(properties.recordFormatType));
  return errors.wrap("supplied properties not correct for \\"DestinationSchemaProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2DestinationSchemaPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2DestinationSchemaPropertyValidator(properties).assertSuccess();
  return {
    "RecordFormatType": cdk.stringToCloudFormation(properties.recordFormatType)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2DestinationSchemaPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationOutputV2.DestinationSchemaProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2.DestinationSchemaProperty>();
  ret.addPropertyResult("recordFormatType", "RecordFormatType", (properties.RecordFormatType != null ? cfn_parse.FromCloudFormation.getString(properties.RecordFormatType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`LambdaOutputProperty\`
 *
 * @param properties - the TypeScript properties of a \`LambdaOutputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2LambdaOutputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceArn", cdk.requiredValidator)(properties.resourceArn));
  errors.collect(cdk.propertyValidator("resourceArn", cdk.validateString)(properties.resourceArn));
  return errors.wrap("supplied properties not correct for \\"LambdaOutputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2LambdaOutputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2LambdaOutputPropertyValidator(properties).assertSuccess();
  return {
    "ResourceARN": cdk.stringToCloudFormation(properties.resourceArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2LambdaOutputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationOutputV2.LambdaOutputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2.LambdaOutputProperty>();
  ret.addPropertyResult("resourceArn", "ResourceARN", (properties.ResourceARN != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KinesisFirehoseOutputProperty\`
 *
 * @param properties - the TypeScript properties of a \`KinesisFirehoseOutputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2KinesisFirehoseOutputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceArn", cdk.requiredValidator)(properties.resourceArn));
  errors.collect(cdk.propertyValidator("resourceArn", cdk.validateString)(properties.resourceArn));
  return errors.wrap("supplied properties not correct for \\"KinesisFirehoseOutputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2KinesisFirehoseOutputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2KinesisFirehoseOutputPropertyValidator(properties).assertSuccess();
  return {
    "ResourceARN": cdk.stringToCloudFormation(properties.resourceArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2KinesisFirehoseOutputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationOutputV2.KinesisFirehoseOutputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2.KinesisFirehoseOutputProperty>();
  ret.addPropertyResult("resourceArn", "ResourceARN", (properties.ResourceARN != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`KinesisStreamsOutputProperty\`
 *
 * @param properties - the TypeScript properties of a \`KinesisStreamsOutputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2KinesisStreamsOutputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("resourceArn", cdk.requiredValidator)(properties.resourceArn));
  errors.collect(cdk.propertyValidator("resourceArn", cdk.validateString)(properties.resourceArn));
  return errors.wrap("supplied properties not correct for \\"KinesisStreamsOutputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2KinesisStreamsOutputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2KinesisStreamsOutputPropertyValidator(properties).assertSuccess();
  return {
    "ResourceARN": cdk.stringToCloudFormation(properties.resourceArn)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2KinesisStreamsOutputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationOutputV2.KinesisStreamsOutputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2.KinesisStreamsOutputProperty>();
  ret.addPropertyResult("resourceArn", "ResourceARN", (properties.ResourceARN != null ? cfn_parse.FromCloudFormation.getString(properties.ResourceARN) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`OutputProperty\`
 *
 * @param properties - the TypeScript properties of a \`OutputProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2OutputPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("destinationSchema", cdk.requiredValidator)(properties.destinationSchema));
  errors.collect(cdk.propertyValidator("destinationSchema", CfnApplicationOutputV2DestinationSchemaPropertyValidator)(properties.destinationSchema));
  errors.collect(cdk.propertyValidator("kinesisFirehoseOutput", CfnApplicationOutputV2KinesisFirehoseOutputPropertyValidator)(properties.kinesisFirehoseOutput));
  errors.collect(cdk.propertyValidator("kinesisStreamsOutput", CfnApplicationOutputV2KinesisStreamsOutputPropertyValidator)(properties.kinesisStreamsOutput));
  errors.collect(cdk.propertyValidator("lambdaOutput", CfnApplicationOutputV2LambdaOutputPropertyValidator)(properties.lambdaOutput));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  return errors.wrap("supplied properties not correct for \\"OutputProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2OutputPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2OutputPropertyValidator(properties).assertSuccess();
  return {
    "DestinationSchema": convertCfnApplicationOutputV2DestinationSchemaPropertyToCloudFormation(properties.destinationSchema),
    "KinesisFirehoseOutput": convertCfnApplicationOutputV2KinesisFirehoseOutputPropertyToCloudFormation(properties.kinesisFirehoseOutput),
    "KinesisStreamsOutput": convertCfnApplicationOutputV2KinesisStreamsOutputPropertyToCloudFormation(properties.kinesisStreamsOutput),
    "LambdaOutput": convertCfnApplicationOutputV2LambdaOutputPropertyToCloudFormation(properties.lambdaOutput),
    "Name": cdk.stringToCloudFormation(properties.name)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2OutputPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationOutputV2.OutputProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2.OutputProperty>();
  ret.addPropertyResult("destinationSchema", "DestinationSchema", (properties.DestinationSchema != null ? CfnApplicationOutputV2DestinationSchemaPropertyFromCloudFormation(properties.DestinationSchema) : undefined));
  ret.addPropertyResult("kinesisFirehoseOutput", "KinesisFirehoseOutput", (properties.KinesisFirehoseOutput != null ? CfnApplicationOutputV2KinesisFirehoseOutputPropertyFromCloudFormation(properties.KinesisFirehoseOutput) : undefined));
  ret.addPropertyResult("kinesisStreamsOutput", "KinesisStreamsOutput", (properties.KinesisStreamsOutput != null ? CfnApplicationOutputV2KinesisStreamsOutputPropertyFromCloudFormation(properties.KinesisStreamsOutput) : undefined));
  ret.addPropertyResult("lambdaOutput", "LambdaOutput", (properties.LambdaOutput != null ? CfnApplicationOutputV2LambdaOutputPropertyFromCloudFormation(properties.LambdaOutput) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationOutputV2Props\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationOutputV2Props\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationOutputV2PropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationName", cdk.requiredValidator)(properties.applicationName));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("output", cdk.requiredValidator)(properties.output));
  errors.collect(cdk.propertyValidator("output", CfnApplicationOutputV2OutputPropertyValidator)(properties.output));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationOutputV2Props\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationOutputV2PropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationOutputV2PropsValidator(properties).assertSuccess();
  return {
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "Output": convertCfnApplicationOutputV2OutputPropertyToCloudFormation(properties.output)
  };
}

// @ts-ignore TS6133
function CfnApplicationOutputV2PropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationOutputV2Props | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationOutputV2Props>();
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("output", "Output", (properties.Output != null ? CfnApplicationOutputV2OutputPropertyFromCloudFormation(properties.Output) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Adds a reference data source to an existing SQL-based Kinesis Data Analytics application.
 *
 * Kinesis Data Analytics reads reference data (that is, an Amazon S3 object) and creates an in-application table within your application. In the request, you provide the source (S3 bucket name and object key name), name of the in-application table to create, and the necessary mapping information that describes how data in an Amazon S3 object maps to columns in the resulting in-application table.
 *
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html
 */
export class CfnApplicationReferenceDataSourceV2 extends cdk.CfnResource implements cdk.IInspectable {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME: string = "AWS::KinesisAnalyticsV2::ApplicationReferenceDataSource";

  /**
   * Build a CfnApplicationReferenceDataSourceV2 from CloudFormation properties
   *
   * A factory method that creates a new instance of this class from an object
   * containing the CloudFormation properties of this resource.
   * Used in the @aws-cdk/cloudformation-include module.
   *
   * @internal
   */
  public static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnApplicationReferenceDataSourceV2 {
    resourceAttributes = resourceAttributes || {};
    const resourceProperties = options.parser.parseValue(resourceAttributes.Properties);
    const propsResult = CfnApplicationReferenceDataSourceV2PropsFromCloudFormation(resourceProperties);
    if (cdk.isResolvableObject(propsResult.value)) {
      throw new Error("Unexpected IResolvable");
    }
    const ret = new CfnApplicationReferenceDataSourceV2(scope, id, propsResult.value);
    for (const [propKey, propVal] of Object.entries(propsResult.extraProperties)) {
      ret.addPropertyOverride(propKey, propVal);
    }
    options.parser.handleAttributes(ret, resourceAttributes, id);
    return ret;
  }

  /**
   * @cloudformationAttribute Id
   */
  public readonly attrId: string;

  /**
   * The name of the application.
   */
  public applicationName: string;

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the reference data source by providing the source information (Amazon S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
   */
  public referenceDataSource: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty;

  /**
   * @param scope Scope in which this resource is defined
   * @param id Construct identifier for this resource (unique in its scope)
   * @param props Resource properties
   */
  public constructor(scope: constructs.Construct, id: string, props: CfnApplicationReferenceDataSourceV2Props) {
    super(scope, id, {
      "type": CfnApplicationReferenceDataSourceV2.CFN_RESOURCE_TYPE_NAME,
      "properties": props
    });

    cdk.requireProperty(props, "applicationName", this);
    cdk.requireProperty(props, "referenceDataSource", this);

    this.attrId = cdk.Token.asString(this.getAtt("Id", cdk.ResolutionTypeHint.STRING));
    this.applicationName = props.applicationName;
    this.referenceDataSource = props.referenceDataSource;
  }

  protected get cfnProperties(): Record<string, any> {
    return {
      "applicationName": this.applicationName,
      "referenceDataSource": this.referenceDataSource
    };
  }

  /**
   * Examines the CloudFormation resource and discloses attributes
   *
   * @param inspector tree inspector to collect and process attributes
   */
  public inspect(inspector: cdk.TreeInspector): void {
    inspector.addAttribute("aws:cdk:cloudformation:type", CfnApplicationReferenceDataSourceV2.CFN_RESOURCE_TYPE_NAME);
    inspector.addAttribute("aws:cdk:cloudformation:props", this.cfnProperties);
  }

  protected renderProperties(props: Record<string, any>): Record<string, any> {
    return convertCfnApplicationReferenceDataSourceV2PropsToCloudFormation(props);
  }
}

export namespace CfnApplicationReferenceDataSourceV2 {
  /**
   * For a SQL-based Kinesis Data Analytics application, describes the reference data source by providing the source information (Amazon S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource.html
   */
  export interface ReferenceDataSourceProperty {
    /**
     * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource-referenceschema
     */
    readonly referenceSchema: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceSchemaProperty;

    /**
     * The name of the in-application table to create.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource-tablename
     */
    readonly tableName?: string;

    /**
     * Identifies the S3 bucket and object that contains the reference data.
     *
     * A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the [UpdateApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_UpdateApplication.html) operation to trigger reloading of data into your application.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource-s3referencedatasource
     */
    readonly s3ReferenceDataSource?: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.S3ReferenceDataSourceProperty;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referenceschema.html
   */
  export interface ReferenceSchemaProperty {
    /**
     * Specifies the encoding of the records in the streaming source.
     *
     * For example, UTF-8.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referenceschema.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referenceschema-recordencoding
     */
    readonly recordEncoding?: string;

    /**
     * A list of \`RecordColumn\` objects.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referenceschema.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referenceschema-recordcolumns
     */
    readonly recordColumns: Array<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.RecordColumnProperty> | cdk.IResolvable;

    /**
     * Specifies the format of the records on the streaming source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-referenceschema.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referenceschema-recordformat
     */
    readonly recordFormat: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.RecordFormatProperty;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
   *
   * Also used to describe the format of the reference data source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn.html
   */
  export interface RecordColumnProperty {
    /**
     * A reference to the data element in the streaming input or the reference data source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn-mapping
     */
    readonly mapping?: string;

    /**
     * The type of column created in the in-application input stream or reference table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn-sqltype
     */
    readonly sqlType: string;

    /**
     * The name of the column that is created in the in-application input stream or reference table.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-recordcolumn-name
     */
    readonly name: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the record format and relevant mapping information that should be applied to schematize the records on the stream.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordformat.html
   */
  export interface RecordFormatProperty {
    /**
     * When you configure application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordformat.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-recordformat-mappingparameters
     */
    readonly mappingParameters?: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.MappingParametersProperty;

    /**
     * The type of record format.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-recordformat.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-recordformat-recordformattype
     */
    readonly recordFormatType: string;
  }

  /**
   * When you configure a SQL-based Kinesis Data Analytics application's input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-mappingparameters.html
   */
  export interface MappingParametersProperty {
    /**
     * Provides additional mapping information when JSON is the record format on the streaming source.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-mappingparameters.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-mappingparameters-jsonmappingparameters
     */
    readonly jsonMappingParameters?: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.JSONMappingParametersProperty;

    /**
     * Provides additional mapping information when the record format uses delimiters (for example, CSV).
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-mappingparameters.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-mappingparameters-csvmappingparameters
     */
    readonly csvMappingParameters?: CfnApplicationReferenceDataSourceV2.CSVMappingParametersProperty | cdk.IResolvable;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, provides additional mapping information when JSON is the record format on the streaming source.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-jsonmappingparameters.html
   */
  export interface JSONMappingParametersProperty {
    /**
     * The path to the top-level parent that contains the records.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-jsonmappingparameters.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-jsonmappingparameters-recordrowpath
     */
    readonly recordRowPath: string;
  }

  /**
   * For a SQL-based Kinesis Data Analytics application, provides additional mapping information when the record format uses delimiters, such as CSV.
   *
   * For example, the following sample records use CSV format, where the records use the *'\\n'* as the row delimiter and a comma (",") as the column delimiter:
   *
   * \`"name1", "address1"\`
   *
   * \`"name2", "address2"\`
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-csvmappingparameters.html
   */
  export interface CSVMappingParametersProperty {
    /**
     * The row delimiter.
     *
     * For example, in a CSV format, *'\\n'* is the typical row delimiter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-csvmappingparameters.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-csvmappingparameters-recordrowdelimiter
     */
    readonly recordRowDelimiter: string;

    /**
     * The column delimiter.
     *
     * For example, in a CSV format, a comma (",") is the typical column delimiter.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-csvmappingparameters.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-csvmappingparameters-recordcolumndelimiter
     */
    readonly recordColumnDelimiter: string;
  }

  /**
   * For an SQL-based Amazon Kinesis Data Analytics application, identifies the Amazon S3 bucket and object that contains the reference data.
   *
   * A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the [UpdateApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/apiv2/API_UpdateApplication.html) operation to trigger reloading of data into your application.
   *
   * @struct
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-s3referencedatasource.html
   */
  export interface S3ReferenceDataSourceProperty {
    /**
     * The Amazon Resource Name (ARN) of the S3 bucket.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-s3referencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-s3referencedatasource-bucketarn
     */
    readonly bucketArn: string;

    /**
     * The object key name containing the reference data.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesisanalyticsv2-applicationreferencedatasource-s3referencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-s3referencedatasource-filekey
     */
    readonly fileKey: string;
  }
}

/**
 * Properties for defining a \`CfnApplicationReferenceDataSource\`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html
 */
export interface CfnApplicationReferenceDataSourceV2Props {
  /**
   * The name of the application.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-applicationname
   */
  readonly applicationName: string;

  /**
   * For a SQL-based Kinesis Data Analytics application, describes the reference data source by providing the source information (Amazon S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesisanalyticsv2-applicationreferencedatasource.html#cfn-kinesisanalyticsv2-applicationreferencedatasource-referencedatasource
   */
  readonly referenceDataSource: cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty;
}

/**
 * Determine whether the given properties match those of a \`RecordColumnProperty\`
 *
 * @param properties - the TypeScript properties of a \`RecordColumnProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2RecordColumnPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("mapping", cdk.validateString)(properties.mapping));
  errors.collect(cdk.propertyValidator("name", cdk.requiredValidator)(properties.name));
  errors.collect(cdk.propertyValidator("name", cdk.validateString)(properties.name));
  errors.collect(cdk.propertyValidator("sqlType", cdk.requiredValidator)(properties.sqlType));
  errors.collect(cdk.propertyValidator("sqlType", cdk.validateString)(properties.sqlType));
  return errors.wrap("supplied properties not correct for \\"RecordColumnProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2RecordColumnPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2RecordColumnPropertyValidator(properties).assertSuccess();
  return {
    "Mapping": cdk.stringToCloudFormation(properties.mapping),
    "Name": cdk.stringToCloudFormation(properties.name),
    "SqlType": cdk.stringToCloudFormation(properties.sqlType)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2RecordColumnPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.RecordColumnProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.RecordColumnProperty>();
  ret.addPropertyResult("mapping", "Mapping", (properties.Mapping != null ? cfn_parse.FromCloudFormation.getString(properties.Mapping) : undefined));
  ret.addPropertyResult("name", "Name", (properties.Name != null ? cfn_parse.FromCloudFormation.getString(properties.Name) : undefined));
  ret.addPropertyResult("sqlType", "SqlType", (properties.SqlType != null ? cfn_parse.FromCloudFormation.getString(properties.SqlType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`JSONMappingParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`JSONMappingParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordRowPath", cdk.requiredValidator)(properties.recordRowPath));
  errors.collect(cdk.propertyValidator("recordRowPath", cdk.validateString)(properties.recordRowPath));
  return errors.wrap("supplied properties not correct for \\"JSONMappingParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyValidator(properties).assertSuccess();
  return {
    "RecordRowPath": cdk.stringToCloudFormation(properties.recordRowPath)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.JSONMappingParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.JSONMappingParametersProperty>();
  ret.addPropertyResult("recordRowPath", "RecordRowPath", (properties.RecordRowPath != null ? cfn_parse.FromCloudFormation.getString(properties.RecordRowPath) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CSVMappingParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`CSVMappingParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordColumnDelimiter", cdk.requiredValidator)(properties.recordColumnDelimiter));
  errors.collect(cdk.propertyValidator("recordColumnDelimiter", cdk.validateString)(properties.recordColumnDelimiter));
  errors.collect(cdk.propertyValidator("recordRowDelimiter", cdk.requiredValidator)(properties.recordRowDelimiter));
  errors.collect(cdk.propertyValidator("recordRowDelimiter", cdk.validateString)(properties.recordRowDelimiter));
  return errors.wrap("supplied properties not correct for \\"CSVMappingParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyValidator(properties).assertSuccess();
  return {
    "RecordColumnDelimiter": cdk.stringToCloudFormation(properties.recordColumnDelimiter),
    "RecordRowDelimiter": cdk.stringToCloudFormation(properties.recordRowDelimiter)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationReferenceDataSourceV2.CSVMappingParametersProperty | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.CSVMappingParametersProperty>();
  ret.addPropertyResult("recordColumnDelimiter", "RecordColumnDelimiter", (properties.RecordColumnDelimiter != null ? cfn_parse.FromCloudFormation.getString(properties.RecordColumnDelimiter) : undefined));
  ret.addPropertyResult("recordRowDelimiter", "RecordRowDelimiter", (properties.RecordRowDelimiter != null ? cfn_parse.FromCloudFormation.getString(properties.RecordRowDelimiter) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`MappingParametersProperty\`
 *
 * @param properties - the TypeScript properties of a \`MappingParametersProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2MappingParametersPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("csvMappingParameters", CfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyValidator)(properties.csvMappingParameters));
  errors.collect(cdk.propertyValidator("jsonMappingParameters", CfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyValidator)(properties.jsonMappingParameters));
  return errors.wrap("supplied properties not correct for \\"MappingParametersProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2MappingParametersPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2MappingParametersPropertyValidator(properties).assertSuccess();
  return {
    "CSVMappingParameters": convertCfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyToCloudFormation(properties.csvMappingParameters),
    "JSONMappingParameters": convertCfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyToCloudFormation(properties.jsonMappingParameters)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2MappingParametersPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.MappingParametersProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.MappingParametersProperty>();
  ret.addPropertyResult("csvMappingParameters", "CSVMappingParameters", (properties.CSVMappingParameters != null ? CfnApplicationReferenceDataSourceV2CSVMappingParametersPropertyFromCloudFormation(properties.CSVMappingParameters) : undefined));
  ret.addPropertyResult("jsonMappingParameters", "JSONMappingParameters", (properties.JSONMappingParameters != null ? CfnApplicationReferenceDataSourceV2JSONMappingParametersPropertyFromCloudFormation(properties.JSONMappingParameters) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`RecordFormatProperty\`
 *
 * @param properties - the TypeScript properties of a \`RecordFormatProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2RecordFormatPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("mappingParameters", CfnApplicationReferenceDataSourceV2MappingParametersPropertyValidator)(properties.mappingParameters));
  errors.collect(cdk.propertyValidator("recordFormatType", cdk.requiredValidator)(properties.recordFormatType));
  errors.collect(cdk.propertyValidator("recordFormatType", cdk.validateString)(properties.recordFormatType));
  return errors.wrap("supplied properties not correct for \\"RecordFormatProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2RecordFormatPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2RecordFormatPropertyValidator(properties).assertSuccess();
  return {
    "MappingParameters": convertCfnApplicationReferenceDataSourceV2MappingParametersPropertyToCloudFormation(properties.mappingParameters),
    "RecordFormatType": cdk.stringToCloudFormation(properties.recordFormatType)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2RecordFormatPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.RecordFormatProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.RecordFormatProperty>();
  ret.addPropertyResult("mappingParameters", "MappingParameters", (properties.MappingParameters != null ? CfnApplicationReferenceDataSourceV2MappingParametersPropertyFromCloudFormation(properties.MappingParameters) : undefined));
  ret.addPropertyResult("recordFormatType", "RecordFormatType", (properties.RecordFormatType != null ? cfn_parse.FromCloudFormation.getString(properties.RecordFormatType) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReferenceSchemaProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReferenceSchemaProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("recordColumns", cdk.requiredValidator)(properties.recordColumns));
  errors.collect(cdk.propertyValidator("recordColumns", cdk.listValidator(CfnApplicationReferenceDataSourceV2RecordColumnPropertyValidator))(properties.recordColumns));
  errors.collect(cdk.propertyValidator("recordEncoding", cdk.validateString)(properties.recordEncoding));
  errors.collect(cdk.propertyValidator("recordFormat", cdk.requiredValidator)(properties.recordFormat));
  errors.collect(cdk.propertyValidator("recordFormat", CfnApplicationReferenceDataSourceV2RecordFormatPropertyValidator)(properties.recordFormat));
  return errors.wrap("supplied properties not correct for \\"ReferenceSchemaProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyValidator(properties).assertSuccess();
  return {
    "RecordColumns": cdk.listMapper(convertCfnApplicationReferenceDataSourceV2RecordColumnPropertyToCloudFormation)(properties.recordColumns),
    "RecordEncoding": cdk.stringToCloudFormation(properties.recordEncoding),
    "RecordFormat": convertCfnApplicationReferenceDataSourceV2RecordFormatPropertyToCloudFormation(properties.recordFormat)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceSchemaProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.ReferenceSchemaProperty>();
  ret.addPropertyResult("recordColumns", "RecordColumns", (properties.RecordColumns != null ? cfn_parse.FromCloudFormation.getArray(CfnApplicationReferenceDataSourceV2RecordColumnPropertyFromCloudFormation)(properties.RecordColumns) : undefined));
  ret.addPropertyResult("recordEncoding", "RecordEncoding", (properties.RecordEncoding != null ? cfn_parse.FromCloudFormation.getString(properties.RecordEncoding) : undefined));
  ret.addPropertyResult("recordFormat", "RecordFormat", (properties.RecordFormat != null ? CfnApplicationReferenceDataSourceV2RecordFormatPropertyFromCloudFormation(properties.RecordFormat) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`S3ReferenceDataSourceProperty\`
 *
 * @param properties - the TypeScript properties of a \`S3ReferenceDataSourceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("bucketArn", cdk.requiredValidator)(properties.bucketArn));
  errors.collect(cdk.propertyValidator("bucketArn", cdk.validateString)(properties.bucketArn));
  errors.collect(cdk.propertyValidator("fileKey", cdk.requiredValidator)(properties.fileKey));
  errors.collect(cdk.propertyValidator("fileKey", cdk.validateString)(properties.fileKey));
  return errors.wrap("supplied properties not correct for \\"S3ReferenceDataSourceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyValidator(properties).assertSuccess();
  return {
    "BucketARN": cdk.stringToCloudFormation(properties.bucketArn),
    "FileKey": cdk.stringToCloudFormation(properties.fileKey)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.S3ReferenceDataSourceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.S3ReferenceDataSourceProperty>();
  ret.addPropertyResult("bucketArn", "BucketARN", (properties.BucketARN != null ? cfn_parse.FromCloudFormation.getString(properties.BucketARN) : undefined));
  ret.addPropertyResult("fileKey", "FileKey", (properties.FileKey != null ? cfn_parse.FromCloudFormation.getString(properties.FileKey) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`ReferenceDataSourceProperty\`
 *
 * @param properties - the TypeScript properties of a \`ReferenceDataSourceProperty\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("referenceSchema", cdk.requiredValidator)(properties.referenceSchema));
  errors.collect(cdk.propertyValidator("referenceSchema", CfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyValidator)(properties.referenceSchema));
  errors.collect(cdk.propertyValidator("s3ReferenceDataSource", CfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyValidator)(properties.s3ReferenceDataSource));
  errors.collect(cdk.propertyValidator("tableName", cdk.validateString)(properties.tableName));
  return errors.wrap("supplied properties not correct for \\"ReferenceDataSourceProperty\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyValidator(properties).assertSuccess();
  return {
    "ReferenceSchema": convertCfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyToCloudFormation(properties.referenceSchema),
    "S3ReferenceDataSource": convertCfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyToCloudFormation(properties.s3ReferenceDataSource),
    "TableName": cdk.stringToCloudFormation(properties.tableName)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<cdk.IResolvable | CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2.ReferenceDataSourceProperty>();
  ret.addPropertyResult("referenceSchema", "ReferenceSchema", (properties.ReferenceSchema != null ? CfnApplicationReferenceDataSourceV2ReferenceSchemaPropertyFromCloudFormation(properties.ReferenceSchema) : undefined));
  ret.addPropertyResult("s3ReferenceDataSource", "S3ReferenceDataSource", (properties.S3ReferenceDataSource != null ? CfnApplicationReferenceDataSourceV2S3ReferenceDataSourcePropertyFromCloudFormation(properties.S3ReferenceDataSource) : undefined));
  ret.addPropertyResult("tableName", "TableName", (properties.TableName != null ? cfn_parse.FromCloudFormation.getString(properties.TableName) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}

/**
 * Determine whether the given properties match those of a \`CfnApplicationReferenceDataSourceV2Props\`
 *
 * @param properties - the TypeScript properties of a \`CfnApplicationReferenceDataSourceV2Props\`
 *
 * @returns the result of the validation.
 */
// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2PropsValidator(properties: any): cdk.ValidationResult {
  if (!cdk.canInspect(properties)) return cdk.VALIDATION_SUCCESS;
  const errors = new cdk.ValidationResults();
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    errors.collect(new cdk.ValidationResult("Expected an object, but received: " + JSON.stringify(properties)));
  }
  errors.collect(cdk.propertyValidator("applicationName", cdk.requiredValidator)(properties.applicationName));
  errors.collect(cdk.propertyValidator("applicationName", cdk.validateString)(properties.applicationName));
  errors.collect(cdk.propertyValidator("referenceDataSource", cdk.requiredValidator)(properties.referenceDataSource));
  errors.collect(cdk.propertyValidator("referenceDataSource", CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyValidator)(properties.referenceDataSource));
  return errors.wrap("supplied properties not correct for \\"CfnApplicationReferenceDataSourceV2Props\\"");
}

// @ts-ignore TS6133
function convertCfnApplicationReferenceDataSourceV2PropsToCloudFormation(properties: any): any {
  if (!cdk.canInspect(properties)) return properties;
  CfnApplicationReferenceDataSourceV2PropsValidator(properties).assertSuccess();
  return {
    "ApplicationName": cdk.stringToCloudFormation(properties.applicationName),
    "ReferenceDataSource": convertCfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyToCloudFormation(properties.referenceDataSource)
  };
}

// @ts-ignore TS6133
function CfnApplicationReferenceDataSourceV2PropsFromCloudFormation(properties: any): cfn_parse.FromCloudFormationResult<CfnApplicationReferenceDataSourceV2Props | cdk.IResolvable> {
  if (cdk.isResolvableObject(properties)) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  properties = ((properties == null) ? {} : properties);
  if (!(properties && typeof properties == 'object' && !Array.isArray(properties))) {
    return new cfn_parse.FromCloudFormationResult(properties);
  }
  const ret = new cfn_parse.FromCloudFormationPropertyObject<CfnApplicationReferenceDataSourceV2Props>();
  ret.addPropertyResult("applicationName", "ApplicationName", (properties.ApplicationName != null ? cfn_parse.FromCloudFormation.getString(properties.ApplicationName) : undefined));
  ret.addPropertyResult("referenceDataSource", "ReferenceDataSource", (properties.ReferenceDataSource != null ? CfnApplicationReferenceDataSourceV2ReferenceDataSourcePropertyFromCloudFormation(properties.ReferenceDataSource) : undefined));
  ret.addUnrecognizedPropertiesAsExtra(properties);
  return ret;
}"
`;
